From c1e9b3a126ef9cd2b267d5340d13db1879b478f0 Mon Sep 17 00:00:00 2001
From: cuiqiusong <cuiqiusong@ovopark.com>
Date: Mon, 21 Aug 2023 17:21:14 +0800
Subject: [PATCH] supper_rkmpp[https://github.com/jjm2473/ffmpeg-rk]

---
 Changelog                                     |   84 +-
 MAINTAINERS                                   |    3 +-
 Makefile                                      |    3 +-
 README.md                                     |    4 +
 compat/windows/mswindres                      |   32 +
 configure                                     |  104 +-
 doc/APIchanges                                |   27 +
 doc/Doxyfile                                  |    2 +-
 doc/codecs.texi                               |    2 +
 doc/encoders.texi                             |    9 +-
 doc/ffmpeg.texi                               |   96 +-
 doc/ffprobe.xsd                               |    2 +
 doc/filters.texi                              |  178 ++-
 doc/general_contents.texi                     |    4 +
 doc/git-howto.texi                            |   22 +-
 fftools/Makefile                              |   29 +-
 fftools/ffmpeg.c                              | 1149 ++++++---------
 fftools/ffmpeg.h                              |  124 +-
 fftools/ffmpeg_demux.c                        |  387 +++++
 fftools/ffmpeg_filter.c                       |   41 +-
 fftools/ffmpeg_hw.c                           |   12 +-
 fftools/ffmpeg_mux.c                          |  568 ++++++--
 fftools/ffmpeg_opt.c                          | 1285 +++++++++--------
 fftools/ffmpeg_wrap.c                         |  274 ++++
 fftools/ffprobe.c                             |    6 +
 fftools/fftools.manifest                      |    9 +
 fftools/fftoolsres.rc                         |    2 +
 fftools/objpool.c                             |  131 ++
 fftools/objpool.h                             |   37 +
 fftools/sync_queue.c                          |  448 ++++++
 fftools/sync_queue.h                          |  109 ++
 fftools/thread_queue.c                        |  245 ++++
 fftools/thread_queue.h                        |   81 ++
 libavcodec/012v.c                             |    1 -
 libavcodec/4xm.c                              |    2 +-
 libavcodec/8bps.c                             |    4 -
 libavcodec/8svx.c                             |    2 -
 libavcodec/Makefile                           |   56 +-
 libavcodec/a64multienc.c                      |    6 +-
 libavcodec/aac.h                              |    1 +
 libavcodec/aaccoder.c                         |  237 ++-
 libavcodec/aaccoder_trellis.h                 |    2 +-
 libavcodec/aacdec.c                           |    4 +-
 libavcodec/aacdec_fixed.c                     |    3 +-
 libavcodec/aacdec_template.c                  |    9 +-
 libavcodec/aacenc.c                           |  275 +++-
 libavcodec/aacenc.h                           |  273 ----
 libavcodec/aacenc_is.c                        |    6 +-
 libavcodec/aacenc_ltp.c                       |    4 +-
 libavcodec/aacenc_pred.c                      |   18 +-
 libavcodec/aacenc_quantization.h              |  243 +---
 libavcodec/aacenc_quantization_misc.h         |    2 +-
 libavcodec/aacenc_tns.c                       |    1 -
 libavcodec/aacsbr_template.c                  |    2 +
 libavcodec/aarch64/h264chroma_init_aarch64.c  |   12 +-
 libavcodec/aarch64/h264cmc_neon.S             |    4 +-
 libavcodec/aarch64/hevcdsp_idct_neon.S        |  216 +--
 libavcodec/aarch64/hevcdsp_init_aarch64.c     |   28 +-
 libavcodec/aarch64/me_cmp_init_aarch64.c      |    7 +-
 libavcodec/aarch64/me_cmp_neon.S              |  179 ++-
 libavcodec/aarch64/rv40dsp_init_aarch64.c     |    8 +-
 libavcodec/aarch64/vc1dsp_init_aarch64.c      |    8 +-
 libavcodec/aarch64/videodsp_init.c            |    2 +-
 libavcodec/aasc.c                             |    1 -
 libavcodec/ac3dec_fixed.c                     |    2 +-
 libavcodec/ac3dec_float.c                     |    4 +-
 libavcodec/ac3enc_fixed.c                     |    2 +-
 libavcodec/ac3enc_float.c                     |    2 +-
 libavcodec/acelp_filters.c                    |    2 +-
 libavcodec/acelp_pitch_delay.c                |    2 -
 libavcodec/acelp_vectors.c                    |    4 +-
 libavcodec/adpcm.c                            |    1 -
 libavcodec/adpcmenc.c                         |    6 +-
 libavcodec/adxdec.c                           |    1 -
 libavcodec/adxenc.c                           |    1 -
 libavcodec/agm.c                              |    3 +-
 libavcodec/aic.c                              |    1 -
 libavcodec/alac.c                             |    2 +-
 libavcodec/alacenc.c                          |    1 -
 libavcodec/allcodecs.c                        |   20 +-
 libavcodec/alpha/me_cmp_alpha.c               |   58 +-
 libavcodec/alpha/me_cmp_mvi_asm.S             |    2 +-
 libavcodec/alsdec.c                           |    2 +-
 libavcodec/amfenc_h264.c                      |    3 +-
 libavcodec/amfenc_hevc.c                      |    3 +-
 libavcodec/amrnbdec.c                         |    1 -
 libavcodec/amrwbdec.c                         |    1 -
 libavcodec/anm.c                              |    1 -
 libavcodec/ansi.c                             |    1 -
 libavcodec/apedec.c                           |    4 +-
 libavcodec/aptxdec.c                          |    2 -
 libavcodec/aptxenc.c                          |    2 -
 libavcodec/arbc.c                             |    2 +-
 libavcodec/argo.c                             |    2 +-
 libavcodec/arm/Makefile                       |    4 +-
 libavcodec/arm/flacdsp_init_arm.c             |    8 +-
 libavcodec/arm/h264chroma_init_arm.c          |   12 +-
 libavcodec/arm/h264cmc_neon.S                 |    4 +-
 libavcodec/arm/hevcdsp_init_neon.c            |   78 +-
 libavcodec/arm/me_cmp_init_arm.c              |   10 +-
 libavcodec/arm/mpegvideoencdsp_init_arm.c     |    4 +-
 libavcodec/arm/rv40dsp_init_arm.c             |    8 +-
 libavcodec/arm/sbcdsp_neon.S                  |  220 +--
 libavcodec/arm/vc1dsp_init_neon.c             |    8 +-
 libavcodec/arm/videodsp_init_armv5te.c        |    2 +-
 libavcodec/arm/vp8.h                          |    4 +-
 libavcodec/arm/vp8_armv6.S                    |    2 +-
 libavcodec/arm/vpx_arith.h                    |  121 ++
 libavcodec/assdec.c                           |    2 -
 libavcodec/assenc.c                           |    2 -
 libavcodec/asvdec.c                           |    2 -
 libavcodec/asvenc.c                           |    8 +-
 libavcodec/atrac1.c                           |    2 +-
 libavcodec/atrac3.c                           |    4 +-
 libavcodec/atrac3plusdec.c                    |    4 +-
 libavcodec/atrac9dec.c                        |    2 +-
 libavcodec/audiotoolboxdec.c                  |    2 +-
 libavcodec/audiotoolboxenc.c                  |    1 -
 libavcodec/aura.c                             |    1 -
 libavcodec/av1dec.c                           |    3 +-
 libavcodec/avcodec.c                          |   31 +-
 libavcodec/avcodec.h                          |   33 +-
 libavcodec/avrndec.c                          |    2 +-
 libavcodec/avs.c                              |    1 -
 libavcodec/avuidec.c                          |    1 -
 libavcodec/avuienc.c                          |    3 +-
 libavcodec/bethsoftvideo.c                    |    1 -
 libavcodec/bfi.c                              |    1 -
 libavcodec/bink.c                             |    4 +-
 libavcodec/binkaudio.c                        |    4 +-
 libavcodec/bintext.c                          |    3 -
 libavcodec/bitpacked_dec.c                    |    1 -
 libavcodec/bitpacked_enc.c                    |    1 -
 libavcodec/bmpenc.c                           |    4 +-
 libavcodec/bmvaudio.c                         |    1 -
 libavcodec/bmvvideo.c                         |    1 -
 libavcodec/c93.c                              |    2 +-
 libavcodec/cavsdec.c                          |    2 +-
 libavcodec/cbs.c                              |  145 +-
 libavcodec/cbs.h                              |   13 +-
 libavcodec/cbs_av1.c                          |    2 +-
 libavcodec/cbs_h2645.c                        |   68 +-
 libavcodec/cbs_internal.h                     |   93 +-
 libavcodec/cbs_jpeg.c                         |   76 +-
 libavcodec/cbs_mpeg2.c                        |   12 +-
 libavcodec/cbs_sei.c                          |    2 +-
 libavcodec/cbs_vp9.c                          |    2 +-
 libavcodec/ccaption_dec.c                     |    1 -
 libavcodec/cdgraphics.c                       |    1 -
 libavcodec/cdtoons.c                          |    1 -
 libavcodec/cdxl.c                             |    1 -
 libavcodec/cfhd.c                             |    2 +-
 libavcodec/cfhdenc.c                          |   17 +-
 libavcodec/cfhdencdsp.c                       |    6 +-
 libavcodec/cfhdencdsp.h                       |    4 +-
 libavcodec/cinepak.c                          |    1 -
 libavcodec/cinepakenc.c                       |    8 +-
 libavcodec/clearvideo.c                       |    2 +-
 libavcodec/cljrdec.c                          |    1 -
 libavcodec/cljrenc.c                          |    6 +-
 libavcodec/cllc.c                             |    1 -
 libavcodec/cngdec.c                           |    3 +-
 libavcodec/cngenc.c                           |    4 +-
 libavcodec/codec.h                            |    8 +
 libavcodec/codec_desc.c                       |   14 +
 libavcodec/codec_id.h                         |    2 +
 libavcodec/codec_internal.h                   |   16 +-
 libavcodec/cook.c                             |    2 +-
 libavcodec/cpia.c                             |    1 -
 libavcodec/cri.c                              |    2 +-
 libavcodec/crystalhd.c                        |    5 +-
 libavcodec/cscd.c                             |    2 +-
 libavcodec/cuviddec.c                         |    5 +-
 libavcodec/cyuv.c                             |    2 -
 libavcodec/dcadec.c                           |    2 +-
 libavcodec/dcaenc.c                           |    2 +-
 libavcodec/dds.c                              |    1 -
 libavcodec/decode.c                           |   77 +-
 libavcodec/decode.h                           |    5 +
 libavcodec/dfa.c                              |    1 -
 libavcodec/dfpwmdec.c                         |    1 -
 libavcodec/dfpwmenc.c                         |    3 +-
 libavcodec/diracdec.c                         |   24 +-
 libavcodec/diracdsp.c                         |    4 +-
 libavcodec/dnxhddec.c                         |    1 -
 libavcodec/dnxhdenc.c                         |    8 +-
 libavcodec/dnxhdenc.h                         |    2 +-
 libavcodec/dolby_e.c                          |    2 +-
 libavcodec/dpcm.c                             |    1 -
 libavcodec/dpxenc.c                           |    1 -
 libavcodec/dsddec.c                           |    1 -
 libavcodec/dsicinaudio.c                      |    1 -
 libavcodec/dsicinvideo.c                      |    2 +-
 libavcodec/dss_sp.c                           |    1 -
 libavcodec/dstdec.c                           |   12 +-
 libavcodec/dv.h                               |    4 +-
 libavcodec/dvaudiodec.c                       |    1 -
 libavcodec/dvbsubdec.c                        |    1 -
 libavcodec/dvdec.c                            |    7 +-
 libavcodec/dvdsubdec.c                        |    1 -
 libavcodec/dvdsubenc.c                        |    1 -
 libavcodec/dvenc.c                            |   12 +-
 libavcodec/dxa.c                              |    2 +-
 libavcodec/dxv.c                              |    7 +-
 libavcodec/eac3enc.c                          |    2 +-
 libavcodec/eacmv.c                            |    2 +-
 libavcodec/eamad.c                            |    1 -
 libavcodec/eatgq.c                            |    1 -
 libavcodec/eatgv.c                            |    1 -
 libavcodec/eatqi.c                            |    1 -
 libavcodec/encode.c                           |   95 +-
 libavcodec/encode.h                           |    5 +
 libavcodec/error_resilience.c                 |   18 +-
 libavcodec/error_resilience.h                 |    4 +-
 libavcodec/escape124.c                        |    1 -
 libavcodec/escape130.c                        |    2 +-
 libavcodec/evrcdec.c                          |    1 -
 libavcodec/exr.c                              |   34 +-
 libavcodec/exrenc.c                           |    7 +-
 libavcodec/fastaudio.c                        |    1 -
 libavcodec/fflcms2.c                          |  311 ++++
 libavcodec/fflcms2.h                          |   87 ++
 libavcodec/ffv1dec.c                          |    2 +-
 libavcodec/ffv1enc.c                          |    4 +-
 libavcodec/ffwavesynth.c                      |    2 +-
 libavcodec/fic.c                              |    1 -
 libavcodec/fitsenc.c                          |    7 +-
 libavcodec/flacdec.c                          |    7 +-
 libavcodec/flacdsp.c                          |   11 +-
 libavcodec/flacdsp.h                          |    6 +-
 libavcodec/flacenc.c                          |    9 +-
 libavcodec/flacencdsp.c                       |   40 +
 libavcodec/flacencdsp.h                       |   34 +
 libavcodec/flashsv.c                          |    4 +-
 libavcodec/flashsv2enc.c                      |    2 +-
 libavcodec/flashsvenc.c                       |    6 +-
 libavcodec/flicvideo.c                        |    1 -
 libavcodec/flvdec.c                           |    3 +-
 libavcodec/flvenc.c                           |    2 +-
 libavcodec/fmvc.c                             |   24 +-
 libavcodec/fraps.c                            |    1 -
 libavcodec/frwu.c                             |    1 -
 libavcodec/g2meet.c                           |    2 +-
 libavcodec/g722dec.c                          |    1 -
 libavcodec/g722enc.c                          |    2 +-
 libavcodec/g723_1dec.c                        |    1 -
 libavcodec/g723_1enc.c                        |    1 -
 libavcodec/g726.c                             |    4 -
 libavcodec/g729dec.c                          |    2 -
 libavcodec/gdv.c                              |    1 -
 libavcodec/get_buffer.c                       |   24 +
 libavcodec/gif.c                              |    4 +-
 libavcodec/gifdec.c                           |    5 +-
 libavcodec/gsmdec.c                           |    2 -
 libavcodec/h261dec.c                          |    5 +-
 libavcodec/h261enc.c                          |    4 +-
 libavcodec/h263dec.c                          |   15 +-
 libavcodec/h264_loopfilter.c                  |    4 +-
 libavcodec/h264_slice.c                       |    2 +-
 libavcodec/h264chroma.h                       |    2 +-
 libavcodec/h264chroma_template.c              |   16 +-
 libavcodec/h264dec.c                          |    2 +-
 libavcodec/half2float.h                       |    4 +-
 libavcodec/hapdec.c                           |    3 +-
 libavcodec/hapenc.c                           |    3 +-
 libavcodec/hcadec.c                           |    2 +-
 libavcodec/hcom.c                             |    2 +-
 libavcodec/hdr_parser.c                       |   79 +
 libavcodec/hdrdec.c                           |  222 +++
 libavcodec/hdrenc.c                           |  189 +++
 libavcodec/hevc_cabac.c                       |  311 ++--
 libavcodec/hevc_filter.c                      |   77 +-
 libavcodec/hevc_mvs.c                         |   58 +-
 libavcodec/hevc_refs.c                        |   41 +-
 libavcodec/hevcdec.c                          |  551 ++++---
 libavcodec/hevcdec.h                          |  117 +-
 libavcodec/hevcdsp.h                          |   72 +-
 libavcodec/hevcdsp_template.c                 |  240 +--
 libavcodec/hevcpred.h                         |    4 +-
 libavcodec/hevcpred_template.c                |    8 +-
 libavcodec/hnm4video.c                        |    2 +-
 libavcodec/hq_hqa.c                           |   51 +-
 libavcodec/hq_hqa.h                           |    2 -
 libavcodec/hqx.c                              |    3 +-
 libavcodec/huffyuvdec.c                       |    6 +-
 libavcodec/huffyuvenc.c                       |   24 +-
 libavcodec/idcinvideo.c                       |    1 -
 libavcodec/iff.c                              |    2 +-
 libavcodec/ilbcdec.c                          |   87 +-
 libavcodec/imc.c                              |    2 -
 libavcodec/imm4.c                             |    3 +-
 libavcodec/imm5.c                             |    3 +-
 libavcodec/imx.c                              |    3 +-
 libavcodec/indeo2.c                           |    1 -
 libavcodec/indeo3.c                           |    2 +-
 libavcodec/indeo4.c                           |    1 -
 libavcodec/indeo5.c                           |    2 +-
 libavcodec/intelh263dec.c                     |    3 +-
 libavcodec/internal.h                         |   20 +-
 libavcodec/interplayacm.c                     |    2 +-
 libavcodec/interplayvideo.c                   |    2 +-
 libavcodec/intrax8.c                          |   28 +-
 libavcodec/intrax8.h                          |    9 +-
 libavcodec/ituh263enc.c                       |    4 +-
 libavcodec/j2kenc.c                           |   14 +-
 libavcodec/jacosubdec.c                       |    1 -
 libavcodec/jpeg2000.h                         |    2 +
 libavcodec/jpeg2000dec.c                      |   17 +-
 libavcodec/jpeglsdec.c                        |    2 +-
 libavcodec/jpeglsenc.c                        |    3 +-
 libavcodec/jvdec.c                            |    1 -
 libavcodec/kgv1dec.c                          |    1 -
 libavcodec/kmvc.c                             |    1 -
 libavcodec/lagarith.c                         |    1 -
 libavcodec/lcldec.c                           |    4 +-
 libavcodec/lclenc.c                           |    3 +-
 libavcodec/libaom.c                           |   49 +
 libavcodec/libaom.h                           |   33 +
 libavcodec/libaomdec.c                        |   30 +-
 libavcodec/libaomenc.c                        |  100 +-
 libavcodec/libaribb24.c                       |    1 +
 libavcodec/libcelt_dec.c                      |    1 +
 libavcodec/libcodec2.c                        |    2 +
 libavcodec/libdav1d.c                         |    4 +-
 libavcodec/libdavs2.c                         |    3 +-
 libavcodec/libfdk-aacdec.c                    |    3 +-
 libavcodec/libfdk-aacenc.c                    |    1 +
 libavcodec/libgsmdec.c                        |    2 +
 libavcodec/libgsmenc.c                        |    2 +
 libavcodec/libilbc.c                          |    2 +
 libavcodec/libjxldec.c                        |    4 +-
 libavcodec/libjxlenc.c                        |   13 +-
 libavcodec/libkvazaar.c                       |    2 +-
 libavcodec/libmp3lame.c                       |    1 +
 libavcodec/libopencore-amr.c                  |    3 +
 libavcodec/libopenh264dec.c                   |    2 +-
 libavcodec/libopenh264enc.c                   |    2 +-
 libavcodec/libopenjpegdec.c                   |    1 +
 libavcodec/libopenjpegenc.c                   |    1 +
 libavcodec/libopusdec.c                       |    3 +-
 libavcodec/libopusenc.c                       |   13 +-
 libavcodec/librav1e.c                         |    3 +-
 libavcodec/libshine.c                         |    1 +
 libavcodec/libspeexdec.c                      |    1 +
 libavcodec/libspeexenc.c                      |    1 +
 libavcodec/libsvtav1.c                        |   10 +-
 libavcodec/libtheoraenc.c                     |    1 +
 libavcodec/libtwolame.c                       |    1 +
 libavcodec/libuavs3d.c                        |    3 +-
 libavcodec/libvo-amrwbenc.c                   |    1 +
 libavcodec/libvorbisdec.c                     |    1 +
 libavcodec/libvorbisenc.c                     |    1 +
 libavcodec/libvpxdec.c                        |    6 +-
 libavcodec/libvpxenc.c                        |   89 +-
 libavcodec/libwebpenc.c                       |    1 +
 libavcodec/libwebpenc_animencoder.c           |    1 +
 libavcodec/libx264.c                          |   66 +-
 libavcodec/libx265.c                          |    3 +-
 libavcodec/libxavs.c                          |    3 +-
 libavcodec/libxavs2.c                         |    3 +-
 libavcodec/libxvid.c                          |    3 +-
 libavcodec/libzvbi-teletextdec.c              |    1 +
 libavcodec/ljpegenc.c                         |    7 +-
 libavcodec/loco.c                             |    1 -
 libavcodec/loongarch/h264chroma_lasx.c        |  172 +--
 libavcodec/loongarch/h264chroma_lasx.h        |    6 +-
 libavcodec/loongarch/hevc_lpf_sao_lsx.c       |  138 +-
 libavcodec/loongarch/hevc_mc_bi_lsx.c         |  338 ++---
 libavcodec/loongarch/hevc_mc_uni_lsx.c        |  143 +-
 libavcodec/loongarch/hevc_mc_uniw_lsx.c       |   26 +-
 libavcodec/loongarch/hevcdsp_lsx.c            |  340 ++---
 libavcodec/loongarch/hevcdsp_lsx.h            |   30 +-
 libavcodec/loongarch/vc1dsp_lasx.c            |   18 +-
 libavcodec/loongarch/vc1dsp_loongarch.h       |    2 +-
 libavcodec/loongarch/videodsp_init.c          |    2 +-
 libavcodec/lossless_videoencdsp.c             |    2 +-
 libavcodec/lossless_videoencdsp.h             |    2 +-
 libavcodec/lscrdec.c                          |    2 +-
 libavcodec/m101.c                             |    1 -
 libavcodec/mace.c                             |    2 -
 libavcodec/magicyuv.c                         |    5 +-
 libavcodec/magicyuvenc.c                      |    5 +-
 libavcodec/mdec.c                             |    1 -
 libavcodec/me_cmp.c                           |   93 +-
 libavcodec/me_cmp.h                           |    6 +-
 libavcodec/mediacodecdec.c                    |    3 +-
 libavcodec/metasound.c                        |    2 +-
 libavcodec/mfenc.c                            |    5 +-
 libavcodec/microdvddec.c                      |    1 -
 libavcodec/midivid.c                          |   15 +-
 libavcodec/mimic.c                            |    5 +-
 libavcodec/mips/aaccoder_mips.c               |   12 +-
 libavcodec/mips/h263dsp_mips.h                |    2 +-
 libavcodec/mips/h264chroma_mips.h             |   20 +-
 libavcodec/mips/h264chroma_mmi.c              |    8 +-
 libavcodec/mips/h264chroma_msa.c              |  142 +-
 libavcodec/mips/hevc_idct_msa.c               |   16 +-
 libavcodec/mips/hevc_lpf_sao_msa.c            |  118 +-
 libavcodec/mips/hevc_mc_bi_msa.c              |  336 ++---
 libavcodec/mips/hevc_mc_biw_msa.c             |  338 ++---
 libavcodec/mips/hevc_mc_uni_msa.c             |  168 +--
 libavcodec/mips/hevc_mc_uniw_msa.c            |  174 +--
 libavcodec/mips/hevcdsp_mips.h                |   54 +-
 libavcodec/mips/hevcdsp_mmi.c                 |   28 +-
 libavcodec/mips/hevcdsp_msa.c                 |  166 +--
 libavcodec/mips/hevcpred_mips.h               |    4 +-
 libavcodec/mips/hevcpred_msa.c                |    8 +-
 libavcodec/mips/me_cmp_mips.h                 |   32 +-
 libavcodec/mips/me_cmp_msa.c                  |   80 +-
 libavcodec/mips/mpegvideoencdsp_msa.c         |    4 +-
 libavcodec/mips/vc1dsp_mips.h                 |    8 +-
 libavcodec/mips/vc1dsp_mmi.c                  |    8 +-
 libavcodec/mips/videodsp_init.c               |    2 +-
 libavcodec/mjpegbdec.c                        |    2 +-
 libavcodec/mjpegdec.c                         |   18 +-
 libavcodec/mjpegenc.c                         |    4 +-
 libavcodec/mlpdec.c                           |    2 -
 libavcodec/mlpenc.c                           |    8 +-
 libavcodec/mmaldec.c                          |    3 +-
 libavcodec/mmvideo.c                          |    1 -
 libavcodec/mobiclip.c                         |    6 +-
 libavcodec/motion_est.c                       |   47 +-
 libavcodec/motion_est.h                       |    4 +-
 libavcodec/motionpixels.c                     |    2 +-
 libavcodec/movtextdec.c                       |    1 -
 libavcodec/movtextenc.c                       |    2 +-
 libavcodec/mpc7.c                             |    1 -
 libavcodec/mpc8.c                             |    1 -
 libavcodec/mpeg12dec.c                        |   11 +-
 libavcodec/mpeg12enc.c                        |    4 +-
 libavcodec/mpeg4videodec.c                    |    9 +-
 libavcodec/mpeg4videoenc.c                    |   10 +-
 libavcodec/mpeg_er.c                          |    3 +-
 libavcodec/mpegaudiodec_fixed.c               |    6 +-
 libavcodec/mpegaudiodec_float.c               |    6 +-
 libavcodec/mpegaudiodec_template.c            |    2 +-
 libavcodec/mpegaudioenc_fixed.c               |    1 -
 libavcodec/mpegaudioenc_float.c               |    1 -
 libavcodec/mpegpicture.c                      |   64 +-
 libavcodec/mpegpicture.h                      |   14 -
 libavcodec/mpegutils.c                        |  112 +-
 libavcodec/mpegutils.h                        |    9 +-
 libavcodec/mpegvideo.c                        |   64 +-
 libavcodec/mpegvideo.h                        |   23 +-
 libavcodec/mpegvideo_dec.c                    |   10 +-
 libavcodec/mpegvideo_enc.c                    |   95 +-
 libavcodec/mpegvideo_motion.c                 |   41 +-
 libavcodec/mpegvideodec.h                     |    4 +-
 libavcodec/mpegvideodsp.c                     |    4 +-
 libavcodec/mpegvideodsp.h                     |    6 +-
 libavcodec/mpegvideoencdsp.c                  |   10 +-
 libavcodec/mpegvideoencdsp.h                  |   10 +-
 libavcodec/mpl2dec.c                          |    1 -
 libavcodec/mscc.c                             |    4 +-
 libavcodec/msmpeg4dec.c                       |   12 +-
 libavcodec/msmpeg4dec.h                       |    8 -
 libavcodec/msmpeg4enc.c                       |    6 +-
 libavcodec/msmpeg4enc.h                       |    6 -
 libavcodec/msrle.c                            |    1 -
 libavcodec/mss1.c                             |    1 -
 libavcodec/mss2.c                             |    1 -
 libavcodec/mss3.c                             |    2 +-
 libavcodec/mss4.c                             |    2 +-
 libavcodec/msvideo1.c                         |    1 -
 libavcodec/msvideo1enc.c                      |    5 +-
 libavcodec/mv30.c                             |    3 +-
 libavcodec/mvcdec.c                           |    2 -
 libavcodec/mvha.c                             |    3 +-
 libavcodec/mwsc.c                             |    3 +-
 libavcodec/mxpegdec.c                         |    2 +-
 libavcodec/nellymoserdec.c                    |    1 -
 libavcodec/nellymoserenc.c                    |    2 +-
 libavcodec/notchlc.c                          |    1 -
 libavcodec/nuv.c                              |    2 +-
 libavcodec/nvdec.c                            |   14 +-
 libavcodec/nvdec_hevc.c                       |    4 +-
 libavcodec/nvdec_vp8.c                        |    8 +-
 libavcodec/nvenc.c                            |   38 +-
 libavcodec/nvenc_h264.c                       |    3 +-
 libavcodec/nvenc_hevc.c                       |    3 +-
 libavcodec/omx.c                              |    4 +-
 libavcodec/on2avc.c                           |    2 +-
 libavcodec/options_table.h                    |    2 +
 libavcodec/opusdec.c                          |    2 +-
 libavcodec/opusenc.c                          |    2 +-
 libavcodec/pafaudio.c                         |    1 -
 libavcodec/pafvideo.c                         |    2 +-
 libavcodec/pamenc.c                           |    4 +-
 libavcodec/parsers.c                          |    1 +
 libavcodec/pcm-blurayenc.c                    |    1 -
 libavcodec/pcm-dvd.c                          |    1 -
 libavcodec/pcm-dvdenc.c                       |    1 -
 libavcodec/pcm.c                              |    2 -
 libavcodec/pcxenc.c                           |    1 -
 libavcodec/pgssubdec.c                        |    1 -
 libavcodec/photocd.c                          |    1 -
 libavcodec/pixlet.c                           |    3 +-
 libavcodec/pngdec.c                           |  108 +-
 libavcodec/pngenc.c                           |   24 +-
 libavcodec/pnm.c                              |    2 +-
 libavcodec/pnm.h                              |    6 +-
 libavcodec/pnm_parser.c                       |    8 +-
 libavcodec/pnmdec.c                           |  143 +-
 libavcodec/pnmenc.c                           |   24 +-
 libavcodec/ppc/h264chroma_template.c          |    4 +-
 libavcodec/ppc/me_cmp.c                       |   30 +-
 libavcodec/ppc/mpegvideodsp.c                 |    2 +-
 libavcodec/ppc/mpegvideoencdsp.c              |    8 +-
 libavcodec/ppc/videodsp.c                     |    2 +-
 libavcodec/proresdata.c                       |   27 -
 libavcodec/proresdata.h                       |    4 -
 libavcodec/proresdec2.c                       |    9 +-
 libavcodec/proresenc_anatoliy.c               |   26 +-
 libavcodec/proresenc_kostya.c                 |   56 +-
 libavcodec/prosumer.c                         |    3 +-
 libavcodec/pthread_frame.c                    |   53 +-
 libavcodec/pthread_slice.c                    |   14 +-
 libavcodec/qcelpdec.c                         |    1 -
 libavcodec/qdm2.c                             |    1 -
 libavcodec/qdmc.c                             |    1 -
 libavcodec/qoienc.c                           |    4 +-
 libavcodec/qpeg.c                             |    3 +-
 libavcodec/qsv.c                              |  255 +++-
 libavcodec/qsv.h                              |    4 +-
 libavcodec/qsv_internal.h                     |    6 +-
 libavcodec/qsvdec.c                           |   23 +-
 libavcodec/qsvenc.c                           |  162 ++-
 libavcodec/qsvenc.h                           |   15 +-
 libavcodec/qsvenc_h264.c                      |    6 +-
 libavcodec/qsvenc_hevc.c                      |    6 +-
 libavcodec/qsvenc_jpeg.c                      |    4 +-
 libavcodec/qsvenc_mpeg2.c                     |    6 +-
 libavcodec/qsvenc_vp9.c                       |    6 +-
 libavcodec/qtrle.c                            |    1 -
 libavcodec/qtrleenc.c                         |    2 +-
 libavcodec/r210dec.c                          |    3 -
 libavcodec/r210enc.c                          |   11 +-
 libavcodec/ra144dec.c                         |    1 -
 libavcodec/ra144enc.c                         |    1 -
 libavcodec/ra288.c                            |    1 -
 libavcodec/ralf.c                             |    2 +-
 libavcodec/rasc.c                             |    3 +-
 libavcodec/ratecontrol.c                      |   24 +-
 libavcodec/raw.c                              |    1 +
 libavcodec/rawdec.c                           |    3 +-
 libavcodec/rawenc.c                           |    1 -
 libavcodec/realtextdec.c                      |    1 -
 libavcodec/rkmppdec.c                         |  535 +------
 libavcodec/rkmppenc.c                         |   76 +
 libavcodec/rl2.c                              |    1 -
 libavcodec/roqaudioenc.c                      |    1 -
 libavcodec/roqvideodec.c                      |    2 +-
 libavcodec/roqvideoenc.c                      |    2 +-
 libavcodec/rpza.c                             |    1 -
 libavcodec/rpzaenc.c                          |   30 +-
 libavcodec/rscc.c                             |    3 +-
 libavcodec/rv10.c                             |    4 +-
 libavcodec/rv10enc.c                          |    2 +-
 libavcodec/rv20enc.c                          |    2 +-
 libavcodec/rv30.c                             |    3 +-
 libavcodec/rv34.c                             |    4 +-
 libavcodec/rv40.c                             |    3 +-
 libavcodec/rv40dsp.c                          |    4 +-
 libavcodec/s302menc.c                         |    1 -
 libavcodec/samidec.c                          |    1 -
 libavcodec/sanm.c                             |    1 -
 libavcodec/sbcdec.c                           |    1 -
 libavcodec/sbcenc.c                           |    1 -
 libavcodec/sbrdsp.c                           |    1 -
 libavcodec/sbrdsp.h                           |    1 -
 libavcodec/sbrdsp_fixed.c                     |    1 -
 libavcodec/scpr.c                             |    3 +-
 libavcodec/screenpresso.c                     |    3 +-
 libavcodec/sga.c                              |    1 -
 libavcodec/sgidec.c                           |    1 -
 libavcodec/sgienc.c                           |    7 +-
 libavcodec/sgirledec.c                        |    1 -
 libavcodec/shorten.c                          |    1 -
 libavcodec/sipr.c                             |    1 -
 libavcodec/siren.c                            |    6 +-
 libavcodec/smacker.c                          |    3 +-
 libavcodec/smc.c                              |    1 -
 libavcodec/smcenc.c                           |    1 -
 libavcodec/snow.c                             |   67 +-
 libavcodec/snow.h                             |    3 +-
 libavcodec/snow_dwt.c                         |   14 +-
 libavcodec/snow_dwt.h                         |    4 +-
 libavcodec/snowdec.c                          |    3 +-
 libavcodec/snowenc.c                          |   89 +-
 libavcodec/sonic.c                            |    6 +-
 libavcodec/sp5xdec.c                          |    4 +-
 libavcodec/speedhq.c                          |    3 +-
 libavcodec/speedhqenc.c                       |    2 +-
 libavcodec/speexdec.c                         |    2 +-
 libavcodec/srtdec.c                           |    2 -
 libavcodec/srtenc.c                           |    3 -
 libavcodec/subviewerdec.c                     |    1 -
 libavcodec/sunrastenc.c                       |    1 -
 libavcodec/svq1dec.c                          |    1 -
 libavcodec/svq1enc.c                          |   14 +-
 libavcodec/svq3.c                             |    2 +-
 libavcodec/takdec.c                           |    1 -
 libavcodec/targa_y216dec.c                    |    1 -
 libavcodec/targaenc.c                         |    3 +-
 libavcodec/tdsc.c                             |    3 +-
 libavcodec/textdec.c                          |    5 -
 libavcodec/thread.h                           |    3 +-
 libavcodec/threadframe.h                      |    4 +-
 libavcodec/tiertexseqv.c                      |    1 -
 libavcodec/tiff.c                             |    6 +-
 libavcodec/tiffenc.c                          |    5 +-
 libavcodec/tmv.c                              |    1 -
 libavcodec/truemotion1.c                      |    2 +-
 libavcodec/truemotion2.c                      |    2 +-
 libavcodec/truemotion2rt.c                    |    1 -
 libavcodec/truespeech.c                       |    1 -
 libavcodec/tscc.c                             |    2 +-
 libavcodec/tscc2.c                            |    2 +-
 libavcodec/tta.c                              |   13 +-
 libavcodec/ttaenc.c                           |    1 -
 libavcodec/ttmlenc.c                          |    4 +-
 libavcodec/ttmlenc.h                          |   10 +-
 libavcodec/twinvqdec.c                        |    2 +-
 libavcodec/ulti.c                             |    1 -
 libavcodec/utils.c                            |    8 +-
 libavcodec/utvideodec.c                       |    1 -
 libavcodec/utvideoenc.c                       |    6 +-
 libavcodec/v210dec.c                          |    1 -
 libavcodec/v210enc.c                          |    1 -
 libavcodec/v210x.c                            |    1 -
 libavcodec/v308dec.c                          |    1 -
 libavcodec/v308enc.c                          |    3 +-
 libavcodec/v408dec.c                          |    2 -
 libavcodec/v408enc.c                          |    4 +-
 libavcodec/v410dec.c                          |    1 -
 libavcodec/v410enc.c                          |    3 +-
 libavcodec/v4l2_m2m_dec.c                     |    3 +-
 libavcodec/v4l2_m2m_enc.c                     |    3 +-
 libavcodec/vaapi_decode.c                     |    4 +
 libavcodec/vaapi_encode.c                     |    1 +
 libavcodec/vaapi_encode_h264.c                |    3 +-
 libavcodec/vaapi_encode_h265.c                |    5 +-
 libavcodec/vaapi_encode_mjpeg.c               |    3 +-
 libavcodec/vaapi_encode_mpeg2.c               |    3 +-
 libavcodec/vaapi_encode_vp8.c                 |    3 +-
 libavcodec/vaapi_encode_vp9.c                 |    5 +-
 libavcodec/vaapi_vp8.c                        |   18 +-
 libavcodec/vb.c                               |    2 +-
 libavcodec/vble.c                             |    1 -
 libavcodec/vbndec.c                           |    1 -
 libavcodec/vbnenc.c                           |    5 +-
 libavcodec/vc1_block.c                        |   17 +-
 libavcodec/vc1dec.c                           |    6 +-
 libavcodec/vc1dsp.c                           |    8 +-
 libavcodec/vc2enc.c                           |    4 +-
 libavcodec/vcr1.c                             |    1 -
 libavcodec/version.h                          |    4 +-
 libavcodec/videodsp.c                         |    2 +-
 libavcodec/videodsp.h                         |    2 +-
 libavcodec/videotoolbox.c                     |   10 +-
 libavcodec/videotoolboxenc.c                  |    9 +-
 libavcodec/vima.c                             |    1 -
 libavcodec/vmdaudio.c                         |    1 -
 libavcodec/vmdvideo.c                         |    2 +-
 libavcodec/vmnc.c                             |    1 -
 libavcodec/vorbisdec.c                        |    2 +-
 libavcodec/vorbisenc.c                        |    2 +-
 libavcodec/vp3.c                              |    8 +-
 libavcodec/vp5.c                              |   65 +-
 libavcodec/vp56.c                             |   15 +-
 libavcodec/vp56.h                             |  184 +--
 libavcodec/vp6.c                              |   83 +-
 libavcodec/vp8.c                              |  496 ++++---
 libavcodec/vp8.h                              |   40 +-
 libavcodec/vp89_rac.h                         |   66 +
 libavcodec/vp9.c                              |  138 +-
 libavcodec/vp9_mc_template.c                  |   12 +-
 libavcodec/vp9block.c                         |  232 +--
 libavcodec/vp9dec.h                           |   21 +-
 libavcodec/vp9mvs.c                           |   50 +-
 libavcodec/vp9prob.c                          |    2 -
 libavcodec/vp9recon.c                         |   42 +-
 libavcodec/vp9shared.h                        |   10 +-
 libavcodec/vpx_rac.c                          |   53 +
 libavcodec/vpx_rac.h                          |  135 ++
 libavcodec/vqavideo.c                         |    2 +-
 libavcodec/vt_internal.h                      |    2 -
 libavcodec/wavpack.c                          |    4 +-
 libavcodec/wavpackenc.c                       |    1 -
 libavcodec/wbmpdec.c                          |   92 ++
 libavcodec/wbmpenc.c                          |   89 ++
 libavcodec/wcmv.c                             |    3 +-
 libavcodec/webp.c                             |    2 +-
 libavcodec/webvttdec.c                        |    1 -
 libavcodec/webvttenc.c                        |    1 -
 libavcodec/wmadec.c                           |    4 +-
 libavcodec/wmaenc.c                           |    6 +-
 libavcodec/wmalosslessdec.c                   |    2 +-
 libavcodec/wmaprodec.c                        |    6 +-
 libavcodec/wmavoice.c                         |    2 +-
 libavcodec/wmv2.c                             |    4 +-
 libavcodec/wmv2.h                             |    2 +-
 libavcodec/wmv2dec.c                          |    8 +-
 libavcodec/wmv2enc.c                          |    2 +-
 libavcodec/wnv1.c                             |    1 -
 libavcodec/wrapped_avframe.c                  |    8 +-
 libavcodec/ws-snd1.c                          |    1 -
 libavcodec/x86/Makefile                       |    3 +-
 libavcodec/x86/cfhdencdsp_init.c              |    4 +-
 libavcodec/x86/flacdsp_init.c                 |   15 +-
 libavcodec/x86/flacencdsp_init.c              |   38 +
 libavcodec/x86/h264_chromamc.asm              |    2 +-
 libavcodec/x86/h264_chromamc_10bit.asm        |    4 +-
 libavcodec/x86/h264chroma_init.c              |   24 +-
 libavcodec/x86/hevc_add_res.asm               |   12 +-
 libavcodec/x86/hevc_mc.asm                    |   14 +-
 libavcodec/x86/hevc_sao.asm                   |    2 +-
 libavcodec/x86/hevc_sao_10bit.asm             |    2 +-
 libavcodec/x86/hevcdsp.h                      |  104 +-
 libavcodec/x86/hevcdsp_init.c                 |  111 +-
 libavcodec/x86/lossless_videoencdsp.asm       |    2 +-
 libavcodec/x86/lossless_videoencdsp_init.c    |    2 +-
 libavcodec/x86/me_cmp.asm                     |   24 +-
 libavcodec/x86/me_cmp_init.c                  |   75 +-
 libavcodec/x86/mpegvideodsp.c                 |    2 +-
 libavcodec/x86/mpegvideoenc_qns_template.c    |    4 +-
 libavcodec/x86/mpegvideoencdsp.asm            |    4 +-
 libavcodec/x86/mpegvideoencdsp_init.c         |    6 +-
 libavcodec/x86/pngdsp.asm                     |   16 +-
 libavcodec/x86/pngdsp_init.c                  |    7 -
 libavcodec/x86/rv40dsp_init.c                 |    8 +-
 libavcodec/x86/vc1dsp_init.c                  |    8 +-
 libavcodec/x86/videodsp_init.c                |    2 +-
 libavcodec/x86/vpx_arith.h                    |   55 +
 libavcodec/xan.c                              |    2 +-
 libavcodec/xbmenc.c                           |    3 +-
 libavcodec/xfacedec.c                         |    1 -
 libavcodec/xl.c                               |    1 -
 libavcodec/xsubdec.c                          |    1 -
 libavcodec/xsubenc.c                          |    1 -
 libavcodec/xwdenc.c                           |    9 +-
 libavcodec/xxan.c                             |    2 +-
 libavcodec/y41pdec.c                          |    1 -
 libavcodec/y41penc.c                          |    3 +-
 libavcodec/ylc.c                              |    1 -
 libavcodec/yop.c                              |    1 -
 libavcodec/yuv4dec.c                          |    1 -
 libavcodec/yuv4enc.c                          |    2 +-
 libavcodec/zerocodec.c                        |    3 +-
 libavcodec/zmbv.c                             |    2 +-
 libavcodec/zmbvenc.c                          |   13 +-
 libavdevice/Makefile                          |    2 +-
 libavdevice/alsa_enc.c                        |    9 +-
 libavdevice/lavfi.c                           |   94 +-
 libavdevice/pulse_audio_enc.c                 |    9 +-
 libavdevice/v4l2.c                            |    1 +
 libavdevice/version.h                         |    4 +-
 libavfilter/Makefile                          |    4 +-
 libavfilter/allfilters.c                      |    2 +
 libavfilter/avfiltergraph.c                   |   20 +-
 libavfilter/buffersrc.c                       |    7 +
 libavfilter/dnn/dnn_backend_openvino.c        |   66 +-
 libavfilter/edge_common.c                     |   74 +-
 libavfilter/edge_common.h                     |   22 +-
 libavfilter/edge_template.c                   |  118 ++
 libavfilter/f_loop.c                          |   14 +
 libavfilter/fflcms2.c                         |  294 +---
 libavfilter/fflcms2.h                         |   65 +-
 libavfilter/framesync.c                       |   19 +
 libavfilter/framesync.h                       |   23 +
 libavfilter/qsvvpp.c                          |  147 +-
 libavfilter/qsvvpp.h                          |   12 +-
 libavfilter/version.h                         |    4 +-
 libavfilter/vf_blurdetect.c                   |    8 +-
 libavfilter/vf_cropdetect.c                   |  217 ++-
 libavfilter/vf_deinterlace_qsv.c              |   72 +-
 libavfilter/vf_deshake_opencl.c               |    7 +
 libavfilter/vf_drawtext.c                     |   16 +
 libavfilter/vf_edgedetect.c                   |   14 +-
 libavfilter/vf_hwdownload.c                   |   68 +-
 libavfilter/vf_overlay_qsv.c                  |    2 +
 libavfilter/vf_overlay_vaapi.c                |    2 +-
 libavfilter/vf_scale.c                        |   20 +-
 libavfilter/vf_scale_qsv.c                    |   87 +-
 libavfilter/vf_scale_rga.c                    |  180 +++
 libavfilter/vf_showinfo.c                     |   18 +-
 libavfilter/vf_sr.c                           |    5 +-
 libavfilter/vf_zscale.c                       |    3 +-
 libavfilter/vsrc_ddagrab.c                    | 1059 ++++++++++++++
 libavfilter/vsrc_ddagrab_shaders.h            |  122 ++
 libavformat/Makefile                          |    3 +-
 libavformat/ac3dec.c                          |    2 +-
 libavformat/aiffdec.c                         |    4 +-
 libavformat/allformats.c                      |    1 +
 libavformat/ape.c                             |    2 -
 libavformat/apm.c                             |    2 +-
 libavformat/argo_cvg.c                        |   70 +-
 libavformat/asfcrypt.c                        |    4 +-
 libavformat/asfdec_o.c                        |   12 +-
 libavformat/avformat.c                        |   66 +
 libavformat/avidec.c                          |   12 +-
 libavformat/avisynth.c                        |    9 +-
 libavformat/cafdec.c                          |    2 +-
 libavformat/cafenc.c                          |   19 +-
 libavformat/dashdec.c                         |    7 +-
 libavformat/dhav.c                            |    2 +-
 libavformat/dxa.c                             |    7 +-
 libavformat/fifo.c                            |    6 +-
 libavformat/flvdec.c                          |   19 +-
 libavformat/flvenc.c                          |   14 +-
 libavformat/genh.c                            |    2 -
 libavformat/hevc.c                            |   10 +-
 libavformat/hls.c                             |    1 -
 libavformat/icodec.c                          |    3 -
 libavformat/iff.c                             |    3 -
 libavformat/imfdec.c                          |   12 +-
 libavformat/img2.c                            |    2 +
 libavformat/img2dec.c                         |    8 +
 libavformat/img2enc.c                         |    2 +-
 libavformat/internal.h                        |   11 +
 libavformat/isom.c                            |    1 -
 libavformat/isom.h                            |    9 +-
 libavformat/isom_tags.c                       |    2 +-
 libavformat/jacosubdec.c                      |    2 +-
 libavformat/lrcenc.c                          |    2 +-
 libavformat/mov.c                             |  207 ++-
 libavformat/movenc.c                          |    2 +-
 libavformat/mpc8.c                            |   40 +-
 libavformat/mux.c                             |    9 +-
 libavformat/mux.h                             |    9 -
 libavformat/mux_utils.c                       |   28 -
 libavformat/mxf.c                             |    3 +
 libavformat/mxf.h                             |    1 +
 libavformat/mxfdec.c                          |   57 +-
 libavformat/nutdec.c                          |    5 -
 libavformat/protocols.c                       |    1 +
 libavformat/rawenc.c                          |    2 +-
 libavformat/riff.c                            |    2 +-
 libavformat/riffdec.c                         |   11 +-
 libavformat/rmdec.c                           |    2 -
 libavformat/rpl.c                             |    2 +-
 libavformat/sbgdec.c                          |    4 +-
 libavformat/sdsdec.c                          |    2 +-
 libavformat/segment.c                         |    6 +-
 libavformat/spdifdec.c                        |    2 +-
 libavformat/subviewerdec.c                    |   36 +-
 libavformat/tee.c                             |    7 +-
 libavformat/ttmlenc.c                         |    2 +-
 libavformat/version.h                         |    2 +-
 libavformat/webm_chunk.c                      |    6 +-
 libavformat/xwma.c                            |    2 +-
 libavrkmpp/Makefile                           |   17 +
 libavrkmpp/avrkmpp.h                          |   95 ++
 libavrkmpp/libavrkmpp.v                       |    7 +
 libavrkmpp/rkmppdec.c                         |  754 ++++++++++
 libavrkmpp/rkmppenc.c                         |  709 +++++++++
 libavrkmpp/version.c                          |   22 +
 libavrkmpp/version.h                          |   26 +
 libavrkmpp/version_major.h                    |   11 +
 libavrkmpp/vf_scale_rga.c                     |  426 ++++++
 libavutil/Makefile                            |    2 +-
 libavutil/buffer.c                            |    3 -
 libavutil/frame.c                             |   13 +-
 libavutil/frame.h                             |   13 +-
 libavutil/hwcontext_d3d11va.c                 |   10 +-
 libavutil/hwcontext_opencl.c                  |    2 +-
 libavutil/hwcontext_qsv.c                     |  590 +++++++-
 libavutil/hwcontext_qsv.h                     |   13 +-
 libavutil/hwcontext_vaapi.c                   |    1 +
 libavutil/hwcontext_videotoolbox.h            |    1 +
 libavutil/loongarch/loongson_intrinsics.h     |   10 +
 libavutil/opt.c                               |   23 +-
 libavutil/pixdesc.c                           |   41 +
 libavutil/pixfmt.h                            |    7 +
 libavutil/tests/.gitignore                    |    1 -
 libavutil/tests/pixfmt_best.c                 |    1 +
 libavutil/tx.c                                |    4 +-
 libavutil/tx_priv.h                           |   11 +-
 libavutil/tx_template.c                       |   50 +-
 libavutil/version.h                           |    5 +-
 libavutil/x86/tx_float.asm                    |    5 +-
 libpostproc/Makefile                          |    2 +-
 libpostproc/version.h                         |    2 +-
 libswresample/Makefile                        |    2 +-
 libswresample/swresample.c                    |    2 +-
 libswresample/version.h                       |    2 +-
 libswscale/Makefile                           |    2 +-
 libswscale/aarch64/hscale.S                   |  107 ++
 libswscale/aarch64/output.S                   |  188 ++-
 libswscale/aarch64/swscale.c                  |   31 +-
 libswscale/input.c                            |   36 +
 libswscale/output.c                           |   57 +
 libswscale/rgb2rgb.c                          |   12 +-
 libswscale/utils.c                            |    2 +
 libswscale/version.h                          |    4 +-
 libswscale/x86/swscale.c                      |    8 +-
 tests/api/api-h264-test.c                     |    2 +-
 tests/api/api-seek-test.c                     |    2 +-
 tests/checkasm/Makefile                       |    2 +-
 tests/checkasm/checkasm.c                     |    2 +-
 tests/checkasm/checkasm.h                     |    4 +-
 tests/checkasm/flacdsp.c                      |    4 +-
 tests/checkasm/hevc_add_res.c                 |   15 +-
 tests/checkasm/motion.c                       |   13 +-
 tests/checkasm/sw_scale.c                     |  188 ++-
 tests/fate/ffmpeg.mak                         |    8 +
 tests/fate/filter-video.mak                   |    8 +-
 tests/fate/hevc.mak                           |    1 +
 tests/fate/image.mak                          |    4 +
 tests/fate/lavf-image.mak                     |    1 +
 .../audiomatch-afconvert-16000-mono-he-m4a    |    2 +-
 .../audiomatch-afconvert-16000-stereo-he-m4a  |    2 +-
 .../audiomatch-afconvert-16000-stereo-he2-m4a |    2 +-
 .../audiomatch-afconvert-44100-mono-he-m4a    |    2 +-
 .../audiomatch-afconvert-44100-stereo-he-m4a  |    2 +-
 .../audiomatch-afconvert-44100-stereo-he2-m4a |    2 +-
 .../fate/audiomatch-nero-16000-mono-he-m4a    |    2 +-
 .../fate/audiomatch-nero-16000-stereo-he-m4a  |    2 +-
 .../fate/audiomatch-nero-16000-stereo-he2-m4a |    2 +-
 .../fate/audiomatch-nero-44100-mono-he-m4a    |    2 +-
 .../fate/audiomatch-nero-44100-stereo-he-m4a  |    2 +-
 .../fate/audiomatch-nero-44100-stereo-he2-m4a |    2 +-
 tests/ref/fate/copy-shortest1                 |    1 -
 tests/ref/fate/copy-shortest2                 |    1 -
 tests/ref/fate/exif-image-embedded            |   44 +
 tests/ref/fate/exif-image-jpg                 |   30 +-
 tests/ref/fate/exif-image-tiff                |    2 +
 tests/ref/fate/exif-image-webp                |   30 +-
 tests/ref/fate/ffprobe_compact                |   28 +-
 tests/ref/fate/ffprobe_csv                    |   28 +-
 tests/ref/fate/ffprobe_default                |   28 +
 tests/ref/fate/ffprobe_flat                   |   28 +
 tests/ref/fate/ffprobe_ini                    |   28 +
 tests/ref/fate/ffprobe_json                   |   28 +
 tests/ref/fate/ffprobe_xml                    |   28 +-
 tests/ref/fate/ffprobe_xsd                    |   28 +-
 tests/ref/fate/filter-metadata-cropdetect     |   63 +-
 tests/ref/fate/filter-metadata-cropdetect1    |   11 +
 tests/ref/fate/filter-metadata-cropdetect2    |   12 +
 tests/ref/fate/filter-metadata-freezedetect   |    4 +-
 tests/ref/fate/filter-metadata-scdet          |   22 +-
 .../fate/filter-metadata-signalstats-yuv420p  |    2 +-
 .../filter-metadata-signalstats-yuv420p10     |    2 +-
 tests/ref/fate/filter-pixdesc-nv16            |    1 +
 tests/ref/fate/filter-pixdesc-vuya            |    1 +
 tests/ref/fate/filter-pixfmts-copy            |    2 +
 tests/ref/fate/filter-pixfmts-crop            |    2 +
 tests/ref/fate/filter-pixfmts-field           |    2 +
 tests/ref/fate/filter-pixfmts-fieldorder      |    2 +
 tests/ref/fate/filter-pixfmts-hflip           |    2 +
 tests/ref/fate/filter-pixfmts-il              |    2 +
 tests/ref/fate/filter-pixfmts-null            |    2 +
 tests/ref/fate/filter-pixfmts-pad             |    2 +
 tests/ref/fate/filter-pixfmts-scale           |    2 +
 tests/ref/fate/filter-pixfmts-transpose       |    1 +
 tests/ref/fate/filter-pixfmts-vflip           |    2 +
 tests/ref/fate/flcl1905                       |  350 ++---
 tests/ref/fate/flv-add_keyframe_index         |    2 +-
 tests/ref/fate/h264-dts_5frames               |   10 +
 ...formance-WPP_HIGH_TP_444_8BIT_RExt_Apple_2 |    8 +
 tests/ref/fate/imgutils                       |    3 +
 tests/ref/fate/jpg-icc                        |    2 +
 tests/ref/fate/matroska-flac-extradata-update |   16 +-
 tests/ref/fate/mkv-1242                       |    3 -
 tests/ref/fate/mov-zombie                     |  130 +-
 tests/ref/fate/pixfmt_best                    |    2 +-
 tests/ref/fate/png-icc                        |    2 +
 tests/ref/fate/png-icc-parse                  |   48 +
 tests/ref/fate/png-side-data                  |    2 +
 tests/ref/fate/shortest-sub                   |    4 +
 tests/ref/fate/sws-pixdesc-query              |   17 +
 tests/ref/fate/wmv8-x8intra                   |  644 ++++-----
 tests/ref/lavf/wbmp                           |    3 +
 tests/ref/seek/vsynth_lena-mpeg4-adap         |   28 +-
 tests/ref/vsynth/vsynth1-mpeg4-adap           |    8 +-
 tests/ref/vsynth/vsynth2-mpeg4-adap           |    8 +-
 tests/ref/vsynth/vsynth3-mpeg4-adap           |    8 +-
 tests/ref/vsynth/vsynth_lena-mpeg4-adap       |    8 +-
 tools/Makefile                                |    2 +
 tools/target_dec_fuzzer.c                     |    9 +-
 980 files changed, 19382 insertions(+), 10581 deletions(-)
 create mode 100644 compat/windows/mswindres
 create mode 100644 fftools/ffmpeg_demux.c
 create mode 100644 fftools/ffmpeg_wrap.c
 create mode 100644 fftools/fftools.manifest
 create mode 100644 fftools/fftoolsres.rc
 create mode 100644 fftools/objpool.c
 create mode 100644 fftools/objpool.h
 create mode 100644 fftools/sync_queue.c
 create mode 100644 fftools/sync_queue.h
 create mode 100644 fftools/thread_queue.c
 create mode 100644 fftools/thread_queue.h
 create mode 100644 libavcodec/arm/vpx_arith.h
 create mode 100644 libavcodec/fflcms2.c
 create mode 100644 libavcodec/fflcms2.h
 create mode 100644 libavcodec/flacencdsp.c
 create mode 100644 libavcodec/flacencdsp.h
 create mode 100644 libavcodec/hdr_parser.c
 create mode 100644 libavcodec/hdrdec.c
 create mode 100644 libavcodec/hdrenc.c
 create mode 100644 libavcodec/libaom.c
 create mode 100644 libavcodec/libaom.h
 create mode 100644 libavcodec/rkmppenc.c
 create mode 100644 libavcodec/vp89_rac.h
 create mode 100644 libavcodec/vpx_rac.c
 create mode 100644 libavcodec/vpx_rac.h
 create mode 100644 libavcodec/wbmpdec.c
 create mode 100644 libavcodec/wbmpenc.c
 create mode 100644 libavcodec/x86/flacencdsp_init.c
 create mode 100644 libavcodec/x86/vpx_arith.h
 create mode 100644 libavfilter/edge_template.c
 create mode 100644 libavfilter/vf_scale_rga.c
 create mode 100644 libavfilter/vsrc_ddagrab.c
 create mode 100644 libavfilter/vsrc_ddagrab_shaders.h
 create mode 100644 libavrkmpp/Makefile
 create mode 100644 libavrkmpp/avrkmpp.h
 create mode 100644 libavrkmpp/libavrkmpp.v
 create mode 100644 libavrkmpp/rkmppdec.c
 create mode 100644 libavrkmpp/rkmppenc.c
 create mode 100644 libavrkmpp/version.c
 create mode 100644 libavrkmpp/version.h
 create mode 100644 libavrkmpp/version_major.h
 create mode 100644 libavrkmpp/vf_scale_rga.c
 create mode 100644 tests/ref/fate/filter-metadata-cropdetect1
 create mode 100644 tests/ref/fate/filter-metadata-cropdetect2
 create mode 100644 tests/ref/fate/filter-pixdesc-nv16
 create mode 100644 tests/ref/fate/filter-pixdesc-vuya
 create mode 100644 tests/ref/fate/hevc-conformance-WPP_HIGH_TP_444_8BIT_RExt_Apple_2
 create mode 100644 tests/ref/fate/png-icc-parse
 create mode 100644 tests/ref/fate/shortest-sub
 create mode 100644 tests/ref/lavf/wbmp

diff --git a/Changelog b/Changelog
index 86f547c..fa83786 100644
--- a/Changelog
+++ b/Changelog
@@ -1,81 +1,15 @@
 Entries are sorted chronologically from oldest to youngest within each release,
 releases are sorted from youngest to oldest.
 
-version 5.1.2:
-- avcodec/dstdec: Check for overflow in build_filter()
-- avformat/spdifdec: Use 64bit to compute bit rate
-- avformat/rpl: Use 64bit for duration computation
-- avformat/xwma: Use av_rescale() for duration computation
-- avformat/sdsdec: Use av_rescale() to avoid intermediate overflow in duration calculation
-- avformat/sbgdec: Check ts_int in genrate_intervals
-- avformat/sbgdec: clamp end_ts
-- avformat/rmdec: check tag_size
-- avformat/nutdec: Check fields
-- avformat/flvdec: Use 64bit for sum_flv_tag_size
-- avformat/jacosubdec: Fix overflow in get_shift()
-- avformat/genh: Check nb_channels for IMA ADPCM
-- avformat/dxa: avoid bpc overflows
-- avformat/dhav: Use 64bit seek_back
-- avformat/cafdec: Check that nb_frasmes fits within 64bit
-- avformat/asfdec_o: Limit packet offset
-- avformat/apm: Use 64bit for bit_rate computation
-- avformat/ape: Check frames size
-- avformat/icodec: Check nb_pal
-- avformat/aiffdec: Use 64bit for block_duration use
-- avformat/aiffdec: Check block_duration
-- avformat/mxfdec: only probe max run in
-- avformat/mxfdec: Check run_in is within 65536
-- avcodec/mjpegdec: Check for unsupported bayer case
-- avcodec/apedec: Fix integer overflow in filter_3800()
-- avcodec/tta: Check 24bit scaling for overflow
-- avcodec/mobiclip: Check quantizer for overflow
-- avcodec/exr: Check preview psize
-- avcodec/tiff: Fix loop detection
-- libavformat/hls: Free keys
-- avcodec/fmvc: Move frame allocation to a later stage
-- avfilter/vf_showinfo: remove backspaces
-- avcodec/speedhq: Check width
-- avcodec/bink: disallow odd positioned scaled blocks
-- avformat/cafenc: derive Opus frame size from the relevant stream parameters
-- avformat/dashdec: Fix crash on invalid input/ENOMEM, fix leak
-- lavc/videotoolbox: do not pass AVCodecContext to decoder output callback
-- lavc/pthread_frame: always transfer stashed hwaccel state
-- avcodec/arm/sbcenc: avoid callee preserved vfp registers
-- avformat/riffdec: don't unconditionally overwrite WAVEFORMATEXTENSIBLE layout
-- avfilter/vf_scale: overwrite the width and height expressions with the original values
-- lavc/pthread_frame: avoid leaving stale hwaccel state in worker threads
-- avutil/tests/.gitignore: Add channel_layout testtool
-
-
-version 5.1.1:
-- avformat/asfdec_o: limit recursion depth in asf_read_unknown()
-- avformat/mov: Check count sums in build_open_gop_key_points()
-- doc/git-howto.texi: Document commit signing
-- libavcodec/8bps: Check that line lengths fit within the buffer
-- avcodec/midivid: Perform lzss_uncompress() before ff_reget_buffer()
-- libavformat/iff: Check for overflow in body_end calculation
-- avformat/avidec: Prevent entity expansion attacks
-- avcodec/h263dec: Sanity check against minimal I/P frame size
-- avcodec/hevcdec: Check s->ref in the md5 path similar to hwaccel
-- avcodec/mpegaudiodec_template: use unsigned shift in handle_crc()
-- avformat/subviewerdec: Make read_ts() more flexible
-- avcodec/mjpegdec: bayer and rct are incompatible
-- MAINTAINERS: Add ED25519 key for signing my commits in the future
-- avcodec/pngdec: Fix APNG_DISPOSE_OP_BACKGROUND
-- avcodec/libvpx: fix assembling vp9 packets with alpha channel
-- fftools/ffmpeg_opt: try to propagate the requested output channel layout
-- avcodec/libsvtav1: properly initialize the flush EbBufferHeaderType struct
-- configure: enable the av1_frame_split bsf for the av1 decoder
-- swresample/swresample: fill the correct buffer to print the output layout string
-- ffprobe: restore reporting error code for failed inputs
-- ipfsgateway: Remove default gateway
-- avcodec/libspeexdec: Fix use of uninitialized value
-- avformat/avisynth: use ch_layout.nb_channels for channel count
-- fate/lavf-image: Disable file checksums for exr tests
-- tests/fate-run: Allow to skip file checksums for lavf_image
-- fate/imf: Rename IMF fate-target
-- avcodec/alac: don't fail if channels aren't set during init() when extradata is valid
-- configure: properly require libx264 if enabled
+version <next>:
+- Radiance HDR image support
+- ddagrab (Desktop Duplication) video capture filter
+- ffmpeg -shortest_buf_duration option
+- ffmpeg now requires threading to be built
+- ffmpeg now runs every muxer in a separate thread
+- Add new mode to cropdetect filter to detect crop-area based on motion vectors and edges
+- VAAPI decoding and encoding for 8bit 444 HEVC and VP9
+- WBMP (Wireless Application Protocol Bitmap) image format
 
 
 version 5.1:
diff --git a/MAINTAINERS b/MAINTAINERS
index 499f6ad..ed2ec0b 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -40,7 +40,8 @@ Miscellaneous Areas
 ===================
 
 documentation                           Stefano Sabatini, Mike Melanson, Timothy Gu, Gyan Doshi
-project server                          rpd Gereffy, Michael Niedermayer, Reimar Doeffinger, Alexander Strasser, Nikolay Aleksandrov
+project server day to day operations    rpd Gereffy, Michael Niedermayer, Reimar Doeffinger, Alexander Strasser, Nikolay Aleksandrov
+project server emergencies              rpd Gereffy, Reimar Doeffinger, Alexander Strasser, Nikolay Aleksandrov
 presets                                 Robert Swain
 metadata subsystem                      Aurelien Jacobs
 release management                      Michael Niedermayer
diff --git a/Makefile b/Makefile
index 61f79e2..27f7347 100644
--- a/Makefile
+++ b/Makefile
@@ -19,10 +19,11 @@ vpath %/fate_config.sh.template $(SRC_PATH)
 TESTTOOLS   = audiogen videogen rotozoom tiny_psnr tiny_ssim base64 audiomatch
 HOSTPROGS  := $(TESTTOOLS:%=tests/%) doc/print_options
 
-ALLFFLIBS = avcodec avdevice avfilter avformat avutil postproc swscale swresample
+ALLFFLIBS = avcodec avdevice avfilter avformat avutil postproc swscale swresample avrkmpp
 
 # $(FFLIBS-yes) needs to be in linking order
 FFLIBS-$(CONFIG_AVDEVICE)   += avdevice
+FFLIBS-$(CONFIG_RKMPP)      += avrkmpp
 FFLIBS-$(CONFIG_AVFILTER)   += avfilter
 FFLIBS-$(CONFIG_AVFORMAT)   += avformat
 FFLIBS-$(CONFIG_AVCODEC)    += avcodec
diff --git a/README.md b/README.md
index f8c23f2..d516b56 100644
--- a/README.md
+++ b/README.md
@@ -1,3 +1,7 @@
+ RK35XX  Jellyfinfirefox https://github.com/hbiyik/FFmpeg/ 
+
+This project is mainly used to support hardware transcoding of RK35XX platform, for example, to support Jellyfin. If you want to use it on a desktop system (such as firefox), or this project cannot meet your needs, you can try https://github.com/hbiyik/FFmpeg/ .
+
 FFmpeg README
 =============
 
diff --git a/compat/windows/mswindres b/compat/windows/mswindres
new file mode 100644
index 0000000..450525a
--- /dev/null
+++ b/compat/windows/mswindres
@@ -0,0 +1,32 @@
+#!/bin/sh
+
+if [ "$1" = "--version" ]; then
+    rc.exe /?
+    exit $?
+fi
+
+if [ $# -lt 2 ]; then
+    echo "Usage: mswindres [-I/include/path ...] [-DSOME_DEFINE ...] [-o output.o] input.rc [output.o]" >&2
+    exit 0
+fi
+
+EXTRA_OPTS="/nologo"
+
+while [ $# -gt 2 ]; do
+    case $1 in
+    -D*) EXTRA_OPTS="$EXTRA_OPTS /d$(echo $1 | sed -e "s/^..//" -e "s/ /\\\\ /g")" ;;
+    -I*) EXTRA_OPTS="$EXTRA_OPTS /i$(echo $1 | sed -e "s/^..//" -e "s/ /\\\\ /g")" ;;
+    -o)  OPT_OUT="$2"; shift ;;
+    esac
+    shift
+done
+
+IN="$1"
+if [ -z "$OPT_OUT" ]; then
+    OUT="$2"
+else
+    OUT="$OPT_OUT"
+fi
+
+eval set -- $EXTRA_OPTS
+rc.exe "$@" /fo "$OUT" "$IN"
diff --git a/configure b/configure
index ba5793b..f2f2f04 100644
--- a/configure
+++ b/configure
@@ -341,6 +341,7 @@ External library support:
   --disable-ffnvcodec      disable dynamically linked Nvidia code [autodetect]
   --enable-libdrm          enable DRM code (Linux) [no]
   --enable-libmfx          enable Intel MediaSDK (AKA Quick Sync Video) code via libmfx [no]
+  --enable-libvpl          enable Intel oneVPL code via libvpl if libmfx is not used [no]
   --enable-libnpp          enable Nvidia Performance Primitives-based code [no]
   --enable-mmal            enable Broadcom Multi-Media Abstraction Layer (Raspberry Pi) via MMAL [no]
   --disable-nvdec          disable Nvidia video decoding acceleration (via hwaccel) [autodetect]
@@ -348,6 +349,7 @@ External library support:
   --enable-omx             enable OpenMAX IL code [no]
   --enable-omx-rpi         enable OpenMAX IL code for Raspberry Pi [no]
   --enable-rkmpp           enable Rockchip Media Process Platform code [no]
+  --enable-librga          enable Rockchip RGA 2D accel via librga [autodetect]
   --disable-v4l2-m2m       disable V4L2 mem2mem code [autodetect]
   --disable-vaapi          disable Video Acceleration API (mainly Unix/Intel) code [autodetect]
   --disable-vdpau          disable Nvidia Video Decode and Presentation API for Unix code [autodetect]
@@ -1904,6 +1906,7 @@ HWACCEL_AUTODETECT_LIBRARY_LIST="
     videotoolbox
     vulkan
     v4l2_m2m
+    librga
 "
 
 # catchall list of things that require external libs to link
@@ -1921,6 +1924,7 @@ HWACCEL_LIBRARY_NONFREE_LIST="
 HWACCEL_LIBRARY_LIST="
     $HWACCEL_LIBRARY_NONFREE_LIST
     libmfx
+    libvpl
     mmal
     omx
     opencl
@@ -1957,6 +1961,7 @@ LIBRARY_LIST="
     avcodec
     swresample
     avutil
+    avrkmpp
 "
 
 LICENSE_LIST="
@@ -2352,6 +2357,8 @@ TOOLCHAIN_FEATURES="
 "
 
 TYPES_LIST="
+    DPI_AWARENESS_CONTEXT
+    IDXGIOutput5
     kCMVideoCodecType_HEVC
     kCMVideoCodecType_HEVCWithAlpha
     kCMVideoCodecType_VP9
@@ -2447,7 +2454,6 @@ CONFIG_EXTRA="
     faandct
     faanidct
     fdctdsp
-    flacdsp
     fmtconvert
     frame_thread_encoder
     g722dsp
@@ -2488,6 +2494,8 @@ CONFIG_EXTRA="
     mpegvideo
     mpegvideodec
     mpegvideoenc
+    msmpeg4dec
+    msmpeg4enc
     mss34dsp
     pixblockdsp
     qpeldsp
@@ -2731,7 +2739,7 @@ h264dsp_select="startcode"
 hevcparse_select="atsc_a53 golomb"
 frame_thread_encoder_deps="encoders threads"
 inflate_wrapper_deps="zlib"
-intrax8_select="blockdsp idctdsp"
+intrax8_select="blockdsp wmv2dsp"
 iso_media_select="mpeg4audio"
 mdct_select="fft"
 mdct15_select="fft"
@@ -2742,6 +2750,8 @@ mpegaudiodsp_select="dct"
 mpegvideo_select="blockdsp h264chroma hpeldsp idctdsp videodsp"
 mpegvideodec_select="mpegvideo mpeg_er"
 mpegvideoenc_select="aandcttables me_cmp mpegvideo pixblockdsp qpeldsp"
+msmpeg4dec_select="h263_decoder"
+msmpeg4enc_select="h263_encoder"
 vc1dsp_select="h264chroma qpeldsp startcode"
 rdft_select="fft"
 
@@ -2781,7 +2791,7 @@ atrac3al_decoder_select="mdct"
 atrac3p_decoder_select="mdct sinewin"
 atrac3pal_decoder_select="mdct sinewin"
 atrac9_decoder_select="mdct"
-av1_decoder_select="av1_frame_split_bsf cbs_av1"
+av1_decoder_select="cbs_av1"
 bink_decoder_select="blockdsp hpeldsp"
 binkaudio_dct_decoder_select="mdct rdft dct sinewin wma_freqs"
 binkaudio_rdft_decoder_select="mdct rdft sinewin wma_freqs"
@@ -2815,8 +2825,7 @@ ffv1_encoder_select="rangecoder"
 ffvhuff_decoder_select="huffyuv_decoder"
 ffvhuff_encoder_select="huffyuv_encoder"
 fic_decoder_select="golomb"
-flac_decoder_select="flacdsp"
-flac_encoder_select="bswapdsp flacdsp lpc"
+flac_encoder_select="bswapdsp lpc"
 flashsv2_decoder_select="inflate_wrapper"
 flashsv2_encoder_select="deflate_wrapper"
 flashsv_decoder_select="inflate_wrapper"
@@ -2891,11 +2900,11 @@ mpeg4_decoder_select="h263_decoder mpeg4video_parser"
 mpeg4_encoder_select="h263_encoder"
 msa1_decoder_select="mss34dsp"
 mscc_decoder_select="inflate_wrapper"
-msmpeg4v1_decoder_select="h263_decoder"
-msmpeg4v2_decoder_select="h263_decoder"
-msmpeg4v2_encoder_select="h263_encoder"
-msmpeg4v3_decoder_select="h263_decoder"
-msmpeg4v3_encoder_select="h263_encoder"
+msmpeg4v1_decoder_select="msmpeg4dec"
+msmpeg4v2_decoder_select="msmpeg4dec"
+msmpeg4v2_encoder_select="msmpeg4enc"
+msmpeg4v3_decoder_select="msmpeg4dec"
+msmpeg4v3_encoder_select="msmpeg4enc"
 mss2_decoder_select="mpegvideodec qpeldsp vc1_decoder"
 mts2_decoder_select="jpegtables mss34dsp"
 mv30_decoder_select="aandcttables blockdsp"
@@ -2966,7 +2975,7 @@ utvideo_encoder_select="bswapdsp huffman llvidencdsp"
 vble_decoder_select="llviddsp"
 vbn_decoder_select="texturedsp"
 vbn_encoder_select="texturedspenc"
-vc1_decoder_select="blockdsp h263_decoder h264qpel intrax8 mpegvideodec vc1dsp"
+vc1_decoder_select="blockdsp h264qpel intrax8 mpegvideodec msmpeg4dec vc1dsp"
 vc1image_decoder_select="vc1_decoder"
 vorbis_decoder_select="mdct"
 vorbis_encoder_select="audio_frame_queue mdct"
@@ -2988,10 +2997,10 @@ wmav1_encoder_select="mdct sinewin wma_freqs"
 wmav2_decoder_select="mdct sinewin wma_freqs"
 wmav2_encoder_select="mdct sinewin wma_freqs"
 wmavoice_decoder_select="lsp rdft dct mdct sinewin"
-wmv1_decoder_select="h263_decoder"
-wmv1_encoder_select="h263_encoder"
-wmv2_decoder_select="blockdsp error_resilience h263_decoder idctdsp intrax8 videodsp wmv2dsp"
-wmv2_encoder_select="h263_encoder wmv2dsp"
+wmv1_decoder_select="msmpeg4dec"
+wmv1_encoder_select="msmpeg4enc"
+wmv2_decoder_select="blockdsp error_resilience idctdsp intrax8 msmpeg4dec videodsp wmv2dsp"
+wmv2_encoder_select="msmpeg4enc wmv2dsp"
 wmv3_decoder_select="vc1_decoder"
 wmv3image_decoder_select="wmv3_decoder"
 xma1_decoder_select="wmapro_decoder"
@@ -3156,6 +3165,8 @@ overlay_cuda_filter_deps="ffnvcodec"
 overlay_cuda_filter_deps_any="cuda_nvcc cuda_llvm"
 sharpen_npp_filter_deps="ffnvcodec libnpp"
 
+ddagrab_filter_deps="d3d11va IDXGIOutput1 DXGI_OUTDUPL_FRAME_INFO"
+
 amf_deps_any="libdl LoadLibrary"
 nvenc_deps="ffnvcodec"
 nvenc_deps_any="libdl LoadLibrary"
@@ -3163,8 +3174,10 @@ nvenc_deps_any="libdl LoadLibrary"
 aac_mf_encoder_deps="mediafoundation"
 ac3_mf_encoder_deps="mediafoundation"
 av1_cuvid_decoder_deps="cuvid CUVIDAV1PICPARAMS"
+av1_rkmpp_decoder_deps="rkmpp"
 h263_v4l2m2m_decoder_deps="v4l2_m2m h263_v4l2_m2m"
 h263_v4l2m2m_encoder_deps="v4l2_m2m h263_v4l2_m2m"
+h263_rkmpp_decoder_deps="rkmpp"
 h264_amf_encoder_deps="amf"
 h264_crystalhd_decoder_select="crystalhd h264_mp4toannexb_bsf h264_parser"
 h264_cuvid_decoder_deps="cuvid"
@@ -3180,6 +3193,7 @@ h264_qsv_decoder_select="h264_mp4toannexb_bsf qsvdec"
 h264_qsv_encoder_select="atsc_a53 qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
 h264_rkmpp_decoder_select="h264_mp4toannexb_bsf"
+h264_rkmpp_encoder_deps="rkmpp"
 h264_vaapi_encoder_select="cbs_h264 vaapi_encode"
 h264_v4l2m2m_decoder_deps="v4l2_m2m h264_v4l2_m2m"
 h264_v4l2m2m_decoder_select="h264_mp4toannexb_bsf"
@@ -3210,6 +3224,7 @@ mjpeg_vaapi_encoder_select="cbs_jpeg jpegtables vaapi_encode"
 mp3_mf_encoder_deps="mediafoundation"
 mpeg1_cuvid_decoder_deps="cuvid"
 mpeg1_v4l2m2m_decoder_deps="v4l2_m2m mpeg1_v4l2_m2m"
+mpeg1_rkmpp_decoder_deps="rkmpp"
 mpeg2_crystalhd_decoder_select="crystalhd"
 mpeg2_cuvid_decoder_deps="cuvid"
 mpeg2_mmal_decoder_deps="mmal"
@@ -3218,6 +3233,7 @@ mpeg2_qsv_decoder_select="qsvdec"
 mpeg2_qsv_encoder_select="qsvenc"
 mpeg2_vaapi_encoder_select="cbs_mpeg2 vaapi_encode"
 mpeg2_v4l2m2m_decoder_deps="v4l2_m2m mpeg2_v4l2_m2m"
+mpeg2_rkmpp_decoder_deps="rkmpp"
 mpeg4_crystalhd_decoder_select="crystalhd"
 mpeg4_cuvid_decoder_deps="cuvid"
 mpeg4_mediacodec_decoder_deps="mediacodec"
@@ -3225,6 +3241,7 @@ mpeg4_mmal_decoder_deps="mmal"
 mpeg4_omx_encoder_deps="omx"
 mpeg4_v4l2m2m_decoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
 mpeg4_v4l2m2m_encoder_deps="v4l2_m2m mpeg4_v4l2_m2m"
+mpeg4_rkmpp_decoder_deps="rkmpp"
 msmpeg4_crystalhd_decoder_select="crystalhd"
 vc1_crystalhd_decoder_select="crystalhd"
 vc1_cuvid_decoder_deps="cuvid"
@@ -3615,6 +3632,7 @@ libzmq_protocol_deps="libzmq"
 libzmq_protocol_select="network"
 
 # filters
+scale_rga_filter_deps="rkmpp librga"
 ametadata_filter_deps="avformat"
 amovie_filter_deps="avcodec avformat"
 aresample_filter_deps="swresample"
@@ -3810,12 +3828,12 @@ swresample_suggest="libm libsoxr stdatomic"
 swscale_deps="avutil"
 swscale_suggest="libm stdatomic"
 
-avcodec_extralibs="pthreads_extralibs iconv_extralibs dxva2_extralibs"
+avcodec_extralibs="pthreads_extralibs iconv_extralibs dxva2_extralibs lcms2_extralibs"
 avfilter_extralibs="pthreads_extralibs"
 avutil_extralibs="d3d11va_extralibs nanosleep_extralibs pthreads_extralibs vaapi_drm_extralibs vaapi_x11_extralibs vdpau_x11_extralibs"
 
 # programs
-ffmpeg_deps="avcodec avfilter avformat"
+ffmpeg_deps="avcodec avfilter avformat threads"
 ffmpeg_select="aformat_filter anull_filter atrim_filter format_filter
                hflip_filter null_filter
                transpose_filter trim_filter vflip_filter"
@@ -4363,6 +4381,7 @@ case "$toolchain" in
             die "Unsupported MSVC version (2013 or newer required)"
         fi
         ld_default="$source_path/compat/windows/mslink"
+        windres_default="$source_path/compat/windows/mswindres"
         nm_default="dumpbin.exe -symbols"
         ar_default="lib.exe"
         case "${arch:-$arch_default}" in
@@ -5563,7 +5582,7 @@ case $target_os in
             # Cannot build both shared and static libs when using dllimport.
             disable static
         fi
-        enabled shared && ! enabled small && test_cmd $windres --version && enable gnu_windres
+        ! enabled small && test_cmd $windres --version && enable gnu_windres
         enabled x86_32 && check_ldflags -Wl,--large-address-aware
         shlibdir_default="$bindir_default"
         SLIBPREF=""
@@ -5613,6 +5632,7 @@ case $target_os in
             # Cannot build both shared and static libs with MSVC or icl.
             disable static
         fi
+        ! enabled small && test_cmd $windres --version && enable gnu_windres
         enabled x86_32 && check_ldflags -LARGEADDRESSAWARE
         shlibdir_default="$bindir_default"
         SLIBPREF=""
@@ -5642,7 +5662,7 @@ case $target_os in
         SHFLAGS='-shared -Wl,--out-implib,$(SUBDIR)lib$(FULLNAME).dll.a'
         enabled x86_64 && objformat="win64" || objformat="win32"
         enable dos_paths
-        enabled shared && ! enabled small && test_cmd $windres --version && enable gnu_windres
+        ! enabled small && test_cmd $windres --version && enable gnu_windres
         add_cppflags -D_POSIX_C_SOURCE=200112 -D_XOPEN_SOURCE=600
         ;;
     *-dos|freedos|opendos)
@@ -6391,8 +6411,12 @@ check_struct "sys/time.h sys/resource.h" "struct rusage" ru_maxrss
 check_type "windows.h dxva.h" "DXVA_PicParams_AV1" -DWINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP -D_CRT_BUILD_DESKTOP_APP=0
 check_type "windows.h dxva.h" "DXVA_PicParams_HEVC" -DWINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP -D_CRT_BUILD_DESKTOP_APP=0
 check_type "windows.h dxva.h" "DXVA_PicParams_VP9" -DWINAPI_FAMILY=WINAPI_FAMILY_DESKTOP_APP -D_CRT_BUILD_DESKTOP_APP=0
+check_type "windows.h dxgi1_2.h" "DXGI_OUTDUPL_FRAME_INFO"
+check_type "windows.h dxgi1_2.h" "IDXGIOutput1"
+check_type "windows.h dxgi1_5.h" "IDXGIOutput5"
 check_type "windows.h d3d11.h" "ID3D11VideoDecoder"
 check_type "windows.h d3d11.h" "ID3D11VideoContext"
+check_type "windows.h" "DPI_AWARENESS_CONTEXT" -D_WIN32_WINNT=0x0A00
 check_type "d3d9.h dxva2api.h" DXVA2_ConfigPictureDecode -D_WIN32_WINNT=0x0602
 check_func_headers mfapi.h MFCreateAlignedMemoryBuffer -lmfplat
 
@@ -6567,19 +6591,37 @@ enabled libjxl            && require_pkg_config libjxl "libjxl >= 0.7.0" jxl/dec
 enabled libklvanc         && require libklvanc libklvanc/vanc.h klvanc_context_create -lklvanc
 enabled libkvazaar        && require_pkg_config libkvazaar "kvazaar >= 0.8.1" kvazaar.h kvz_api_get
 enabled liblensfun        && require_pkg_config liblensfun lensfun lensfun.h lf_db_new
+
+if enabled libmfx && enabled libvpl; then
+   die "ERROR: can not use libmfx and libvpl together"
 # While it may appear that require is being used as a pkg-config
 # fallback for libmfx, it is actually being used to detect a different
 # installation route altogether.  If libmfx is installed via the Intel
 # Media SDK or Intel Media Server Studio, these don't come with
 # pkg-config support.  Instead, users should make sure that the build
 # can find the libraries and headers through other means.
-enabled libmfx            && { check_pkg_config libmfx "libmfx >= 1.28" "mfx/mfxvideo.h" MFXInit ||
-                               { require libmfx "mfx/mfxvideo.h mfx/mfxdefs.h" MFXInit "-llibmfx $advapi32_extralibs" &&
-                                 { test_cpp_condition mfx/mfxdefs.h "MFX_VERSION >= 1028" || die "ERROR: libmfx version must be >= 1.28"; }  &&
-                                 warn "using libmfx without pkg-config"; } }
+elif enabled libmfx; then
+    { check_pkg_config libmfx "libmfx >= 1.28 libmfx < 2.0" "mfxvideo.h" MFXInit ||
+# Some old versions of libmfx have the following settings in libmfx.pc:
+#   includedir=/usr/include
+#   Cflags: -I${includedir}
+# So add -I${includedir}/mfx to CFLAGS
+      { check_pkg_config libmfx "libmfx >= 1.28 libmfx < 2.0" "mfx/mfxvideo.h" MFXInit && add_cflags -I${libmfx_incdir}/mfx; } ||
+      { require libmfx "mfxvideo.h mfxdefs.h" MFXInit "-llibmfx $advapi32_extralibs" &&
+        { test_cpp_condition mfxdefs.h "MFX_VERSION >= 1028 && MFX_VERSION < 2000" || die "ERROR: libmfx version must be >= 1.28 and < 2.0"; }  &&
+        warn "using libmfx without pkg-config"; } } &&
+    warn "build FFmpeg against libmfx 1.x, obsolete features of libmfx such as OPAQUE memory,\n"\
+         "multi-frame encode, user plugins and LA_EXT rate control mode are enabled"
+elif enabled libvpl; then
+# Consider pkg-config only. The name of libmfx is still passed to check_pkg_config function for --enable-libvpl option
+# because QSV has dependency on libmfx, we can use the same dependency if using libmfx in this check. The package name
+# is extracted from "vpl >= 2.6"
+    check_pkg_config libmfx "vpl >= 2.6" "mfxvideo.h mfxdispatcher.h" MFXLoad || \
+            die "ERROR: libvpl >= 2.6 not found"
+fi
 
 if enabled libmfx; then
-   check_cc MFX_CODEC_VP9 "mfx/mfxvp9.h mfx/mfxstructures.h" "MFX_CODEC_VP9"
+   check_cc MFX_CODEC_VP9 "mfxdefs.h mfxstructures.h" "MFX_CODEC_VP9"
 fi
 
 enabled libmodplug        && require_pkg_config libmodplug libmodplug libmodplug/modplug.h ModPlug_Load
@@ -6667,7 +6709,7 @@ enabled libwebp           && {
     enabled libwebp_encoder      && require_pkg_config libwebp "libwebp >= 0.2.0" webp/encode.h WebPGetEncoderVersion
     enabled libwebp_anim_encoder && check_pkg_config libwebp_anim_encoder "libwebpmux >= 0.4.0" webp/mux.h WebPAnimEncoderOptionsInit; }
 enabled libx264           && require_pkg_config libx264 x264 "stdint.h x264.h" x264_encoder_encode &&
-                             require_cpp_condition libx264 x264.h "X264_BUILD >= 118" && {
+                             require_cpp_condition libx264 x264.h "X264_BUILD >= 122" && {
                              [ "$toolchain" != "msvc" ] ||
                              require_cpp_condition libx264 x264.h "X264_BUILD >= 158"; } &&
                              check_cpp_condition libx262 x264.h "X264_MPEG2"
@@ -6730,11 +6772,16 @@ enabled openssl           && { { check_pkg_config openssl "openssl >= 3.0.0" ope
                                check_lib openssl openssl/ssl.h SSL_library_init -lssl -lcrypto -lws2_32 -lgdi32 ||
                                die "ERROR: openssl not found"; }
 enabled pocketsphinx      && require_pkg_config pocketsphinx pocketsphinx pocketsphinx/pocketsphinx.h ps_init
+enabled librga            && check_lib librga rga/RgaApi.h c_RkRgaInit -lrga && prepend rkmpp_deps "librga"
 enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/rk_mpi.h mpp_create &&
                                require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.7" rockchip/rk_mpi.h mpp_create &&
                                { enabled libdrm ||
-                                 die "ERROR: rkmpp requires --enable-libdrm"; }
+                                 die "ERROR: rkmpp requires --enable-libdrm"; } &&
+                               { enabled librga ||
+                                 warn "using rkmpp without librga"; }
                              }
+enabled librga            && enable scale_rga_filter
+enabled rkmpp             && enable avrkmpp
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
 
@@ -7053,7 +7100,7 @@ EOF
 
 # add some linker flags
 check_ldflags -Wl,--warn-common
-check_ldflags -Wl,-rpath-link=:libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec:libavutil
+check_ldflags -Wl,-rpath-link=:libpostproc:libswresample:libswscale:libavfilter:libavdevice:libavformat:libavcodec:libavutil:libavrkmpp
 enabled rpath && add_ldexeflags -Wl,-rpath,$libdir && add_ldsoflags -Wl,-rpath,$libdir
 test_ldflags -Wl,-Bsymbolic && append SHFLAGS -Wl,-Bsymbolic
 
@@ -7424,6 +7471,9 @@ enabled subtitles_filter    && prepend avfilter_deps "avformat avcodec"
 enabled uspp_filter         && prepend avfilter_deps "avcodec"
 enabled zoompan_filter      && prepend avfilter_deps "swscale"
 
+enabled librga              && prepend avfilter_deps "avrkmpp"
+enabled rkmpp               && prepend avcodec_deps "avrkmpp"
+
 enabled lavfi_indev         && prepend avdevice_deps "avfilter"
 
 #FIXME
diff --git a/doc/APIchanges b/doc/APIchanges
index f9a1484..b3ba07e 100644
--- a/doc/APIchanges
+++ b/doc/APIchanges
@@ -14,6 +14,33 @@ libavutil:     2021-04-27
 
 API changes, most recent first:
 
+2022-08-07 - e95b08a7dd - lavu 57.33.101 - pixfmt.h
+  Add AV_PIX_FMT_RGBAF16{BE,LE} pixel formats.
+
+2022-08-xx - xxxxxxxxxx - lavu 57.33.100 - hwcontext_qsv.h
+  Add loader field to AVQSVDeviceContext
+
+2022-08-03 - xxxxxxxxxx - lavu 57.32.100 - pixfmt.h
+  Add AV_PIX_FMT_VUYA.
+
+2022-08-xx - xxxxxxxxxx - lavc 59.41.100 - avcodec.h codec.h
+  Add AV_CODEC_FLAG_RECON_FRAME and AV_CODEC_CAP_ENCODER_RECON_FRAME.
+  avcodec_receive_frame() may now be used on encoders when
+  AV_CODEC_FLAG_RECON_FRAME is active.
+
+2022-08-xx - xxxxxxxxxx - lavu 57.31.100 - frame.h
+  av_frame_make_writable() may now be called on non-refcounted
+  frames and will make a refcounted copy out of them.
+  Previously an error was returned in such cases.
+
+2022-07-xx - xxxxxxxxx - lavc 59.40.100 - avcodec.h
+  Add the AV_CODEC_FLAG2_ICC_PROFILES flag to AVCodecContext, to enable
+  automatic reading and writing of embedded ICC profiles in image files.
+  The "flags2" option now supports the corresponding flag "icc_profiles".
+
+2022-07-xx - xxxxxxxxxx - lavu 57.30.100 - frame.h
+  Add AVFrame.duration, deprecate AVFrame.pkt_duration.
+
 -------- 8< --------- FFmpeg 5.1 was cut here -------- 8< ---------
 
 2022-06-12 - 7cae3d8b76 - lavf 59.25.100 - avio.h
diff --git a/doc/Doxyfile b/doc/Doxyfile
index 6c24f81..0891899 100644
--- a/doc/Doxyfile
+++ b/doc/Doxyfile
@@ -38,7 +38,7 @@ PROJECT_NAME           = FFmpeg
 # could be handy for archiving the generated documentation or if some version
 # control system is used.
 
-PROJECT_NUMBER         = 5.1.2
+PROJECT_NUMBER         =
 
 # Using the PROJECT_BRIEF tag one can provide an optional one line description
 # for a project that appears at the top of each page and should give viewer a
diff --git a/doc/codecs.texi b/doc/codecs.texi
index 5e10020..1adacd2 100644
--- a/doc/codecs.texi
+++ b/doc/codecs.texi
@@ -644,6 +644,8 @@ for codecs that support it. See also @file{doc/examples/export_mvs.c}.
 Do not skip samples and export skip information as frame side data.
 @item ass_ro_flush_noop
 Do not reset ASS ReadOrder field on flush.
+@item icc_profiles
+Generate/parse embedded ICC profiles from/to colorimetry tags.
 @end table
 
 @item export_side_data @var{flags} (@emph{decoding/encoding,audio,video,subtitles})
diff --git a/doc/encoders.texi b/doc/encoders.texi
index 02a91ff..6d73f74 100644
--- a/doc/encoders.texi
+++ b/doc/encoders.texi
@@ -3337,10 +3337,13 @@ For encoders set this flag to ON to reduce power consumption and GPU usage.
 Following options can be used durning qsv encoding.
 
 @table @option
-@item @var{qsv_config_qp}
+@item @var{global_quality}
+@item @var{i_quant_factor}
+@item @var{i_quant_offset}
+@item @var{b_quant_factor}
+@item @var{b_quant_offset}
 Supported in h264_qsv and hevc_qsv.
-This option can be set in per-frame metadata. QP parameter can be dynamically
-changed when encoding in CQP mode.
+Change these value to reset qsv codec's qp configuration.
 @end table
 
 @subsection H264 options
diff --git a/doc/ffmpeg.texi b/doc/ffmpeg.texi
index 767df69..42440d9 100644
--- a/doc/ffmpeg.texi
+++ b/doc/ffmpeg.texi
@@ -992,7 +992,8 @@ to keep the interlaced format for minimum losses.
 The alternative is to deinterlace the input stream by use of a filter
 such as @code{yadif} or @code{bwdif}, but deinterlacing introduces losses.
 @item -psnr
-Calculate PSNR of compressed frames.
+Calculate PSNR of compressed frames. This option is deprecated, pass the
+PSNR flag to the encoder instead, using @code{-flags +psnr}.
 @item -vstats
 Dump video coding statistics to @file{vstats_HHMMSS.log}.
 @item -vstats_file @var{file}
@@ -1410,18 +1411,18 @@ Set the size of the canvas used to render subtitles.
 @section Advanced options
 
 @table @option
-@item -map [-]@var{input_file_id}[:@var{stream_specifier}][?][,@var{sync_file_id}[:@var{stream_specifier}]] | @var{[linklabel]} (@emph{output})
+@item -map [-]@var{input_file_id}[:@var{stream_specifier}][?] | @var{[linklabel]} (@emph{output})
 
-Designate one or more input streams as a source for the output file. Each input
-stream is identified by the input file index @var{input_file_id} and
-the input stream index @var{input_stream_id} within the input
-file. Both indices start at 0. If specified,
-@var{sync_file_id}:@var{stream_specifier} sets which input stream
-is used as a presentation sync reference.
+Create one or more streams in the output file. This option has two forms for
+specifying the data source(s): the first selects one or more streams from some
+input file (specified with @code{-i}), the second takes an output from some
+complex filtergraph (specified with @code{-filter_complex} or
+@code{-filter_complex_script}).
 
-The first @code{-map} option on the command line specifies the
-source for output stream 0, the second @code{-map} option specifies
-the source for output stream 1, etc.
+In the first form, an output stream is created for every stream from the input
+file with the index @var{input_file_id}. If @var{stream_specifier} is given,
+only those streams that match the specifier are used (see the
+@ref{Stream specifiers} section for the @var{stream_specifier} syntax).
 
 A @code{-} character before the stream identifier creates a "negative" mapping.
 It disables matching streams from already created mappings.
@@ -1435,39 +1436,56 @@ An alternative @var{[linklabel]} form will map outputs from complex filter
 graphs (see the @option{-filter_complex} option) to the output file.
 @var{linklabel} must correspond to a defined output link label in the graph.
 
-For example, to map ALL streams from the first input file to output
+This option may be specified multiple times, each adding more streams to the
+output file. Any given input stream may also be mapped any number of times as a
+source for different output streams, e.g. in order to use different encoding
+options and/or filters. The streams are created in the output in the same order
+in which the @code{-map} options are given on the commandline.
+
+Using this option disables the default mappings for this output file.
+
+Examples:
+
+@table @emph
+
+@item map everything
+To map ALL streams from the first input file to output
 @example
 ffmpeg -i INPUT -map 0 output
 @end example
 
-For example, if you have two audio streams in the first input file,
-these streams are identified by "0:0" and "0:1". You can use
-@code{-map} to select which streams to place in an output file. For
-example:
+@item select specific stream
+If you have two audio streams in the first input file, these streams are
+identified by @var{0:0} and @var{0:1}. You can use @code{-map} to select which
+streams to place in an output file. For example:
 @example
 ffmpeg -i INPUT -map 0:1 out.wav
 @end example
-will map the input stream in @file{INPUT} identified by "0:1" to
-the (single) output stream in @file{out.wav}.
+will map the second input stream in @file{INPUT} to the (single) output stream
+in @file{out.wav}.
 
-For example, to select the stream with index 2 from input file
-@file{a.mov} (specified by the identifier "0:2"), and stream with
-index 6 from input @file{b.mov} (specified by the identifier "1:6"),
-and copy them to the output file @file{out.mov}:
+@item create multiple streams
+To select the stream with index 2 from input file @file{a.mov} (specified by the
+identifier @var{0:2}), and stream with index 6 from input @file{b.mov}
+(specified by the identifier @var{1:6}), and copy them to the output file
+@file{out.mov}:
 @example
 ffmpeg -i a.mov -i b.mov -c copy -map 0:2 -map 1:6 out.mov
 @end example
 
+@item create multiple streams 2
 To select all video and the third audio stream from an input file:
 @example
 ffmpeg -i INPUT -map 0:v -map 0:a:2 OUTPUT
 @end example
 
+@item negative map
 To map all the streams except the second audio, use negative mappings
 @example
 ffmpeg -i INPUT -map 0 -map -0:a:1 OUTPUT
 @end example
 
+@item optional map
 To map the video and audio streams from the first input, and using the
 trailing @code{?}, ignore the audio mapping if no audio streams exist in
 the first input:
@@ -1475,12 +1493,13 @@ the first input:
 ffmpeg -i INPUT -map 0:v -map 0:a? OUTPUT
 @end example
 
+@item map by language
 To pick the English audio stream:
 @example
 ffmpeg -i INPUT -map 0:m:language:eng OUTPUT
 @end example
 
-Note that using this option disables the default mappings for this output file.
+@end table
 
 @item -ignore_unknown
 Ignore input streams with unknown type instead of failing if copying
@@ -1491,6 +1510,10 @@ Allow input streams with unknown type to be copied instead of failing if copying
 such streams is attempted.
 
 @item -map_channel [@var{input_file_id}.@var{stream_specifier}.@var{channel_id}|-1][?][:@var{output_file_id}.@var{stream_specifier}]
+This option is deprecated and will be removed. It can be replaced by the
+@var{pan} filter. In some cases it may be easier to use some combination of the
+@var{channelsplit}, @var{channelmap}, or @var{amerge} filters.
+
 Map an audio channel from a given input to an output. If
 @var{output_file_id}.@var{stream_specifier} is not set, the audio channel will
 be mapped on all the audio streams.
@@ -1765,6 +1788,22 @@ Default value is 0.
 Enable bitexact mode for (de)muxer and (de/en)coder
 @item -shortest (@emph{output})
 Finish encoding when the shortest output stream ends.
+
+Note that this option may require buffering frames, which introduces extra
+latency. The maximum amount of this latency may be controlled with the
+@code{-shortest_buf_duration} option.
+
+@item -shortest_buf_duration @var{duration} (@emph{output})
+The @code{-shortest} option may require buffering potentially large amounts
+of data when at least one of the streams is "sparse" (i.e. has large gaps
+between frames  this is typically the case for subtitles).
+
+This option controls the maximum duration of buffered frames in seconds.
+Larger values may allow the @code{-shortest} option to produce more accurate
+results, but increase memory use and latency.
+
+The default value is 10 seconds.
+
 @item -dts_delta_threshold
 Timestamp discontinuity delta threshold.
 @item -dts_error_threshold @var{seconds}
@@ -1899,13 +1938,16 @@ to the @option{-ss} option is considered an actual timestamp, and is not
 offset by the start time of the file. This matters only for files which do
 not start from timestamp 0, such as transport streams.
 
-@item -thread_queue_size @var{size} (@emph{input})
-This option sets the maximum number of queued packets when reading from the
-file or device. With low latency / high rate live streams, packets may be
-discarded if they are not read in a timely manner; setting this value can
+@item -thread_queue_size @var{size} (@emph{input/output})
+For input, this option sets the maximum number of queued packets when reading
+from the file or device. With low latency / high rate live streams, packets may
+be discarded if they are not read in a timely manner; setting this value can
 force ffmpeg to use a separate input thread and read packets as soon as they
 arrive. By default ffmpeg only does this if multiple inputs are specified.
 
+For output, this option specified the maximum number of packets that may be
+queued to each muxing thread.
+
 @item -sdp_file @var{file} (@emph{global})
 Print sdp information for an output stream to @var{file}.
 This allows dumping sdp information when at least one output isn't an
diff --git a/doc/ffprobe.xsd b/doc/ffprobe.xsd
index 3af621a..6e678a9 100644
--- a/doc/ffprobe.xsd
+++ b/doc/ffprobe.xsd
@@ -92,6 +92,8 @@
       <xsd:attribute name="best_effort_timestamp_time" type="xsd:float" />
       <xsd:attribute name="pkt_duration"  type="xsd:long" />
       <xsd:attribute name="pkt_duration_time" type="xsd:float"/>
+      <xsd:attribute name="duration"      type="xsd:long" />
+      <xsd:attribute name="duration_time" type="xsd:float"/>
       <xsd:attribute name="pkt_pos"       type="xsd:long" />
       <xsd:attribute name="pkt_size"      type="xsd:int" />
 
diff --git a/doc/filters.texi b/doc/filters.texi
index 40f21fb..01a359f 100644
--- a/doc/filters.texi
+++ b/doc/filters.texi
@@ -2210,13 +2210,6 @@ and @var{pan} audio filters support many formats). If the @var{amix}
 input has integer samples then @ref{aresample} will be automatically
 inserted to perform the conversion to float samples.
 
-For example
-@example
-ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex amix=inputs=3:duration=first:dropout_transition=3 OUTPUT
-@end example
-will mix 3 input audio streams to a single output with the same duration as the
-first input and a dropout transition time of 3 seconds.
-
 It accepts the following parameters:
 @table @option
 
@@ -2243,8 +2236,10 @@ The transition time, in seconds, for volume renormalization when an input
 stream ends. The default value is 2 seconds.
 
 @item weights
-Specify weight of each input audio stream as sequence.
-Each weight is separated by space. By default all inputs have same weight.
+Specify weight of each input audio stream as a sequence of numbers separated
+by a space. If fewer weights are specified compared to number of inputs, the
+last weight is assigned to the remaining inputs.
+Default weight for each input is 1.
 
 @item normalize
 Always scale inputs instead of only doing summation of samples.
@@ -2252,6 +2247,26 @@ Beware of heavy clipping if inputs are not normalized prior or after filtering
 by this filter if this option is disabled. By default is enabled.
 @end table
 
+@subsection Examples
+
+@itemize
+
+@item
+This will mix 3 input audio streams to a single output with the same duration as the
+first input and a dropout transition time of 3 seconds:
+@example
+ffmpeg -i INPUT1 -i INPUT2 -i INPUT3 -filter_complex amix=inputs=3:duration=first:dropout_transition=3 OUTPUT
+@end example
+
+@item
+This will mix one vocal and one music input audio stream to a single output with the same duration as the
+longest input. The music will have quarter the weight as the vocals, and the inputs are not normalized:
+@example
+ffmpeg -i VOCALS -i MUSIC -filter_complex amix=inputs=2:duration=longest:dropout_transition=0:weights="1 0.25":normalize=0 OUTPUT
+@end example
+
+@end itemize
+
 @subsection Commands
 
 This filter supports the following commands:
@@ -10138,12 +10153,23 @@ Auto-detect the crop size.
 
 It calculates the necessary cropping parameters and prints the
 recommended parameters via the logging system. The detected dimensions
-correspond to the non-black area of the input video.
+correspond to the non-black or video area of the input video according to @var{mode}.
 
 It accepts the following parameters:
 
 @table @option
 
+@item mode
+Depending on @var{mode} crop detection is based on either the mere black value of surrounding pixels or a combination of motion vectors and edge pixels.
+
+@table @samp
+@item black
+Detect black pixels surrounding the playing video. For fine control use option @var{limit}.
+
+@item mvedges
+Detect the playing video by the motion vectors inside the video and scanning for edge pixels typically forming the border of a playing video.
+@end table
+
 @item limit
 Set higher black value threshold, which can be optionally specified
 from nothing (0) to everything (255 for 8-bit based formats). An intensity
@@ -10169,8 +10195,48 @@ detect the current optimal crop area. Default value is 0.
 This can be useful when channel logos distort the video area. 0
 indicates 'never reset', and returns the largest area encountered during
 playback.
+
+@item mv_threshold
+Set motion in pixel units as threshold for motion detection. It defaults to 8.
+
+@item low
+@item high
+Set low and high threshold values used by the Canny thresholding
+algorithm.
+
+The high threshold selects the "strong" edge pixels, which are then
+connected through 8-connectivity with the "weak" edge pixels selected
+by the low threshold.
+
+@var{low} and @var{high} threshold values must be chosen in the range
+[0,1], and @var{low} should be lesser or equal to @var{high}.
+
+Default value for @var{low} is @code{5/255}, and default value for @var{high}
+is @code{15/255}.
 @end table
 
+@subsection Examples
+
+@itemize
+@item
+Find video area surrounded by black borders:
+@example
+ffmpeg -i file.mp4 -vf cropdetect,metadata=mode=print -f null -
+@end example
+
+@item
+Find an embedded video area, generate motion vectors beforehand:
+@example
+ffmpeg -i file.mp4 -vf mestimate,cropdetect=mode=mvedges,metadata=mode=print -f null -
+@end example
+
+@item
+Find an embedded video area, use motion vectors from decoder:
+@example
+ffmpeg -flags2 +export_mvs -i file.mp4 -vf cropdetect=mode=mvedges,metadata=mode=print -f null -
+@end example
+@end itemize
+
 @anchor{cue}
 @section cue
 
@@ -11842,7 +11908,7 @@ The current packet's position in the input file or stream
 (in bytes, from the start of the input). A value of -1 indicates
 this info is not available.
 
-@item pkt_duration
+@item duration
 The current packet's duration, in seconds.
 
 @item pkt_size
@@ -26117,9 +26183,9 @@ Set the height of the overlaid video on the main video.
 Default value is the height of input overlay video.
 
 @item alpha
-Set blocking detection thresholds. Allowed range is 0.0 to 1.0, it
-requires an input video with alpha channel.
-Default value is @code{0.0}.
+Set transparency of overlaid video. Allowed range is 0.0 to 1.0.
+Higher value means lower transparency.
+Default value is @code{1.0}.
 
 @end table
 
@@ -26435,6 +26501,90 @@ need for a nullsrc video source.
 @end itemize
 
 
+@section ddagrab
+
+Captures the Windows Desktop via Desktop Duplication API.
+
+The filter exclusively returns D3D11 Hardware Frames, for on-gpu encoding
+or processing. So an explicit @ref{hwdownload} is needed for any kind of
+software processing.
+
+It accepts the following options:
+
+@table @option
+@item output_idx
+DXGI Output Index to capture.
+
+Usually corresponds to the index Windows has given the screen minus one,
+so it's starting at 0.
+
+Defaults to output 0.
+
+@item draw_mouse
+Whether to draw the mouse cursor.
+
+Defaults to true.
+
+Only affects hardware cursors. If a game or application renders its own cursor,
+it'll always be captured.
+
+@item framerate
+Framerate at which the desktop will be captured.
+
+Defaults to 30 FPS.
+
+@item video_size
+Specify the size of the captured video.
+
+Defaults to the full size of the screen.
+
+Cropped from the bottom/right if smaller than screen size.
+
+@item offset_x
+Horizontal offset of the captured video.
+
+@item offset_y
+Vertical offset of the captured video.
+
+@item output_fmt
+Desired filter output format.
+Defaults to 8 Bit BGRA.
+
+It accepts the following values:
+@table @samp
+@item auto
+Passes all supported output formats to DDA and returns what DDA decides to use.
+@item 8bit
+@item bgra
+8 Bit formats always work, and DDA will convert to them if neccesary.
+@item 10bit
+@item x2bgr10
+Filter initialization will fail if 10 bit format is requested but unavailable.
+@end table
+
+@end table
+
+@subsection Examples
+
+Capture primary screen and encode using nvenc:
+@example
+ffmpeg -f lavfi -i ddagrab -c:v h264_nvenc -cq 18 output.mp4
+@end example
+
+You can also skip the lavfi device and directly use the filter.
+Also demonstrates downloading the frame and encoding with libx264.
+Explicit output format specification is required in this case:
+@example
+ffmpeg -filter_complex ddagrab=output_idx=1:framerate=60,hwdownload,format=bgra -c:v libx264 -crf 18 output.mp4
+@end example
+
+If you want to capture only a subsection of the desktop, this can be achieved
+by specifying a smaller size and its offsets into the screen:
+@example
+ddagrab=video_size=800x600:offset_x=100:offset_y=100
+@end example
+
+
 @section gradients
 Generate several gradients.
 
diff --git a/doc/general_contents.texi b/doc/general_contents.texi
index b1d3e3a..86ec6d6 100644
--- a/doc/general_contents.texi
+++ b/doc/general_contents.texi
@@ -749,6 +749,8 @@ following image formats are supported:
     @tab OpenEXR
 @item FITS         @tab X @tab X
     @tab Flexible Image Transport System
+@item HDR          @tab X @tab X
+    @tab Radiance HDR RGBE Image format
 @item IMG          @tab   @tab X
     @tab GEM Raster image
 @item JPEG         @tab X @tab X
@@ -799,6 +801,8 @@ following image formats are supported:
     @tab Targa (.TGA) image format
 @item VBN  @tab X @tab X
     @tab Vizrt Binary Image format
+@item WBMP         @tab X @tab X
+    @tab Wireless Application Protocol Bitmap image format
 @item WebP         @tab E @tab X
     @tab WebP image format, encoding supported through external library libwebp
 @item XBM  @tab X @tab X
diff --git a/doc/git-howto.texi b/doc/git-howto.texi
index 5bb39bb..874afab 100644
--- a/doc/git-howto.texi
+++ b/doc/git-howto.texi
@@ -187,18 +187,11 @@ to make sure you don't have untracked files or deletions.
 git add [-i|-p|-A] <filenames/dirnames>
 @end example
 
-Make sure you have told Git your name, email address and GPG key
+Make sure you have told Git your name and email address
 
 @example
 git config --global user.name "My Name"
 git config --global user.email my@@email.invalid
-git config --global user.signingkey ABCDEF0123245
-@end example
-
-Enable signing all commits or use -S
-
-@example
-git config --global commit.gpgsign true
 @end example
 
 Use @option{--global} to set the global configuration for all your Git checkouts.
@@ -430,19 +423,6 @@ git checkout -b svn_23456 $SHA1
 where @var{$SHA1} is the commit hash from the @command{git log} output.
 
 
-@chapter gpg key generation
-
-If you have no gpg key yet, we recommend that you create a ed25519 based key as it
-is small, fast and secure. Especially it results in small signatures in git.
-
-@example
-gpg --default-new-key-algo "ed25519/cert,sign+cv25519/encr" --quick-generate-key "human@@server.com"
-@end example
-
-When generating a key, make sure the email specified matches the email used in git as some sites like
-github consider mismatches a reason to declare such commits unverified. After generating a key you
-can add it to the MAINTAINER file and upload it to a keyserver.
-
 @chapter Pre-push checklist
 
 Once you have a set of commits that you feel are ready for pushing,
diff --git a/fftools/Makefile b/fftools/Makefile
index 81ad6c4..6327eab 100644
--- a/fftools/Makefile
+++ b/fftools/Makefile
@@ -1,22 +1,31 @@
 AVPROGS-$(CONFIG_FFMPEG)   += ffmpeg
 AVPROGS-$(CONFIG_FFPLAY)   += ffplay
 AVPROGS-$(CONFIG_FFPROBE)  += ffprobe
+WRAPPROGS-$(CONFIG_FFMPEG)   += ffmpeg_wrap
 
 AVPROGS     := $(AVPROGS-yes:%=%$(PROGSSUF)$(EXESUF))
-PROGS       += $(AVPROGS)
+WRAPPROGS     := $(WRAPPROGS-yes:%=%$(PROGSSUF)$(EXESUF))
+PROGS       += $(AVPROGS) $(WRAPPROGS)
 
-AVBASENAMES  = ffmpeg ffplay ffprobe
+AVBASENAMES  = ffmpeg ffplay ffprobe ffmpeg_wrap
 ALLAVPROGS   = $(AVBASENAMES:%=%$(PROGSSUF)$(EXESUF))
 ALLAVPROGS_G = $(AVBASENAMES:%=%$(PROGSSUF)_g$(EXESUF))
 
 OBJS-ffmpeg +=                  \
+    fftools/ffmpeg_demux.o      \
     fftools/ffmpeg_filter.o     \
     fftools/ffmpeg_hw.o         \
     fftools/ffmpeg_mux.o        \
     fftools/ffmpeg_opt.o        \
+    fftools/objpool.o           \
+    fftools/sync_queue.o        \
+    fftools/thread_queue.o      \
 
 define DOFFTOOL
 OBJS-$(1) += fftools/cmdutils.o fftools/opt_common.o fftools/$(1).o $(OBJS-$(1)-yes)
+ifdef HAVE_GNU_WINDRES
+OBJS-$(1) += fftools/fftoolsres.o
+endif
 $(1)$(PROGSSUF)_g$(EXESUF): $$(OBJS-$(1))
 $$(OBJS-$(1)): | fftools
 $$(OBJS-$(1)): CFLAGS  += $(CFLAGS-$(1))
@@ -27,7 +36,17 @@ endef
 
 $(foreach P,$(AVPROGS-yes),$(eval $(call DOFFTOOL,$(P))))
 
-all: $(AVPROGS)
+define DOWRAP
+OBJS-$(1) += fftools/$(1).o $(OBJS-$(1)-yes)
+$(1)$(PROGSSUF)_g$(EXESUF): $$(OBJS-$(1))
+$$(OBJS-$(1)): | fftools
+$$(OBJS-$(1)): CPPFLAGS  += -DHAVE_AV_CONFIG_H
+$(1)$(PROGSSUF)_g$(EXESUF): FF_EXTRALIBS :=
+-include $$(OBJS-$(1):.o=.d)
+endef
+$(foreach P,$(WRAPPROGS-yes),$(eval $(call DOWRAP,$(P))))
+
+all: $(AVPROGS) $(WRAPPROGS)
 
 fftools/ffprobe.o fftools/cmdutils.o: libavutil/ffversion.h | fftools
 OUTDIRS += fftools
@@ -39,9 +58,9 @@ endif
 install-progs-yes:
 install-progs-$(CONFIG_SHARED): install-libs
 
-install-progs: install-progs-yes $(AVPROGS)
+install-progs: install-progs-yes $(AVPROGS) $(WRAPPROGS)
 	$(Q)mkdir -p "$(BINDIR)"
-	$(INSTALL) -c -m 755 $(AVPROGS) "$(BINDIR)"
+	$(INSTALL) -c -m 755 $(AVPROGS) $(WRAPPROGS) "$(BINDIR)"
 
 uninstall: uninstall-progs
 
diff --git a/fftools/ffmpeg.c b/fftools/ffmpeg.c
index e7384f0..ef7177f 100644
--- a/fftools/ffmpeg.c
+++ b/fftools/ffmpeg.c
@@ -104,6 +104,7 @@
 
 #include "ffmpeg.h"
 #include "cmdutils.h"
+#include "sync_queue.h"
 
 #include "libavutil/avassert.h"
 
@@ -137,13 +138,9 @@ static int64_t nb_frames_drop = 0;
 static int64_t decode_error_stat[2];
 unsigned nb_output_dumped = 0;
 
-int want_sdp = 1;
-
 static BenchmarkTimeStamps current_time;
 AVIOContext *progress_avio = NULL;
 
-static uint8_t *subtitle_out;
-
 InputStream **input_streams = NULL;
 int        nb_input_streams = 0;
 InputFile   **input_files   = NULL;
@@ -164,10 +161,6 @@ static struct termios oldtty;
 static int restore_tty;
 #endif
 
-#if HAVE_THREADS
-static void free_input_threads(void);
-#endif
-
 /* sub2video hack:
    Convert subtitles to video with alpha to insert them in filter graphs.
    This is a temporary solution until libavfilter gets real subtitles support.
@@ -264,7 +257,7 @@ void sub2video_update(InputStream *ist, int64_t heartbeat_pts, AVSubtitle *sub)
         num_rects = 0;
     }
     if (sub2video_get_blank_frame(ist) < 0) {
-        av_log(ist->dec_ctx, AV_LOG_ERROR,
+        av_log(NULL, AV_LOG_ERROR,
                "Impossible to get a blank canvas.\n");
         return;
     }
@@ -560,8 +553,6 @@ static void ffmpeg_cleanup(int ret)
     }
     av_freep(&filtergraphs);
 
-    av_freep(&subtitle_out);
-
     /* close files */
     for (i = 0; i < nb_output_files; i++)
         of_close(&output_files[i]);
@@ -575,6 +566,7 @@ static void ffmpeg_cleanup(int ret)
         av_bsf_free(&ost->bsf_ctx);
 
         av_frame_free(&ost->filtered_frame);
+        av_frame_free(&ost->sq_frame);
         av_frame_free(&ost->last_frame);
         av_packet_free(&ost->pkt);
         av_dict_free(&ost->encoder_opts);
@@ -584,30 +576,23 @@ static void ffmpeg_cleanup(int ret)
         av_freep(&ost->avfilter);
         av_freep(&ost->logfile_prefix);
 
+#if FFMPEG_OPT_MAP_CHANNEL
         av_freep(&ost->audio_channels_map);
         ost->audio_channels_mapped = 0;
+#endif
 
         av_dict_free(&ost->sws_dict);
         av_dict_free(&ost->swr_opts);
 
+        if (ost->enc_ctx)
+            av_freep(&ost->enc_ctx->stats_in);
         avcodec_free_context(&ost->enc_ctx);
-        avcodec_parameters_free(&ost->ref_par);
-
-        if (ost->muxing_queue) {
-            AVPacket *pkt;
-            while (av_fifo_read(ost->muxing_queue, &pkt, 1) >= 0)
-                av_packet_free(&pkt);
-            av_fifo_freep2(&ost->muxing_queue);
-        }
 
         av_freep(&output_streams[i]);
     }
-#if HAVE_THREADS
     free_input_threads();
-#endif
     for (i = 0; i < nb_input_files; i++) {
         avformat_close_input(&input_files[i]->ctx);
-        av_packet_free(&input_files[i]->pkt);
         av_freep(&input_files[i]);
     }
     for (i = 0; i < nb_input_streams; i++) {
@@ -623,6 +608,7 @@ static void ffmpeg_cleanup(int ret)
         av_freep(&ist->dts_buffer);
 
         avcodec_free_context(&ist->dec_ctx);
+        avcodec_parameters_free(&ist->par);
 
         av_freep(&input_streams[i]);
     }
@@ -702,13 +688,10 @@ static void update_benchmark(const char *fmt, ...)
 static void close_output_stream(OutputStream *ost)
 {
     OutputFile *of = output_files[ost->file_index];
-    AVRational time_base = ost->stream_copy ? ost->mux_timebase : ost->enc_ctx->time_base;
-
     ost->finished |= ENCODER_FINISHED;
-    if (of->shortest) {
-        int64_t end = av_rescale_q(ost->sync_opts - ost->first_pts, time_base, AV_TIME_BASE_Q);
-        of->recording_time = FFMIN(of->recording_time, end);
-    }
+
+    if (ost->sq_idx_encode >= 0)
+        sq_send(of->sq_encode, ost->sq_idx_encode, SQFRAME(NULL));
 }
 
 /*
@@ -725,27 +708,54 @@ static void close_output_stream(OutputStream *ost)
 static void output_packet(OutputFile *of, AVPacket *pkt,
                           OutputStream *ost, int eof)
 {
+    const char *err_msg;
     int ret = 0;
 
+    if (!eof && pkt->dts != AV_NOPTS_VALUE)
+        ost->last_mux_dts = av_rescale_q(pkt->dts, ost->mux_timebase, AV_TIME_BASE_Q);
+
     /* apply the output bitstream filters */
     if (ost->bsf_ctx) {
+        int bsf_eof = 0;
+
         ret = av_bsf_send_packet(ost->bsf_ctx, eof ? NULL : pkt);
+        if (ret < 0) {
+            err_msg = "submitting a packet for bitstream filtering";
+            goto fail;
+        }
+
+        while (!bsf_eof) {
+            ret = av_bsf_receive_packet(ost->bsf_ctx, pkt);
+            if (ret == AVERROR(EAGAIN))
+                return;
+            else if (ret == AVERROR_EOF)
+                bsf_eof = 1;
+            else if (ret < 0) {
+                err_msg = "applying bitstream filters to a packet";
+                goto fail;
+            }
+
+            ret = of_submit_packet(of, bsf_eof ? NULL : pkt, ost);
+            if (ret < 0)
+                goto mux_fail;
+        }
+    } else {
+        ret = of_submit_packet(of, eof ? NULL : pkt, ost);
         if (ret < 0)
-            goto finish;
-        while ((ret = av_bsf_receive_packet(ost->bsf_ctx, pkt)) >= 0)
-            of_write_packet(of, pkt, ost, 0);
-        if (ret == AVERROR(EAGAIN))
-            ret = 0;
-    } else if (!eof)
-        of_write_packet(of, pkt, ost, 0);
-
-finish:
-    if (ret < 0 && ret != AVERROR_EOF) {
-        av_log(NULL, AV_LOG_ERROR, "Error applying bitstream filters to an output "
-               "packet for stream #%d:%d.\n", ost->file_index, ost->index);
-        if(exit_on_error)
-            exit_program(1);
+            goto mux_fail;
     }
+
+    return;
+
+mux_fail:
+    err_msg = "submitting a packet to the muxer";
+
+fail:
+    av_log(NULL, AV_LOG_ERROR, "Error %s for output stream #%d:%d.\n",
+           err_msg, ost->file_index, ost->index);
+    if (exit_on_error)
+        exit_program(1);
+
 }
 
 static int check_recording_time(OutputStream *ost)
@@ -765,7 +775,9 @@ static double adjust_frame_pts_to_encoder_tb(OutputFile *of, OutputStream *ost,
                                              AVFrame *frame)
 {
     double float_pts = AV_NOPTS_VALUE; // this is identical to frame.pts but with higher precision
+    int64_t orig_pts = AV_NOPTS_VALUE;
     AVCodecContext *enc = ost->enc_ctx;
+    AVRational filter_tb = (AVRational){ -1, -1 };
     if (!frame || frame->pts == AV_NOPTS_VALUE ||
         !enc || !ost->filter || !ost->filter->graph->graph)
         goto early_exit;
@@ -774,9 +786,10 @@ static double adjust_frame_pts_to_encoder_tb(OutputFile *of, OutputStream *ost,
         AVFilterContext *filter = ost->filter->filter;
 
         int64_t start_time = (of->start_time == AV_NOPTS_VALUE) ? 0 : of->start_time;
-        AVRational filter_tb = av_buffersink_get_time_base(filter);
         AVRational tb = enc->time_base;
         int extra_bits = av_clip(29 - av_log2(tb.den), 0, 16);
+        filter_tb = av_buffersink_get_time_base(filter);
+        orig_pts = frame->pts;
 
         tb.den <<= extra_bits;
         float_pts =
@@ -794,9 +807,14 @@ static double adjust_frame_pts_to_encoder_tb(OutputFile *of, OutputStream *ost,
 early_exit:
 
     if (debug_ts) {
+        av_log(NULL, AV_LOG_INFO, "filter_raw -> pts:%s pts_time:%s time_base:%d/%d\n",
+               frame ? av_ts2str(orig_pts) : "NULL",
+               frame ? av_ts2timestr(orig_pts, &filter_tb) : "NULL",
+               filter_tb.num, filter_tb.den);
+
         av_log(NULL, AV_LOG_INFO, "filter -> pts:%s pts_time:%s exact:%f time_base:%d/%d\n",
                frame ? av_ts2str(frame->pts) : "NULL",
-               frame ? av_ts2timestr(frame->pts, &enc->time_base) : "NULL",
+               (enc && frame) ? av_ts2timestr(frame->pts, &enc->time_base) : "NULL",
                float_pts,
                enc ? enc->time_base.num : -1,
                enc ? enc->time_base.den : -1);
@@ -899,6 +917,7 @@ static int encode_frame(OutputFile *of, OutputStream *ost, AVFrame *frame)
 
     if (frame) {
         ost->frames_encoded++;
+        ost->samples_encoded += frame->nb_samples;
 
         if (debug_ts) {
             av_log(NULL, AV_LOG_INFO, "encoder <- type:%s "
@@ -971,6 +990,52 @@ static int encode_frame(OutputFile *of, OutputStream *ost, AVFrame *frame)
     av_assert0(0);
 }
 
+static int submit_encode_frame(OutputFile *of, OutputStream *ost,
+                               AVFrame *frame)
+{
+    int ret;
+
+    if (ost->sq_idx_encode < 0)
+        return encode_frame(of, ost, frame);
+
+    if (frame) {
+        ret = av_frame_ref(ost->sq_frame, frame);
+        if (ret < 0)
+            return ret;
+        frame = ost->sq_frame;
+    }
+
+    ret = sq_send(of->sq_encode, ost->sq_idx_encode,
+                  SQFRAME(frame));
+    if (ret < 0) {
+        if (frame)
+            av_frame_unref(frame);
+        if (ret != AVERROR_EOF)
+            return ret;
+    }
+
+    while (1) {
+        AVFrame *enc_frame = ost->sq_frame;
+
+        ret = sq_receive(of->sq_encode, ost->sq_idx_encode,
+                               SQFRAME(enc_frame));
+        if (ret == AVERROR_EOF) {
+            enc_frame = NULL;
+        } else if (ret < 0) {
+            return (ret == AVERROR(EAGAIN)) ? 0 : ret;
+        }
+
+        ret = encode_frame(of, ost, enc_frame);
+        if (enc_frame)
+            av_frame_unref(enc_frame);
+        if (ret < 0) {
+            if (ret == AVERROR_EOF)
+                close_output_stream(ost);
+            return ret;
+        }
+    }
+}
+
 static void do_audio_out(OutputFile *of, OutputStream *ost,
                          AVFrame *frame)
 {
@@ -984,10 +1049,9 @@ static void do_audio_out(OutputFile *of, OutputStream *ost,
     if (frame->pts == AV_NOPTS_VALUE || audio_sync_method < 0)
         frame->pts = ost->sync_opts;
     ost->sync_opts = frame->pts + frame->nb_samples;
-    ost->samples_encoded += frame->nb_samples;
 
-    ret = encode_frame(of, ost, frame);
-    if (ret < 0)
+    ret = submit_encode_frame(of, ost, frame);
+    if (ret < 0 && ret != AVERROR_EOF)
         exit_program(1);
 }
 
@@ -996,7 +1060,7 @@ static void do_subtitle_out(OutputFile *of,
                             AVSubtitle *sub)
 {
     int subtitle_out_max_size = 1024 * 1024;
-    int subtitle_out_size, nb, i;
+    int subtitle_out_size, nb, i, ret;
     AVCodecContext *enc;
     AVPacket *pkt = ost->pkt;
     int64_t pts;
@@ -1010,14 +1074,6 @@ static void do_subtitle_out(OutputFile *of,
 
     enc = ost->enc_ctx;
 
-    if (!subtitle_out) {
-        subtitle_out = av_malloc(subtitle_out_max_size);
-        if (!subtitle_out) {
-            av_log(NULL, AV_LOG_FATAL, "Failed to allocate subtitle_out\n");
-            exit_program(1);
-        }
-    }
-
     /* Note: DVB subtitle need one packet to draw them and one other
        packet to clear them */
     /* XXX: signal it in the codec context ? */
@@ -1037,6 +1093,12 @@ static void do_subtitle_out(OutputFile *of,
         if (!check_recording_time(ost))
             return;
 
+        ret = av_new_packet(pkt, subtitle_out_max_size);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_FATAL, "Failed to allocate subtitle encode buffer\n");
+            exit_program(1);
+        }
+
         sub->pts = pts;
         // start_display_time is required to be 0
         sub->pts               += av_rescale_q(sub->start_display_time, (AVRational){ 1, 1000 }, AV_TIME_BASE_Q);
@@ -1047,8 +1109,7 @@ static void do_subtitle_out(OutputFile *of,
 
         ost->frames_encoded++;
 
-        subtitle_out_size = avcodec_encode_subtitle(enc, subtitle_out,
-                                                    subtitle_out_max_size, sub);
+        subtitle_out_size = avcodec_encode_subtitle(enc, pkt->data, pkt->size, sub);
         if (i == 1)
             sub->num_rects = save_num_rects;
         if (subtitle_out_size < 0) {
@@ -1056,9 +1117,7 @@ static void do_subtitle_out(OutputFile *of,
             exit_program(1);
         }
 
-        av_packet_unref(pkt);
-        pkt->data = subtitle_out;
-        pkt->size = subtitle_out_size;
+        av_shrink_packet(pkt, subtitle_out_size);
         pkt->pts  = av_rescale_q(sub->pts, AV_TIME_BASE_Q, ost->mux_timebase);
         pkt->duration = av_rescale_q(sub->end_display_time, (AVRational){ 1, 1000 }, ost->mux_timebase);
         if (enc->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {
@@ -1107,8 +1166,8 @@ static void do_video_out(OutputFile *of,
         (nb_filtergraphs == 0 || !filtergraphs[0]->graph_desc) &&
         next_picture &&
         ist &&
-        lrintf(next_picture->pkt_duration * av_q2d(ist->st->time_base) / av_q2d(enc->time_base)) > 0) {
-        duration = lrintf(next_picture->pkt_duration * av_q2d(ist->st->time_base) / av_q2d(enc->time_base));
+        lrintf(next_picture->duration * av_q2d(ist->st->time_base) / av_q2d(enc->time_base)) > 0) {
+        duration = lrintf(next_picture->duration * av_q2d(ist->st->time_base) / av_q2d(enc->time_base));
     }
 
     if (!next_picture) {
@@ -1139,7 +1198,7 @@ static void do_video_out(OutputFile *of,
 
         switch (ost->vsync_method) {
         case VSYNC_VSCFR:
-            if (ost->frame_number == 0 && delta0 >= 0.5) {
+            if (ost->vsync_frame_number == 0 && delta0 >= 0.5) {
                 av_log(NULL, AV_LOG_DEBUG, "Not duplicating %d initial frames\n", (int)lrintf(delta0));
                 delta = duration;
                 delta0 = 0;
@@ -1147,7 +1206,7 @@ static void do_video_out(OutputFile *of,
             }
         case VSYNC_CFR:
             // FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c
-            if (frame_drop_threshold && delta < frame_drop_threshold && ost->frame_number) {
+            if (frame_drop_threshold && delta < frame_drop_threshold && ost->vsync_frame_number) {
                 nb_frames = 0;
             } else if (delta < -1.1)
                 nb_frames = 0;
@@ -1156,15 +1215,18 @@ static void do_video_out(OutputFile *of,
                 if (delta0 > 1.1)
                     nb0_frames = llrintf(delta0 - 0.6);
             }
+            next_picture->duration = 1;
             break;
         case VSYNC_VFR:
             if (delta <= -0.6)
                 nb_frames = 0;
             else if (delta > 0.6)
                 ost->sync_opts = llrint(sync_ipts);
+            next_picture->duration = duration;
             break;
         case VSYNC_DROP:
         case VSYNC_PASSTHROUGH:
+            next_picture->duration = duration;
             ost->sync_opts = llrint(sync_ipts);
             break;
         default:
@@ -1177,7 +1239,7 @@ static void do_video_out(OutputFile *of,
      * But there may be reordering, so we can't throw away frames on encoder
      * flush, we need to limit them here, before they go into encoder.
      */
-    nb_frames = FFMIN(nb_frames, ost->max_frames - ost->frame_number);
+    nb_frames = FFMIN(nb_frames, ost->max_frames - ost->vsync_frame_number);
     nb0_frames = FFMIN(nb0_frames, nb_frames);
 
     memmove(ost->last_nb0_frames + 1,
@@ -1189,7 +1251,7 @@ static void do_video_out(OutputFile *of,
         nb_frames_drop++;
         av_log(NULL, AV_LOG_VERBOSE,
                "*** dropping frame %"PRId64" from stream %d at ts %"PRId64"\n",
-               ost->frame_number, ost->st->index, ost->last_frame->pts);
+               ost->vsync_frame_number, ost->st->index, ost->last_frame->pts);
     }
     if (nb_frames > (nb0_frames && ost->last_dropped) + (nb_frames > nb0_frames)) {
         if (nb_frames > dts_error_threshold * 30) {
@@ -1278,12 +1340,12 @@ static void do_video_out(OutputFile *of,
             av_log(NULL, AV_LOG_DEBUG, "Forced keyframe at time %f\n", pts_time);
         }
 
-        ret = encode_frame(of, ost, in_picture);
-        if (ret < 0)
+        ret = submit_encode_frame(of, ost, in_picture);
+        if (ret < 0 && ret != AVERROR_EOF)
             exit_program(1);
 
         ost->sync_opts++;
-        ost->frame_number++;
+        ost->vsync_frame_number++;
     }
 
     av_frame_unref(ost->last_frame);
@@ -1291,19 +1353,6 @@ static void do_video_out(OutputFile *of,
         av_frame_move_ref(ost->last_frame, next_picture);
 }
 
-static void finish_output_stream(OutputStream *ost)
-{
-    OutputFile *of = output_files[ost->file_index];
-    AVRational time_base = ost->stream_copy ? ost->mux_timebase : ost->enc_ctx->time_base;
-
-    ost->finished = ENCODER_FINISHED | MUXER_FINISHED;
-
-    if (of->shortest) {
-        int64_t end = av_rescale_q(ost->sync_opts - ost->first_pts, time_base, AV_TIME_BASE_Q);
-        of->recording_time = FFMIN(of->recording_time, end);
-    }
-}
-
 /**
  * Get and encode new output from any of the filtergraphs, without causing
  * activity.
@@ -1359,6 +1408,12 @@ static int reap_filters(int flush)
                 continue;
             }
 
+            if (filtered_frame->pts != AV_NOPTS_VALUE) {
+                AVRational tb = av_buffersink_get_time_base(filter);
+                ost->last_filter_pts = av_rescale_q(filtered_frame->pts, tb,
+                                                    AV_TIME_BASE_Q);
+            }
+
             switch (av_buffersink_get_type(filter)) {
             case AVMEDIA_TYPE_VIDEO:
                 if (!ost->frame_aspect_ratio.num)
@@ -1398,15 +1453,17 @@ static void print_final_stats(int64_t total_size)
 
     for (i = 0; i < nb_output_streams; i++) {
         OutputStream *ost = output_streams[i];
-        switch (ost->enc_ctx->codec_type) {
+        AVCodecParameters *par = ost->st->codecpar;
+        switch (par->codec_type) {
             case AVMEDIA_TYPE_VIDEO: video_size += ost->data_size; break;
             case AVMEDIA_TYPE_AUDIO: audio_size += ost->data_size; break;
             case AVMEDIA_TYPE_SUBTITLE: subtitle_size += ost->data_size; break;
             default:                 other_size += ost->data_size; break;
         }
-        extra_size += ost->enc_ctx->extradata_size;
+        extra_size += par->extradata_size;
         data_size  += ost->data_size;
-        if (   (ost->enc_ctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2))
+        if (ost->enc_ctx &&
+            (ost->enc_ctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2))
             != AV_CODEC_FLAG_PASS1)
             pass1_used = 0;
     }
@@ -1436,7 +1493,7 @@ static void print_final_stats(int64_t total_size)
 
         for (j = 0; j < f->nb_streams; j++) {
             InputStream *ist = input_streams[f->ist_index + j];
-            enum AVMediaType type = ist->dec_ctx->codec_type;
+            enum AVMediaType type = ist->par->codec_type;
 
             total_size    += ist->data_size;
             total_packets += ist->nb_packets;
@@ -1466,18 +1523,18 @@ static void print_final_stats(int64_t total_size)
         uint64_t total_packets = 0, total_size = 0;
 
         av_log(NULL, AV_LOG_VERBOSE, "Output file #%d (%s):\n",
-               i, of->ctx->url);
+               i, of->url);
 
-        for (j = 0; j < of->ctx->nb_streams; j++) {
+        for (j = 0; j < of->nb_streams; j++) {
             OutputStream *ost = output_streams[of->ost_index + j];
-            enum AVMediaType type = ost->enc_ctx->codec_type;
+            enum AVMediaType type = ost->st->codecpar->codec_type;
 
             total_size    += ost->data_size;
-            total_packets += ost->packets_written;
+            total_packets += atomic_load(&ost->packets_written);
 
             av_log(NULL, AV_LOG_VERBOSE, "  Output stream #%d:%d (%s): ",
                    i, j, av_get_media_type_string(type));
-            if (ost->encoding_needed) {
+            if (ost->enc_ctx) {
                 av_log(NULL, AV_LOG_VERBOSE, "%"PRIu64" frames encoded",
                        ost->frames_encoded);
                 if (type == AVMEDIA_TYPE_AUDIO)
@@ -1486,7 +1543,7 @@ static void print_final_stats(int64_t total_size)
             }
 
             av_log(NULL, AV_LOG_VERBOSE, "%"PRIu64" packets muxed (%"PRIu64" bytes); ",
-                   ost->packets_written, ost->data_size);
+                   atomic_load(&ost->packets_written), ost->data_size);
 
             av_log(NULL, AV_LOG_VERBOSE, "\n");
         }
@@ -1507,10 +1564,7 @@ static void print_final_stats(int64_t total_size)
 static void print_report(int is_last_report, int64_t timer_start, int64_t cur_time)
 {
     AVBPrint buf, buf_script;
-    OutputStream *ost;
-    AVFormatContext *oc;
-    int64_t total_size;
-    AVCodecContext *enc;
+    int64_t total_size = of_filesize(output_files[0]);
     int vid, i;
     double bitrate;
     double speed;
@@ -1538,31 +1592,22 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
 
     t = (cur_time-timer_start) / 1000000.0;
 
-
-    oc = output_files[0]->ctx;
-
-    total_size = avio_size(oc->pb);
-    if (total_size <= 0) // FIXME improve avio_size() so it works with non seekable output too
-        total_size = avio_tell(oc->pb);
-
     vid = 0;
     av_bprint_init(&buf, 0, AV_BPRINT_SIZE_AUTOMATIC);
     av_bprint_init(&buf_script, 0, AV_BPRINT_SIZE_AUTOMATIC);
     for (i = 0; i < nb_output_streams; i++) {
-        float q = -1;
-        ost = output_streams[i];
-        enc = ost->enc_ctx;
-        if (!ost->stream_copy)
-            q = ost->quality / (float) FF_QP2LAMBDA;
+        OutputStream         * const ost = output_streams[i];
+        const AVCodecContext * const enc = ost->enc_ctx;
+        const float q = enc ? ost->quality / (float) FF_QP2LAMBDA : -1;
 
-        if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {
+        if (vid && ost->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
             av_bprintf(&buf, "q=%2.1f ", q);
             av_bprintf(&buf_script, "stream_%d_%d_q=%.1f\n",
                        ost->file_index, ost->index, q);
         }
-        if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) {
+        if (!vid && ost->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
             float fps;
-            int64_t frame_number = ost->frame_number;
+            uint64_t frame_number = atomic_load(&ost->packets_written);
 
             fps = t > 1 ? frame_number / t : 0;
             av_bprintf(&buf, "frame=%5"PRId64" fps=%3.*f q=%3.1f ",
@@ -1582,7 +1627,8 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
                     av_bprintf(&buf, "%X", av_log2(qp_histogram[j] + 1));
             }
 
-            if ((enc->flags & AV_CODEC_FLAG_PSNR) && (ost->pict_type != AV_PICTURE_TYPE_NONE || is_last_report)) {
+            if (enc && (enc->flags & AV_CODEC_FLAG_PSNR) &&
+                (ost->pict_type != AV_PICTURE_TYPE_NONE || is_last_report)) {
                 int j;
                 double error, error_sum = 0;
                 double scale, scale_sum = 0;
@@ -1614,9 +1660,8 @@ static void print_report(int is_last_report, int64_t timer_start, int64_t cur_ti
             vid = 1;
         }
         /* compute min output value */
-        if (av_stream_get_end_pts(ost->st) != AV_NOPTS_VALUE) {
-            pts = FFMAX(pts, av_rescale_q(av_stream_get_end_pts(ost->st),
-                                          ost->st->time_base, AV_TIME_BASE_Q));
+        if (ost->last_mux_dts != AV_NOPTS_VALUE) {
+            pts = FFMAX(pts, ost->last_mux_dts);
             if (copy_ts) {
                 if (copy_ts_first_pts == AV_NOPTS_VALUE && pts > 1)
                     copy_ts_first_pts = pts;
@@ -1736,12 +1781,19 @@ static void flush_encoders(void)
 {
     int i, ret;
 
+    for (i = 0; i < nb_output_streams; i++) {
+        OutputStream   *ost = output_streams[i];
+        OutputFile      *of = output_files[ost->file_index];
+        if (ost->sq_idx_encode >= 0)
+            sq_send(of->sq_encode, ost->sq_idx_encode, SQFRAME(NULL));
+    }
+
     for (i = 0; i < nb_output_streams; i++) {
         OutputStream   *ost = output_streams[i];
         AVCodecContext *enc = ost->enc_ctx;
         OutputFile      *of = output_files[ost->file_index];
 
-        if (!ost->encoding_needed)
+        if (!enc)
             continue;
 
         // Try to enable encoding with no input frames.
@@ -1758,7 +1810,7 @@ static void flush_encoders(void)
                 for (x = 0; x < fg->nb_inputs; x++) {
                     InputFilter *ifilter = fg->inputs[x];
                     if (ifilter->format < 0 &&
-                        ifilter_parameters_from_codecpar(ifilter, ifilter->ist->st->codecpar) < 0) {
+                        ifilter_parameters_from_codecpar(ifilter, ifilter->ist->par) < 0) {
                         av_log(NULL, AV_LOG_ERROR, "Error copying paramerets from input stream\n");
                         exit_program(1);
                     }
@@ -1773,7 +1825,7 @@ static void flush_encoders(void)
                     exit_program(1);
                 }
 
-                finish_output_stream(ost);
+                output_packet(of, ost->pkt, ost, 1);
             }
 
             init_output_stream_wrapper(ost, NULL, 1);
@@ -1782,7 +1834,7 @@ static void flush_encoders(void)
         if (enc->codec_type != AVMEDIA_TYPE_VIDEO && enc->codec_type != AVMEDIA_TYPE_AUDIO)
             continue;
 
-        ret = encode_frame(of, ost, NULL);
+        ret = submit_encode_frame(of, ost, NULL);
         if (ret != AVERROR_EOF)
             exit_program(1);
     }
@@ -1828,12 +1880,9 @@ static void do_streamcopy(InputStream *ist, OutputStream *ost, const AVPacket *p
         return;
 
     if (!ost->streamcopy_started && !ost->copy_prior_start) {
-        int64_t comp_start = start_time;
-        if (copy_ts && f->start_time != AV_NOPTS_VALUE)
-            comp_start = FFMAX(start_time, f->start_time + f->ts_offset);
         if (pkt->pts == AV_NOPTS_VALUE ?
-            ist->pts < comp_start :
-            pkt->pts < av_rescale_q(comp_start, AV_TIME_BASE_Q, ist->st->time_base))
+            ist->pts < ost->ts_copy_start :
+            pkt->pts < av_rescale_q(ost->ts_copy_start, AV_TIME_BASE_Q, ist->st->time_base))
             return;
     }
 
@@ -1864,11 +1913,11 @@ static void do_streamcopy(InputStream *ist, OutputStream *ost, const AVPacket *p
     if (pkt->dts == AV_NOPTS_VALUE) {
         opkt->dts = av_rescale_q(ist->dts, AV_TIME_BASE_Q, ost->mux_timebase);
     } else if (ost->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
-        int duration = av_get_audio_frame_duration(ist->dec_ctx, pkt->size);
+        int duration = av_get_audio_frame_duration2(ist->par, pkt->size);
         if(!duration)
-            duration = ist->dec_ctx->frame_size;
+            duration = ist->par->frame_size;
         opkt->dts = av_rescale_delta(ist->st->time_base, pkt->dts,
-                                    (AVRational){1, ist->dec_ctx->sample_rate}, duration,
+                                    (AVRational){1, ist->par->sample_rate}, duration,
                                     &ist->filter_in_rescale_delta_last, ost->mux_timebase);
         /* dts will be set immediately afterwards to what pts is now */
         opkt->pts = opkt->dts - ost_tb_start_time;
@@ -1885,25 +1934,6 @@ static void do_streamcopy(InputStream *ist, OutputStream *ost, const AVPacket *p
     ost->streamcopy_started = 1;
 }
 
-int guess_input_channel_layout(InputStream *ist)
-{
-    AVCodecContext *dec = ist->dec_ctx;
-
-    if (dec->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC) {
-        char layout_name[256];
-
-        if (dec->ch_layout.nb_channels > ist->guess_layout_max)
-            return 0;
-        av_channel_layout_default(&dec->ch_layout, dec->ch_layout.nb_channels);
-        if (dec->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC)
-            return 0;
-        av_channel_layout_describe(&dec->ch_layout, layout_name, sizeof(layout_name));
-        av_log(NULL, AV_LOG_WARNING, "Guessed Channel Layout for Input Stream "
-               "#%d.%d : %s\n", ist->file_index, ist->st->index, layout_name);
-    }
-    return 1;
-}
-
 static void check_decode_result(InputStream *ist, int *got_output, int ret)
 {
     if (*got_output || ret<0)
@@ -1947,7 +1977,7 @@ static int ifilter_send_frame(InputFilter *ifilter, AVFrame *frame, int keep_ref
     /* determine if the parameters for this input changed */
     need_reinit = ifilter->format != frame->format;
 
-    switch (ifilter->ist->st->codecpar->codec_type) {
+    switch (ifilter->ist->par->codec_type) {
     case AVMEDIA_TYPE_AUDIO:
         need_reinit |= ifilter->sample_rate    != frame->sample_rate ||
                        av_channel_layout_compare(&ifilter->ch_layout, &frame->ch_layout);
@@ -2027,7 +2057,7 @@ static int ifilter_send_eof(InputFilter *ifilter, int64_t pts)
     } else {
         // the filtergraph was never configured
         if (ifilter->format < 0) {
-            ret = ifilter_parameters_from_codecpar(ifilter, ifilter->ist->st->codecpar);
+            ret = ifilter_parameters_from_codecpar(ifilter, ifilter->ist->par);
             if (ret < 0)
                 return ret;
         }
@@ -2183,9 +2213,9 @@ static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output, int64_
 
     // The following line may be required in some cases where there is no parser
     // or the parser does not has_b_frames correctly
-    if (ist->st->codecpar->video_delay < ist->dec_ctx->has_b_frames) {
+    if (ist->par->video_delay < ist->dec_ctx->has_b_frames) {
         if (ist->dec_ctx->codec_id == AV_CODEC_ID_H264) {
-            ist->st->codecpar->video_delay = ist->dec_ctx->has_b_frames;
+            ist->par->video_delay = ist->dec_ctx->has_b_frames;
         } else
             av_log(ist->dec_ctx, AV_LOG_WARNING,
                    "video_delay is larger in decoder than demuxer %d > %d.\n"
@@ -2193,7 +2223,7 @@ static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output, int64_
                    "of this file to https://streams.videolan.org/upload/ "
                    "and contact the ffmpeg-devel mailing list. (ffmpeg-devel@ffmpeg.org)\n",
                    ist->dec_ctx->has_b_frames,
-                   ist->st->codecpar->video_delay);
+                   ist->par->video_delay);
     }
 
     if (ret != AVERROR_EOF)
@@ -2226,10 +2256,9 @@ static int decode_video(InputStream *ist, AVPacket *pkt, int *got_output, int64_
         if (err < 0)
             goto fail;
     }
-    ist->hwaccel_retrieved_pix_fmt = decoded_frame->format;
 
     best_effort_timestamp= decoded_frame->best_effort_timestamp;
-    *duration_pts = decoded_frame->pkt_duration;
+    *duration_pts = decoded_frame->duration;
 
     if (ist->framerate.num)
         best_effort_timestamp = ist->cfr_next_pts++;
@@ -2293,7 +2322,7 @@ static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output,
             end = av_rescale(subtitle.pts - ist->prev_sub.subtitle.pts,
                              1000, AV_TIME_BASE);
             if (end < ist->prev_sub.subtitle.end_display_time) {
-                av_log(ist->dec_ctx, AV_LOG_DEBUG,
+                av_log(NULL, AV_LOG_DEBUG,
                        "Subtitle duration reduced from %"PRId32" to %d%s\n",
                        ist->prev_sub.subtitle.end_display_time, end,
                        end <= 0 ? ", dropping it" : "");
@@ -2332,7 +2361,7 @@ static int transcode_subtitles(InputStream *ist, AVPacket *pkt, int *got_output,
     for (i = 0; i < nb_output_streams; i++) {
         OutputStream *ost = output_streams[i];
 
-        if (!check_output_constraints(ist, ost) || !ost->encoding_needed
+        if (!check_output_constraints(ist, ost) || !ost->enc_ctx
             || ost->enc->type != AVMEDIA_TYPE_SUBTITLE)
             continue;
 
@@ -2363,6 +2392,7 @@ static int send_filter_eof(InputStream *ist)
 /* pkt = NULL means EOF (needed to flush decoder buffers) */
 static int process_input_packet(InputStream *ist, const AVPacket *pkt, int no_eof)
 {
+    const AVCodecParameters *par = ist->par;
     int ret = 0, i;
     int repeating = 0;
     int eof_reached = 0;
@@ -2395,7 +2425,7 @@ static int process_input_packet(InputStream *ist, const AVPacket *pkt, int no_eo
 
     if (pkt && pkt->dts != AV_NOPTS_VALUE) {
         ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);
-        if (ist->dec_ctx->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)
+        if (par->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)
             ist->next_pts = ist->pts = ist->dts;
     }
 
@@ -2409,7 +2439,7 @@ static int process_input_packet(InputStream *ist, const AVPacket *pkt, int no_eo
         ist->pts = ist->next_pts;
         ist->dts = ist->next_dts;
 
-        switch (ist->dec_ctx->codec_type) {
+        switch (par->codec_type) {
         case AVMEDIA_TYPE_AUDIO:
             ret = decode_audio    (ist, repeating ? NULL : avpkt, &got_output,
                                    &decode_failed);
@@ -2506,12 +2536,12 @@ static int process_input_packet(InputStream *ist, const AVPacket *pkt, int no_eo
     /* handle stream copy */
     if (!ist->decoding_needed && pkt) {
         ist->dts = ist->next_dts;
-        switch (ist->dec_ctx->codec_type) {
+        switch (par->codec_type) {
         case AVMEDIA_TYPE_AUDIO:
             av_assert1(pkt->duration >= 0);
-            if (ist->dec_ctx->sample_rate) {
-                ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) /
-                                  ist->dec_ctx->sample_rate;
+            if (par->sample_rate) {
+                ist->next_dts += ((int64_t)AV_TIME_BASE * par->frame_size) /
+                                  par->sample_rate;
             } else {
                 ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);
             }
@@ -2540,7 +2570,8 @@ static int process_input_packet(InputStream *ist, const AVPacket *pkt, int no_eo
     for (i = 0; i < nb_output_streams; i++) {
         OutputStream *ost = output_streams[i];
 
-        if (!check_output_constraints(ist, ost) || ost->encoding_needed)
+        if (!check_output_constraints(ist, ost) || ost->enc_ctx ||
+            (!pkt && no_eof))
             continue;
 
         do_streamcopy(ist, ost, pkt);
@@ -2708,24 +2739,31 @@ static int init_output_stream_streamcopy(OutputStream *ost)
 {
     OutputFile *of = output_files[ost->file_index];
     InputStream *ist = get_input_stream(ost);
-    AVCodecParameters *par_dst = ost->st->codecpar;
-    AVCodecParameters *par_src = ost->ref_par;
+    InputFile *ifile = input_files[ist->file_index];
+    AVCodecParameters *par = ost->st->codecpar;
+    AVCodecContext *codec_ctx;
     AVRational sar;
     int i, ret;
-    uint32_t codec_tag = par_dst->codec_tag;
+    uint32_t codec_tag = par->codec_tag;
 
     av_assert0(ist && !ost->filter);
 
-    ret = avcodec_parameters_to_context(ost->enc_ctx, ist->st->codecpar);
+    codec_ctx = avcodec_alloc_context3(NULL);
+    if (!codec_ctx)
+        return AVERROR(ENOMEM);
+
+    ret = avcodec_parameters_to_context(codec_ctx, ist->par);
     if (ret >= 0)
-        ret = av_opt_set_dict(ost->enc_ctx, &ost->encoder_opts);
+        ret = av_opt_set_dict(codec_ctx, &ost->encoder_opts);
     if (ret < 0) {
         av_log(NULL, AV_LOG_FATAL,
                "Error setting up codec context options.\n");
+        avcodec_free_context(&codec_ctx);
         return ret;
     }
 
-    ret = avcodec_parameters_from_context(par_src, ost->enc_ctx);
+    ret = avcodec_parameters_from_context(par, codec_ctx);
+    avcodec_free_context(&codec_ctx);
     if (ret < 0) {
         av_log(NULL, AV_LOG_FATAL,
                "Error getting reference codec parameters.\n");
@@ -2735,16 +2773,12 @@ static int init_output_stream_streamcopy(OutputStream *ost)
     if (!codec_tag) {
         unsigned int codec_tag_tmp;
         if (!of->format->codec_tag ||
-            av_codec_get_id (of->format->codec_tag, par_src->codec_tag) == par_src->codec_id ||
-            !av_codec_get_tag2(of->format->codec_tag, par_src->codec_id, &codec_tag_tmp))
-            codec_tag = par_src->codec_tag;
+            av_codec_get_id (of->format->codec_tag, par->codec_tag) == par->codec_id ||
+            !av_codec_get_tag2(of->format->codec_tag, par->codec_id, &codec_tag_tmp))
+            codec_tag = par->codec_tag;
     }
 
-    ret = avcodec_parameters_copy(par_dst, par_src);
-    if (ret < 0)
-        return ret;
-
-    par_dst->codec_tag = codec_tag;
+    par->codec_tag = codec_tag;
 
     if (!ost->frame_rate.num)
         ost->frame_rate = ist->framerate;
@@ -2770,6 +2804,15 @@ static int init_output_stream_streamcopy(OutputStream *ost)
     if (ost->st->duration <= 0 && ist->st->duration > 0)
         ost->st->duration = av_rescale_q(ist->st->duration, ist->st->time_base, ost->st->time_base);
 
+    if (!ost->copy_prior_start) {
+        ost->ts_copy_start = (of->start_time == AV_NOPTS_VALUE) ?
+                             0 : of->start_time;
+        if (copy_ts && ifile->start_time != AV_NOPTS_VALUE) {
+            ost->ts_copy_start = FFMAX(ost->ts_copy_start,
+                                       ifile->start_time + ifile->ts_offset);
+        }
+    }
+
     if (ist->st->nb_side_data) {
         for (i = 0; i < ist->st->nb_side_data; i++) {
             const AVPacketSideData *sd_src = &ist->st->side_data[i];
@@ -2789,30 +2832,27 @@ static int init_output_stream_streamcopy(OutputStream *ost)
             av_display_rotation_set((int32_t *)sd, -ost->rotate_override_value);
     }
 
-    switch (par_dst->codec_type) {
+    switch (par->codec_type) {
     case AVMEDIA_TYPE_AUDIO:
-        if (audio_volume != 256) {
-            av_log(NULL, AV_LOG_FATAL, "-acodec copy and -vol are incompatible (frames are not decoded)\n");
-            exit_program(1);
-        }
-        if((par_dst->block_align == 1 || par_dst->block_align == 1152 || par_dst->block_align == 576) && par_dst->codec_id == AV_CODEC_ID_MP3)
-            par_dst->block_align= 0;
-        if(par_dst->codec_id == AV_CODEC_ID_AC3)
-            par_dst->block_align= 0;
+        if ((par->block_align == 1 || par->block_align == 1152 || par->block_align == 576) &&
+            par->codec_id == AV_CODEC_ID_MP3)
+            par->block_align = 0;
+        if (par->codec_id == AV_CODEC_ID_AC3)
+            par->block_align = 0;
         break;
     case AVMEDIA_TYPE_VIDEO:
         if (ost->frame_aspect_ratio.num) { // overridden by the -aspect cli option
             sar =
                 av_mul_q(ost->frame_aspect_ratio,
-                         (AVRational){ par_dst->height, par_dst->width });
+                         (AVRational){ par->height, par->width });
             av_log(NULL, AV_LOG_WARNING, "Overriding aspect ratio "
                    "with stream copy may produce invalid files\n");
             }
         else if (ist->st->sample_aspect_ratio.num)
             sar = ist->st->sample_aspect_ratio;
         else
-            sar = par_src->sample_aspect_ratio;
-        ost->st->sample_aspect_ratio = par_dst->sample_aspect_ratio = sar;
+            sar = par->sample_aspect_ratio;
+        ost->st->sample_aspect_ratio = par->sample_aspect_ratio = sar;
         ost->st->avg_frame_rate = ist->st->avg_frame_rate;
         ost->st->r_frame_rate = ist->st->r_frame_rate;
         break;
@@ -2825,37 +2865,18 @@ static int init_output_stream_streamcopy(OutputStream *ost)
 
 static void set_encoder_id(OutputFile *of, OutputStream *ost)
 {
-    const AVDictionaryEntry *e;
-
     uint8_t *encoder_string;
     int encoder_string_len;
-    int format_flags = 0;
-    int codec_flags = ost->enc_ctx->flags;
 
     if (av_dict_get(ost->st->metadata, "encoder",  NULL, 0))
         return;
 
-    e = av_dict_get(of->opts, "fflags", NULL, 0);
-    if (e) {
-        const AVOption *o = av_opt_find(of->ctx, "fflags", NULL, 0, 0);
-        if (!o)
-            return;
-        av_opt_eval_flags(of->ctx, o, e->value, &format_flags);
-    }
-    e = av_dict_get(ost->encoder_opts, "flags", NULL, 0);
-    if (e) {
-        const AVOption *o = av_opt_find(ost->enc_ctx, "flags", NULL, 0, 0);
-        if (!o)
-            return;
-        av_opt_eval_flags(ost->enc_ctx, o, e->value, &codec_flags);
-    }
-
     encoder_string_len = sizeof(LIBAVCODEC_IDENT) + strlen(ost->enc->name) + 2;
     encoder_string     = av_mallocz(encoder_string_len);
     if (!encoder_string)
         exit_program(1);
 
-    if (!(format_flags & AVFMT_FLAG_BITEXACT) && !(codec_flags & AV_CODEC_FLAG_BITEXACT))
+    if (!of->bitexact && !ost->bitexact)
         av_strlcpy(encoder_string, LIBAVCODEC_IDENT " ", encoder_string_len);
     else
         av_strlcpy(encoder_string, "Lavc ", encoder_string_len);
@@ -2889,12 +2910,15 @@ static void parse_forced_key_frames(char *kf, OutputStream *ost,
             *next++ = 0;
 
         if (!memcmp(p, "chapters", 8)) {
-
-            AVFormatContext *avf = output_files[ost->file_index]->ctx;
+            OutputFile *of = output_files[ost->file_index];
+            AVChapter * const *ch;
+            unsigned int    nb_ch;
             int j;
 
-            if (avf->nb_chapters > INT_MAX - size ||
-                !(pts = av_realloc_f(pts, size += avf->nb_chapters - 1,
+            ch = of_get_chapters(of, &nb_ch);
+
+            if (nb_ch > INT_MAX - size ||
+                !(pts = av_realloc_f(pts, size += nb_ch - 1,
                                      sizeof(*pts)))) {
                 av_log(NULL, AV_LOG_FATAL,
                        "Could not allocate forced key frames array.\n");
@@ -2903,8 +2927,8 @@ static void parse_forced_key_frames(char *kf, OutputStream *ost,
             t = p[8] ? parse_time_or_die("force_key_frames", p + 8, 1) : 0;
             t = av_rescale_q(t, AV_TIME_BASE_Q, avctx->time_base);
 
-            for (j = 0; j < avf->nb_chapters; j++) {
-                AVChapter *c = avf->chapters[j];
+            for (j = 0; j < nb_ch; j++) {
+                const AVChapter *c = ch[j];
                 av_assert1(index < size);
                 pts[index++] = av_rescale_q(c->start, c->time_base,
                                             avctx->time_base) + t;
@@ -2931,7 +2955,6 @@ static void init_encoder_time_base(OutputStream *ost, AVRational default_time_ba
 {
     InputStream *ist = get_input_stream(ost);
     AVCodecContext *enc_ctx = ost->enc_ctx;
-    AVFormatContext *oc;
 
     if (ost->enc_timebase.num > 0) {
         enc_ctx->time_base = ost->enc_timebase;
@@ -2944,8 +2967,9 @@ static void init_encoder_time_base(OutputStream *ost, AVRational default_time_ba
             return;
         }
 
-        oc = output_files[ost->file_index]->ctx;
-        av_log(oc, AV_LOG_WARNING, "Input stream data not available, using default time base\n");
+        av_log(NULL, AV_LOG_WARNING,
+               "Input stream data for output stream #%d:%d not available, "
+               "using default time base\n", ost->file_index, ost->index);
     }
 
     enc_ctx->time_base = default_time_base;
@@ -2957,7 +2981,6 @@ static int init_output_stream_encode(OutputStream *ost, AVFrame *frame)
     AVCodecContext *enc_ctx = ost->enc_ctx;
     AVCodecContext *dec_ctx = NULL;
     OutputFile      *of = output_files[ost->file_index];
-    AVFormatContext *oc = of->ctx;
     int ret;
 
     set_encoder_id(output_files[ost->file_index], ost);
@@ -3020,7 +3043,7 @@ static int init_output_stream_encode(OutputStream *ost, AVFrame *frame)
         if (   av_q2d(enc_ctx->time_base) < 0.001 && ost->vsync_method != VSYNC_PASSTHROUGH
            && (ost->vsync_method == VSYNC_CFR || ost->vsync_method == VSYNC_VSCFR ||
                (ost->vsync_method == VSYNC_AUTO && !(of->format->flags & AVFMT_VARIABLE_FPS)))){
-            av_log(oc, AV_LOG_WARNING, "Frame rate very high for a muxer not efficiently supporting it.\n"
+            av_log(NULL, AV_LOG_WARNING, "Frame rate very high for a muxer not efficiently supporting it.\n"
                                        "Please consider specifying a lower framerate, a different muxer or "
                                        "setting vsync/fps_mode to vfr\n");
         }
@@ -3098,8 +3121,8 @@ static int init_output_stream_encode(OutputStream *ost, AVFrame *frame)
     case AVMEDIA_TYPE_SUBTITLE:
         enc_ctx->time_base = AV_TIME_BASE_Q;
         if (!enc_ctx->width) {
-            enc_ctx->width     = input_streams[ost->source_index]->st->codecpar->width;
-            enc_ctx->height    = input_streams[ost->source_index]->st->codecpar->height;
+            enc_ctx->width     = input_streams[ost->source_index]->par->width;
+            enc_ctx->height    = input_streams[ost->source_index]->par->height;
         }
         break;
     case AVMEDIA_TYPE_DATA:
@@ -3109,6 +3132,12 @@ static int init_output_stream_encode(OutputStream *ost, AVFrame *frame)
         break;
     }
 
+    if (ost->bitexact)
+        enc_ctx->flags |= AV_CODEC_FLAG_BITEXACT;
+
+    if (ost->sq_idx_encode >= 0)
+        sq_set_tb(of->sq_encode, ost->sq_idx_encode, enc_ctx->time_base);
+
     ost->mux_timebase = enc_ctx->time_base;
 
     return 0;
@@ -3117,9 +3146,10 @@ static int init_output_stream_encode(OutputStream *ost, AVFrame *frame)
 static int init_output_stream(OutputStream *ost, AVFrame *frame,
                               char *error, int error_len)
 {
+    OutputFile *of = output_files[ost->file_index];
     int ret = 0;
 
-    if (ost->encoding_needed) {
+    if (ost->enc_ctx) {
         const AVCodec *codec = ost->enc;
         AVCodecContext *dec = NULL;
         InputStream *ist;
@@ -3236,7 +3266,7 @@ static int init_output_stream(OutputStream *ost, AVFrame *frame,
         // copy estimated duration as a hint to the muxer
         if (ost->st->duration <= 0 && ist && ist->st->duration > 0)
             ost->st->duration = av_rescale_q(ist->st->duration, ist->st->time_base, ost->st->time_base);
-    } else if (ost->stream_copy) {
+    } else if (ost->source_index >= 0) {
         ret = init_output_stream_streamcopy(ost);
         if (ret < 0)
             return ret;
@@ -3249,6 +3279,9 @@ static int init_output_stream(OutputStream *ost, AVFrame *frame,
     if (ret < 0)
         return ret;
 
+    if (ost->sq_idx_mux >= 0)
+        sq_set_tb(of->sq_mux, ost->sq_idx_mux, ost->mux_timebase);
+
     ost->initialized = 1;
 
     ret = of_check_init(output_files[ost->file_index]);
@@ -3258,25 +3291,9 @@ static int init_output_stream(OutputStream *ost, AVFrame *frame,
     return ret;
 }
 
-static void report_new_stream(int input_index, AVPacket *pkt)
-{
-    InputFile *file = input_files[input_index];
-    AVStream *st = file->ctx->streams[pkt->stream_index];
-
-    if (pkt->stream_index < file->nb_streams_warn)
-        return;
-    av_log(file->ctx, AV_LOG_WARNING,
-           "New %s stream %d:%d at pos:%"PRId64" and DTS:%ss\n",
-           av_get_media_type_string(st->codecpar->codec_type),
-           input_index, pkt->stream_index,
-           pkt->pos, av_ts2timestr(pkt->dts, &st->time_base));
-    file->nb_streams_warn = pkt->stream_index + 1;
-}
-
 static int transcode_init(void)
 {
     int ret = 0, i, j, k;
-    AVFormatContext *oc;
     OutputStream *ost;
     InputStream *ist;
     char error[1024] = {0};
@@ -3304,15 +3321,32 @@ static int transcode_init(void)
                 input_streams[j + ifile->ist_index]->start = av_gettime_relative();
     }
 
+    // Correct starttime based on the enabled streams
+    for (i = 0; i < nb_input_files; i++) {
+        InputFile       *ifile = input_files[i];
+        AVFormatContext    *is = ifile->ctx;
+        int64_t new_start_time = INT64_MAX;
+
+        if (is->start_time == AV_NOPTS_VALUE ||
+            !(is->iformat->flags & AVFMT_TS_DISCONT))
+            continue;
+
+        for (int j = 0; j < is->nb_streams; j++) {
+            AVStream *st = is->streams[j];
+            if(st->discard == AVDISCARD_ALL || st->start_time == AV_NOPTS_VALUE)
+                continue;
+            new_start_time = FFMIN(new_start_time, av_rescale_q(st->start_time, st->time_base, AV_TIME_BASE_Q));
+        }
+        if (new_start_time > is->start_time) {
+            av_log(is, AV_LOG_VERBOSE, "Correcting start time by %"PRId64"\n", new_start_time - is->start_time);
+            ifile->ts_offset = -new_start_time;
+        }
+    }
+
     /* init input streams */
     for (i = 0; i < nb_input_streams; i++)
-        if ((ret = init_input_stream(i, error, sizeof(error))) < 0) {
-            for (i = 0; i < nb_output_streams; i++) {
-                ost = output_streams[i];
-                avcodec_close(ost->enc_ctx);
-            }
+        if ((ret = init_input_stream(i, error, sizeof(error))) < 0)
             goto dump_format;
-        }
 
     /*
      * initialize stream copy and subtitle/data streams.
@@ -3324,9 +3358,9 @@ static int transcode_init(void)
      *   known after the encoder is initialized.
      */
     for (i = 0; i < nb_output_streams; i++) {
-        if (!output_streams[i]->stream_copy &&
-            (output_streams[i]->enc_ctx->codec_type == AVMEDIA_TYPE_VIDEO ||
-             output_streams[i]->enc_ctx->codec_type == AVMEDIA_TYPE_AUDIO))
+        if (output_streams[i]->enc_ctx &&
+            (output_streams[i]->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ||
+             output_streams[i]->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO))
             continue;
 
         ret = init_output_stream_wrapper(output_streams[i], NULL, 0);
@@ -3350,16 +3384,6 @@ static int transcode_init(void)
         }
     }
 
-    /* write headers for files with no streams */
-    for (i = 0; i < nb_output_files; i++) {
-        oc = output_files[i]->ctx;
-        if (output_files[i]->format->flags & AVFMT_NOSTREAMS && oc->nb_streams == 0) {
-            ret = of_check_init(output_files[i]);
-            if (ret < 0)
-                goto dump_format;
-        }
-    }
-
  dump_format:
     /* dump the stream mapping */
     av_log(NULL, AV_LOG_INFO, "Stream mapping:\n");
@@ -3404,13 +3428,7 @@ static int transcode_init(void)
                input_streams[ost->source_index]->st->index,
                ost->file_index,
                ost->index);
-        if (ost->sync_ist != input_streams[ost->source_index])
-            av_log(NULL, AV_LOG_INFO, " [sync #%d:%d]",
-                   ost->sync_ist->file_index,
-                   ost->sync_ist->st->index);
-        if (ost->stream_copy)
-            av_log(NULL, AV_LOG_INFO, " (copy)");
-        else {
+        if (ost->enc_ctx) {
             const AVCodec *in_codec    = input_streams[ost->source_index]->dec;
             const AVCodec *out_codec   = ost->enc;
             const char *decoder_name   = "?";
@@ -3440,7 +3458,8 @@ static int transcode_init(void)
             av_log(NULL, AV_LOG_INFO, " (%s (%s) -> %s (%s))",
                    in_codec_name, decoder_name,
                    out_codec_name, encoder_name);
-        }
+        } else
+            av_log(NULL, AV_LOG_INFO, " (copy)");
         av_log(NULL, AV_LOG_INFO, "\n");
     }
 
@@ -3461,18 +3480,9 @@ static int need_output(void)
 
     for (i = 0; i < nb_output_streams; i++) {
         OutputStream *ost    = output_streams[i];
-        OutputFile *of       = output_files[ost->file_index];
-        AVFormatContext *os  = output_files[ost->file_index]->ctx;
 
-        if (ost->finished ||
-            (os->pb && avio_tell(os->pb) >= of->limit_filesize))
-            continue;
-        if (ost->frame_number >= ost->max_frames) {
-            int j;
-            for (j = 0; j < of->ctx->nb_streams; j++)
-                close_output_stream(output_streams[of->ost_index + j]);
+        if (ost->finished)
             continue;
-        }
 
         return 1;
     }
@@ -3493,13 +3503,18 @@ static OutputStream *choose_output(void)
 
     for (i = 0; i < nb_output_streams; i++) {
         OutputStream *ost = output_streams[i];
-        int64_t opts = ost->last_mux_dts == AV_NOPTS_VALUE ? INT64_MIN :
-                       av_rescale_q(ost->last_mux_dts, ost->st->time_base,
-                                    AV_TIME_BASE_Q);
-        if (ost->last_mux_dts == AV_NOPTS_VALUE)
-            av_log(NULL, AV_LOG_DEBUG,
-                "cur_dts is invalid st:%d (%d) [init:%d i_done:%d finish:%d] (this is harmless if it occurs once at the start per stream)\n",
-                ost->st->index, ost->st->id, ost->initialized, ost->inputs_done, ost->finished);
+        int64_t opts;
+
+        if (ost->filter && ost->last_filter_pts != AV_NOPTS_VALUE) {
+            opts = ost->last_filter_pts;
+        } else {
+            opts = ost->last_mux_dts == AV_NOPTS_VALUE ?
+                   INT64_MIN : ost->last_mux_dts;
+            if (ost->last_mux_dts == AV_NOPTS_VALUE)
+                av_log(NULL, AV_LOG_DEBUG,
+                    "cur_dts is invalid st:%d (%d) [init:%d i_done:%d finish:%d] (this is harmless if it occurs once at the start per stream)\n",
+                    ost->st->index, ost->st->id, ost->initialized, ost->inputs_done, ost->finished);
+        }
 
         if (!ost->initialized && !ost->inputs_done)
             return ost->unavailable ? NULL : ost;
@@ -3543,15 +3558,6 @@ static int check_keyboard_interaction(int64_t cur_time)
     if (key == '+') av_log_set_level(av_log_get_level()+10);
     if (key == '-') av_log_set_level(av_log_get_level()-10);
     if (key == 's') qp_hist     ^= 1;
-    if (key == 'h'){
-        if (do_hex_dump){
-            do_hex_dump = do_pkt_dump = 0;
-        } else if(do_pkt_dump){
-            do_hex_dump = 1;
-        } else
-            do_pkt_dump = 1;
-        av_log_set_level(AV_LOG_DEBUG);
-    }
     if (key == 'c' || key == 'C'){
         char buf[4096], target[64], command[256], arg[256] = {0};
         double time;
@@ -3618,7 +3624,8 @@ static int check_keyboard_interaction(int64_t cur_time)
         }
         for(i=0;i<nb_output_streams;i++) {
             OutputStream *ost = output_streams[i];
-            ost->enc_ctx->debug = debug;
+            if (ost->enc_ctx)
+                ost->enc_ctx->debug = debug;
         }
         if(debug) av_log_set_level(AV_LOG_DEBUG);
         fprintf(stderr,"debug=%d\n", debug);
@@ -3639,155 +3646,6 @@ static int check_keyboard_interaction(int64_t cur_time)
     return 0;
 }
 
-#if HAVE_THREADS
-static void *input_thread(void *arg)
-{
-    InputFile *f = arg;
-    AVPacket *pkt = f->pkt, *queue_pkt;
-    unsigned flags = f->non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0;
-    int ret = 0;
-
-    while (1) {
-        ret = av_read_frame(f->ctx, pkt);
-
-        if (ret == AVERROR(EAGAIN)) {
-            av_usleep(10000);
-            continue;
-        }
-        if (ret < 0) {
-            av_thread_message_queue_set_err_recv(f->in_thread_queue, ret);
-            break;
-        }
-        queue_pkt = av_packet_alloc();
-        if (!queue_pkt) {
-            av_packet_unref(pkt);
-            av_thread_message_queue_set_err_recv(f->in_thread_queue, AVERROR(ENOMEM));
-            break;
-        }
-        av_packet_move_ref(queue_pkt, pkt);
-        ret = av_thread_message_queue_send(f->in_thread_queue, &queue_pkt, flags);
-        if (flags && ret == AVERROR(EAGAIN)) {
-            flags = 0;
-            ret = av_thread_message_queue_send(f->in_thread_queue, &queue_pkt, flags);
-            av_log(f->ctx, AV_LOG_WARNING,
-                   "Thread message queue blocking; consider raising the "
-                   "thread_queue_size option (current value: %d)\n",
-                   f->thread_queue_size);
-        }
-        if (ret < 0) {
-            if (ret != AVERROR_EOF)
-                av_log(f->ctx, AV_LOG_ERROR,
-                       "Unable to send packet to main thread: %s\n",
-                       av_err2str(ret));
-            av_packet_free(&queue_pkt);
-            av_thread_message_queue_set_err_recv(f->in_thread_queue, ret);
-            break;
-        }
-    }
-
-    return NULL;
-}
-
-static void free_input_thread(int i)
-{
-    InputFile *f = input_files[i];
-    AVPacket *pkt;
-
-    if (!f || !f->in_thread_queue)
-        return;
-    av_thread_message_queue_set_err_send(f->in_thread_queue, AVERROR_EOF);
-    while (av_thread_message_queue_recv(f->in_thread_queue, &pkt, 0) >= 0)
-        av_packet_free(&pkt);
-
-    pthread_join(f->thread, NULL);
-    f->joined = 1;
-    av_thread_message_queue_free(&f->in_thread_queue);
-}
-
-static void free_input_threads(void)
-{
-    int i;
-
-    for (i = 0; i < nb_input_files; i++)
-        free_input_thread(i);
-}
-
-static int init_input_thread(int i)
-{
-    int ret;
-    InputFile *f = input_files[i];
-
-    if (f->thread_queue_size < 0)
-        f->thread_queue_size = (nb_input_files > 1 ? 8 : 0);
-    if (!f->thread_queue_size)
-        return 0;
-
-    if (f->ctx->pb ? !f->ctx->pb->seekable :
-        strcmp(f->ctx->iformat->name, "lavfi"))
-        f->non_blocking = 1;
-    ret = av_thread_message_queue_alloc(&f->in_thread_queue,
-                                        f->thread_queue_size, sizeof(f->pkt));
-    if (ret < 0)
-        return ret;
-
-    if ((ret = pthread_create(&f->thread, NULL, input_thread, f))) {
-        av_log(NULL, AV_LOG_ERROR, "pthread_create failed: %s. Try to increase `ulimit -v` or decrease `ulimit -s`.\n", strerror(ret));
-        av_thread_message_queue_free(&f->in_thread_queue);
-        return AVERROR(ret);
-    }
-
-    return 0;
-}
-
-static int init_input_threads(void)
-{
-    int i, ret;
-
-    for (i = 0; i < nb_input_files; i++) {
-        ret = init_input_thread(i);
-        if (ret < 0)
-            return ret;
-    }
-    return 0;
-}
-
-static int get_input_packet_mt(InputFile *f, AVPacket **pkt)
-{
-    return av_thread_message_queue_recv(f->in_thread_queue, pkt,
-                                        f->non_blocking ?
-                                        AV_THREAD_MESSAGE_NONBLOCK : 0);
-}
-#endif
-
-static int get_input_packet(InputFile *f, AVPacket **pkt)
-{
-    if (f->readrate || f->rate_emu) {
-        int i;
-        int64_t file_start = copy_ts * (
-                              (f->ctx->start_time != AV_NOPTS_VALUE ? f->ctx->start_time * !start_at_zero : 0) +
-                              (f->start_time != AV_NOPTS_VALUE ? f->start_time : 0)
-                             );
-        float scale = f->rate_emu ? 1.0 : f->readrate;
-        for (i = 0; i < f->nb_streams; i++) {
-            InputStream *ist = input_streams[f->ist_index + i];
-            int64_t stream_ts_offset, pts, now;
-            if (!ist->nb_packets || (ist->decoding_needed && !ist->got_output)) continue;
-            stream_ts_offset = FFMAX(ist->first_dts != AV_NOPTS_VALUE ? ist->first_dts : 0, file_start);
-            pts = av_rescale(ist->dts, 1000000, AV_TIME_BASE);
-            now = (av_gettime_relative() - ist->start) * scale + stream_ts_offset;
-            if (pts > now)
-                return AVERROR(EAGAIN);
-        }
-    }
-
-#if HAVE_THREADS
-    if (f->thread_queue_size)
-        return get_input_packet_mt(f, pkt);
-#endif
-    *pkt = f->pkt;
-    return av_read_frame(f->ctx, *pkt);
-}
-
 static int got_eagain(void)
 {
     int i;
@@ -3806,83 +3664,119 @@ static void reset_eagain(void)
         output_streams[i]->unavailable = 0;
 }
 
-// set duration to max(tmp, duration) in a proper time base and return duration's time_base
-static AVRational duration_max(int64_t tmp, int64_t *duration, AVRational tmp_time_base,
-                               AVRational time_base)
+static void decode_flush(InputFile *ifile)
 {
-    int ret;
+    for (int i = 0; i < ifile->nb_streams; i++) {
+        InputStream *ist = input_streams[ifile->ist_index + i];
+        int ret;
 
-    if (!*duration) {
-        *duration = tmp;
-        return tmp_time_base;
-    }
-
-    ret = av_compare_ts(*duration, time_base, tmp, tmp_time_base);
-    if (ret < 0) {
-        *duration = tmp;
-        return tmp_time_base;
-    }
+        if (!ist->processing_needed)
+            continue;
 
-    return time_base;
-}
+        do {
+            ret = process_input_packet(ist, NULL, 1);
+        } while (ret > 0);
 
-static int seek_to_start(InputFile *ifile, AVFormatContext *is)
-{
-    InputStream *ist;
-    AVCodecContext *avctx;
-    int i, ret, has_audio = 0;
-    int64_t duration = 0;
+        if (ist->decoding_needed) {
+            /* report last frame duration to the demuxer thread */
+            if (ist->par->codec_type == AVMEDIA_TYPE_AUDIO) {
+                LastFrameDuration dur;
 
-    ret = avformat_seek_file(is, -1, INT64_MIN, is->start_time, is->start_time, 0);
-    if (ret < 0)
-        return ret;
+                dur.stream_idx = i;
+                dur.duration   = av_rescale_q(ist->nb_samples,
+                                              (AVRational){ 1, ist->dec_ctx->sample_rate},
+                                              ist->st->time_base);
 
-    for (i = 0; i < ifile->nb_streams; i++) {
-        ist   = input_streams[ifile->ist_index + i];
-        avctx = ist->dec_ctx;
+                av_thread_message_queue_send(ifile->audio_duration_queue, &dur, 0);
+            }
 
-        /* duration is the length of the last frame in a stream
-         * when audio stream is present we don't care about
-         * last video frame length because it's not defined exactly */
-        if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && ist->nb_samples)
-            has_audio = 1;
+            avcodec_flush_buffers(ist->dec_ctx);
+        }
     }
+}
 
-    for (i = 0; i < ifile->nb_streams; i++) {
-        ist   = input_streams[ifile->ist_index + i];
-        avctx = ist->dec_ctx;
+static void ts_discontinuity_detect(InputFile *ifile, InputStream *ist,
+                                    AVPacket *pkt)
+{
+    const int fmt_is_discont = ifile->ctx->iformat->flags & AVFMT_TS_DISCONT;
+    int disable_discontinuity_correction = copy_ts;
+    int64_t pkt_dts = av_rescale_q_rnd(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q,
+                                       AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);
 
-        if (has_audio) {
-            if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && ist->nb_samples) {
-                AVRational sample_rate = {1, avctx->sample_rate};
+    if (copy_ts && ist->next_dts != AV_NOPTS_VALUE &&
+        fmt_is_discont && ist->st->pts_wrap_bits < 60) {
+        int64_t wrap_dts = av_rescale_q_rnd(pkt->dts + (1LL<<ist->st->pts_wrap_bits),
+                                            ist->st->time_base, AV_TIME_BASE_Q,
+                                            AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);
+        if (FFABS(wrap_dts - ist->next_dts) < FFABS(pkt_dts - ist->next_dts)/10)
+            disable_discontinuity_correction = 0;
+    }
 
-                duration = av_rescale_q(ist->nb_samples, sample_rate, ist->st->time_base);
-            } else {
-                continue;
+    if (ist->next_dts != AV_NOPTS_VALUE && !disable_discontinuity_correction) {
+        int64_t delta = pkt_dts - ist->next_dts;
+        if (fmt_is_discont) {
+            if (FFABS(delta) > 1LL * dts_delta_threshold * AV_TIME_BASE ||
+                pkt_dts + AV_TIME_BASE/10 < FFMAX(ist->pts, ist->dts)) {
+                ifile->ts_offset_discont -= delta;
+                av_log(NULL, AV_LOG_DEBUG,
+                       "timestamp discontinuity for stream #%d:%d "
+                       "(id=%d, type=%s): %"PRId64", new offset= %"PRId64"\n",
+                       ist->file_index, ist->st->index, ist->st->id,
+                       av_get_media_type_string(ist->par->codec_type),
+                       delta, ifile->ts_offset_discont);
+                pkt->dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
+                if (pkt->pts != AV_NOPTS_VALUE)
+                    pkt->pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
             }
         } else {
-            if (ist->framerate.num) {
-                duration = av_rescale_q(1, av_inv_q(ist->framerate), ist->st->time_base);
-            } else if (ist->st->avg_frame_rate.num) {
-                duration = av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate), ist->st->time_base);
-            } else {
-                duration = 1;
+            if (FFABS(delta) > 1LL * dts_error_threshold * AV_TIME_BASE) {
+                av_log(NULL, AV_LOG_WARNING, "DTS %"PRId64", next:%"PRId64" st:%d invalid dropping\n", pkt->dts, ist->next_dts, pkt->stream_index);
+                pkt->dts = AV_NOPTS_VALUE;
+            }
+            if (pkt->pts != AV_NOPTS_VALUE){
+                int64_t pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);
+                delta = pkt_pts - ist->next_dts;
+                if (FFABS(delta) > 1LL * dts_error_threshold * AV_TIME_BASE) {
+                    av_log(NULL, AV_LOG_WARNING, "PTS %"PRId64", next:%"PRId64" invalid dropping st:%d\n", pkt->pts, ist->next_dts, pkt->stream_index);
+                    pkt->pts = AV_NOPTS_VALUE;
+                }
             }
         }
-        if (!ifile->duration)
-            ifile->time_base = ist->st->time_base;
-        /* the total duration of the stream, max_pts - min_pts is
-         * the duration of the stream without the last frame */
-        if (ist->max_pts > ist->min_pts && ist->max_pts - (uint64_t)ist->min_pts < INT64_MAX - duration)
-            duration += ist->max_pts - ist->min_pts;
-        ifile->time_base = duration_max(duration, &ifile->duration, ist->st->time_base,
-                                        ifile->time_base);
+    } else if (ist->next_dts == AV_NOPTS_VALUE && !copy_ts &&
+               fmt_is_discont && ifile->last_ts != AV_NOPTS_VALUE) {
+        int64_t delta = pkt_dts - ifile->last_ts;
+        if (FFABS(delta) > 1LL * dts_delta_threshold * AV_TIME_BASE) {
+            ifile->ts_offset_discont -= delta;
+            av_log(NULL, AV_LOG_DEBUG,
+                   "Inter stream timestamp discontinuity %"PRId64", new offset= %"PRId64"\n",
+                   delta, ifile->ts_offset_discont);
+            pkt->dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
+            if (pkt->pts != AV_NOPTS_VALUE)
+                pkt->pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
+        }
     }
 
-    if (ifile->loop > 0)
-        ifile->loop--;
+    ifile->last_ts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);
+}
+
+static void ts_discontinuity_process(InputFile *ifile, InputStream *ist,
+                                     AVPacket *pkt)
+{
+    int64_t offset = av_rescale_q(ifile->ts_offset_discont, AV_TIME_BASE_Q,
+                                  ist->st->time_base);
 
-    return ret;
+    // apply previously-detected timestamp-discontinuity offset
+    // (to all streams, not just audio/video)
+    if (pkt->dts != AV_NOPTS_VALUE)
+        pkt->dts += offset;
+    if (pkt->pts != AV_NOPTS_VALUE)
+        pkt->pts += offset;
+
+    // detect timestamp discontinuities for audio/video
+    if ((ist->par->codec_type == AVMEDIA_TYPE_VIDEO ||
+         ist->par->codec_type == AVMEDIA_TYPE_AUDIO) &&
+        pkt->dts != AV_NOPTS_VALUE)
+        ts_discontinuity_detect(ifile, ist, pkt);
 }
 
 /*
@@ -3898,48 +3792,19 @@ static int process_input(int file_index)
     AVFormatContext *is;
     InputStream *ist;
     AVPacket *pkt;
-    int ret, thread_ret, i, j;
-    int64_t duration;
-    int64_t pkt_dts;
-    int disable_discontinuity_correction = copy_ts;
+    int ret, i, j;
 
     is  = ifile->ctx;
-    ret = get_input_packet(ifile, &pkt);
+    ret = ifile_get_packet(ifile, &pkt);
 
     if (ret == AVERROR(EAGAIN)) {
         ifile->eagain = 1;
         return ret;
     }
-    if (ret < 0 && ifile->loop) {
-        AVCodecContext *avctx;
-        for (i = 0; i < ifile->nb_streams; i++) {
-            ist = input_streams[ifile->ist_index + i];
-            avctx = ist->dec_ctx;
-            if (ist->processing_needed) {
-                ret = process_input_packet(ist, NULL, 1);
-                if (ret>0)
-                    return 0;
-                if (ist->decoding_needed)
-                    avcodec_flush_buffers(avctx);
-            }
-        }
-#if HAVE_THREADS
-        free_input_thread(file_index);
-#endif
-        ret = seek_to_start(ifile, is);
-#if HAVE_THREADS
-        thread_ret = init_input_thread(file_index);
-        if (thread_ret < 0)
-            return thread_ret;
-#endif
-        if (ret < 0)
-            av_log(NULL, AV_LOG_WARNING, "Seek to start failed.\n");
-        else
-            ret = get_input_packet(ifile, &pkt);
-        if (ret == AVERROR(EAGAIN)) {
-            ifile->eagain = 1;
-            return ret;
-        }
+    if (ret == 1) {
+        /* the input file is looped: flush the decoders */
+        decode_flush(ifile);
+        return AVERROR(EAGAIN);
     }
     if (ret < 0) {
         if (ret != AVERROR_EOF) {
@@ -3961,8 +3826,10 @@ static int process_input(int file_index)
                 OutputStream *ost = output_streams[j];
 
                 if (ost->source_index == ifile->ist_index + i &&
-                    (ost->stream_copy || ost->enc->type == AVMEDIA_TYPE_SUBTITLE))
-                    finish_output_stream(ost);
+                    (!ost->enc_ctx || ost->enc->type == AVMEDIA_TYPE_SUBTITLE)) {
+                    OutputFile *of = output_files[ost->file_index];
+                    output_packet(of, ost->pkt, ost, 1);
+                }
             }
         }
 
@@ -3972,17 +3839,6 @@ static int process_input(int file_index)
 
     reset_eagain();
 
-    if (do_pkt_dump) {
-        av_pkt_dump_log2(NULL, AV_LOG_INFO, pkt, do_hex_dump,
-                         is->streams[pkt->stream_index]);
-    }
-    /* the following test is needed in case new streams appear
-       dynamically in stream : we ignore them */
-    if (pkt->stream_index >= ifile->nb_streams) {
-        report_new_stream(file_index, pkt);
-        goto discard_packet;
-    }
-
     ist = input_streams[ifile->ist_index + pkt->stream_index];
 
     ist->data_size += pkt->size;
@@ -3991,61 +3847,6 @@ static int process_input(int file_index)
     if (ist->discard)
         goto discard_packet;
 
-    if (pkt->flags & AV_PKT_FLAG_CORRUPT) {
-        av_log(NULL, exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING,
-               "%s: corrupt input packet in stream %d\n", is->url, pkt->stream_index);
-        if (exit_on_error)
-            exit_program(1);
-    }
-
-    if (debug_ts) {
-        av_log(NULL, AV_LOG_INFO, "demuxer -> ist_index:%d type:%s "
-               "next_dts:%s next_dts_time:%s next_pts:%s next_pts_time:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s off:%s off_time:%s\n",
-               ifile->ist_index + pkt->stream_index, av_get_media_type_string(ist->dec_ctx->codec_type),
-               av_ts2str(ist->next_dts), av_ts2timestr(ist->next_dts, &AV_TIME_BASE_Q),
-               av_ts2str(ist->next_pts), av_ts2timestr(ist->next_pts, &AV_TIME_BASE_Q),
-               av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, &ist->st->time_base),
-               av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, &ist->st->time_base),
-               av_ts2str(pkt->duration), av_ts2timestr(pkt->duration, &ist->st->time_base),
-               av_ts2str(input_files[ist->file_index]->ts_offset),
-               av_ts2timestr(input_files[ist->file_index]->ts_offset, &AV_TIME_BASE_Q));
-    }
-
-    if(!ist->wrap_correction_done && is->start_time != AV_NOPTS_VALUE && ist->st->pts_wrap_bits < 64){
-        int64_t stime, stime2;
-        // Correcting starttime based on the enabled streams
-        // FIXME this ideally should be done before the first use of starttime but we do not know which are the enabled streams at that point.
-        //       so we instead do it here as part of discontinuity handling
-        if (   ist->next_dts == AV_NOPTS_VALUE
-            && ifile->ts_offset == -is->start_time
-            && (is->iformat->flags & AVFMT_TS_DISCONT)) {
-            int64_t new_start_time = INT64_MAX;
-            for (i=0; i<is->nb_streams; i++) {
-                AVStream *st = is->streams[i];
-                if(st->discard == AVDISCARD_ALL || st->start_time == AV_NOPTS_VALUE)
-                    continue;
-                new_start_time = FFMIN(new_start_time, av_rescale_q(st->start_time, st->time_base, AV_TIME_BASE_Q));
-            }
-            if (new_start_time > is->start_time) {
-                av_log(is, AV_LOG_VERBOSE, "Correcting start time by %"PRId64"\n", new_start_time - is->start_time);
-                ifile->ts_offset = -new_start_time;
-            }
-        }
-
-        stime = av_rescale_q(is->start_time, AV_TIME_BASE_Q, ist->st->time_base);
-        stime2= stime + (1ULL<<ist->st->pts_wrap_bits);
-        ist->wrap_correction_done = 1;
-
-        if(stime2 > stime && pkt->dts != AV_NOPTS_VALUE && pkt->dts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {
-            pkt->dts -= 1ULL<<ist->st->pts_wrap_bits;
-            ist->wrap_correction_done = 0;
-        }
-        if(stime2 > stime && pkt->pts != AV_NOPTS_VALUE && pkt->pts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {
-            pkt->pts -= 1ULL<<ist->st->pts_wrap_bits;
-            ist->wrap_correction_done = 0;
-        }
-    }
-
     /* add the stream-global side data to the first packet */
     if (ist->nb_packets == 1) {
         for (i = 0; i < ist->st->nb_side_data; i++) {
@@ -4066,99 +3867,13 @@ static int process_input(int file_index)
         }
     }
 
-    if (pkt->dts != AV_NOPTS_VALUE)
-        pkt->dts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);
-    if (pkt->pts != AV_NOPTS_VALUE)
-        pkt->pts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);
-
-    if (pkt->pts != AV_NOPTS_VALUE)
-        pkt->pts *= ist->ts_scale;
-    if (pkt->dts != AV_NOPTS_VALUE)
-        pkt->dts *= ist->ts_scale;
-
-    pkt_dts = av_rescale_q_rnd(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);
-    if ((ist->dec_ctx->codec_type == AVMEDIA_TYPE_VIDEO ||
-         ist->dec_ctx->codec_type == AVMEDIA_TYPE_AUDIO) &&
-        pkt_dts != AV_NOPTS_VALUE && ist->next_dts == AV_NOPTS_VALUE && !copy_ts
-        && (is->iformat->flags & AVFMT_TS_DISCONT) && ifile->last_ts != AV_NOPTS_VALUE) {
-        int64_t delta   = pkt_dts - ifile->last_ts;
-        if (delta < -1LL*dts_delta_threshold*AV_TIME_BASE ||
-            delta >  1LL*dts_delta_threshold*AV_TIME_BASE){
-            ifile->ts_offset -= delta;
-            av_log(NULL, AV_LOG_DEBUG,
-                   "Inter stream timestamp discontinuity %"PRId64", new offset= %"PRId64"\n",
-                   delta, ifile->ts_offset);
-            pkt->dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
-            if (pkt->pts != AV_NOPTS_VALUE)
-                pkt->pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
-        }
-    }
-
-    duration = av_rescale_q(ifile->duration, ifile->time_base, ist->st->time_base);
-    if (pkt->pts != AV_NOPTS_VALUE) {
-        pkt->pts += duration;
-        ist->max_pts = FFMAX(pkt->pts, ist->max_pts);
-        ist->min_pts = FFMIN(pkt->pts, ist->min_pts);
-    }
-
-    if (pkt->dts != AV_NOPTS_VALUE)
-        pkt->dts += duration;
-
-    pkt_dts = av_rescale_q_rnd(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);
-
-    if (copy_ts && pkt_dts != AV_NOPTS_VALUE && ist->next_dts != AV_NOPTS_VALUE &&
-        (is->iformat->flags & AVFMT_TS_DISCONT) && ist->st->pts_wrap_bits < 60) {
-        int64_t wrap_dts = av_rescale_q_rnd(pkt->dts + (1LL<<ist->st->pts_wrap_bits),
-                                            ist->st->time_base, AV_TIME_BASE_Q,
-                                            AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);
-        if (FFABS(wrap_dts - ist->next_dts) < FFABS(pkt_dts - ist->next_dts)/10)
-            disable_discontinuity_correction = 0;
-    }
-
-    if ((ist->dec_ctx->codec_type == AVMEDIA_TYPE_VIDEO ||
-         ist->dec_ctx->codec_type == AVMEDIA_TYPE_AUDIO) &&
-         pkt_dts != AV_NOPTS_VALUE && ist->next_dts != AV_NOPTS_VALUE &&
-        !disable_discontinuity_correction) {
-        int64_t delta   = pkt_dts - ist->next_dts;
-        if (is->iformat->flags & AVFMT_TS_DISCONT) {
-            if (delta < -1LL*dts_delta_threshold*AV_TIME_BASE ||
-                delta >  1LL*dts_delta_threshold*AV_TIME_BASE ||
-                pkt_dts + AV_TIME_BASE/10 < FFMAX(ist->pts, ist->dts)) {
-                ifile->ts_offset -= delta;
-                av_log(NULL, AV_LOG_DEBUG,
-                       "timestamp discontinuity for stream #%d:%d "
-                       "(id=%d, type=%s): %"PRId64", new offset= %"PRId64"\n",
-                       ist->file_index, ist->st->index, ist->st->id,
-                       av_get_media_type_string(ist->dec_ctx->codec_type),
-                       delta, ifile->ts_offset);
-                pkt->dts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
-                if (pkt->pts != AV_NOPTS_VALUE)
-                    pkt->pts -= av_rescale_q(delta, AV_TIME_BASE_Q, ist->st->time_base);
-            }
-        } else {
-            if ( delta < -1LL*dts_error_threshold*AV_TIME_BASE ||
-                 delta >  1LL*dts_error_threshold*AV_TIME_BASE) {
-                av_log(NULL, AV_LOG_WARNING, "DTS %"PRId64", next:%"PRId64" st:%d invalid dropping\n", pkt->dts, ist->next_dts, pkt->stream_index);
-                pkt->dts = AV_NOPTS_VALUE;
-            }
-            if (pkt->pts != AV_NOPTS_VALUE){
-                int64_t pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);
-                delta   = pkt_pts - ist->next_dts;
-                if ( delta < -1LL*dts_error_threshold*AV_TIME_BASE ||
-                     delta >  1LL*dts_error_threshold*AV_TIME_BASE) {
-                    av_log(NULL, AV_LOG_WARNING, "PTS %"PRId64", next:%"PRId64" invalid dropping st:%d\n", pkt->pts, ist->next_dts, pkt->stream_index);
-                    pkt->pts = AV_NOPTS_VALUE;
-                }
-            }
-        }
-    }
-
-    if (pkt->dts != AV_NOPTS_VALUE)
-        ifile->last_ts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);
+    // detect and try to correct for timestamp discontinuities
+    ts_discontinuity_process(ifile, ist, pkt);
 
     if (debug_ts) {
         av_log(NULL, AV_LOG_INFO, "demuxer+ffmpeg -> ist_index:%d type:%s pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s off:%s off_time:%s\n",
-               ifile->ist_index + pkt->stream_index, av_get_media_type_string(ist->dec_ctx->codec_type),
+               ifile->ist_index + pkt->stream_index,
+               av_get_media_type_string(ist->par->codec_type),
                av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, &ist->st->time_base),
                av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, &ist->st->time_base),
                av_ts2str(pkt->duration), av_ts2timestr(pkt->duration, &ist->st->time_base),
@@ -4171,12 +3886,7 @@ static int process_input(int file_index)
     process_input_packet(ist, pkt, 0);
 
 discard_packet:
-#if HAVE_THREADS
-    if (ifile->thread_queue_size)
-        av_packet_free(&pkt);
-    else
-#endif
-    av_packet_unref(pkt);
+    av_packet_free(&pkt);
 
     return 0;
 }
@@ -4327,7 +4037,6 @@ static int transcode_step(void)
 static int transcode(void)
 {
     int ret, i;
-    AVFormatContext *os;
     OutputStream *ost;
     InputStream *ist;
     int64_t timer_start;
@@ -4343,10 +4052,8 @@ static int transcode(void)
 
     timer_start = av_gettime_relative();
 
-#if HAVE_THREADS
     if ((ret = init_input_threads()) < 0)
         goto fail;
-#endif
 
     while (!received_sigterm) {
         int64_t cur_time= av_gettime_relative();
@@ -4371,9 +4078,7 @@ static int transcode(void)
         /* dump report by using the output first video and audio streams */
         print_report(0, timer_start, cur_time);
     }
-#if HAVE_THREADS
     free_input_threads();
-#endif
 
     /* at the end of stream, we must flush the decoder buffers */
     for (i = 0; i < nb_input_streams; i++) {
@@ -4396,26 +4101,13 @@ static int transcode(void)
     /* dump report by using the first video and audio streams */
     print_report(1, timer_start, av_gettime_relative());
 
-    /* close the output files */
-    for (i = 0; i < nb_output_files; i++) {
-        os = output_files[i]->ctx;
-        if (os && os->oformat && !(os->oformat->flags & AVFMT_NOFILE)) {
-            if ((ret = avio_closep(&os->pb)) < 0) {
-                av_log(NULL, AV_LOG_ERROR, "Error closing file %s: %s\n", os->url, av_err2str(ret));
-                if (exit_on_error)
-                    exit_program(1);
-            }
-        }
-    }
-
     /* close each encoder */
     for (i = 0; i < nb_output_streams; i++) {
+        uint64_t packets_written;
         ost = output_streams[i];
-        if (ost->encoding_needed) {
-            av_freep(&ost->enc_ctx->stats_in);
-        }
-        total_packets_written += ost->packets_written;
-        if (!ost->packets_written && (abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM)) {
+        packets_written = atomic_load(&ost->packets_written);
+        total_packets_written += packets_written;
+        if (!packets_written && (abort_on_flags & ABORT_ON_FLAG_EMPTY_OUTPUT_STREAM)) {
             av_log(NULL, AV_LOG_FATAL, "Empty output on stream %d.\n", i);
             exit_program(1);
         }
@@ -4431,8 +4123,6 @@ static int transcode(void)
         ist = input_streams[i];
         if (ist->decoding_needed) {
             avcodec_close(ist->dec_ctx);
-            if (ist->hwaccel_uninit)
-                ist->hwaccel_uninit(ist->dec_ctx);
         }
     }
 
@@ -4442,9 +4132,7 @@ static int transcode(void)
     ret = 0;
 
  fail:
-#if HAVE_THREADS
     free_input_threads();
-#endif
 
     if (output_streams) {
         for (i = 0; i < nb_output_streams; i++) {
@@ -4515,7 +4203,7 @@ static int64_t getmaxrss(void)
 
 int main(int argc, char **argv)
 {
-    int i, ret;
+    int ret;
     BenchmarkTimeStamps ti;
 
     init_dynload();
@@ -4551,11 +4239,6 @@ int main(int argc, char **argv)
         exit_program(1);
     }
 
-    for (i = 0; i < nb_output_files; i++) {
-        if (strcmp(output_files[i]->format->name, "rtp"))
-            want_sdp = 0;
-    }
-
     current_time = ti = get_benchmark_time_stamps();
     if (transcode() < 0)
         exit_program(1);
diff --git a/fftools/ffmpeg.h b/fftools/ffmpeg.h
index 391a35c..44cc23f 100644
--- a/fftools/ffmpeg.h
+++ b/fftools/ffmpeg.h
@@ -21,11 +21,13 @@
 
 #include "config.h"
 
+#include <stdatomic.h>
 #include <stdint.h>
 #include <stdio.h>
 #include <signal.h>
 
 #include "cmdutils.h"
+#include "sync_queue.h"
 
 #include "libavformat/avformat.h"
 #include "libavformat/avio.h"
@@ -47,6 +49,11 @@
 
 #include "libswresample/swresample.h"
 
+// deprecated features
+#define FFMPEG_OPT_PSNR 1
+#define FFMPEG_OPT_MAP_CHANNEL 1
+#define FFMPEG_OPT_MAP_SYNC 1
+
 enum VideoSyncMethod {
     VSYNC_AUTO = -1,
     VSYNC_PASSTHROUGH,
@@ -75,15 +82,15 @@ typedef struct StreamMap {
     int disabled;           /* 1 is this mapping is disabled by a negative map */
     int file_index;
     int stream_index;
-    int sync_file_index;
-    int sync_stream_index;
     char *linklabel;       /* name of an output link, for mapping lavfi outputs */
 } StreamMap;
 
+#if FFMPEG_OPT_MAP_CHANNEL
 typedef struct {
     int  file_idx,  stream_idx,  channel_idx; // input
     int ofile_idx, ostream_idx;               // output
 } AudioChannelMap;
+#endif
 
 typedef struct OptionsContext {
     OptionGroup *g;
@@ -136,8 +143,10 @@ typedef struct OptionsContext {
     /* output options */
     StreamMap *stream_maps;
     int     nb_stream_maps;
+#if FFMPEG_OPT_MAP_CHANNEL
     AudioChannelMap *audio_channel_maps; /* one info entry per -map_channel */
     int           nb_audio_channel_maps; /* number of (valid) -map_channel settings */
+#endif
     int metadata_global_manual;
     int metadata_streams_manual;
     int metadata_chapters_manual;
@@ -148,9 +157,10 @@ typedef struct OptionsContext {
 
     int64_t recording_time;
     int64_t stop_time;
-    uint64_t limit_filesize;
+    int64_t limit_filesize;
     float mux_preload;
     float mux_max_delay;
+    float shortest_buf_duration;
     int shortest;
     int bitexact;
 
@@ -313,6 +323,12 @@ typedef struct InputStream {
 #define DECODING_FOR_FILTER 2
     int processing_needed;   /* non zero if the packets must be processed */
 
+    /**
+     * Codec parameters - to be used by the decoding/streamcopy code.
+     * st->codecpar should not be accessed, because it may be modified
+     * concurrently by the demuxing thread.
+     */
+    AVCodecParameters *par;
     AVCodecContext *dec_ctx;
     const AVCodec *dec;
     AVFrame *decoded_frame;
@@ -379,12 +395,8 @@ typedef struct InputStream {
     char  *hwaccel_device;
     enum AVPixelFormat hwaccel_output_format;
 
-    /* hwaccel context */
-    void  *hwaccel_ctx;
-    void (*hwaccel_uninit)(AVCodecContext *s);
     int  (*hwaccel_retrieve_data)(AVCodecContext *s, AVFrame *frame);
     enum AVPixelFormat hwaccel_pix_fmt;
-    enum AVPixelFormat hwaccel_retrieved_pix_fmt;
 
     /* stats */
     // combined size of all the packets read
@@ -401,7 +413,14 @@ typedef struct InputStream {
     int got_output;
 } InputStream;
 
+typedef struct LastFrameDuration {
+    int     stream_idx;
+    int64_t duration;
+} LastFrameDuration;
+
 typedef struct InputFile {
+    int index;
+
     AVFormatContext *ctx;
     int eof_reached;      /* true if eof reached */
     int eagain;           /* true if last read attempt returned EAGAIN */
@@ -414,6 +433,10 @@ typedef struct InputFile {
     int input_sync_ref;
 
     int64_t ts_offset;
+    /**
+     * Extra timestamp offset added by discontinuity handling.
+     */
+    int64_t ts_offset_discont;
     int64_t last_ts;
     int64_t start_time;   /* user-specified start time in AV_TIME_BASE or AV_NOPTS_VALUE */
     int64_t recording_time;
@@ -424,15 +447,15 @@ typedef struct InputFile {
     float readrate;
     int accurate_seek;
 
-    AVPacket *pkt;
-
-#if HAVE_THREADS
     AVThreadMessageQueue *in_thread_queue;
     pthread_t thread;           /* thread reading from this file */
     int non_blocking;           /* reading packets from the thread should not block */
-    int joined;                 /* the thread has been joined */
     int thread_queue_size;      /* maximum number of queued packets */
-#endif
+
+    /* when looping the input file, this queue is used by decoders to report
+     * the last frame duration back to the demuxer thread */
+    AVThreadMessageQueue *audio_duration_queue;
+    int                   audio_duration_queue_size;
 } InputFile;
 
 enum forced_keyframes_const {
@@ -459,17 +482,24 @@ typedef struct OutputStream {
     int index;               /* stream index in the output file */
     int source_index;        /* InputStream index */
     AVStream *st;            /* stream in the output file */
-    int encoding_needed;     /* true if encoding needed for this stream */
-    int64_t frame_number;
+    /* number of frames emitted by the video-encoding sync code */
+    int64_t vsync_frame_number;
     /* input pts and corresponding output pts
        for A/V sync */
-    struct InputStream *sync_ist; /* input stream to sync against */
     int64_t sync_opts;       /* output frame counter, could be changed to some true timestamp */ // FIXME look at frame_number
     /* pts of the first frame encoded for this stream, used for limiting
      * recording time */
     int64_t first_pts;
-    /* dts of the last packet sent to the muxer */
+    /* dts of the last packet sent to the muxing queue, in AV_TIME_BASE_Q */
     int64_t last_mux_dts;
+    /* pts of the last frame received from the filters, in AV_TIME_BASE_Q */
+    int64_t last_filter_pts;
+
+    // timestamp from which the streamcopied streams should start,
+    // in AV_TIME_BASE_Q;
+    // everything before it should be discarded
+    int64_t ts_copy_start;
+
     // the timebase of the packets sent to the muxer
     AVRational mux_timebase;
     AVRational enc_timebase;
@@ -477,17 +507,15 @@ typedef struct OutputStream {
     AVBSFContext            *bsf_ctx;
 
     AVCodecContext *enc_ctx;
-    AVCodecParameters *ref_par; /* associated input codec parameters with encoders options applied */
     const AVCodec *enc;
     int64_t max_frames;
     AVFrame *filtered_frame;
     AVFrame *last_frame;
+    AVFrame *sq_frame;
     AVPacket *pkt;
     int64_t last_dropped;
     int64_t last_nb0_frames[3];
 
-    void  *hwaccel_ctx;
-
     /* video only */
     AVRational frame_rate;
     AVRational max_frame_rate;
@@ -498,6 +526,7 @@ typedef struct OutputStream {
     int top_field_first;
     int rotate_overridden;
     int autoscale;
+    int bitexact;
     int bits_per_raw_sample;
     double rotate_override_value;
 
@@ -514,8 +543,10 @@ typedef struct OutputStream {
     int dropped_keyframe;
 
     /* audio only */
+#if FFMPEG_OPT_MAP_CHANNEL
     int *audio_channels_map;             /* list of the channels id to pick from the source stream */
     int audio_channels_mapped;           /* number of channels in audio_channels_map */
+#endif
 
     char *logfile_prefix;
     FILE *logfile;
@@ -531,7 +562,6 @@ typedef struct OutputStream {
     char *apad;
     OSTFinished finished;        /* no more packets should be written for this stream */
     int unavailable;                     /* true if the steram is unavailable (possibly temporarily) */
-    int stream_copy;
 
     // init_output_stream() has been called for this stream
     // The encoder and the bitstream filters have been initialized and the stream
@@ -552,7 +582,7 @@ typedef struct OutputStream {
     // combined size of all the packets written
     uint64_t data_size;
     // number of packets send to the muxer
-    uint64_t packets_written;
+    atomic_uint_least64_t packets_written;
     // number of frames/samples sent to the encoder
     uint64_t frames_encoded;
     uint64_t samples_encoded;
@@ -564,15 +594,6 @@ typedef struct OutputStream {
 
     int max_muxing_queue_size;
 
-    /* the packets are buffered here until the muxer is ready to be initialized */
-    AVFifo *muxing_queue;
-
-    /*
-     * The size of the AVPackets' buffers in queue.
-     * Updated when a packet is either pushed or pulled from the queue.
-     */
-    size_t muxing_queue_data_size;
-
     /* Threshold after which max_muxing_queue_size will be in effect */
     size_t muxing_queue_data_threshold;
 
@@ -581,23 +602,30 @@ typedef struct OutputStream {
 
     /* frame encode sum of squared error values */
     int64_t error[4];
+
+    int sq_idx_encode;
+    int sq_idx_mux;
 } OutputStream;
 
+typedef struct Muxer Muxer;
+
 typedef struct OutputFile {
     int index;
 
+    Muxer                *mux;
     const AVOutputFormat *format;
+    const char           *url;
 
-    AVFormatContext *ctx;
-    AVDictionary *opts;
+    SyncQueue *sq_encode;
+    SyncQueue *sq_mux;
+
+    int nb_streams;
     int ost_index;       /* index of the first stream in output_streams */
     int64_t recording_time;  ///< desired length of the resulting file in microseconds == AV_TIME_BASE units
     int64_t start_time;      ///< start time in microseconds == AV_TIME_BASE units
-    uint64_t limit_filesize; /* filesize limit expressed in bytes */
 
     int shortest;
-
-    int header_written;
+    int bitexact;
 } OutputFile;
 
 extern InputStream **input_streams;
@@ -656,7 +684,6 @@ extern char *qsv_device;
 #endif
 extern HWDevice *filter_hw_device;
 
-extern int want_sdp;
 extern unsigned nb_output_dumped;
 extern int main_return_code;
 
@@ -669,8 +696,6 @@ void show_usage(void);
 void remove_avoptions(AVDictionary **a, AVDictionary *b);
 void assert_avoptions(AVDictionary *m);
 
-int guess_input_channel_layout(InputStream *ist);
-
 int configure_filtergraph(FilterGraph *fg);
 void check_filter_outputs(void);
 int filtergraph_is_simple(FilterGraph *fg);
@@ -696,12 +721,31 @@ int hw_device_setup_for_filter(FilterGraph *fg);
 
 int hwaccel_decode_init(AVCodecContext *avctx);
 
+int of_muxer_init(OutputFile *of, AVFormatContext *fc,
+                  AVDictionary *opts, int64_t limit_filesize,
+                  int thread_queue_size);
 /* open the muxer when all the streams are initialized */
 int of_check_init(OutputFile *of);
 int of_write_trailer(OutputFile *of);
 void of_close(OutputFile **pof);
 
-void of_write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost,
-                     int unqueue);
+int of_submit_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost);
+int64_t of_filesize(OutputFile *of);
+AVChapter * const *
+of_get_chapters(OutputFile *of, unsigned int *nb_chapters);
+
+/**
+ * Get next input packet from the demuxer.
+ *
+ * @param pkt the packet is written here when this function returns 0
+ * @return
+ * - 0 when a packet has been read successfully
+ * - 1 when stream end was reached, but the stream is looped;
+ *     caller should flush decoders and read from this demuxer again
+ * - a negative error code on failure
+ */
+int ifile_get_packet(InputFile *f, AVPacket **pkt);
+int init_input_threads(void);
+void free_input_threads(void);
 
 #endif /* FFTOOLS_FFMPEG_H */
diff --git a/fftools/ffmpeg_demux.c b/fftools/ffmpeg_demux.c
new file mode 100644
index 0000000..6dfb5bb
--- /dev/null
+++ b/fftools/ffmpeg_demux.c
@@ -0,0 +1,387 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "ffmpeg.h"
+
+#include "libavutil/avassert.h"
+#include "libavutil/error.h"
+#include "libavutil/time.h"
+#include "libavutil/timestamp.h"
+#include "libavutil/thread.h"
+#include "libavutil/threadmessage.h"
+
+#include "libavcodec/packet.h"
+
+#include "libavformat/avformat.h"
+
+typedef struct DemuxMsg {
+    AVPacket *pkt;
+    int looping;
+} DemuxMsg;
+
+static void report_new_stream(InputFile *file, const AVPacket *pkt)
+{
+    AVStream *st = file->ctx->streams[pkt->stream_index];
+
+    if (pkt->stream_index < file->nb_streams_warn)
+        return;
+    av_log(file->ctx, AV_LOG_WARNING,
+           "New %s stream %d:%d at pos:%"PRId64" and DTS:%ss\n",
+           av_get_media_type_string(st->codecpar->codec_type),
+           file->index, pkt->stream_index,
+           pkt->pos, av_ts2timestr(pkt->dts, &st->time_base));
+    file->nb_streams_warn = pkt->stream_index + 1;
+}
+
+static void ifile_duration_update(InputFile *f, InputStream *ist,
+                                  int64_t last_duration)
+{
+    /* the total duration of the stream, max_pts - min_pts is
+     * the duration of the stream without the last frame */
+    if (ist->max_pts > ist->min_pts &&
+        ist->max_pts - (uint64_t)ist->min_pts < INT64_MAX - last_duration)
+        last_duration += ist->max_pts - ist->min_pts;
+
+    if (!f->duration ||
+        av_compare_ts(f->duration, f->time_base,
+                      last_duration, ist->st->time_base) < 0) {
+        f->duration = last_duration;
+        f->time_base = ist->st->time_base;
+    }
+}
+
+static int seek_to_start(InputFile *ifile)
+{
+    AVFormatContext *is = ifile->ctx;
+    InputStream *ist;
+    int ret;
+
+    ret = avformat_seek_file(is, -1, INT64_MIN, is->start_time, is->start_time, 0);
+    if (ret < 0)
+        return ret;
+
+    if (ifile->audio_duration_queue_size) {
+        /* duration is the length of the last frame in a stream
+         * when audio stream is present we don't care about
+         * last video frame length because it's not defined exactly */
+        int got_durations = 0;
+
+        while (got_durations < ifile->audio_duration_queue_size) {
+            LastFrameDuration dur;
+            ret = av_thread_message_queue_recv(ifile->audio_duration_queue, &dur, 0);
+            if (ret < 0)
+                return ret;
+            got_durations++;
+
+            ist = input_streams[ifile->ist_index + dur.stream_idx];
+            ifile_duration_update(ifile, ist, dur.duration);
+        }
+    } else {
+        for (int i = 0; i < ifile->nb_streams; i++) {
+            int64_t duration = 0;
+            ist   = input_streams[ifile->ist_index + i];
+
+            if (ist->framerate.num) {
+                duration = av_rescale_q(1, av_inv_q(ist->framerate), ist->st->time_base);
+            } else if (ist->st->avg_frame_rate.num) {
+                duration = av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate), ist->st->time_base);
+            } else {
+                duration = 1;
+            }
+
+            ifile_duration_update(ifile, ist, duration);
+        }
+    }
+
+    if (ifile->loop > 0)
+        ifile->loop--;
+
+    return ret;
+}
+
+static void ts_fixup(InputFile *ifile, AVPacket *pkt)
+{
+    InputStream *ist = input_streams[ifile->ist_index + pkt->stream_index];
+    const int64_t start_time = ifile->ctx->start_time;
+    int64_t duration;
+
+    if (debug_ts) {
+        av_log(NULL, AV_LOG_INFO, "demuxer -> ist_index:%d type:%s "
+               "pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s\n",
+               ifile->ist_index + pkt->stream_index,
+               av_get_media_type_string(ist->st->codecpar->codec_type),
+               av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, &ist->st->time_base),
+               av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, &ist->st->time_base),
+               av_ts2str(pkt->duration), av_ts2timestr(pkt->duration, &ist->st->time_base));
+    }
+
+    if (!ist->wrap_correction_done && start_time != AV_NOPTS_VALUE &&
+        ist->st->pts_wrap_bits < 64) {
+        int64_t stime, stime2;
+
+        stime = av_rescale_q(start_time, AV_TIME_BASE_Q, ist->st->time_base);
+        stime2= stime + (1ULL<<ist->st->pts_wrap_bits);
+        ist->wrap_correction_done = 1;
+
+        if(stime2 > stime && pkt->dts != AV_NOPTS_VALUE && pkt->dts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {
+            pkt->dts -= 1ULL<<ist->st->pts_wrap_bits;
+            ist->wrap_correction_done = 0;
+        }
+        if(stime2 > stime && pkt->pts != AV_NOPTS_VALUE && pkt->pts > stime + (1LL<<(ist->st->pts_wrap_bits-1))) {
+            pkt->pts -= 1ULL<<ist->st->pts_wrap_bits;
+            ist->wrap_correction_done = 0;
+        }
+    }
+
+    if (pkt->dts != AV_NOPTS_VALUE)
+        pkt->dts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);
+    if (pkt->pts != AV_NOPTS_VALUE)
+        pkt->pts += av_rescale_q(ifile->ts_offset, AV_TIME_BASE_Q, ist->st->time_base);
+
+    if (pkt->pts != AV_NOPTS_VALUE)
+        pkt->pts *= ist->ts_scale;
+    if (pkt->dts != AV_NOPTS_VALUE)
+        pkt->dts *= ist->ts_scale;
+
+    duration = av_rescale_q(ifile->duration, ifile->time_base, ist->st->time_base);
+    if (pkt->pts != AV_NOPTS_VALUE) {
+        pkt->pts += duration;
+        ist->max_pts = FFMAX(pkt->pts, ist->max_pts);
+        ist->min_pts = FFMIN(pkt->pts, ist->min_pts);
+    }
+
+    if (pkt->dts != AV_NOPTS_VALUE)
+        pkt->dts += duration;
+}
+
+static void *input_thread(void *arg)
+{
+    InputFile *f = arg;
+    AVPacket *pkt;
+    unsigned flags = f->non_blocking ? AV_THREAD_MESSAGE_NONBLOCK : 0;
+    int ret = 0;
+
+    pkt = av_packet_alloc();
+    if (!pkt) {
+        ret = AVERROR(ENOMEM);
+        goto finish;
+    }
+
+    while (1) {
+        DemuxMsg msg = { NULL };
+
+        ret = av_read_frame(f->ctx, pkt);
+
+        if (ret == AVERROR(EAGAIN)) {
+            av_usleep(10000);
+            continue;
+        }
+        if (ret < 0) {
+            if (f->loop) {
+                /* signal looping to the consumer thread */
+                msg.looping = 1;
+                ret = av_thread_message_queue_send(f->in_thread_queue, &msg, 0);
+                if (ret >= 0)
+                    ret = seek_to_start(f);
+                if (ret >= 0)
+                    continue;
+
+                /* fallthrough to the error path */
+            }
+
+            break;
+        }
+
+        if (do_pkt_dump) {
+            av_pkt_dump_log2(NULL, AV_LOG_INFO, pkt, do_hex_dump,
+                             f->ctx->streams[pkt->stream_index]);
+        }
+
+        /* the following test is needed in case new streams appear
+           dynamically in stream : we ignore them */
+        if (pkt->stream_index >= f->nb_streams) {
+            report_new_stream(f, pkt);
+            av_packet_unref(pkt);
+            continue;
+        }
+
+        if (pkt->flags & AV_PKT_FLAG_CORRUPT) {
+            av_log(NULL, exit_on_error ? AV_LOG_FATAL : AV_LOG_WARNING,
+                   "%s: corrupt input packet in stream %d\n",
+                   f->ctx->url, pkt->stream_index);
+            if (exit_on_error) {
+                av_packet_unref(pkt);
+                ret = AVERROR_INVALIDDATA;
+                break;
+            }
+        }
+
+        ts_fixup(f, pkt);
+
+        msg.pkt = av_packet_alloc();
+        if (!msg.pkt) {
+            av_packet_unref(pkt);
+            ret = AVERROR(ENOMEM);
+            break;
+        }
+        av_packet_move_ref(msg.pkt, pkt);
+        ret = av_thread_message_queue_send(f->in_thread_queue, &msg, flags);
+        if (flags && ret == AVERROR(EAGAIN)) {
+            flags = 0;
+            ret = av_thread_message_queue_send(f->in_thread_queue, &msg, flags);
+            av_log(f->ctx, AV_LOG_WARNING,
+                   "Thread message queue blocking; consider raising the "
+                   "thread_queue_size option (current value: %d)\n",
+                   f->thread_queue_size);
+        }
+        if (ret < 0) {
+            if (ret != AVERROR_EOF)
+                av_log(f->ctx, AV_LOG_ERROR,
+                       "Unable to send packet to main thread: %s\n",
+                       av_err2str(ret));
+            av_packet_free(&msg.pkt);
+            break;
+        }
+    }
+
+finish:
+    av_assert0(ret < 0);
+    av_thread_message_queue_set_err_recv(f->in_thread_queue, ret);
+
+    av_packet_free(&pkt);
+
+    return NULL;
+}
+
+static void free_input_thread(int i)
+{
+    InputFile *f = input_files[i];
+    DemuxMsg msg;
+
+    if (!f || !f->in_thread_queue)
+        return;
+    av_thread_message_queue_set_err_send(f->in_thread_queue, AVERROR_EOF);
+    while (av_thread_message_queue_recv(f->in_thread_queue, &msg, 0) >= 0)
+        av_packet_free(&msg.pkt);
+
+    pthread_join(f->thread, NULL);
+    av_thread_message_queue_free(&f->in_thread_queue);
+    av_thread_message_queue_free(&f->audio_duration_queue);
+}
+
+void free_input_threads(void)
+{
+    int i;
+
+    for (i = 0; i < nb_input_files; i++)
+        free_input_thread(i);
+}
+
+static int init_input_thread(int i)
+{
+    int ret;
+    InputFile *f = input_files[i];
+
+    if (f->thread_queue_size <= 0)
+        f->thread_queue_size = (nb_input_files > 1 ? 8 : 1);
+
+    if (f->ctx->pb ? !f->ctx->pb->seekable :
+        strcmp(f->ctx->iformat->name, "lavfi"))
+        f->non_blocking = 1;
+    ret = av_thread_message_queue_alloc(&f->in_thread_queue,
+                                        f->thread_queue_size, sizeof(DemuxMsg));
+    if (ret < 0)
+        return ret;
+
+    if (f->loop) {
+        int nb_audio_dec = 0;
+
+        for (int i = 0; i < f->nb_streams; i++) {
+            InputStream *ist = input_streams[f->ist_index + i];
+            nb_audio_dec += !!(ist->decoding_needed &&
+                               ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO);
+        }
+
+        if (nb_audio_dec) {
+            ret = av_thread_message_queue_alloc(&f->audio_duration_queue,
+                                                nb_audio_dec, sizeof(LastFrameDuration));
+            if (ret < 0)
+                goto fail;
+            f->audio_duration_queue_size = nb_audio_dec;
+        }
+    }
+
+    if ((ret = pthread_create(&f->thread, NULL, input_thread, f))) {
+        av_log(NULL, AV_LOG_ERROR, "pthread_create failed: %s. Try to increase `ulimit -v` or decrease `ulimit -s`.\n", strerror(ret));
+        ret = AVERROR(ret);
+        goto fail;
+    }
+
+    return 0;
+fail:
+    av_thread_message_queue_free(&f->in_thread_queue);
+    return ret;
+}
+
+int init_input_threads(void)
+{
+    int i, ret;
+
+    for (i = 0; i < nb_input_files; i++) {
+        ret = init_input_thread(i);
+        if (ret < 0)
+            return ret;
+    }
+    return 0;
+}
+
+int ifile_get_packet(InputFile *f, AVPacket **pkt)
+{
+    DemuxMsg msg;
+    int ret;
+
+    if (f->readrate || f->rate_emu) {
+        int i;
+        int64_t file_start = copy_ts * (
+                              (f->ctx->start_time != AV_NOPTS_VALUE ? f->ctx->start_time * !start_at_zero : 0) +
+                              (f->start_time != AV_NOPTS_VALUE ? f->start_time : 0)
+                             );
+        float scale = f->rate_emu ? 1.0 : f->readrate;
+        for (i = 0; i < f->nb_streams; i++) {
+            InputStream *ist = input_streams[f->ist_index + i];
+            int64_t stream_ts_offset, pts, now;
+            if (!ist->nb_packets || (ist->decoding_needed && !ist->got_output)) continue;
+            stream_ts_offset = FFMAX(ist->first_dts != AV_NOPTS_VALUE ? ist->first_dts : 0, file_start);
+            pts = av_rescale(ist->dts, 1000000, AV_TIME_BASE);
+            now = (av_gettime_relative() - ist->start) * scale + stream_ts_offset;
+            if (pts > now)
+                return AVERROR(EAGAIN);
+        }
+    }
+
+    ret = av_thread_message_queue_recv(f->in_thread_queue, &msg,
+                                       f->non_blocking ?
+                                       AV_THREAD_MESSAGE_NONBLOCK : 0);
+    if (ret < 0)
+        return ret;
+    if (msg.looping)
+        return 1;
+
+    *pkt = msg.pkt;
+    return 0;
+}
diff --git a/fftools/ffmpeg_filter.c b/fftools/ffmpeg_filter.c
index 0845c63..f9ae76f 100644
--- a/fftools/ffmpeg_filter.c
+++ b/fftools/ffmpeg_filter.c
@@ -52,8 +52,9 @@ static const enum AVPixelFormat *get_compliance_normal_pix_fmts(const AVCodec *c
     }
 }
 
-static enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodecContext *enc_ctx,
-                                    const AVCodec *codec, enum AVPixelFormat target)
+static enum AVPixelFormat
+choose_pixel_fmt(const AVCodec *codec, enum AVPixelFormat target,
+                 int strict_std_compliance)
 {
     if (codec && codec->pix_fmts) {
         const enum AVPixelFormat *p = codec->pix_fmts;
@@ -62,7 +63,7 @@ static enum AVPixelFormat choose_pixel_fmt(AVStream *st, AVCodecContext *enc_ctx
         int has_alpha = desc ? desc->nb_components % 2 == 0 : 0;
         enum AVPixelFormat best= AV_PIX_FMT_NONE;
 
-        if (enc_ctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL) {
+        if (strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL) {
             p = get_compliance_normal_pix_fmts(codec, p);
         }
         for (; *p != AV_PIX_FMT_NONE; p++) {
@@ -102,7 +103,8 @@ static const char *choose_pix_fmts(OutputFilter *ofilter, AVBPrint *bprint)
         return av_get_pix_fmt_name(ost->enc_ctx->pix_fmt);
     }
     if (ost->enc_ctx->pix_fmt != AV_PIX_FMT_NONE) {
-        return av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc_ctx, ost->enc, ost->enc_ctx->pix_fmt));
+        return av_get_pix_fmt_name(choose_pixel_fmt(ost->enc, ost->enc_ctx->pix_fmt,
+                                                    ost->enc_ctx->strict_std_compliance));
     } else if (ost->enc && ost->enc->pix_fmts) {
         const enum AVPixelFormat *p;
 
@@ -558,6 +560,7 @@ static int configure_output_audio_filter(FilterGraph *fg, OutputFilter *ofilter,
     pad_idx = 0;                                                            \
 } while (0)
     av_bprint_init(&args, 0, AV_BPRINT_SIZE_UNLIMITED);
+#if FFMPEG_OPT_MAP_CHANNEL
     if (ost->audio_channels_mapped) {
         AVChannelLayout mapped_layout = { 0 };
         int i;
@@ -570,6 +573,7 @@ static int configure_output_audio_filter(FilterGraph *fg, OutputFilter *ofilter,
         AUTO_INSERT_FILTER("-map_channel", "pan", args.str);
         av_bprint_clear(&args);
     }
+#endif
 
     if (codec->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC)
         av_channel_layout_default(&codec->ch_layout, codec->ch_layout.nb_channels);
@@ -603,11 +607,11 @@ static int configure_output_audio_filter(FilterGraph *fg, OutputFilter *ofilter,
     if (ost->apad && of->shortest) {
         int i;
 
-        for (i=0; i<of->ctx->nb_streams; i++)
-            if (of->ctx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+        for (i = 0; i < of->nb_streams; i++)
+            if (output_streams[of->ost_index + i]->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
                 break;
 
-        if (i<of->ctx->nb_streams) {
+        if (i < of->nb_streams) {
             AUTO_INSERT_FILTER("-apad", "apad", ost->apad);
         }
     }
@@ -898,29 +902,6 @@ static int configure_input_audio_filter(FilterGraph *fg, InputFilter *ifilter,
         AUTO_INSERT_FILTER_INPUT("-async", "aresample", args);
     }
 
-//     if (ost->audio_channels_mapped) {
-//         int i;
-//         AVBPrint pan_buf;
-//         av_bprint_init(&pan_buf, 256, 8192);
-//         av_bprintf(&pan_buf, "0x%"PRIx64,
-//                    av_get_default_channel_layout(ost->audio_channels_mapped));
-//         for (i = 0; i < ost->audio_channels_mapped; i++)
-//             if (ost->audio_channels_map[i] != -1)
-//                 av_bprintf(&pan_buf, ":c%d=c%d", i, ost->audio_channels_map[i]);
-//         AUTO_INSERT_FILTER_INPUT("-map_channel", "pan", pan_buf.str);
-//         av_bprint_finalize(&pan_buf, NULL);
-//     }
-
-    if (audio_volume != 256) {
-        char args[256];
-
-        av_log(NULL, AV_LOG_WARNING, "-vol has been deprecated. Use the volume "
-               "audio filter instead.\n");
-
-        snprintf(args, sizeof(args), "%f", audio_volume / 256.);
-        AUTO_INSERT_FILTER_INPUT("-vol", "volume", args);
-    }
-
     snprintf(name, sizeof(name), "trim for input stream %d:%d",
              ist->file_index, ist->st->index);
     if (copy_ts) {
diff --git a/fftools/ffmpeg_hw.c b/fftools/ffmpeg_hw.c
index 14e702b..8acfeaf 100644
--- a/fftools/ffmpeg_hw.c
+++ b/fftools/ffmpeg_hw.c
@@ -339,7 +339,7 @@ int hw_device_setup_for_decode(InputStream *ist)
             if (ist->hwaccel_id == HWACCEL_AUTO) {
                 ist->hwaccel_device_type = dev->type;
             } else if (ist->hwaccel_device_type != dev->type) {
-                av_log(ist->dec_ctx, AV_LOG_ERROR, "Invalid hwaccel device "
+                av_log(NULL, AV_LOG_ERROR, "Invalid hwaccel device "
                        "specified for decoder: device %s of type %s is not "
                        "usable with hwaccel %s.\n", dev->name,
                        av_hwdevice_get_type_name(dev->type),
@@ -390,7 +390,7 @@ int hw_device_setup_for_decode(InputStream *ist)
             type = config->device_type;
             dev = hw_device_get_by_type(type);
             if (dev) {
-                av_log(ist->dec_ctx, AV_LOG_INFO, "Using auto "
+                av_log(NULL, AV_LOG_INFO, "Using auto "
                        "hwaccel type %s with existing device %s.\n",
                        av_hwdevice_get_type_name(type), dev->name);
             }
@@ -408,12 +408,12 @@ int hw_device_setup_for_decode(InputStream *ist)
                 continue;
             }
             if (ist->hwaccel_device) {
-                av_log(ist->dec_ctx, AV_LOG_INFO, "Using auto "
+                av_log(NULL, AV_LOG_INFO, "Using auto "
                        "hwaccel type %s with new device created "
                        "from %s.\n", av_hwdevice_get_type_name(type),
                        ist->hwaccel_device);
             } else {
-                av_log(ist->dec_ctx, AV_LOG_INFO, "Using auto "
+                av_log(NULL, AV_LOG_INFO, "Using auto "
                        "hwaccel type %s with new default device.\n",
                        av_hwdevice_get_type_name(type));
             }
@@ -421,7 +421,7 @@ int hw_device_setup_for_decode(InputStream *ist)
         if (dev) {
             ist->hwaccel_device_type = type;
         } else {
-            av_log(ist->dec_ctx, AV_LOG_INFO, "Auto hwaccel "
+            av_log(NULL, AV_LOG_INFO, "Auto hwaccel "
                    "disabled: no device found.\n");
             ist->hwaccel_id = HWACCEL_NONE;
             return 0;
@@ -429,7 +429,7 @@ int hw_device_setup_for_decode(InputStream *ist)
     }
 
     if (!dev) {
-        av_log(ist->dec_ctx, AV_LOG_ERROR, "No device available "
+        av_log(NULL, AV_LOG_ERROR, "No device available "
                "for decoder: device type %s needed for codec %s.\n",
                av_hwdevice_get_type_name(type), ist->dec->name);
         return err;
diff --git a/fftools/ffmpeg_mux.c b/fftools/ffmpeg_mux.c
index a55fd18..b424ef0 100644
--- a/fftools/ffmpeg_mux.c
+++ b/fftools/ffmpeg_mux.c
@@ -16,84 +16,90 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#include <stdatomic.h>
 #include <stdio.h>
 #include <string.h>
 
 #include "ffmpeg.h"
+#include "objpool.h"
+#include "sync_queue.h"
+#include "thread_queue.h"
 
 #include "libavutil/fifo.h"
 #include "libavutil/intreadwrite.h"
 #include "libavutil/log.h"
 #include "libavutil/mem.h"
 #include "libavutil/timestamp.h"
+#include "libavutil/thread.h"
 
 #include "libavcodec/packet.h"
 
 #include "libavformat/avformat.h"
 #include "libavformat/avio.h"
 
-static void close_all_output_streams(OutputStream *ost, OSTFinished this_stream, OSTFinished others)
+typedef struct MuxStream {
+    /* the packets are buffered here until the muxer is ready to be initialized */
+    AVFifo *muxing_queue;
+
+    /*
+     * The size of the AVPackets' buffers in queue.
+     * Updated when a packet is either pushed or pulled from the queue.
+     */
+    size_t muxing_queue_data_size;
+
+    /* dts of the last packet sent to the muxer, in the stream timebase
+     * used for making up missing dts values */
+    int64_t last_mux_dts;
+} MuxStream;
+
+struct Muxer {
+    AVFormatContext *fc;
+
+    pthread_t    thread;
+    ThreadQueue *tq;
+
+    MuxStream *streams;
+
+    AVDictionary *opts;
+
+    int thread_queue_size;
+
+    /* filesize limit expressed in bytes */
+    int64_t limit_filesize;
+    atomic_int_least64_t last_filesize;
+    int header_written;
+
+    AVPacket *sq_pkt;
+};
+
+static int want_sdp = 1;
+
+static int64_t filesize(AVIOContext *pb)
 {
-    int i;
-    for (i = 0; i < nb_output_streams; i++) {
-        OutputStream *ost2 = output_streams[i];
-        ost2->finished |= ost == ost2 ? this_stream : others;
+    int64_t ret = -1;
+
+    if (pb) {
+        ret = avio_size(pb);
+        if (ret <= 0) // FIXME improve avio_size() so it works with non seekable output too
+            ret = avio_tell(pb);
     }
+
+    return ret;
 }
 
-void of_write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost,
-                     int unqueue)
+static int write_packet(OutputFile *of, OutputStream *ost, AVPacket *pkt)
 {
-    AVFormatContext *s = of->ctx;
+    MuxStream *ms = &of->mux->streams[ost->index];
+    AVFormatContext *s = of->mux->fc;
     AVStream *st = ost->st;
+    int64_t fs;
     int ret;
 
-    /*
-     * Audio encoders may split the packets --  #frames in != #packets out.
-     * But there is no reordering, so we can limit the number of output packets
-     * by simply dropping them here.
-     * Counting encoded video frames needs to be done separately because of
-     * reordering, see do_video_out().
-     * Do not count the packet when unqueued because it has been counted when queued.
-     */
-    if (!(st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->encoding_needed) && !unqueue) {
-        if (ost->frame_number >= ost->max_frames) {
-            av_packet_unref(pkt);
-            return;
-        }
-        ost->frame_number++;
-    }
-
-    if (!of->header_written) {
-        AVPacket *tmp_pkt;
-        /* the muxer is not initialized yet, buffer the packet */
-        if (!av_fifo_can_write(ost->muxing_queue)) {
-            size_t cur_size = av_fifo_can_read(ost->muxing_queue);
-            unsigned int are_we_over_size =
-                (ost->muxing_queue_data_size + pkt->size) > ost->muxing_queue_data_threshold;
-            size_t limit    = are_we_over_size ? ost->max_muxing_queue_size : SIZE_MAX;
-            size_t new_size = FFMIN(2 * cur_size, limit);
-
-            if (new_size <= cur_size) {
-                av_log(NULL, AV_LOG_ERROR,
-                       "Too many packets buffered for output stream %d:%d.\n",
-                       ost->file_index, ost->st->index);
-                exit_program(1);
-            }
-            ret = av_fifo_grow2(ost->muxing_queue, new_size - cur_size);
-            if (ret < 0)
-                exit_program(1);
-        }
-        ret = av_packet_make_refcounted(pkt);
-        if (ret < 0)
-            exit_program(1);
-        tmp_pkt = av_packet_alloc();
-        if (!tmp_pkt)
-            exit_program(1);
-        av_packet_move_ref(tmp_pkt, pkt);
-        ost->muxing_queue_data_size += tmp_pkt->size;
-        av_fifo_write(ost->muxing_queue, &tmp_pkt, 1);
-        return;
+    fs = filesize(s->pb);
+    atomic_store(&of->mux->last_filesize, fs);
+    if (fs >= of->mux->limit_filesize) {
+        ret = AVERROR_EOF;
+        goto fail;
     }
 
     if ((st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO && ost->vsync_method == VSYNC_DROP) ||
@@ -119,25 +125,26 @@ void of_write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost,
                    pkt->dts, pkt->pts,
                    ost->file_index, ost->st->index);
             pkt->pts =
-            pkt->dts = pkt->pts + pkt->dts + ost->last_mux_dts + 1
-                     - FFMIN3(pkt->pts, pkt->dts, ost->last_mux_dts + 1)
-                     - FFMAX3(pkt->pts, pkt->dts, ost->last_mux_dts + 1);
+            pkt->dts = pkt->pts + pkt->dts + ms->last_mux_dts + 1
+                     - FFMIN3(pkt->pts, pkt->dts, ms->last_mux_dts + 1)
+                     - FFMAX3(pkt->pts, pkt->dts, ms->last_mux_dts + 1);
         }
         if ((st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO || st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO || st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) &&
             pkt->dts != AV_NOPTS_VALUE &&
-            ost->last_mux_dts != AV_NOPTS_VALUE) {
-            int64_t max = ost->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);
+            ms->last_mux_dts != AV_NOPTS_VALUE) {
+            int64_t max = ms->last_mux_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);
             if (pkt->dts < max) {
                 int loglevel = max - pkt->dts > 2 || st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO ? AV_LOG_WARNING : AV_LOG_DEBUG;
                 if (exit_on_error)
                     loglevel = AV_LOG_ERROR;
                 av_log(s, loglevel, "Non-monotonous DTS in output stream "
                        "%d:%d; previous: %"PRId64", current: %"PRId64"; ",
-                       ost->file_index, ost->st->index, ost->last_mux_dts, pkt->dts);
+                       ost->file_index, ost->st->index, ms->last_mux_dts, pkt->dts);
                 if (exit_on_error) {
-                    av_log(NULL, AV_LOG_FATAL, "aborting.\n");
-                    exit_program(1);
+                    ret = AVERROR(EINVAL);
+                    goto fail;
                 }
+
                 av_log(s, loglevel, "changing to %"PRId64". This may result "
                        "in incorrect timestamps in the output file.\n",
                        max);
@@ -147,17 +154,17 @@ void of_write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost,
             }
         }
     }
-    ost->last_mux_dts = pkt->dts;
+    ms->last_mux_dts = pkt->dts;
 
     ost->data_size += pkt->size;
-    ost->packets_written++;
+    atomic_fetch_add(&ost->packets_written, 1);
 
     pkt->stream_index = ost->index;
 
     if (debug_ts) {
         av_log(NULL, AV_LOG_INFO, "muxer <- type:%s "
                 "pkt_pts:%s pkt_pts_time:%s pkt_dts:%s pkt_dts_time:%s duration:%s duration_time:%s size:%d\n",
-                av_get_media_type_string(ost->enc_ctx->codec_type),
+                av_get_media_type_string(st->codecpar->codec_type),
                 av_ts2str(pkt->pts), av_ts2timestr(pkt->pts, &ost->st->time_base),
                 av_ts2str(pkt->dts), av_ts2timestr(pkt->dts, &ost->st->time_base),
                 av_ts2str(pkt->duration), av_ts2timestr(pkt->duration, &ost->st->time_base),
@@ -168,9 +175,237 @@ void of_write_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost,
     ret = av_interleaved_write_frame(s, pkt);
     if (ret < 0) {
         print_error("av_interleaved_write_frame()", ret);
-        main_return_code = 1;
-        close_all_output_streams(ost, MUXER_FINISHED | ENCODER_FINISHED, ENCODER_FINISHED);
+        goto fail;
+    }
+
+    return 0;
+fail:
+    av_packet_unref(pkt);
+    return ret;
+}
+
+static int sync_queue_process(OutputFile *of, OutputStream *ost, AVPacket *pkt)
+{
+    if (ost->sq_idx_mux >= 0) {
+        int ret = sq_send(of->sq_mux, ost->sq_idx_mux, SQPKT(pkt));
+        if (ret < 0)
+            return ret;
+
+        while (1) {
+            ret = sq_receive(of->sq_mux, -1, SQPKT(of->mux->sq_pkt));
+            if (ret < 0)
+                return (ret == AVERROR_EOF || ret == AVERROR(EAGAIN)) ? 0 : ret;
+
+            ret = write_packet(of, output_streams[of->ost_index + ret],
+                               of->mux->sq_pkt);
+            if (ret < 0)
+                return ret;
+        }
+    } else if (pkt)
+        return write_packet(of, ost, pkt);
+
+    return 0;
+}
+
+static void *muxer_thread(void *arg)
+{
+    OutputFile *of = arg;
+    Muxer     *mux = of->mux;
+    AVPacket  *pkt = NULL;
+    int        ret = 0;
+
+    pkt = av_packet_alloc();
+    if (!pkt) {
+        ret = AVERROR(ENOMEM);
+        goto finish;
+    }
+
+    while (1) {
+        OutputStream *ost;
+        int stream_idx;
+
+        ret = tq_receive(mux->tq, &stream_idx, pkt);
+        if (stream_idx < 0) {
+            av_log(NULL, AV_LOG_VERBOSE,
+                   "All streams finished for output file #%d\n", of->index);
+            ret = 0;
+            break;
+        }
+
+        ost = output_streams[of->ost_index + stream_idx];
+        ret = sync_queue_process(of, ost, ret < 0 ? NULL : pkt);
+        av_packet_unref(pkt);
+        if (ret == AVERROR_EOF)
+            tq_receive_finish(mux->tq, stream_idx);
+        else if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR,
+                   "Error muxing a packet for output file #%d\n", of->index);
+            break;
+        }
+    }
+
+finish:
+    av_packet_free(&pkt);
+
+    for (unsigned int i = 0; i < mux->fc->nb_streams; i++)
+        tq_receive_finish(mux->tq, i);
+
+    av_log(NULL, AV_LOG_VERBOSE, "Terminating muxer thread %d\n", of->index);
+
+    return (void*)(intptr_t)ret;
+}
+
+static int submit_packet(OutputFile *of, OutputStream *ost, AVPacket *pkt)
+{
+    Muxer *mux = of->mux;
+    int ret = 0;
+
+    if (!pkt || ost->finished & MUXER_FINISHED)
+        goto finish;
+
+    ret = tq_send(mux->tq, ost->index, pkt);
+    if (ret < 0)
+        goto finish;
+
+    return 0;
+
+finish:
+    if (pkt)
+        av_packet_unref(pkt);
+
+    ost->finished |= MUXER_FINISHED;
+    tq_send_finish(mux->tq, ost->index);
+    return ret == AVERROR_EOF ? 0 : ret;
+}
+
+static int queue_packet(OutputFile *of, OutputStream *ost, AVPacket *pkt)
+{
+    MuxStream *ms = &of->mux->streams[ost->index];
+    AVPacket *tmp_pkt = NULL;
+    int ret;
+
+    if (!av_fifo_can_write(ms->muxing_queue)) {
+        size_t cur_size = av_fifo_can_read(ms->muxing_queue);
+        size_t pkt_size = pkt ? pkt->size : 0;
+        unsigned int are_we_over_size =
+            (ms->muxing_queue_data_size + pkt_size) > ost->muxing_queue_data_threshold;
+        size_t limit    = are_we_over_size ? ost->max_muxing_queue_size : SIZE_MAX;
+        size_t new_size = FFMIN(2 * cur_size, limit);
+
+        if (new_size <= cur_size) {
+            av_log(NULL, AV_LOG_ERROR,
+                   "Too many packets buffered for output stream %d:%d.\n",
+                   ost->file_index, ost->st->index);
+            return AVERROR(ENOSPC);
+        }
+        ret = av_fifo_grow2(ms->muxing_queue, new_size - cur_size);
+        if (ret < 0)
+            return ret;
+    }
+
+    if (pkt) {
+        ret = av_packet_make_refcounted(pkt);
+        if (ret < 0)
+            return ret;
+
+        tmp_pkt = av_packet_alloc();
+        if (!tmp_pkt)
+            return AVERROR(ENOMEM);
+
+        av_packet_move_ref(tmp_pkt, pkt);
+        ms->muxing_queue_data_size += tmp_pkt->size;
+    }
+    av_fifo_write(ms->muxing_queue, &tmp_pkt, 1);
+
+    return 0;
+}
+
+int of_submit_packet(OutputFile *of, AVPacket *pkt, OutputStream *ost)
+{
+    int ret;
+
+    if (of->mux->tq) {
+        return submit_packet(of, ost, pkt);
+    } else {
+        /* the muxer is not initialized yet, buffer the packet */
+        ret = queue_packet(of, ost, pkt);
+        if (ret < 0) {
+            av_packet_unref(pkt);
+            return ret;
+        }
+    }
+
+    return 0;
+}
+
+static int thread_stop(OutputFile *of)
+{
+    Muxer *mux = of->mux;
+    void *ret;
+
+    if (!mux || !mux->tq)
+        return 0;
+
+    for (unsigned int i = 0; i < mux->fc->nb_streams; i++)
+        tq_send_finish(mux->tq, i);
+
+    pthread_join(mux->thread, &ret);
+
+    tq_free(&mux->tq);
+
+    return (int)(intptr_t)ret;
+}
+
+static void pkt_move(void *dst, void *src)
+{
+    av_packet_move_ref(dst, src);
+}
+
+static int thread_start(OutputFile *of)
+{
+    Muxer          *mux = of->mux;
+    AVFormatContext *fc = mux->fc;
+    ObjPool *op;
+    int ret;
+
+    op = objpool_alloc_packets();
+    if (!op)
+        return AVERROR(ENOMEM);
+
+    mux->tq = tq_alloc(fc->nb_streams, mux->thread_queue_size, op, pkt_move);
+    if (!mux->tq) {
+        objpool_free(&op);
+        return AVERROR(ENOMEM);
+    }
+
+    ret = pthread_create(&mux->thread, NULL, muxer_thread, (void*)of);
+    if (ret) {
+        tq_free(&mux->tq);
+        return AVERROR(ret);
     }
+
+    /* flush the muxing queues */
+    for (int i = 0; i < fc->nb_streams; i++) {
+        MuxStream     *ms = &of->mux->streams[i];
+        OutputStream *ost = output_streams[of->ost_index + i];
+        AVPacket *pkt;
+
+        /* try to improve muxing time_base (only possible if nothing has been written yet) */
+        if (!av_fifo_can_read(ms->muxing_queue))
+            ost->mux_timebase = ost->st->time_base;
+
+        while (av_fifo_read(ms->muxing_queue, &pkt, 1) >= 0) {
+            ret = submit_packet(of, ost, pkt);
+            if (pkt) {
+                ms->muxing_queue_data_size -= pkt->size;
+                av_packet_free(&pkt);
+            }
+            if (ret < 0)
+                return ret;
+        }
+    }
+
+    return 0;
 }
 
 static int print_sdp(void)
@@ -182,16 +417,16 @@ static int print_sdp(void)
     AVFormatContext **avc;
 
     for (i = 0; i < nb_output_files; i++) {
-        if (!output_files[i]->header_written)
+        if (!output_files[i]->mux->header_written)
             return 0;
     }
 
     avc = av_malloc_array(nb_output_files, sizeof(*avc));
     if (!avc)
-        exit_program(1);
+        return AVERROR(ENOMEM);
     for (i = 0, j = 0; i < nb_output_files; i++) {
-        if (!strcmp(output_files[i]->ctx->oformat->name, "rtp")) {
-            avc[j] = output_files[i]->ctx;
+        if (!strcmp(output_files[i]->format->name, "rtp")) {
+            avc[j] = output_files[i]->mux->fc;
             j++;
         }
     }
@@ -221,6 +456,9 @@ static int print_sdp(void)
         av_freep(&sdp_filename);
     }
 
+    // SDP successfully written, allow muxer threads to start
+    ret = 1;
+
 fail:
     av_freep(&avc);
     return ret;
@@ -229,15 +467,16 @@ fail:
 /* open the muxer when all the streams are initialized */
 int of_check_init(OutputFile *of)
 {
+    AVFormatContext *fc = of->mux->fc;
     int ret, i;
 
-    for (i = 0; i < of->ctx->nb_streams; i++) {
+    for (i = 0; i < fc->nb_streams; i++) {
         OutputStream *ost = output_streams[of->ost_index + i];
         if (!ost->initialized)
             return 0;
     }
 
-    ret = avformat_write_header(of->ctx, &of->opts);
+    ret = avformat_write_header(fc, &of->mux->opts);
     if (ret < 0) {
         av_log(NULL, AV_LOG_ERROR,
                "Could not write header for output file #%d "
@@ -246,9 +485,9 @@ int of_check_init(OutputFile *of)
         return ret;
     }
     //assert_avoptions(of->opts);
-    of->header_written = 1;
+    of->mux->header_written = 1;
 
-    av_dump_format(of->ctx, of->index, of->ctx->url, 1);
+    av_dump_format(fc, of->index, fc->url, 1);
     nb_output_dumped++;
 
     if (sdp_filename || want_sdp) {
@@ -256,23 +495,19 @@ int of_check_init(OutputFile *of)
         if (ret < 0) {
             av_log(NULL, AV_LOG_ERROR, "Error writing the SDP.\n");
             return ret;
+        } else if (ret == 1) {
+            /* SDP is written only after all the muxers are ready, so now we
+             * start ALL the threads */
+            for (i = 0; i < nb_output_files; i++) {
+                ret = thread_start(output_files[i]);
+                if (ret < 0)
+                    return ret;
+            }
         }
-    }
-
-    /* flush the muxing queues */
-    for (i = 0; i < of->ctx->nb_streams; i++) {
-        OutputStream *ost = output_streams[of->ost_index + i];
-        AVPacket *pkt;
-
-        /* try to improve muxing time_base (only possible if nothing has been written yet) */
-        if (!av_fifo_can_read(ost->muxing_queue))
-            ost->mux_timebase = ost->st->time_base;
-
-        while (av_fifo_read(ost->muxing_queue, &pkt, 1) >= 0) {
-            ost->muxing_queue_data_size -= pkt->size;
-            of_write_packet(of, pkt, ost, 1);
-            av_packet_free(&pkt);
-        }
+    } else {
+        ret = thread_start(of);
+        if (ret < 0)
+            return ret;
     }
 
     return 0;
@@ -280,38 +515,169 @@ int of_check_init(OutputFile *of)
 
 int of_write_trailer(OutputFile *of)
 {
+    AVFormatContext *fc = of->mux->fc;
     int ret;
 
-    if (!of->header_written) {
+    if (!of->mux->tq) {
         av_log(NULL, AV_LOG_ERROR,
                "Nothing was written into output file %d (%s), because "
                "at least one of its streams received no packets.\n",
-               of->index, of->ctx->url);
+               of->index, fc->url);
         return AVERROR(EINVAL);
     }
 
-    ret = av_write_trailer(of->ctx);
+    ret = thread_stop(of);
+    if (ret < 0)
+        main_return_code = ret;
+
+    ret = av_write_trailer(fc);
     if (ret < 0) {
-        av_log(NULL, AV_LOG_ERROR, "Error writing trailer of %s: %s\n", of->ctx->url, av_err2str(ret));
+        av_log(NULL, AV_LOG_ERROR, "Error writing trailer of %s: %s\n", fc->url, av_err2str(ret));
         return ret;
     }
 
+    of->mux->last_filesize = filesize(fc->pb);
+
+    if (!(of->format->flags & AVFMT_NOFILE)) {
+        ret = avio_closep(&fc->pb);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "Error closing file %s: %s\n",
+                   fc->url, av_err2str(ret));
+            return ret;
+        }
+    }
+
     return 0;
 }
 
+static void fc_close(AVFormatContext **pfc)
+{
+    AVFormatContext *fc = *pfc;
+
+    if (!fc)
+        return;
+
+    if (!(fc->oformat->flags & AVFMT_NOFILE))
+        avio_closep(&fc->pb);
+    avformat_free_context(fc);
+
+    *pfc = NULL;
+}
+
+static void mux_free(Muxer **pmux)
+{
+    Muxer *mux = *pmux;
+
+    if (!mux)
+        return;
+
+    for (int i = 0; i < mux->fc->nb_streams; i++) {
+        MuxStream *ms = &mux->streams[i];
+        AVPacket *pkt;
+
+        if (!ms->muxing_queue)
+            continue;
+
+        while (av_fifo_read(ms->muxing_queue, &pkt, 1) >= 0)
+            av_packet_free(&pkt);
+        av_fifo_freep2(&ms->muxing_queue);
+    }
+    av_freep(&mux->streams);
+    av_dict_free(&mux->opts);
+
+    av_packet_free(&mux->sq_pkt);
+
+    fc_close(&mux->fc);
+
+    av_freep(pmux);
+}
+
 void of_close(OutputFile **pof)
 {
     OutputFile *of = *pof;
-    AVFormatContext *s;
 
     if (!of)
         return;
 
-    s = of->ctx;
-    if (s && s->oformat && !(s->oformat->flags & AVFMT_NOFILE))
-        avio_closep(&s->pb);
-    avformat_free_context(s);
-    av_dict_free(&of->opts);
+    thread_stop(of);
+
+    sq_free(&of->sq_encode);
+    sq_free(&of->sq_mux);
+
+    mux_free(&of->mux);
 
     av_freep(pof);
 }
+
+int of_muxer_init(OutputFile *of, AVFormatContext *fc,
+                  AVDictionary *opts, int64_t limit_filesize,
+                  int thread_queue_size)
+{
+    Muxer *mux = av_mallocz(sizeof(*mux));
+    int ret = 0;
+
+    if (!mux) {
+        fc_close(&fc);
+        return AVERROR(ENOMEM);
+    }
+
+    mux->streams = av_calloc(fc->nb_streams, sizeof(*mux->streams));
+    if (!mux->streams) {
+        fc_close(&fc);
+        av_freep(&mux);
+        return AVERROR(ENOMEM);
+    }
+
+    of->mux  = mux;
+    mux->fc  = fc;
+
+    for (int i = 0; i < fc->nb_streams; i++) {
+        MuxStream *ms = &mux->streams[i];
+        ms->muxing_queue = av_fifo_alloc2(8, sizeof(AVPacket*), 0);
+        if (!ms->muxing_queue) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        ms->last_mux_dts = AV_NOPTS_VALUE;
+    }
+
+    mux->thread_queue_size = thread_queue_size > 0 ? thread_queue_size : 8;
+    mux->limit_filesize = limit_filesize;
+    mux->opts           = opts;
+
+    if (strcmp(of->format->name, "rtp"))
+        want_sdp = 0;
+
+    if (of->sq_mux) {
+        mux->sq_pkt = av_packet_alloc();
+        if (!mux->sq_pkt) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+    }
+
+    /* write the header for files with no streams */
+    if (of->format->flags & AVFMT_NOSTREAMS && fc->nb_streams == 0) {
+        ret = of_check_init(of);
+        if (ret < 0)
+            goto fail;
+    }
+
+fail:
+    if (ret < 0)
+        mux_free(&of->mux);
+
+    return ret;
+}
+
+int64_t of_filesize(OutputFile *of)
+{
+    return atomic_load(&of->mux->last_filesize);
+}
+
+AVChapter * const *
+of_get_chapters(OutputFile *of, unsigned int *nb_chapters)
+{
+    *nb_chapters = of->mux->fc->nb_chapters;
+    return of->mux->fc->chapters;
+}
diff --git a/fftools/ffmpeg_opt.c b/fftools/ffmpeg_opt.c
index 6e18a4a..30ca5cd 100644
--- a/fftools/ffmpeg_opt.c
+++ b/fftools/ffmpeg_opt.c
@@ -31,6 +31,7 @@
 #include "fopen_utf8.h"
 #include "cmdutils.h"
 #include "opt_common.h"
+#include "sync_queue.h"
 
 #include "libavformat/avformat.h"
 
@@ -156,7 +157,6 @@ float audio_drift_threshold = 0.1;
 float dts_delta_threshold   = 10;
 float dts_error_threshold   = 3600*30;
 
-int audio_volume      = 256;
 int audio_sync_method = 0;
 enum VideoSyncMethod video_sync_method = VSYNC_AUTO;
 float frame_drop_threshold = 0;
@@ -183,7 +183,9 @@ int64_t stats_period = 500000;
 
 static int file_overwrite     = 0;
 static int no_file_overwrite  = 0;
+#if FFMPEG_OPT_PSNR
 static int do_psnr            = 0;
+#endif
 static int input_stream_potentially_available = 0;
 static int ignore_unknown_streams = 0;
 static int copy_unknown_streams = 0;
@@ -217,7 +219,9 @@ static void uninit_options(OptionsContext *o)
     for (i = 0; i < o->nb_stream_maps; i++)
         av_freep(&o->stream_maps[i].linklabel);
     av_freep(&o->stream_maps);
+#if FFMPEG_OPT_MAP_CHANNEL
     av_freep(&o->audio_channel_maps);
+#endif
     av_freep(&o->streamid_map);
     av_freep(&o->attachments);
 }
@@ -231,11 +235,12 @@ static void init_options(OptionsContext *o)
     o->start_time     = AV_NOPTS_VALUE;
     o->start_time_eof = AV_NOPTS_VALUE;
     o->recording_time = INT64_MAX;
-    o->limit_filesize = UINT64_MAX;
+    o->limit_filesize = INT64_MAX;
     o->chapters_input_file = INT_MAX;
     o->accurate_seek  = 1;
     o->thread_queue_size = -1;
     o->input_sync_ref = -1;
+    o->shortest_buf_duration = 10.f;
 }
 
 static int show_hwaccels(void *optctx, const char *opt, const char *arg)
@@ -410,9 +415,10 @@ static int opt_map(void *optctx, const char *opt, const char *arg)
     OptionsContext *o = optctx;
     StreamMap *m = NULL;
     int i, negative = 0, file_idx, disabled = 0;
-    int sync_file_idx = -1, sync_stream_idx = 0;
-    char *p, *sync;
-    char *map;
+#if FFMPEG_OPT_MAP_SYNC
+    char *sync;
+#endif
+    char *map, *p;
     char *allow_unused;
 
     if (*arg == '-') {
@@ -423,33 +429,13 @@ static int opt_map(void *optctx, const char *opt, const char *arg)
     if (!map)
         return AVERROR(ENOMEM);
 
+#if FFMPEG_OPT_MAP_SYNC
     /* parse sync stream first, just pick first matching stream */
     if (sync = strchr(map, ',')) {
         *sync = 0;
-        sync_file_idx = strtol(sync + 1, &sync, 0);
-        if (sync_file_idx >= nb_input_files || sync_file_idx < 0) {
-            av_log(NULL, AV_LOG_FATAL, "Invalid sync file index: %d.\n", sync_file_idx);
-            exit_program(1);
-        }
-        if (*sync)
-            sync++;
-        for (i = 0; i < input_files[sync_file_idx]->nb_streams; i++)
-            if (check_stream_specifier(input_files[sync_file_idx]->ctx,
-                                       input_files[sync_file_idx]->ctx->streams[i], sync) == 1) {
-                sync_stream_idx = i;
-                break;
-            }
-        if (i == input_files[sync_file_idx]->nb_streams) {
-            av_log(NULL, AV_LOG_FATAL, "Sync stream specification in map %s does not "
-                                       "match any streams.\n", arg);
-            exit_program(1);
-        }
-        if (input_streams[input_files[sync_file_idx]->ist_index + sync_stream_idx]->user_set_discard == AVDISCARD_ALL) {
-            av_log(NULL, AV_LOG_FATAL, "Sync stream specification in map %s matches a disabled input "
-                                       "stream.\n", arg);
-            exit_program(1);
-        }
+        av_log(NULL, AV_LOG_WARNING, "Specifying a sync stream is deprecated and has no effect\n");
     }
+#endif
 
 
     if (map[0] == '[') {
@@ -494,14 +480,6 @@ static int opt_map(void *optctx, const char *opt, const char *arg)
 
                 m->file_index   = file_idx;
                 m->stream_index = i;
-
-                if (sync_file_idx >= 0) {
-                    m->sync_file_index   = sync_file_idx;
-                    m->sync_stream_index = sync_stream_idx;
-                } else {
-                    m->sync_file_index   = file_idx;
-                    m->sync_stream_index = i;
-                }
             }
     }
 
@@ -531,6 +509,7 @@ static int opt_attach(void *optctx, const char *opt, const char *arg)
     return 0;
 }
 
+#if FFMPEG_OPT_MAP_CHANNEL
 static int opt_map_channel(void *optctx, const char *opt, const char *arg)
 {
     OptionsContext *o = optctx;
@@ -539,6 +518,12 @@ static int opt_map_channel(void *optctx, const char *opt, const char *arg)
     AudioChannelMap *m;
     char *allow_unused;
     char *mapchan;
+
+    av_log(NULL, AV_LOG_WARNING,
+           "The -%s option is deprecated and will be removed. "
+           "It can be replaced by the 'pan' filter, or in some cases by "
+           "combinations of 'channelsplit', 'channelmap', 'amerge' filters.\n", opt);
+
     mapchan = av_strdup(arg);
     if (!mapchan)
         return AVERROR(ENOMEM);
@@ -607,6 +592,7 @@ static int opt_map_channel(void *optctx, const char *opt, const char *arg)
     av_free(mapchan);
     return 0;
 }
+#endif
 
 static int opt_sdp_file(void *optctx, const char *opt, const char *arg)
 {
@@ -844,7 +830,9 @@ static const AVCodec *find_codec_or_die(const char *name, enum AVMediaType type,
     return codec;
 }
 
-static const AVCodec *choose_decoder(OptionsContext *o, AVFormatContext *s, AVStream *st)
+static const AVCodec *choose_decoder(OptionsContext *o, AVFormatContext *s, AVStream *st,
+                                     enum HWAccelID hwaccel_id, enum AVHWDeviceType hwaccel_device_type)
+
 {
     char *codec_name = NULL;
 
@@ -855,8 +843,51 @@ static const AVCodec *choose_decoder(OptionsContext *o, AVFormatContext *s, AVSt
         if (recast_media && st->codecpar->codec_type != codec->type)
             st->codecpar->codec_type = codec->type;
         return codec;
-    } else
+    } else {
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&
+            hwaccel_id == HWACCEL_GENERIC &&
+            hwaccel_device_type != AV_HWDEVICE_TYPE_NONE) {
+            const AVCodec *c;
+            void *i = NULL;
+
+            while ((c = av_codec_iterate(&i))) {
+                const AVCodecHWConfig *config;
+
+                if (c->id != st->codecpar->codec_id ||
+                    !av_codec_is_decoder(c))
+                    continue;
+
+                for (int j = 0; config = avcodec_get_hw_config(c, j); j++) {
+                    if (config->device_type == hwaccel_device_type) {
+                        av_log(NULL, AV_LOG_VERBOSE, "Selecting decoder '%s' because of requested hwaccel method %s\n",
+                               c->name, av_hwdevice_get_type_name(hwaccel_device_type));
+                        return c;
+                    }
+                }
+            }
+        }
+
         return avcodec_find_decoder(st->codecpar->codec_id);
+    }
+}
+
+static int guess_input_channel_layout(InputStream *ist)
+{
+    AVCodecContext *dec = ist->dec_ctx;
+
+    if (dec->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC) {
+        char layout_name[256];
+
+        if (dec->ch_layout.nb_channels > ist->guess_layout_max)
+            return 0;
+        av_channel_layout_default(&dec->ch_layout, dec->ch_layout.nb_channels);
+        if (dec->ch_layout.order == AV_CHANNEL_ORDER_UNSPEC)
+            return 0;
+        av_channel_layout_describe(&dec->ch_layout, layout_name, sizeof(layout_name));
+        av_log(NULL, AV_LOG_WARNING, "Guessed Channel Layout for Input Stream "
+               "#%d.%d : %s\n", ist->file_index, ist->st->index, layout_name);
+    }
+    return 1;
 }
 
 /* Add all the streams from the given input file to the global
@@ -903,72 +934,7 @@ static void add_input_streams(OptionsContext *o, AVFormatContext *ic)
             st->codecpar->codec_tag = tag;
         }
 
-        ist->dec = choose_decoder(o, ic, st);
-        ist->decoder_opts = filter_codec_opts(o->g->codec_opts, ist->st->codecpar->codec_id, ic, st, ist->dec);
-
-        ist->reinit_filters = -1;
-        MATCH_PER_STREAM_OPT(reinit_filters, i, ist->reinit_filters, ic, st);
-
-        MATCH_PER_STREAM_OPT(discard, str, discard_str, ic, st);
-        ist->user_set_discard = AVDISCARD_NONE;
-
-        if ((o->video_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) ||
-            (o->audio_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) ||
-            (o->subtitle_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) ||
-            (o->data_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_DATA))
-                ist->user_set_discard = AVDISCARD_ALL;
-
-        if (discard_str && av_opt_eval_int(&cc, discard_opt, discard_str, &ist->user_set_discard) < 0) {
-            av_log(NULL, AV_LOG_ERROR, "Error parsing discard %s.\n",
-                    discard_str);
-            exit_program(1);
-        }
-
-        ist->filter_in_rescale_delta_last = AV_NOPTS_VALUE;
-        ist->prev_pkt_pts = AV_NOPTS_VALUE;
-
-        ist->dec_ctx = avcodec_alloc_context3(ist->dec);
-        if (!ist->dec_ctx) {
-            av_log(NULL, AV_LOG_ERROR, "Error allocating the decoder context.\n");
-            exit_program(1);
-        }
-
-        ret = avcodec_parameters_to_context(ist->dec_ctx, par);
-        if (ret < 0) {
-            av_log(NULL, AV_LOG_ERROR, "Error initializing the decoder context.\n");
-            exit_program(1);
-        }
-
-        ist->decoded_frame = av_frame_alloc();
-        if (!ist->decoded_frame)
-            exit_program(1);
-
-        ist->pkt = av_packet_alloc();
-        if (!ist->pkt)
-            exit_program(1);
-
-        if (o->bitexact)
-            ist->dec_ctx->flags |= AV_CODEC_FLAG_BITEXACT;
-
-        switch (par->codec_type) {
-        case AVMEDIA_TYPE_VIDEO:
-            if(!ist->dec)
-                ist->dec = avcodec_find_decoder(par->codec_id);
-
-            // avformat_find_stream_info() doesn't set this for us anymore.
-            ist->dec_ctx->framerate = st->avg_frame_rate;
-
-            MATCH_PER_STREAM_OPT(frame_rates, str, framerate, ic, st);
-            if (framerate && av_parse_video_rate(&ist->framerate,
-                                                 framerate) < 0) {
-                av_log(NULL, AV_LOG_ERROR, "Error parsing framerate %s.\n",
-                       framerate);
-                exit_program(1);
-            }
-
-            ist->top_field_first = -1;
-            MATCH_PER_STREAM_OPT(top_field_first, i, ist->top_field_first, ic, st);
-
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
             MATCH_PER_STREAM_OPT(hwaccels, str, hwaccel, ic, st);
             MATCH_PER_STREAM_OPT(hwaccel_output_formats, str,
                                  hwaccel_output_format, ic, st);
@@ -1034,6 +1000,70 @@ static void add_input_streams(OptionsContext *o, AVFormatContext *ic)
             }
 
             ist->hwaccel_pix_fmt = AV_PIX_FMT_NONE;
+        }
+
+        ist->dec = choose_decoder(o, ic, st, ist->hwaccel_id, ist->hwaccel_device_type);
+        ist->decoder_opts = filter_codec_opts(o->g->codec_opts, ist->st->codecpar->codec_id, ic, st, ist->dec);
+
+        ist->reinit_filters = -1;
+        MATCH_PER_STREAM_OPT(reinit_filters, i, ist->reinit_filters, ic, st);
+
+        MATCH_PER_STREAM_OPT(discard, str, discard_str, ic, st);
+        ist->user_set_discard = AVDISCARD_NONE;
+
+        if ((o->video_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) ||
+            (o->audio_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) ||
+            (o->subtitle_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) ||
+            (o->data_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_DATA))
+                ist->user_set_discard = AVDISCARD_ALL;
+
+        if (discard_str && av_opt_eval_int(&cc, discard_opt, discard_str, &ist->user_set_discard) < 0) {
+            av_log(NULL, AV_LOG_ERROR, "Error parsing discard %s.\n",
+                    discard_str);
+            exit_program(1);
+        }
+
+        ist->filter_in_rescale_delta_last = AV_NOPTS_VALUE;
+        ist->prev_pkt_pts = AV_NOPTS_VALUE;
+
+        ist->dec_ctx = avcodec_alloc_context3(ist->dec);
+        if (!ist->dec_ctx) {
+            av_log(NULL, AV_LOG_ERROR, "Error allocating the decoder context.\n");
+            exit_program(1);
+        }
+
+        ret = avcodec_parameters_to_context(ist->dec_ctx, par);
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_ERROR, "Error initializing the decoder context.\n");
+            exit_program(1);
+        }
+
+        ist->decoded_frame = av_frame_alloc();
+        if (!ist->decoded_frame)
+            exit_program(1);
+
+        ist->pkt = av_packet_alloc();
+        if (!ist->pkt)
+            exit_program(1);
+
+        if (o->bitexact)
+            ist->dec_ctx->flags |= AV_CODEC_FLAG_BITEXACT;
+
+        switch (par->codec_type) {
+        case AVMEDIA_TYPE_VIDEO:
+            // avformat_find_stream_info() doesn't set this for us anymore.
+            ist->dec_ctx->framerate = st->avg_frame_rate;
+
+            MATCH_PER_STREAM_OPT(frame_rates, str, framerate, ic, st);
+            if (framerate && av_parse_video_rate(&ist->framerate,
+                                                 framerate) < 0) {
+                av_log(NULL, AV_LOG_ERROR, "Error parsing framerate %s.\n",
+                       framerate);
+                exit_program(1);
+            }
+
+            ist->top_field_first = -1;
+            MATCH_PER_STREAM_OPT(top_field_first, i, ist->top_field_first, ic, st);
 
             break;
         case AVMEDIA_TYPE_AUDIO:
@@ -1044,8 +1074,6 @@ static void add_input_streams(OptionsContext *o, AVFormatContext *ic)
         case AVMEDIA_TYPE_DATA:
         case AVMEDIA_TYPE_SUBTITLE: {
             char *canvas_size = NULL;
-            if(!ist->dec)
-                ist->dec = avcodec_find_decoder(par->codec_id);
             MATCH_PER_STREAM_OPT(fix_sub_duration, i, ist->fix_sub_duration, ic, st);
             MATCH_PER_STREAM_OPT(canvas_sizes, str, canvas_size, ic, st);
             if (canvas_size &&
@@ -1062,7 +1090,11 @@ static void add_input_streams(OptionsContext *o, AVFormatContext *ic)
             abort();
         }
 
-        ret = avcodec_parameters_from_context(par, ist->dec_ctx);
+        ist->par = avcodec_parameters_alloc();
+        if (!ist->par)
+            exit_program(1);
+
+        ret = avcodec_parameters_from_context(ist->par, ist->dec_ctx);
         if (ret < 0) {
             av_log(NULL, AV_LOG_ERROR, "Error initializing the decoder context.\n");
             exit_program(1);
@@ -1275,7 +1307,7 @@ static int open_input_file(OptionsContext *o, const char *filename)
 
     /* apply forced codec ids */
     for (i = 0; i < ic->nb_streams; i++)
-        choose_decoder(o, ic, ic->streams[i]);
+        choose_decoder(o, ic, ic->streams[i], HWACCEL_NONE, AV_HWDEVICE_TYPE_NONE);
 
     if (find_stream_info) {
         AVDictionary **opts = setup_find_stream_info_opts(ic, o->g->codec_opts);
@@ -1355,6 +1387,7 @@ static int open_input_file(OptionsContext *o, const char *filename)
     f = ALLOC_ARRAY_ELEM(input_files, nb_input_files);
 
     f->ctx        = ic;
+    f->index      = nb_input_files - 1;
     f->ist_index  = nb_input_streams - ic->nb_streams;
     f->start_time = o->start_time;
     f->recording_time = o->recording_time;
@@ -1370,20 +1403,15 @@ static int open_input_file(OptionsContext *o, const char *filename)
 
     f->readrate = o->readrate ? o->readrate : 0.0;
     if (f->readrate < 0.0f) {
-        av_log(NULL, AV_LOG_ERROR, "Option -readrate for Input #%d is %0.3f; it must be non-negative.\n", nb_input_files, f->readrate);
+        av_log(NULL, AV_LOG_ERROR, "Option -readrate for Input #%d is %0.3f; it must be non-negative.\n", f->index, f->readrate);
         exit_program(1);
     }
     if (f->readrate && f->rate_emu) {
-        av_log(NULL, AV_LOG_WARNING, "Both -readrate and -re set for Input #%d. Using -readrate %0.3f.\n", nb_input_files, f->readrate);
+        av_log(NULL, AV_LOG_WARNING, "Both -readrate and -re set for Input #%d. Using -readrate %0.3f.\n", f->index, f->readrate);
         f->rate_emu = 0;
     }
 
-    f->pkt = av_packet_alloc();
-    if (!f->pkt)
-        exit_program(1);
-#if HAVE_THREADS
     f->thread_queue_size = o->thread_queue_size;
-#endif
 
     /* check if all codec options have been used */
     unused_opts = strip_specifiers(o->g->codec_opts);
@@ -1409,7 +1437,7 @@ static int open_input_file(OptionsContext *o, const char *filename)
         if (!(option->flags & AV_OPT_FLAG_DECODING_PARAM)) {
             av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for "
                    "input file #%d (%s) is not a decoding option.\n", e->key,
-                   option->help ? option->help : "", nb_input_files - 1,
+                   option->help ? option->help : "", f->index,
                    filename);
             exit_program(1);
         }
@@ -1419,7 +1447,7 @@ static int open_input_file(OptionsContext *o, const char *filename)
                "likely reason is either wrong type (e.g. a video option with "
                "no video streams) or that it is a private option of some decoder "
                "which was not actually used for any stream.\n", e->key,
-               option->help ? option->help : "", nb_input_files - 1, filename);
+               option->help ? option->help : "", f->index, filename);
     }
     av_dict_free(&unused_opts);
 
@@ -1502,22 +1530,31 @@ static int choose_encoder(OptionsContext *o, AVFormatContext *s, OutputStream *o
                        avcodec_get_name(ost->st->codecpar->codec_id));
                 return AVERROR_ENCODER_NOT_FOUND;
             }
-        } else if (!strcmp(codec_name, "copy"))
-            ost->stream_copy = 1;
-        else {
+        } else if (strcmp(codec_name, "copy")) {
             ost->enc = find_codec_or_die(codec_name, ost->st->codecpar->codec_type, 1);
             ost->st->codecpar->codec_id = ost->enc->id;
         }
-        ost->encoding_needed = !ost->stream_copy;
-    } else {
-        /* no encoding supported for other media types */
-        ost->stream_copy     = 1;
-        ost->encoding_needed = 0;
     }
 
     return 0;
 }
 
+static int check_opt_bitexact(void *ctx, const AVDictionary *opts,
+                              const char *opt_name, int flag)
+{
+    const AVDictionaryEntry *e = av_dict_get(opts, opt_name, NULL, 0);
+
+    if (e) {
+        const AVOption *o = av_opt_find(ctx, opt_name, NULL, 0, 0);
+        int val = 0;
+        if (!o)
+            return 0;
+        av_opt_eval_flags(ctx, o, e->value, &val);
+        return !!(val & flag);
+    }
+    return 0;
+}
+
 static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, enum AVMediaType type, int source_index)
 {
     OutputStream *ost;
@@ -1551,17 +1588,12 @@ static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, e
         exit_program(1);
     }
 
-    ost->enc_ctx = avcodec_alloc_context3(ost->enc);
-    if (!ost->enc_ctx) {
-        av_log(NULL, AV_LOG_ERROR, "Error allocating the encoding context.\n");
-        exit_program(1);
-    }
-    ost->enc_ctx->codec_type = type;
-
-    ost->ref_par = avcodec_parameters_alloc();
-    if (!ost->ref_par) {
-        av_log(NULL, AV_LOG_ERROR, "Error allocating the encoding parameters.\n");
-        exit_program(1);
+    if (ost->enc) {
+        ost->enc_ctx = avcodec_alloc_context3(ost->enc);
+        if (!ost->enc_ctx) {
+            av_log(NULL, AV_LOG_ERROR, "Error allocating the encoding context.\n");
+            exit_program(1);
+        }
     }
 
     ost->filtered_frame = av_frame_alloc();
@@ -1610,8 +1642,12 @@ static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, e
     }
 
 
-    if (o->bitexact)
-        ost->enc_ctx->flags |= AV_CODEC_FLAG_BITEXACT;
+    if (o->bitexact) {
+        ost->bitexact        = 1;
+    } else if (ost->enc_ctx) {
+        ost->bitexact        = check_opt_bitexact(ost->enc_ctx, ost->encoder_opts, "flags",
+                                                  AV_CODEC_FLAG_BITEXACT);
+    }
 
     MATCH_PER_STREAM_OPT(time_bases, str, time_base, oc, st);
     if (time_base) {
@@ -1662,12 +1698,13 @@ static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, e
         uint32_t tag = strtol(codec_tag, &next, 0);
         if (*next)
             tag = AV_RL32(codec_tag);
-        ost->st->codecpar->codec_tag =
-        ost->enc_ctx->codec_tag = tag;
+        ost->st->codecpar->codec_tag = tag;
+        if (ost->enc_ctx)
+            ost->enc_ctx->codec_tag = tag;
     }
 
     MATCH_PER_STREAM_OPT(qscale, dbl, qscale, oc, st);
-    if (qscale >= 0) {
+    if (ost->enc_ctx && qscale >= 0) {
         ost->enc_ctx->flags |= AV_CODEC_FLAG_QSCALE;
         ost->enc_ctx->global_quality = FF_QP2LAMBDA * qscale;
     }
@@ -1678,15 +1715,13 @@ static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, e
     ost->max_muxing_queue_size = 128;
     MATCH_PER_STREAM_OPT(max_muxing_queue_size, i, ost->max_muxing_queue_size, oc, st);
 
-    ost->muxing_queue_data_size = 0;
-
     ost->muxing_queue_data_threshold = 50*1024*1024;
     MATCH_PER_STREAM_OPT(muxing_queue_data_threshold, i, ost->muxing_queue_data_threshold, oc, st);
 
     MATCH_PER_STREAM_OPT(bits_per_raw_sample, i, ost->bits_per_raw_sample,
                          oc, st);
 
-    if (oc->oformat->flags & AVFMT_GLOBALHEADER)
+    if (oc->oformat->flags & AVFMT_GLOBALHEADER && ost->enc_ctx)
         ost->enc_ctx->flags |= AV_CODEC_FLAG_GLOBAL_HEADER;
 
     av_dict_copy(&ost->sws_dict, o->g->sws_dict, 0);
@@ -1697,15 +1732,11 @@ static OutputStream *new_output_stream(OptionsContext *o, AVFormatContext *oc, e
 
     ost->source_index = source_index;
     if (source_index >= 0) {
-        ost->sync_ist = input_streams[source_index];
         input_streams[source_index]->discard = 0;
         input_streams[source_index]->st->discard = input_streams[source_index]->user_set_discard;
     }
     ost->last_mux_dts = AV_NOPTS_VALUE;
-
-    ost->muxing_queue = av_fifo_alloc2(8, sizeof(AVPacket*), 0);
-    if (!ost->muxing_queue)
-        exit_program(1);
+    ost->last_filter_pts = AV_NOPTS_VALUE;
 
     MATCH_PER_STREAM_OPT(copy_initial_nonkeyframes, i,
                          ost->copy_initial_nonkeyframes, oc, st);
@@ -1794,12 +1825,10 @@ static OutputStream *new_video_stream(OptionsContext *o, AVFormatContext *oc, in
 {
     AVStream *st;
     OutputStream *ost;
-    AVCodecContext *video_enc;
     char *frame_rate = NULL, *max_frame_rate = NULL, *frame_aspect_ratio = NULL;
 
     ost = new_output_stream(o, oc, AVMEDIA_TYPE_VIDEO, source_index);
     st  = ost->st;
-    video_enc = ost->enc_ctx;
 
     MATCH_PER_STREAM_OPT(frame_rates, str, frame_rate, oc, st);
     if (frame_rate && av_parse_video_rate(&ost->frame_rate, frame_rate) < 0) {
@@ -1836,7 +1865,8 @@ static OutputStream *new_video_stream(OptionsContext *o, AVFormatContext *oc, in
     MATCH_PER_STREAM_OPT(filter_scripts, str, ost->filters_script, oc, st);
     MATCH_PER_STREAM_OPT(filters,        str, ost->filters,        oc, st);
 
-    if (!ost->stream_copy) {
+    if (ost->enc_ctx) {
+        AVCodecContext *video_enc = ost->enc_ctx;
         const char *p = NULL;
         char *frame_size = NULL;
         char *frame_pix_fmt = NULL;
@@ -1920,8 +1950,12 @@ static OutputStream *new_video_stream(OptionsContext *o, AVFormatContext *oc, in
         }
         video_enc->rc_override_count = i;
 
-        if (do_psnr)
+#if FFMPEG_OPT_PSNR
+        if (do_psnr) {
+            av_log(NULL, AV_LOG_WARNING, "The -psnr option is deprecated, use -flags +psnr\n");
             video_enc->flags|= AV_CODEC_FLAG_PSNR;
+        }
+#endif
 
         /* two pass mode */
         MATCH_PER_STREAM_OPT(pass, i, do_pass, oc, st);
@@ -2020,9 +2054,7 @@ static OutputStream *new_video_stream(OptionsContext *o, AVFormatContext *oc, in
         ost->last_frame = av_frame_alloc();
         if (!ost->last_frame)
             exit_program(1);
-    }
-
-    if (ost->stream_copy)
+    } else
         check_streamcopy_filters(o, oc, ost, AVMEDIA_TYPE_VIDEO);
 
     return ost;
@@ -2030,21 +2062,18 @@ static OutputStream *new_video_stream(OptionsContext *o, AVFormatContext *oc, in
 
 static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc, int source_index)
 {
-    int n;
     AVStream *st;
     OutputStream *ost;
-    AVCodecContext *audio_enc;
 
     ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO, source_index);
     st  = ost->st;
 
-    audio_enc = ost->enc_ctx;
-    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;
 
     MATCH_PER_STREAM_OPT(filter_scripts, str, ost->filters_script, oc, st);
     MATCH_PER_STREAM_OPT(filters,        str, ost->filters,        oc, st);
 
-    if (!ost->stream_copy) {
+    if (ost->enc_ctx) {
+        AVCodecContext *audio_enc = ost->enc_ctx;
         int channels = 0;
         char *layout = NULL;
         char *sample_fmt = NULL;
@@ -2092,8 +2121,9 @@ static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc, in
         if (!ost->avfilter)
             exit_program(1);
 
+#if FFMPEG_OPT_MAP_CHANNEL
         /* check for channel mapping for this audio stream */
-        for (n = 0; n < o->nb_audio_channel_maps; n++) {
+        for (int n = 0; n < o->nb_audio_channel_maps; n++) {
             AudioChannelMap *map = &o->audio_channel_maps[n];
             if ((map->ofile_idx   == -1 || ost->file_index == map->ofile_idx) &&
                 (map->ostream_idx == -1 || ost->st->index  == map->ostream_idx)) {
@@ -2120,9 +2150,8 @@ static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc, in
                 }
             }
         }
-    }
-
-    if (ost->stream_copy)
+#endif
+    } else
         check_streamcopy_filters(o, oc, ost, AVMEDIA_TYPE_AUDIO);
 
     return ost;
@@ -2133,7 +2162,7 @@ static OutputStream *new_data_stream(OptionsContext *o, AVFormatContext *oc, int
     OutputStream *ost;
 
     ost = new_output_stream(o, oc, AVMEDIA_TYPE_DATA, source_index);
-    if (!ost->stream_copy) {
+    if (ost->enc_ctx) {
         av_log(NULL, AV_LOG_FATAL, "Data stream encoding not supported yet (only streamcopy)\n");
         exit_program(1);
     }
@@ -2146,7 +2175,7 @@ static OutputStream *new_unknown_stream(OptionsContext *o, AVFormatContext *oc,
     OutputStream *ost;
 
     ost = new_output_stream(o, oc, AVMEDIA_TYPE_UNKNOWN, source_index);
-    if (!ost->stream_copy) {
+    if (ost->enc_ctx) {
         av_log(NULL, AV_LOG_FATAL, "Unknown stream encoding not supported yet (only streamcopy)\n");
         exit_program(1);
     }
@@ -2157,7 +2186,6 @@ static OutputStream *new_unknown_stream(OptionsContext *o, AVFormatContext *oc,
 static OutputStream *new_attachment_stream(OptionsContext *o, AVFormatContext *oc, int source_index)
 {
     OutputStream *ost = new_output_stream(o, oc, AVMEDIA_TYPE_ATTACHMENT, source_index);
-    ost->stream_copy = 1;
     ost->finished    = 1;
     return ost;
 }
@@ -2166,15 +2194,12 @@ static OutputStream *new_subtitle_stream(OptionsContext *o, AVFormatContext *oc,
 {
     AVStream *st;
     OutputStream *ost;
-    AVCodecContext *subtitle_enc;
 
     ost = new_output_stream(o, oc, AVMEDIA_TYPE_SUBTITLE, source_index);
     st  = ost->st;
-    subtitle_enc = ost->enc_ctx;
 
-    subtitle_enc->codec_type = AVMEDIA_TYPE_SUBTITLE;
-
-    if (!ost->stream_copy) {
+    if (ost->enc_ctx) {
+        AVCodecContext *subtitle_enc = ost->enc_ctx;
         char *frame_size = NULL;
 
         MATCH_PER_STREAM_OPT(frame_sizes, str, frame_size, oc, st);
@@ -2338,7 +2363,7 @@ static void init_output_filter(OutputFilter *ofilter, OptionsContext *o,
     ofilter->ost      = ost;
     ofilter->format   = -1;
 
-    if (ost->stream_copy) {
+    if (!ost->enc_ctx) {
         av_log(NULL, AV_LOG_ERROR, "Streamcopy requested for output stream %d:%d, "
                "which is fed from a complex filtergraph. Filtering and streamcopy "
                "cannot be used together.\n", ost->file_index, ost->index);
@@ -2372,311 +2397,309 @@ static int init_complex_filters(void)
     return 0;
 }
 
-static void set_channel_layout(OutputFilter *f, OutputStream *ost)
+static int setup_sync_queues(OutputFile *of, AVFormatContext *oc, int64_t buf_size_us)
 {
-    int i, err;
+    int nb_av_enc = 0, nb_interleaved = 0;
+    int limit_frames = 0, limit_frames_av_enc = 0;
 
-    if (ost->enc_ctx->ch_layout.order != AV_CHANNEL_ORDER_UNSPEC) {
-        /* Pass the layout through for all orders but UNSPEC */
-        err = av_channel_layout_copy(&f->ch_layout, &ost->enc_ctx->ch_layout);
-        if (err < 0)
-            exit_program(1);
-        return;
-    }
+#define IS_AV_ENC(ost, type)  \
+    (ost->enc_ctx && (type == AVMEDIA_TYPE_VIDEO || type == AVMEDIA_TYPE_AUDIO))
+#define IS_INTERLEAVED(type) (type != AVMEDIA_TYPE_ATTACHMENT)
 
-    /* Requested layout is of order UNSPEC */
-    if (!ost->enc->ch_layouts) {
-        /* Use the default native layout for the requested amount of channels when the
-           encoder doesn't have a list of supported layouts */
-        av_channel_layout_default(&f->ch_layout, ost->enc_ctx->ch_layout.nb_channels);
-        return;
-    }
-    /* Encoder has a list of supported layouts. Pick the first layout in it with the
-       same amount of channels as the requested layout */
-    for (i = 0; ost->enc->ch_layouts[i].nb_channels; i++) {
-        if (ost->enc->ch_layouts[i].nb_channels == ost->enc_ctx->ch_layout.nb_channels)
-            break;
-    }
-    if (ost->enc->ch_layouts[i].nb_channels) {
-        /* Use it if one is found */
-        err = av_channel_layout_copy(&f->ch_layout, &ost->enc->ch_layouts[i]);
-        if (err < 0)
-            exit_program(1);
-        return;
-    }
-    /* If no layout for the amount of channels requested was found, use the default
-       native layout for it. */
-    av_channel_layout_default(&f->ch_layout, ost->enc_ctx->ch_layout.nb_channels);
-}
+    for (int i = 0; i < oc->nb_streams; i++) {
+        OutputStream *ost = output_streams[of->ost_index + i];
+        enum AVMediaType type = ost->st->codecpar->codec_type;
 
-static int open_output_file(OptionsContext *o, const char *filename)
-{
-    AVFormatContext *oc;
-    int i, j, err;
-    OutputFile *of;
-    OutputStream *ost;
-    InputStream  *ist;
-    AVDictionary *unused_opts = NULL;
-    const AVDictionaryEntry *e = NULL;
+        ost->sq_idx_encode = -1;
+        ost->sq_idx_mux    = -1;
 
-    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {
-        o->stop_time = INT64_MAX;
-        av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n");
-    }
+        nb_interleaved += IS_INTERLEAVED(type);
+        nb_av_enc      += IS_AV_ENC(ost, type);
 
-    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {
-        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;
-        if (o->stop_time <= start_time) {
-            av_log(NULL, AV_LOG_ERROR, "-to value smaller than -ss; aborting.\n");
-            exit_program(1);
-        } else {
-            o->recording_time = o->stop_time - start_time;
-        }
+        limit_frames        |=  ost->max_frames < INT64_MAX;
+        limit_frames_av_enc |= (ost->max_frames < INT64_MAX) && IS_AV_ENC(ost, type);
     }
 
-    of = ALLOC_ARRAY_ELEM(output_files, nb_output_files);
+    if (!((nb_interleaved > 1 && of->shortest) ||
+          (nb_interleaved > 0 && limit_frames)))
+        return 0;
 
-    of->index          = nb_output_files - 1;
-    of->ost_index      = nb_output_streams;
-    of->recording_time = o->recording_time;
-    of->start_time     = o->start_time;
-    of->limit_filesize = o->limit_filesize;
-    of->shortest       = o->shortest;
-    av_dict_copy(&of->opts, o->g->format_opts, 0);
+    /* if we have more than one encoded audio/video streams, or at least
+     * one encoded audio/video stream is frame-limited, then we
+     * synchronize them before encoding */
+    if ((of->shortest && nb_av_enc > 1) || limit_frames_av_enc) {
+        of->sq_encode = sq_alloc(SYNC_QUEUE_FRAMES, buf_size_us);
+        if (!of->sq_encode)
+            return AVERROR(ENOMEM);
 
-    if (!strcmp(filename, "-"))
-        filename = "pipe:";
+        for (int i = 0; i < oc->nb_streams; i++) {
+            OutputStream *ost = output_streams[of->ost_index + i];
+            enum AVMediaType type = ost->st->codecpar->codec_type;
 
-    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);
-    if (!oc) {
-        print_error(filename, err);
-        exit_program(1);
-    }
+            if (!IS_AV_ENC(ost, type))
+                continue;
 
-    of->ctx = oc;
-    of->format = oc->oformat;
-    if (o->recording_time != INT64_MAX)
-        oc->duration = o->recording_time;
+            ost->sq_idx_encode = sq_add_stream(of->sq_encode,
+                                               of->shortest || ost->max_frames < INT64_MAX);
+            if (ost->sq_idx_encode < 0)
+                return ost->sq_idx_encode;
 
-    oc->interrupt_callback = int_cb;
+            ost->sq_frame = av_frame_alloc();
+            if (!ost->sq_frame)
+                return AVERROR(ENOMEM);
 
-    if (o->bitexact) {
-        oc->flags    |= AVFMT_FLAG_BITEXACT;
+            if (ost->max_frames != INT64_MAX)
+                sq_limit_frames(of->sq_encode, ost->sq_idx_encode, ost->max_frames);
+        }
     }
 
-    /* create streams for all unlabeled output pads */
-    for (i = 0; i < nb_filtergraphs; i++) {
-        FilterGraph *fg = filtergraphs[i];
-        for (j = 0; j < fg->nb_outputs; j++) {
-            OutputFilter *ofilter = fg->outputs[j];
+    /* if there are any additional interleaved streams, then ALL the streams
+     * are also synchronized before sending them to the muxer */
+    if (nb_interleaved > nb_av_enc) {
+        of->sq_mux = sq_alloc(SYNC_QUEUE_PACKETS, buf_size_us);
+        if (!of->sq_mux)
+            return AVERROR(ENOMEM);
 
-            if (!ofilter->out_tmp || ofilter->out_tmp->name)
+        for (int i = 0; i < oc->nb_streams; i++) {
+            OutputStream *ost = output_streams[of->ost_index + i];
+            enum AVMediaType type = ost->st->codecpar->codec_type;
+
+            if (!IS_INTERLEAVED(type))
                 continue;
 
-            switch (ofilter->type) {
-            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;
-            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;
-            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;
-            }
-            init_output_filter(ofilter, o, oc);
+            ost->sq_idx_mux = sq_add_stream(of->sq_mux,
+                                            of->shortest || ost->max_frames < INT64_MAX);
+            if (ost->sq_idx_mux < 0)
+                return ost->sq_idx_mux;
+
+            if (ost->max_frames != INT64_MAX)
+                sq_limit_frames(of->sq_mux, ost->sq_idx_mux, ost->max_frames);
         }
     }
 
-    if (!o->nb_stream_maps) {
-        char *subtitle_codec_name = NULL;
-        /* pick the "best" stream of each type */
+#undef IS_AV_ENC
+#undef IS_INTERLEAVED
 
-        /* video: highest resolution */
-        if (!o->video_disable && av_guess_codec(oc->oformat, NULL, filename, NULL, AVMEDIA_TYPE_VIDEO) != AV_CODEC_ID_NONE) {
-            int best_score = 0, idx = -1;
-            int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);
-            for (j = 0; j < nb_input_files; j++) {
-                InputFile *ifile = input_files[j];
-                int file_best_score = 0, file_best_idx = -1;
-                for (i = 0; i < ifile->nb_streams; i++) {
-                    int score;
-                    ist = input_streams[ifile->ist_index + i];
-                    score = ist->st->codecpar->width * ist->st->codecpar->height
-                               + 100000000 * !!(ist->st->event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS)
-                               + 5000000*!!(ist->st->disposition & AV_DISPOSITION_DEFAULT);
-                    if (ist->user_set_discard == AVDISCARD_ALL)
-                        continue;
-                    if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))
-                        score = 1;
-                    if (ist->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&
-                        score > file_best_score) {
-                        if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))
-                            continue;
-                        file_best_score = score;
-                        file_best_idx = ifile->ist_index + i;
-                    }
-                }
-                if (file_best_idx >= 0) {
-                    if((qcr == MKTAG('A', 'P', 'I', 'C')) || !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))
-                        file_best_score -= 5000000*!!(input_streams[file_best_idx]->st->disposition & AV_DISPOSITION_DEFAULT);
-                    if (file_best_score > best_score) {
-                        best_score = file_best_score;
-                        idx = file_best_idx;
-                    }
-               }
+    return 0;
+}
+
+static void map_auto_video(OutputFile *of, AVFormatContext *oc,
+                           OptionsContext *o)
+{
+    InputStream *ist;
+    int best_score = 0, idx = -1;
+    int qcr;
+
+    /* video: highest resolution */
+    if (av_guess_codec(oc->oformat, NULL, oc->url, NULL, AVMEDIA_TYPE_VIDEO) == AV_CODEC_ID_NONE)
+        return;
+
+    qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0);
+    for (int j = 0; j < nb_input_files; j++) {
+        InputFile *ifile = input_files[j];
+        int file_best_score = 0, file_best_idx = -1;
+        for (int i = 0; i < ifile->nb_streams; i++) {
+            int score;
+            ist = input_streams[ifile->ist_index + i];
+            score = ist->st->codecpar->width * ist->st->codecpar->height
+                       + 100000000 * !!(ist->st->event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS)
+                       + 5000000*!!(ist->st->disposition & AV_DISPOSITION_DEFAULT);
+            if (ist->user_set_discard == AVDISCARD_ALL)
+                continue;
+            if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))
+                score = 1;
+            if (ist->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO &&
+                score > file_best_score) {
+                if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))
+                    continue;
+                file_best_score = score;
+                file_best_idx = ifile->ist_index + i;
             }
-            if (idx >= 0)
-                new_video_stream(o, oc, idx);
         }
+        if (file_best_idx >= 0) {
+            if((qcr == MKTAG('A', 'P', 'I', 'C')) || !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC))
+                file_best_score -= 5000000*!!(input_streams[file_best_idx]->st->disposition & AV_DISPOSITION_DEFAULT);
+            if (file_best_score > best_score) {
+                best_score = file_best_score;
+                idx = file_best_idx;
+            }
+       }
+    }
+    if (idx >= 0)
+        new_video_stream(o, oc, idx);
+}
+
+static void map_auto_audio(OutputFile *of, AVFormatContext *oc,
+                           OptionsContext *o)
+{
+    InputStream *ist;
+    int best_score = 0, idx = -1;
 
         /* audio: most channels */
-        if (!o->audio_disable && av_guess_codec(oc->oformat, NULL, filename, NULL, AVMEDIA_TYPE_AUDIO) != AV_CODEC_ID_NONE) {
-            int best_score = 0, idx = -1;
-            for (j = 0; j < nb_input_files; j++) {
-                InputFile *ifile = input_files[j];
-                int file_best_score = 0, file_best_idx = -1;
-                for (i = 0; i < ifile->nb_streams; i++) {
-                    int score;
-                    ist = input_streams[ifile->ist_index + i];
-                    score = ist->st->codecpar->ch_layout.nb_channels
-                            + 100000000 * !!(ist->st->event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS)
-                            + 5000000*!!(ist->st->disposition & AV_DISPOSITION_DEFAULT);
-                    if (ist->user_set_discard == AVDISCARD_ALL)
-                        continue;
-                    if (ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&
-                        score > file_best_score) {
-                        file_best_score = score;
-                        file_best_idx = ifile->ist_index + i;
-                    }
-                }
-                if (file_best_idx >= 0) {
-                    file_best_score -= 5000000*!!(input_streams[file_best_idx]->st->disposition & AV_DISPOSITION_DEFAULT);
-                    if (file_best_score > best_score) {
-                        best_score = file_best_score;
-                        idx = file_best_idx;
-                    }
-               }
+    if (av_guess_codec(oc->oformat, NULL, oc->url, NULL, AVMEDIA_TYPE_AUDIO) == AV_CODEC_ID_NONE)
+        return;
+
+    for (int j = 0; j < nb_input_files; j++) {
+        InputFile *ifile = input_files[j];
+        int file_best_score = 0, file_best_idx = -1;
+        for (int i = 0; i < ifile->nb_streams; i++) {
+            int score;
+            ist = input_streams[ifile->ist_index + i];
+            score = ist->st->codecpar->ch_layout.nb_channels
+                    + 100000000 * !!(ist->st->event_flags & AVSTREAM_EVENT_FLAG_NEW_PACKETS)
+                    + 5000000*!!(ist->st->disposition & AV_DISPOSITION_DEFAULT);
+            if (ist->user_set_discard == AVDISCARD_ALL)
+                continue;
+            if (ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO &&
+                score > file_best_score) {
+                file_best_score = score;
+                file_best_idx = ifile->ist_index + i;
             }
-            if (idx >= 0)
-                new_audio_stream(o, oc, idx);
         }
+        if (file_best_idx >= 0) {
+            file_best_score -= 5000000*!!(input_streams[file_best_idx]->st->disposition & AV_DISPOSITION_DEFAULT);
+            if (file_best_score > best_score) {
+                best_score = file_best_score;
+                idx = file_best_idx;
+            }
+       }
+    }
+    if (idx >= 0)
+        new_audio_stream(o, oc, idx);
+}
+
+static void map_auto_subtitle(OutputFile *of, AVFormatContext *oc,
+                              OptionsContext *o)
+{
+    char *subtitle_codec_name = NULL;
 
         /* subtitles: pick first */
-        MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, "s");
-        if (!o->subtitle_disable && (avcodec_find_encoder(oc->oformat->subtitle_codec) || subtitle_codec_name)) {
-            for (i = 0; i < nb_input_streams; i++)
-                if (input_streams[i]->st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {
-                    AVCodecDescriptor const *input_descriptor =
-                        avcodec_descriptor_get(input_streams[i]->st->codecpar->codec_id);
-                    AVCodecDescriptor const *output_descriptor = NULL;
-                    AVCodec const *output_codec =
-                        avcodec_find_encoder(oc->oformat->subtitle_codec);
-                    int input_props = 0, output_props = 0;
-                    if (input_streams[i]->user_set_discard == AVDISCARD_ALL)
-                        continue;
-                    if (output_codec)
-                        output_descriptor = avcodec_descriptor_get(output_codec->id);
-                    if (input_descriptor)
-                        input_props = input_descriptor->props & (AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB);
-                    if (output_descriptor)
-                        output_props = output_descriptor->props & (AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB);
-                    if (subtitle_codec_name ||
-                        input_props & output_props ||
-                        // Map dvb teletext which has neither property to any output subtitle encoder
-                        input_descriptor && output_descriptor &&
-                        (!input_descriptor->props ||
-                         !output_descriptor->props)) {
-                        new_subtitle_stream(o, oc, i);
-                        break;
-                    }
-                }
-        }
-        /* Data only if codec id match */
-        if (!o->data_disable ) {
-            enum AVCodecID codec_id = av_guess_codec(oc->oformat, NULL, filename, NULL, AVMEDIA_TYPE_DATA);
-            for (i = 0; codec_id != AV_CODEC_ID_NONE && i < nb_input_streams; i++) {
-                if (input_streams[i]->user_set_discard == AVDISCARD_ALL)
-                    continue;
-                if (input_streams[i]->st->codecpar->codec_type == AVMEDIA_TYPE_DATA
-                    && input_streams[i]->st->codecpar->codec_id == codec_id )
-                    new_data_stream(o, oc, i);
+    MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, "s");
+    if (!avcodec_find_encoder(oc->oformat->subtitle_codec) && !subtitle_codec_name)
+        return;
+
+    for (int i = 0; i < nb_input_streams; i++)
+        if (input_streams[i]->st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE) {
+            AVCodecDescriptor const *input_descriptor =
+                avcodec_descriptor_get(input_streams[i]->st->codecpar->codec_id);
+            AVCodecDescriptor const *output_descriptor = NULL;
+            AVCodec const *output_codec =
+                avcodec_find_encoder(oc->oformat->subtitle_codec);
+            int input_props = 0, output_props = 0;
+            if (input_streams[i]->user_set_discard == AVDISCARD_ALL)
+                continue;
+            if (output_codec)
+                output_descriptor = avcodec_descriptor_get(output_codec->id);
+            if (input_descriptor)
+                input_props = input_descriptor->props & (AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB);
+            if (output_descriptor)
+                output_props = output_descriptor->props & (AV_CODEC_PROP_TEXT_SUB | AV_CODEC_PROP_BITMAP_SUB);
+            if (subtitle_codec_name ||
+                input_props & output_props ||
+                // Map dvb teletext which has neither property to any output subtitle encoder
+                input_descriptor && output_descriptor &&
+                (!input_descriptor->props ||
+                 !output_descriptor->props)) {
+                new_subtitle_stream(o, oc, i);
+                break;
             }
         }
-    } else {
-        for (i = 0; i < o->nb_stream_maps; i++) {
-            StreamMap *map = &o->stream_maps[i];
+}
 
-            if (map->disabled)
-                continue;
+static void map_auto_data(OutputFile *of, AVFormatContext *oc,
+                          OptionsContext *o)
+{
+    /* Data only if codec id match */
+    enum AVCodecID codec_id = av_guess_codec(oc->oformat, NULL, oc->url, NULL, AVMEDIA_TYPE_DATA);
+    for (int i = 0; codec_id != AV_CODEC_ID_NONE && i < nb_input_streams; i++) {
+        if (input_streams[i]->user_set_discard == AVDISCARD_ALL)
+            continue;
+        if (input_streams[i]->st->codecpar->codec_type == AVMEDIA_TYPE_DATA
+            && input_streams[i]->st->codecpar->codec_id == codec_id )
+            new_data_stream(o, oc, i);
+    }
+}
 
-            if (map->linklabel) {
-                FilterGraph *fg;
-                OutputFilter *ofilter = NULL;
-                int j, k;
-
-                for (j = 0; j < nb_filtergraphs; j++) {
-                    fg = filtergraphs[j];
-                    for (k = 0; k < fg->nb_outputs; k++) {
-                        AVFilterInOut *out = fg->outputs[k]->out_tmp;
-                        if (out && !strcmp(out->name, map->linklabel)) {
-                            ofilter = fg->outputs[k];
-                            goto loop_end;
-                        }
-                    }
-                }
-loop_end:
-                if (!ofilter) {
-                    av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist "
-                           "in any defined filter graph, or was already used elsewhere.\n", map->linklabel);
-                    exit_program(1);
-                }
-                init_output_filter(ofilter, o, oc);
-            } else {
-                int src_idx = input_files[map->file_index]->ist_index + map->stream_index;
+static void map_manual(OutputFile *of, AVFormatContext *oc,
+                       OptionsContext *o, const StreamMap *map)
+{
+    InputStream *ist;
 
-                ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];
-                if (ist->user_set_discard == AVDISCARD_ALL) {
-                    av_log(NULL, AV_LOG_FATAL, "Stream #%d:%d is disabled and cannot be mapped.\n",
-                           map->file_index, map->stream_index);
-                    exit_program(1);
-                }
-                if(o->subtitle_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE)
-                    continue;
-                if(o->   audio_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
-                    continue;
-                if(o->   video_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
-                    continue;
-                if(o->    data_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_DATA)
-                    continue;
+    if (map->disabled)
+        return;
 
-                ost = NULL;
-                switch (ist->st->codecpar->codec_type) {
-                case AVMEDIA_TYPE_VIDEO:      ost = new_video_stream     (o, oc, src_idx); break;
-                case AVMEDIA_TYPE_AUDIO:      ost = new_audio_stream     (o, oc, src_idx); break;
-                case AVMEDIA_TYPE_SUBTITLE:   ost = new_subtitle_stream  (o, oc, src_idx); break;
-                case AVMEDIA_TYPE_DATA:       ost = new_data_stream      (o, oc, src_idx); break;
-                case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break;
-                case AVMEDIA_TYPE_UNKNOWN:
-                    if (copy_unknown_streams) {
-                        ost = new_unknown_stream   (o, oc, src_idx);
-                        break;
-                    }
-                default:
-                    av_log(NULL, ignore_unknown_streams ? AV_LOG_WARNING : AV_LOG_FATAL,
-                           "Cannot map stream #%d:%d - unsupported type.\n",
-                           map->file_index, map->stream_index);
-                    if (!ignore_unknown_streams) {
-                        av_log(NULL, AV_LOG_FATAL,
-                               "If you want unsupported types ignored instead "
-                               "of failing, please use the -ignore_unknown option\n"
-                               "If you want them copied, please use -copy_unknown\n");
-                        exit_program(1);
-                    }
+    if (map->linklabel) {
+        FilterGraph *fg;
+        OutputFilter *ofilter = NULL;
+        int j, k;
+
+        for (j = 0; j < nb_filtergraphs; j++) {
+            fg = filtergraphs[j];
+            for (k = 0; k < fg->nb_outputs; k++) {
+                AVFilterInOut *out = fg->outputs[k]->out_tmp;
+                if (out && !strcmp(out->name, map->linklabel)) {
+                    ofilter = fg->outputs[k];
+                    goto loop_end;
                 }
-                if (ost)
-                    ost->sync_ist = input_streams[  input_files[map->sync_file_index]->ist_index
-                                                  + map->sync_stream_index];
+            }
+        }
+loop_end:
+        if (!ofilter) {
+            av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist "
+                   "in any defined filter graph, or was already used elsewhere.\n", map->linklabel);
+            exit_program(1);
+        }
+        init_output_filter(ofilter, o, oc);
+    } else {
+        int src_idx = input_files[map->file_index]->ist_index + map->stream_index;
+
+        ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index];
+        if (ist->user_set_discard == AVDISCARD_ALL) {
+            av_log(NULL, AV_LOG_FATAL, "Stream #%d:%d is disabled and cannot be mapped.\n",
+                   map->file_index, map->stream_index);
+            exit_program(1);
+        }
+        if(o->subtitle_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_SUBTITLE)
+            return;
+        if(o->   audio_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO)
+            return;
+        if(o->   video_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO)
+            return;
+        if(o->    data_disable && ist->st->codecpar->codec_type == AVMEDIA_TYPE_DATA)
+            return;
+
+        switch (ist->st->codecpar->codec_type) {
+        case AVMEDIA_TYPE_VIDEO:      new_video_stream     (o, oc, src_idx); break;
+        case AVMEDIA_TYPE_AUDIO:      new_audio_stream     (o, oc, src_idx); break;
+        case AVMEDIA_TYPE_SUBTITLE:   new_subtitle_stream  (o, oc, src_idx); break;
+        case AVMEDIA_TYPE_DATA:       new_data_stream      (o, oc, src_idx); break;
+        case AVMEDIA_TYPE_ATTACHMENT: new_attachment_stream(o, oc, src_idx); break;
+        case AVMEDIA_TYPE_UNKNOWN:
+            if (copy_unknown_streams) {
+                new_unknown_stream   (o, oc, src_idx);
+                break;
+            }
+        default:
+            av_log(NULL, ignore_unknown_streams ? AV_LOG_WARNING : AV_LOG_FATAL,
+                   "Cannot map stream #%d:%d - unsupported type.\n",
+                   map->file_index, map->stream_index);
+            if (!ignore_unknown_streams) {
+                av_log(NULL, AV_LOG_FATAL,
+                       "If you want unsupported types ignored instead "
+                       "of failing, please use the -ignore_unknown option\n"
+                       "If you want them copied, please use -copy_unknown\n");
+                exit_program(1);
             }
         }
     }
+}
+
+static void of_add_attachments(AVFormatContext *oc, OptionsContext *o)
+{
+    OutputStream *ost;
+    int err;
 
-    /* handle attached files */
-    for (i = 0; i < o->nb_attachments; i++) {
+    for (int i = 0; i < o->nb_attachments; i++) {
         AVIOContext *pb;
         uint8_t *attachment;
         const char *p;
@@ -2702,7 +2725,6 @@ loop_end:
         memset(attachment + len, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 
         ost = new_attachment_stream(o, oc, -1);
-        ost->stream_copy               = 0;
         ost->attachment_filename       = o->attachments[i];
         ost->st->codecpar->extradata      = attachment;
         ost->st->codecpar->extradata_size = len;
@@ -2711,6 +2733,228 @@ loop_end:
         av_dict_set(&ost->st->metadata, "filename", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE);
         avio_closep(&pb);
     }
+}
+
+static void of_add_programs(AVFormatContext *oc, const OptionsContext *o)
+{
+    /* process manually set programs */
+    for (int i = 0; i < o->nb_program; i++) {
+        const char *p = o->program[i].u.str;
+        int progid = i+1;
+        AVProgram *program;
+
+        while(*p) {
+            const char *p2 = av_get_token(&p, ":");
+            const char *to_dealloc = p2;
+            char *key;
+            if (!p2)
+                break;
+
+            if(*p) p++;
+
+            key = av_get_token(&p2, "=");
+            if (!key || !*p2) {
+                av_freep(&to_dealloc);
+                av_freep(&key);
+                break;
+            }
+            p2++;
+
+            if (!strcmp(key, "program_num"))
+                progid = strtol(p2, NULL, 0);
+            av_freep(&to_dealloc);
+            av_freep(&key);
+        }
+
+        program = av_new_program(oc, progid);
+
+        p = o->program[i].u.str;
+        while(*p) {
+            const char *p2 = av_get_token(&p, ":");
+            const char *to_dealloc = p2;
+            char *key;
+            if (!p2)
+                break;
+            if(*p) p++;
+
+            key = av_get_token(&p2, "=");
+            if (!key) {
+                av_log(NULL, AV_LOG_FATAL,
+                       "No '=' character in program string %s.\n",
+                       p2);
+                exit_program(1);
+            }
+            if (!*p2)
+                exit_program(1);
+            p2++;
+
+            if (!strcmp(key, "title")) {
+                av_dict_set(&program->metadata, "title", p2, 0);
+            } else if (!strcmp(key, "program_num")) {
+            } else if (!strcmp(key, "st")) {
+                int st_num = strtol(p2, NULL, 0);
+                av_program_add_stream_index(oc, progid, st_num);
+            } else {
+                av_log(NULL, AV_LOG_FATAL, "Unknown program key %s.\n", key);
+                exit_program(1);
+            }
+            av_freep(&to_dealloc);
+            av_freep(&key);
+        }
+    }
+}
+
+static void of_add_metadata(AVFormatContext *oc, const OptionsContext *o)
+{
+    for (int i = 0; i < o->nb_metadata; i++) {
+        AVDictionary **m;
+        char type, *val;
+        const char *stream_spec;
+        int index = 0, ret = 0;
+
+        val = strchr(o->metadata[i].u.str, '=');
+        if (!val) {
+            av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n",
+                   o->metadata[i].u.str);
+            exit_program(1);
+        }
+        *val++ = 0;
+
+        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);
+        if (type == 's') {
+            for (int j = 0; j < oc->nb_streams; j++) {
+                OutputStream *ost = output_streams[nb_output_streams - oc->nb_streams + j];
+                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {
+                    if (!strcmp(o->metadata[i].u.str, "rotate")) {
+                        char *tail;
+                        double theta = av_strtod(val, &tail);
+                        if (!*tail) {
+                            ost->rotate_overridden = 1;
+                            ost->rotate_override_value = theta;
+                        }
+                    } else {
+                        av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);
+                    }
+                } else if (ret < 0)
+                    exit_program(1);
+            }
+        } else {
+            switch (type) {
+            case 'g':
+                m = &oc->metadata;
+                break;
+            case 'c':
+                if (index < 0 || index >= oc->nb_chapters) {
+                    av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index);
+                    exit_program(1);
+                }
+                m = &oc->chapters[index]->metadata;
+                break;
+            case 'p':
+                if (index < 0 || index >= oc->nb_programs) {
+                    av_log(NULL, AV_LOG_FATAL, "Invalid program index %d in metadata specifier.\n", index);
+                    exit_program(1);
+                }
+                m = &oc->programs[index]->metadata;
+                break;
+            default:
+                av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", o->metadata[i].specifier);
+                exit_program(1);
+            }
+            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);
+        }
+    }
+}
+
+static int open_output_file(OptionsContext *o, const char *filename)
+{
+    AVFormatContext *oc;
+    int i, j, err;
+    OutputFile *of;
+    AVDictionary *unused_opts = NULL, *format_opts = NULL;
+    const AVDictionaryEntry *e = NULL;
+
+    if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) {
+        o->stop_time = INT64_MAX;
+        av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n");
+    }
+
+    if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) {
+        int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time;
+        if (o->stop_time <= start_time) {
+            av_log(NULL, AV_LOG_ERROR, "-to value smaller than -ss; aborting.\n");
+            exit_program(1);
+        } else {
+            o->recording_time = o->stop_time - start_time;
+        }
+    }
+
+    of = ALLOC_ARRAY_ELEM(output_files, nb_output_files);
+
+    of->index          = nb_output_files - 1;
+    of->ost_index      = nb_output_streams;
+    of->recording_time = o->recording_time;
+    of->start_time     = o->start_time;
+    of->shortest       = o->shortest;
+    av_dict_copy(&format_opts, o->g->format_opts, 0);
+
+    if (!strcmp(filename, "-"))
+        filename = "pipe:";
+
+    err = avformat_alloc_output_context2(&oc, NULL, o->format, filename);
+    if (!oc) {
+        print_error(filename, err);
+        exit_program(1);
+    }
+
+    of->format = oc->oformat;
+    if (o->recording_time != INT64_MAX)
+        oc->duration = o->recording_time;
+
+    oc->interrupt_callback = int_cb;
+
+    if (o->bitexact) {
+        oc->flags    |= AVFMT_FLAG_BITEXACT;
+        of->bitexact  = 1;
+    } else {
+        of->bitexact  = check_opt_bitexact(oc, format_opts, "fflags",
+                                           AVFMT_FLAG_BITEXACT);
+    }
+
+    /* create streams for all unlabeled output pads */
+    for (i = 0; i < nb_filtergraphs; i++) {
+        FilterGraph *fg = filtergraphs[i];
+        for (j = 0; j < fg->nb_outputs; j++) {
+            OutputFilter *ofilter = fg->outputs[j];
+
+            if (!ofilter->out_tmp || ofilter->out_tmp->name)
+                continue;
+
+            switch (ofilter->type) {
+            case AVMEDIA_TYPE_VIDEO:    o->video_disable    = 1; break;
+            case AVMEDIA_TYPE_AUDIO:    o->audio_disable    = 1; break;
+            case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break;
+            }
+            init_output_filter(ofilter, o, oc);
+        }
+    }
+
+    if (!o->nb_stream_maps) {
+        /* pick the "best" stream of each type */
+        if (!o->video_disable)
+            map_auto_video(of, oc, o);
+        if (!o->audio_disable)
+            map_auto_audio(of, oc, o);
+        if (!o->subtitle_disable)
+            map_auto_subtitle(of, oc, o);
+        if (!o->data_disable)
+            map_auto_data(of, oc, o);
+    } else {
+        for (int i = 0; i < o->nb_stream_maps; i++)
+            map_manual(of, oc, o, &o->stream_maps[i]);
+    }
+
+    of_add_attachments(oc, o);
 
     if (!oc->nb_streams && !(oc->oformat->flags & AVFMT_NOSTREAMS)) {
         av_dump_format(oc, nb_output_files - 1, oc->url, 1);
@@ -2764,7 +3008,7 @@ loop_end:
     for (i = of->ost_index; i < nb_output_streams; i++) {
         OutputStream *ost = output_streams[i];
 
-        if (ost->encoding_needed && ost->source_index >= 0) {
+        if (ost->enc_ctx && ost->source_index >= 0) {
             InputStream *ist = input_streams[ost->source_index];
             ist->decoding_needed |= DECODING_FOR_OST;
             ist->processing_needed = 1;
@@ -2780,7 +3024,7 @@ loop_end:
                     exit_program(1);
                 }
             }
-        } else if (ost->stream_copy && ost->source_index >= 0) {
+        } else if (ost->source_index >= 0) {
             InputStream *ist = input_streams[ost->source_index];
             ist->processing_needed = 1;
         }
@@ -2811,7 +3055,7 @@ loop_end:
                     f->sample_rates = ost->enc->supported_samplerates;
                 }
                 if (ost->enc_ctx->ch_layout.nb_channels) {
-                    set_channel_layout(f, ost);
+                    av_channel_layout_default(&f->ch_layout, ost->enc_ctx->ch_layout.nb_channels);
                 } else if (ost->enc->ch_layouts) {
                     f->ch_layouts = ost->enc->ch_layouts;
                 }
@@ -2841,7 +3085,7 @@ loop_end:
         /* open the file */
         if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE,
                               &oc->interrupt_callback,
-                              &of->opts)) < 0) {
+                              &format_opts)) < 0) {
             print_error(filename, err);
             exit_program(1);
         }
@@ -2849,7 +3093,7 @@ loop_end:
         assert_file_overwrite(filename);
 
     if (o->mux_preload) {
-        av_dict_set_int(&of->opts, "preload", o->mux_preload*AV_TIME_BASE, 0);
+        av_dict_set_int(&format_opts, "preload", o->mux_preload*AV_TIME_BASE, 0);
     }
     oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE);
 
@@ -2905,141 +3149,32 @@ loop_end:
                 continue;
             ist = input_streams[output_streams[i]->source_index];
             av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE);
-            if (!output_streams[i]->stream_copy) {
+            if (output_streams[i]->enc_ctx) {
                 av_dict_set(&output_streams[i]->st->metadata, "encoder", NULL, 0);
             }
         }
 
-    /* process manually set programs */
-    for (i = 0; i < o->nb_program; i++) {
-        const char *p = o->program[i].u.str;
-        int progid = i+1;
-        AVProgram *program;
+    of_add_programs(oc, o);
+    of_add_metadata(oc, o);
 
-        while(*p) {
-            const char *p2 = av_get_token(&p, ":");
-            const char *to_dealloc = p2;
-            char *key;
-            if (!p2)
-                break;
-
-            if(*p) p++;
-
-            key = av_get_token(&p2, "=");
-            if (!key || !*p2) {
-                av_freep(&to_dealloc);
-                av_freep(&key);
-                break;
-            }
-            p2++;
-
-            if (!strcmp(key, "program_num"))
-                progid = strtol(p2, NULL, 0);
-            av_freep(&to_dealloc);
-            av_freep(&key);
-        }
-
-        program = av_new_program(oc, progid);
-
-        p = o->program[i].u.str;
-        while(*p) {
-            const char *p2 = av_get_token(&p, ":");
-            const char *to_dealloc = p2;
-            char *key;
-            if (!p2)
-                break;
-            if(*p) p++;
-
-            key = av_get_token(&p2, "=");
-            if (!key) {
-                av_log(NULL, AV_LOG_FATAL,
-                       "No '=' character in program string %s.\n",
-                       p2);
-                exit_program(1);
-            }
-            if (!*p2)
-                exit_program(1);
-            p2++;
-
-            if (!strcmp(key, "title")) {
-                av_dict_set(&program->metadata, "title", p2, 0);
-            } else if (!strcmp(key, "program_num")) {
-            } else if (!strcmp(key, "st")) {
-                int st_num = strtol(p2, NULL, 0);
-                av_program_add_stream_index(oc, progid, st_num);
-            } else {
-                av_log(NULL, AV_LOG_FATAL, "Unknown program key %s.\n", key);
-                exit_program(1);
-            }
-            av_freep(&to_dealloc);
-            av_freep(&key);
-        }
+    err = set_dispositions(of, oc);
+    if (err < 0) {
+        av_log(NULL, AV_LOG_FATAL, "Error setting output stream dispositions\n");
+        exit_program(1);
     }
 
-    /* process manually set metadata */
-    for (i = 0; i < o->nb_metadata; i++) {
-        AVDictionary **m;
-        char type, *val;
-        const char *stream_spec;
-        int index = 0, j, ret = 0;
-
-        val = strchr(o->metadata[i].u.str, '=');
-        if (!val) {
-            av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n",
-                   o->metadata[i].u.str);
-            exit_program(1);
-        }
-        *val++ = 0;
-
-        parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec);
-        if (type == 's') {
-            for (j = 0; j < oc->nb_streams; j++) {
-                ost = output_streams[nb_output_streams - oc->nb_streams + j];
-                if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) {
-                    if (!strcmp(o->metadata[i].u.str, "rotate")) {
-                        char *tail;
-                        double theta = av_strtod(val, &tail);
-                        if (!*tail) {
-                            ost->rotate_overridden = 1;
-                            ost->rotate_override_value = theta;
-                        }
-                    } else {
-                        av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0);
-                    }
-                } else if (ret < 0)
-                    exit_program(1);
-            }
-        }
-        else {
-            switch (type) {
-            case 'g':
-                m = &oc->metadata;
-                break;
-            case 'c':
-                if (index < 0 || index >= oc->nb_chapters) {
-                    av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index);
-                    exit_program(1);
-                }
-                m = &oc->chapters[index]->metadata;
-                break;
-            case 'p':
-                if (index < 0 || index >= oc->nb_programs) {
-                    av_log(NULL, AV_LOG_FATAL, "Invalid program index %d in metadata specifier.\n", index);
-                    exit_program(1);
-                }
-                m = &oc->programs[index]->metadata;
-                break;
-            default:
-                av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", o->metadata[i].specifier);
-                exit_program(1);
-            }
-            av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0);
-        }
+    err = setup_sync_queues(of, oc, o->shortest_buf_duration * AV_TIME_BASE);
+    if (err < 0) {
+        av_log(NULL, AV_LOG_FATAL, "Error setting up output sync queues\n");
+        exit_program(1);
     }
 
-    err = set_dispositions(of, oc);
+    of->nb_streams = oc->nb_streams;
+    of->url        = filename;
+
+    err = of_muxer_init(of, oc, format_opts, o->limit_filesize, o->thread_queue_size);
     if (err < 0) {
-        av_log(NULL, AV_LOG_FATAL, "Error setting output stream dispositions\n");
+        av_log(NULL, AV_LOG_FATAL, "Error initializing internal muxing state\n");
         exit_program(1);
     }
 
@@ -3667,8 +3802,10 @@ const OptionDef options[] = {
                         OPT_OUTPUT,                                  { .func_arg = opt_map },
         "set input stream mapping",
         "[-]input_file_id[:stream_specifier][,sync_file_id[:stream_specifier]]" },
+#if FFMPEG_OPT_MAP_CHANNEL
     { "map_channel",    HAS_ARG | OPT_EXPERT | OPT_PERFILE | OPT_OUTPUT, { .func_arg = opt_map_channel },
-        "map an audio channel from one stream to another", "file.stream.channel[:syncfile.syncstream]" },
+        "map an audio channel from one stream to another (deprecated)", "file.stream.channel[:syncfile.syncstream]" },
+#endif
     { "map_metadata",   HAS_ARG | OPT_STRING | OPT_SPEC |
                         OPT_OUTPUT,                                  { .off       = OFFSET(metadata_map) },
         "set metadata information of outfile from infile",
@@ -3754,6 +3891,8 @@ const OptionDef options[] = {
     { "shortest",       OPT_BOOL | OPT_EXPERT | OPT_OFFSET |
                         OPT_OUTPUT,                                  { .off = OFFSET(shortest) },
         "finish encoding within shortest input" },
+    { "shortest_buf_duration", HAS_ARG | OPT_FLOAT | OPT_EXPERT | OPT_OFFSET | OPT_OUTPUT, { .off = OFFSET(shortest_buf_duration) },
+        "maximum buffering duration (in seconds) for the -shortest option" },
     { "bitexact",       OPT_BOOL | OPT_EXPERT | OPT_OFFSET |
                         OPT_OUTPUT | OPT_INPUT,                      { .off = OFFSET(bitexact) },
         "bitexact mode" },
@@ -3826,7 +3965,7 @@ const OptionDef options[] = {
     { "disposition",    OPT_STRING | HAS_ARG | OPT_SPEC |
                         OPT_OUTPUT,                                  { .off = OFFSET(disposition) },
         "disposition", "" },
-    { "thread_queue_size", HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT,
+    { "thread_queue_size", HAS_ARG | OPT_INT | OPT_OFFSET | OPT_EXPERT | OPT_INPUT | OPT_OUTPUT,
                                                                      { .off = OFFSET(thread_queue_size) },
         "set the maximum number of queued packets from the demuxer" },
     { "find_stream_info", OPT_BOOL | OPT_PERFILE | OPT_INPUT | OPT_EXPERT, { &find_stream_info },
@@ -3868,8 +4007,10 @@ const OptionDef options[] = {
     { "passlogfile",  OPT_VIDEO | HAS_ARG | OPT_STRING | OPT_EXPERT | OPT_SPEC |
                       OPT_OUTPUT,                                                { .off = OFFSET(passlogfiles) },
         "select two pass log file name prefix", "prefix" },
+#if FFMPEG_OPT_PSNR
     { "psnr",         OPT_VIDEO | OPT_BOOL | OPT_EXPERT,                         { &do_psnr },
-        "calculate PSNR of compressed frames" },
+        "calculate PSNR of compressed frames (deprecated, use -flags +psnr)" },
+#endif
     { "vstats",       OPT_VIDEO | OPT_EXPERT ,                                   { .func_arg = opt_vstats },
         "dump video coding statistics to file" },
     { "vstats_file",  OPT_VIDEO | HAS_ARG | OPT_EXPERT ,                         { .func_arg = opt_vstats_file },
@@ -3948,8 +4089,6 @@ const OptionDef options[] = {
     { "atag",           OPT_AUDIO | HAS_ARG  | OPT_EXPERT | OPT_PERFILE |
                         OPT_OUTPUT,                                                { .func_arg = opt_old2new },
         "force audio tag/fourcc", "fourcc/tag" },
-    { "vol",            OPT_AUDIO | HAS_ARG  | OPT_INT,                            { &audio_volume },
-        "change audio volume (256=normal)" , "volume" },
     { "sample_fmt",     OPT_AUDIO | HAS_ARG  | OPT_EXPERT | OPT_SPEC |
                         OPT_STRING | OPT_INPUT | OPT_OUTPUT,                       { .off = OFFSET(sample_fmts) },
         "set sample format", "format" },
diff --git a/fftools/ffmpeg_wrap.c b/fftools/ffmpeg_wrap.c
new file mode 100644
index 0000000..cee50da
--- /dev/null
+++ b/fftools/ffmpeg_wrap.c
@@ -0,0 +1,274 @@
+#ifdef HAVE_AV_CONFIG_H
+// ffmpeg make will go here
+#include "config.h"
+#include "config_components.h"
+
+#include <time.h>
+#include <errno.h>
+
+// for ffmpeg build
+#include "cmdutils.h"
+const char program_name[] = "ffmpeg_wrap";
+const int program_birth_year = 2022;
+void show_help_default(const char *opt, const char *arg) {}
+
+#endif
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <unistd.h>
+
+#define ACTION_MASK 0x0FF00
+#define ARG_MASK 0x00FF
+
+typedef enum {
+    CONTINUE=0x0000,
+    DROP=0x0100,
+    EXTEND=0x0200,
+    BREAK=0x0400,
+} ACTION;
+
+const char* BARGS[]={"-x264opts:0", "-pix_fmt", "-preset", "-crf", NULL};
+const char* BFLAGS[]={NULL};
+
+static int arg_filter (const char **arg) {
+    for(const char** p=BARGS;*p != NULL;++p) {
+        if (!strcmp(*p, *arg)) {
+            return DROP|0x2;
+        }
+    }
+    return CONTINUE;
+}
+
+static int flag_filter (const char **arg) {
+    for(const char** p=BFLAGS;*p != NULL;++p) {
+        if (!strcmp(*p, *arg)) {
+            return DROP|0x1;
+        }
+    }
+    return CONTINUE;
+}
+
+char scale_rga[32] = {0};
+int libx264_to_mpp = 0;
+int has_input = 0;
+int skip_video = 0;
+int image_dump = 0;
+int h264_image_dump = 0;
+int dump_attachment = 0;
+int copy_video = 0;
+int copy_audio = 0;
+int aac = 0;
+int hls = 0;
+int tonemap = 0;
+int thumbnail = 0;
+int ext_c;
+const char* ext_v[16];
+
+static char* bufprintf(const char* fmt, ...) {
+    static char buf[512] = {0};
+    static char *p = buf;
+    int count;
+    char *ret = p;
+    va_list va;
+    va_start(va, fmt);
+    count = vsprintf(p, fmt, va);
+    va_end(va);
+    if (count > 0) {
+        p += (count + 1);
+    } else if (count < 0){
+        return NULL;
+    } else {
+        *p = '\0';
+    }
+    return ret;
+}
+
+static int conv(const char **arg) {
+    int w,h;
+    const char *p = NULL;
+    if (!strcmp("-vf", *arg) || !strcmp("-filter_complex", *arg)) {
+#if CONFIG_SCALE_RGA_FILTER
+        if (!strcmp("-vf", *arg)) {
+            if (strstr(arg[1], "tonemap=")) {
+                tonemap = 1;
+            }
+            if (strstr(arg[1], "thumbnail=")) {
+                thumbnail = 1;
+            }
+        }
+        p = strstr(arg[1], "scale=trunc(");
+
+        if (p) {
+            if (1 != sscanf(p, "scale=trunc(min(max(iw\\,ih*dar)\\,%d)/2)*2:trunc(ow/dar/2)*2", &w) &&
+                1 != sscanf(p, "scale=trunc(min(max(iw,ih*dar),%d)/2)*2:trunc(ow/dar/2)*2", &w) &&
+                1 != sscanf(p, "scale=trunc(min(max(iw\\,ih*a)\\,%d)/2)*2:trunc(ow/a/2)*2", &w) &&
+                1 != sscanf(p, "scale=trunc(min(max(iw,ih*a),%d)/2)*2:trunc(ow/a/2)*2", &w) &&
+                1 != sscanf(p, "scale=trunc(min(max(iw\\,ih*dar)\\,min(%d\\,", &w) &&
+                1 != sscanf(p, "scale=trunc(min(max(iw,ih*dar),min(%d,", &w)) {
+                w = 1920;
+            }
+            if (w > 1920) {
+                w = 1920;
+            } else if (w < 256) {
+                w = 256;
+            } else {
+                w = w / 2 * 2;
+            }
+            h = w * 9 / 32 * 2;
+            sprintf(scale_rga, "scale_rga=%dx%d", w, h);
+            return DROP|0x2;
+        }
+#endif
+        return DROP|0x2;
+    } else if (!strncmp("-codec:v:", *arg, 9)) {
+        if (!strcmp("libx264", arg[1])) {
+            libx264_to_mpp = 1;
+            ext_c = 0;
+#if CONFIG_SCALE_RGA_FILTER
+            if ('\0' == scale_rga[0])
+                strcpy(scale_rga, "scale_rga=1920x1080");
+            ext_v[ext_c++] = "-vf";
+            ext_v[ext_c++] = scale_rga;
+#endif
+            ext_v[ext_c++] = *arg;
+            ext_v[ext_c++] = "h264_rkmpp";
+            ext_v[ext_c++] = "-flags:v";
+            ext_v[ext_c++] = "-global_header";
+            return EXTEND|DROP|0x2;
+        } else if (!strcmp("h264", arg[1])) {
+            h264_image_dump = 1;
+            return DROP|0x2;
+        } else if (!strcmp("copy", arg[1])) {
+            copy_video = 1;
+        }
+#if CONFIG_LIBFDK_AAC_ENCODER
+    } else if (!strcmp("-codec:a:0", *arg)) {
+        if (!strcmp("aac", arg[1]) || !strcmp("libfdk_aac", arg[1])) {
+            aac = 1;
+            ext_c = 0;
+            ext_v[ext_c++] = "-codec:a:0";
+            ext_v[ext_c++] = "libfdk_aac";
+            if (hls) {
+                ext_v[ext_c++] = "-flags:a";
+                ext_v[ext_c++] = "-global_header";
+            }
+            return EXTEND|DROP|0x2;
+        }
+#endif
+    } else if (has_input && !strcmp("-f", *arg)) {
+        if (!strcmp("hls", arg[1])) {
+            hls = 1;
+            if (aac) {
+                ext_c = 2;
+                ext_v[0] = "-flags:a";
+                ext_v[1] = "-global_header";
+                return EXTEND;
+            }
+        }
+#if CONFIG_SCALE_RGA_FILTER
+        else if (!strcmp("image2", arg[1])) {
+            ext_c = 2;
+            ext_v[0] = "-vf";
+            ext_v[1] = "scale_rga=1280x720,hwdownload,scale";
+            return EXTEND;
+        }
+#endif
+    } else if (!strcmp("-maxrate", *arg)) {
+        if (libx264_to_mpp) {
+            h = atoi(arg[1]);
+            ext_c = 2;
+            ext_v[0] = "-b:v";
+            if (h < 2000000)
+                ext_v[1] = arg[1];
+            else
+                ext_v[1] = bufprintf("%d", h - 640000);
+            return EXTEND|CONTINUE;
+        }
+    } else if (!strcmp("-vframes", *arg)) {
+        if (!strcmp("1", arg[1])) {
+            image_dump = 1;
+        }
+    } else if (!strcmp("-i", *arg)) {
+        has_input = 1;
+    } else if (!strncmp("-dump_attachment:", *arg, 17)) {
+        dump_attachment = 1;
+        return BREAK;
+    } else if (!strcmp("-vn", *arg)) {
+        skip_video = 1;
+    } else if (!strcmp("-acodec", *arg)) {
+        if (!strcmp("copy", arg[1])) {
+            copy_audio = 1;
+        }
+    } else if (!strcmp("-fflags", *arg)) {
+        if (!strcmp("+igndts+genpts", arg[1])) {
+            return DROP|0x2;
+        }
+    } else if (!strcmp("-analyzeduration", *arg)) {
+        ext_c = 0;
+        ext_v[ext_c++] = "-analyzeduration";
+        ext_v[ext_c++] = "10000000";
+        ext_v[ext_c++] = "-probesize";
+        ext_v[ext_c++] = "10000000";
+        return EXTEND|DROP|0x2;
+    }
+    return CONTINUE;
+}
+
+typedef int (*Filter)(const char **) ;
+
+Filter filters[]={conv, arg_filter, flag_filter, NULL};
+
+#define MAX_MPP_DEC_ARGC 0
+
+static int conv_opts(int argc, const char **argv, const char* nargv[]) {
+    int nargc = MAX_MPP_DEC_ARGC+1;
+    for (int i=1; i<argc; ++i) {
+        Filter *f;
+        for (f = filters; *f != NULL; ++f) {
+            int r = (*f)(argv+i);
+            if (BREAK == r) {
+                return MAX_MPP_DEC_ARGC+1;
+            }
+            if (EXTEND == (r & EXTEND)) {
+                for (int j=0; j<ext_c; ++j) {
+                    nargv[nargc++] = ext_v[j];
+                }
+            }
+            if (DROP == (r & DROP)) {
+                i += (r & ARG_MASK) - 1;
+                break;
+            }
+        }
+
+        if (*f == NULL) {
+            nargv[nargc++] = argv[i];
+        }
+    }
+    return nargc;
+}
+
+int main(int argc, const char **argv)
+{
+    const char* nargv[128];
+    int pargc = 0;
+    int nargc = conv_opts(argc, argv, nargv);
+
+    if (!dump_attachment) {
+        nargv[nargc] = NULL;
+        nargv[MAX_MPP_DEC_ARGC - pargc] = "ffmpeg";
+        argv = nargv+(MAX_MPP_DEC_ARGC - pargc);
+    }
+    const char **p = argv;
+    fprintf(stderr, "\n%s", *p);
+    for (++p; *p != NULL; ++p) {
+        fprintf(stderr, " \"%s\"", *p);
+    }
+    fprintf(stderr, "\n");
+#ifndef HAVE_AV_CONFIG_H
+    return 0;
+#else
+    return execvp("ffmpeg.mpp", argv);
+#endif
+}
diff --git a/fftools/ffprobe.c b/fftools/ffprobe.c
index 608d905..8983dc2 100644
--- a/fftools/ffprobe.c
+++ b/fftools/ffprobe.c
@@ -2570,8 +2570,14 @@ static void show_frame(WriterContext *w, AVFrame *frame, AVStream *stream,
     print_time("pkt_dts_time",          frame->pkt_dts, &stream->time_base);
     print_ts  ("best_effort_timestamp", frame->best_effort_timestamp);
     print_time("best_effort_timestamp_time", frame->best_effort_timestamp, &stream->time_base);
+#if LIBAVUTIL_VERSION_MAJOR < 58
+    AV_NOWARN_DEPRECATED(
     print_duration_ts  ("pkt_duration",      frame->pkt_duration);
     print_duration_time("pkt_duration_time", frame->pkt_duration, &stream->time_base);
+    )
+#endif
+    print_duration_ts  ("duration",          frame->duration);
+    print_duration_time("duration_time",     frame->duration, &stream->time_base);
     if (frame->pkt_pos != -1) print_fmt    ("pkt_pos", "%"PRId64, frame->pkt_pos);
     else                      print_str_opt("pkt_pos", "N/A");
     if (frame->pkt_size != -1) print_val    ("pkt_size", frame->pkt_size, unit_byte_str);
diff --git a/fftools/fftools.manifest b/fftools/fftools.manifest
new file mode 100644
index 0000000..f2708ec
--- /dev/null
+++ b/fftools/fftools.manifest
@@ -0,0 +1,9 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0" xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
+  <asmv3:application>
+    <asmv3:windowsSettings>
+      <dpiAware xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">true</dpiAware>
+      <dpiAwareness xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">PerMonitorV2</dpiAwareness>
+    </asmv3:windowsSettings>
+  </asmv3:application>
+</assembly>
diff --git a/fftools/fftoolsres.rc b/fftools/fftoolsres.rc
new file mode 100644
index 0000000..0b8b7c8
--- /dev/null
+++ b/fftools/fftoolsres.rc
@@ -0,0 +1,2 @@
+#include <windows.h>
+1 RT_MANIFEST fftools.manifest
diff --git a/fftools/objpool.c b/fftools/objpool.c
new file mode 100644
index 0000000..87237cf
--- /dev/null
+++ b/fftools/objpool.c
@@ -0,0 +1,131 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+
+#include "libavcodec/packet.h"
+
+#include "libavutil/common.h"
+#include "libavutil/error.h"
+#include "libavutil/frame.h"
+#include "libavutil/mem.h"
+
+#include "objpool.h"
+
+struct ObjPool {
+    void        *pool[32];
+    unsigned int pool_count;
+
+    ObjPoolCBAlloc alloc;
+    ObjPoolCBReset reset;
+    ObjPoolCBFree  free;
+};
+
+ObjPool *objpool_alloc(ObjPoolCBAlloc cb_alloc, ObjPoolCBReset cb_reset,
+                       ObjPoolCBFree cb_free)
+{
+    ObjPool *op = av_mallocz(sizeof(*op));
+
+    if (!op)
+        return NULL;
+
+    op->alloc = cb_alloc;
+    op->reset = cb_reset;
+    op->free  = cb_free;
+
+    return op;
+}
+
+void objpool_free(ObjPool **pop)
+{
+    ObjPool *op = *pop;
+
+    if (!op)
+        return;
+
+    for (unsigned int i = 0; i < op->pool_count; i++)
+        op->free(&op->pool[i]);
+
+    av_freep(pop);
+}
+
+int  objpool_get(ObjPool *op, void **obj)
+{
+    if (op->pool_count) {
+        *obj = op->pool[--op->pool_count];
+        op->pool[op->pool_count] = NULL;
+    } else
+        *obj = op->alloc();
+
+    return *obj ? 0 : AVERROR(ENOMEM);
+}
+
+void objpool_release(ObjPool *op, void **obj)
+{
+    if (!*obj)
+        return;
+
+    op->reset(*obj);
+
+    if (op->pool_count < FF_ARRAY_ELEMS(op->pool))
+        op->pool[op->pool_count++] = *obj;
+    else
+        op->free(obj);
+
+    *obj = NULL;
+}
+
+static void *alloc_packet(void)
+{
+    return av_packet_alloc();
+}
+static void *alloc_frame(void)
+{
+    return av_frame_alloc();
+}
+
+static void reset_packet(void *obj)
+{
+    av_packet_unref(obj);
+}
+static void reset_frame(void *obj)
+{
+    av_frame_unref(obj);
+}
+
+static void free_packet(void **obj)
+{
+    AVPacket *pkt = *obj;
+    av_packet_free(&pkt);
+    *obj = NULL;
+}
+static void free_frame(void **obj)
+{
+    AVFrame *frame = *obj;
+    av_frame_free(&frame);
+    *obj = NULL;
+}
+
+ObjPool *objpool_alloc_packets(void)
+{
+    return objpool_alloc(alloc_packet, reset_packet, free_packet);
+}
+ObjPool *objpool_alloc_frames(void)
+{
+    return objpool_alloc(alloc_frame, reset_frame, free_frame);
+}
diff --git a/fftools/objpool.h b/fftools/objpool.h
new file mode 100644
index 0000000..1b2aea6
--- /dev/null
+++ b/fftools/objpool.h
@@ -0,0 +1,37 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFTOOLS_OBJPOOL_H
+#define FFTOOLS_OBJPOOL_H
+
+typedef struct ObjPool ObjPool;
+
+typedef void* (*ObjPoolCBAlloc)(void);
+typedef void  (*ObjPoolCBReset)(void *);
+typedef void  (*ObjPoolCBFree)(void **);
+
+void     objpool_free(ObjPool **op);
+ObjPool *objpool_alloc(ObjPoolCBAlloc cb_alloc, ObjPoolCBReset cb_reset,
+                       ObjPoolCBFree cb_free);
+ObjPool *objpool_alloc_packets(void);
+ObjPool *objpool_alloc_frames(void);
+
+int  objpool_get(ObjPool *op, void **obj);
+void objpool_release(ObjPool *op, void **obj);
+
+#endif // FFTOOLS_OBJPOOL_H
diff --git a/fftools/sync_queue.c b/fftools/sync_queue.c
new file mode 100644
index 0000000..c2b23ee
--- /dev/null
+++ b/fftools/sync_queue.c
@@ -0,0 +1,448 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include <string.h>
+
+#include "libavutil/avassert.h"
+#include "libavutil/error.h"
+#include "libavutil/fifo.h"
+#include "libavutil/mathematics.h"
+#include "libavutil/mem.h"
+
+#include "objpool.h"
+#include "sync_queue.h"
+
+typedef struct SyncQueueStream {
+    AVFifo          *fifo;
+    AVRational       tb;
+
+    /* stream head: largest timestamp seen */
+    int64_t          head_ts;
+    int              limiting;
+    /* no more frames will be sent for this stream */
+    int              finished;
+
+    uint64_t         frames_sent;
+    uint64_t         frames_max;
+} SyncQueueStream;
+
+struct SyncQueue {
+    enum SyncQueueType type;
+
+    /* no more frames will be sent for any stream */
+    int finished;
+    /* sync head: the stream with the _smallest_ head timestamp
+     * this stream determines which frames can be output */
+    int head_stream;
+    /* the finished stream with the smallest finish timestamp or -1 */
+    int head_finished_stream;
+
+    // maximum buffering duration in microseconds
+    int64_t buf_size_us;
+
+    SyncQueueStream *streams;
+    unsigned int  nb_streams;
+
+    // pool of preallocated frames to avoid constant allocations
+    ObjPool *pool;
+};
+
+static void frame_move(const SyncQueue *sq, SyncQueueFrame dst,
+                       SyncQueueFrame src)
+{
+    if (sq->type == SYNC_QUEUE_PACKETS)
+        av_packet_move_ref(dst.p, src.p);
+    else
+        av_frame_move_ref(dst.f, src.f);
+}
+
+static int64_t frame_ts(const SyncQueue *sq, SyncQueueFrame frame)
+{
+    return (sq->type == SYNC_QUEUE_PACKETS) ?
+           frame.p->pts + frame.p->duration :
+           frame.f->pts + frame.f->duration;
+}
+
+static int frame_null(const SyncQueue *sq, SyncQueueFrame frame)
+{
+    return (sq->type == SYNC_QUEUE_PACKETS) ? (frame.p == NULL) : (frame.f == NULL);
+}
+
+static void finish_stream(SyncQueue *sq, unsigned int stream_idx)
+{
+    SyncQueueStream *st = &sq->streams[stream_idx];
+
+    st->finished = 1;
+
+    if (st->limiting && st->head_ts != AV_NOPTS_VALUE) {
+        /* check if this stream is the new finished head */
+        if (sq->head_finished_stream < 0 ||
+            av_compare_ts(st->head_ts, st->tb,
+                          sq->streams[sq->head_finished_stream].head_ts,
+                          sq->streams[sq->head_finished_stream].tb) < 0) {
+            sq->head_finished_stream = stream_idx;
+        }
+
+        /* mark as finished all streams that should no longer receive new frames,
+         * due to them being ahead of some finished stream */
+        st = &sq->streams[sq->head_finished_stream];
+        for (unsigned int i = 0; i < sq->nb_streams; i++) {
+            SyncQueueStream *st1 = &sq->streams[i];
+            if (st != st1 && st1->head_ts != AV_NOPTS_VALUE &&
+                av_compare_ts(st->head_ts, st->tb, st1->head_ts, st1->tb) <= 0)
+                st1->finished = 1;
+        }
+    }
+
+    /* mark the whole queue as finished if all streams are finished */
+    for (unsigned int i = 0; i < sq->nb_streams; i++) {
+        if (!sq->streams[i].finished)
+            return;
+    }
+    sq->finished = 1;
+}
+
+static void queue_head_update(SyncQueue *sq)
+{
+    if (sq->head_stream < 0) {
+        /* wait for one timestamp in each stream before determining
+         * the queue head */
+        for (unsigned int i = 0; i < sq->nb_streams; i++) {
+            SyncQueueStream *st = &sq->streams[i];
+            if (st->limiting && st->head_ts == AV_NOPTS_VALUE)
+                return;
+        }
+
+        // placeholder value, correct one will be found below
+        sq->head_stream = 0;
+    }
+
+    for (unsigned int i = 0; i < sq->nb_streams; i++) {
+        SyncQueueStream *st_head  = &sq->streams[sq->head_stream];
+        SyncQueueStream *st_other = &sq->streams[i];
+        if (st_other->limiting && st_other->head_ts != AV_NOPTS_VALUE &&
+            av_compare_ts(st_other->head_ts, st_other->tb,
+                          st_head->head_ts,  st_head->tb) < 0)
+            sq->head_stream = i;
+    }
+}
+
+/* update this stream's head timestamp */
+static void stream_update_ts(SyncQueue *sq, unsigned int stream_idx, int64_t ts)
+{
+    SyncQueueStream *st = &sq->streams[stream_idx];
+
+    if (ts == AV_NOPTS_VALUE ||
+        (st->head_ts != AV_NOPTS_VALUE && st->head_ts >= ts))
+        return;
+
+    st->head_ts = ts;
+
+    /* if this stream is now ahead of some finished stream, then
+     * this stream is also finished */
+    if (sq->head_finished_stream >= 0 &&
+        av_compare_ts(sq->streams[sq->head_finished_stream].head_ts,
+                      sq->streams[sq->head_finished_stream].tb,
+                      ts, st->tb) <= 0)
+        finish_stream(sq, stream_idx);
+
+    /* update the overall head timestamp if it could have changed */
+    if (st->limiting &&
+        (sq->head_stream < 0 || sq->head_stream == stream_idx))
+        queue_head_update(sq);
+}
+
+/* If the queue for the given stream (or all streams when stream_idx=-1)
+ * is overflowing, trigger a fake heartbeat on lagging streams.
+ *
+ * @return 1 if heartbeat triggered, 0 otherwise
+ */
+static int overflow_heartbeat(SyncQueue *sq, int stream_idx)
+{
+    SyncQueueStream *st;
+    SyncQueueFrame frame;
+    int64_t tail_ts = AV_NOPTS_VALUE;
+
+    /* if no stream specified, pick the one that is most ahead */
+    if (stream_idx < 0) {
+        int64_t ts = AV_NOPTS_VALUE;
+
+        for (int i = 0; i < sq->nb_streams; i++) {
+            st = &sq->streams[i];
+            if (st->head_ts != AV_NOPTS_VALUE &&
+                (ts == AV_NOPTS_VALUE ||
+                 av_compare_ts(ts, sq->streams[stream_idx].tb,
+                               st->head_ts, st->tb) < 0)) {
+                ts = st->head_ts;
+                stream_idx = i;
+            }
+        }
+        /* no stream has a timestamp yet -> nothing to do */
+        if (stream_idx < 0)
+            return 0;
+    }
+
+    st = &sq->streams[stream_idx];
+
+    /* get the chosen stream's tail timestamp */
+    for (size_t i = 0; tail_ts == AV_NOPTS_VALUE &&
+                       av_fifo_peek(st->fifo, &frame, 1, i) >= 0; i++)
+        tail_ts = frame_ts(sq, frame);
+
+    /* overflow triggers when the tail is over specified duration behind the head */
+    if (tail_ts == AV_NOPTS_VALUE || tail_ts >= st->head_ts ||
+        av_rescale_q(st->head_ts - tail_ts, st->tb, AV_TIME_BASE_Q) < sq->buf_size_us)
+        return 0;
+
+    /* signal a fake timestamp for all streams that prevent tail_ts from being output */
+    tail_ts++;
+    for (unsigned int i = 0; i < sq->nb_streams; i++) {
+        SyncQueueStream *st1 = &sq->streams[i];
+        int64_t ts;
+
+        if (st == st1 || st1->finished ||
+            (st1->head_ts != AV_NOPTS_VALUE &&
+             av_compare_ts(tail_ts, st->tb, st1->head_ts, st1->tb) <= 0))
+            continue;
+
+        ts = av_rescale_q(tail_ts, st->tb, st1->tb);
+        if (st1->head_ts != AV_NOPTS_VALUE)
+            ts = FFMAX(st1->head_ts + 1, ts);
+
+        stream_update_ts(sq, i, ts);
+    }
+
+    return 1;
+}
+
+int sq_send(SyncQueue *sq, unsigned int stream_idx, SyncQueueFrame frame)
+{
+    SyncQueueStream *st;
+    SyncQueueFrame dst;
+    int64_t ts;
+    int ret;
+
+    av_assert0(stream_idx < sq->nb_streams);
+    st = &sq->streams[stream_idx];
+
+    av_assert0(st->tb.num > 0 && st->tb.den > 0);
+
+    if (frame_null(sq, frame)) {
+        finish_stream(sq, stream_idx);
+        return 0;
+    }
+    if (st->finished)
+        return AVERROR_EOF;
+
+    ret = objpool_get(sq->pool, (void**)&dst);
+    if (ret < 0)
+        return ret;
+
+    frame_move(sq, dst, frame);
+
+    ts = frame_ts(sq, dst);
+
+    ret = av_fifo_write(st->fifo, &dst, 1);
+    if (ret < 0) {
+        frame_move(sq, frame, dst);
+        objpool_release(sq->pool, (void**)&dst);
+        return ret;
+    }
+
+    stream_update_ts(sq, stream_idx, ts);
+
+    st->frames_sent++;
+    if (st->frames_sent >= st->frames_max)
+        finish_stream(sq, stream_idx);
+
+    return 0;
+}
+
+static int receive_for_stream(SyncQueue *sq, unsigned int stream_idx,
+                              SyncQueueFrame frame)
+{
+    SyncQueueStream *st_head = sq->head_stream >= 0 ?
+                               &sq->streams[sq->head_stream] : NULL;
+    SyncQueueStream *st;
+
+    av_assert0(stream_idx < sq->nb_streams);
+    st = &sq->streams[stream_idx];
+
+    if (av_fifo_can_read(st->fifo)) {
+        SyncQueueFrame peek;
+        int64_t ts;
+        int cmp = 1;
+
+        av_fifo_peek(st->fifo, &peek, 1, 0);
+        ts = frame_ts(sq, peek);
+
+        /* check if this stream's tail timestamp does not overtake
+         * the overall queue head */
+        if (ts != AV_NOPTS_VALUE && st_head)
+            cmp = av_compare_ts(ts, st->tb, st_head->head_ts, st_head->tb);
+
+        /* We can release frames that do not end after the queue head.
+         * Frames with no timestamps are just passed through with no conditions.
+         */
+        if (cmp <= 0 || ts == AV_NOPTS_VALUE) {
+            frame_move(sq, frame, peek);
+            objpool_release(sq->pool, (void**)&peek);
+            av_fifo_drain2(st->fifo, 1);
+            return 0;
+        }
+    }
+
+    return (sq->finished || (st->finished && !av_fifo_can_read(st->fifo))) ?
+            AVERROR_EOF : AVERROR(EAGAIN);
+}
+
+static int receive_internal(SyncQueue *sq, int stream_idx, SyncQueueFrame frame)
+{
+    int nb_eof = 0;
+    int ret;
+
+    /* read a frame for a specific stream */
+    if (stream_idx >= 0) {
+        ret = receive_for_stream(sq, stream_idx, frame);
+        return (ret < 0) ? ret : stream_idx;
+    }
+
+    /* read a frame for any stream with available output */
+    for (unsigned int i = 0; i < sq->nb_streams; i++) {
+        ret = receive_for_stream(sq, i, frame);
+        if (ret == AVERROR_EOF || ret == AVERROR(EAGAIN)) {
+            nb_eof += (ret == AVERROR_EOF);
+            continue;
+        }
+        return (ret < 0) ? ret : i;
+    }
+
+    return (nb_eof == sq->nb_streams) ? AVERROR_EOF : AVERROR(EAGAIN);
+}
+
+int sq_receive(SyncQueue *sq, int stream_idx, SyncQueueFrame frame)
+{
+    int ret = receive_internal(sq, stream_idx, frame);
+
+    /* try again if the queue overflowed and triggered a fake heartbeat
+     * for lagging streams */
+    if (ret == AVERROR(EAGAIN) && overflow_heartbeat(sq, stream_idx))
+        ret = receive_internal(sq, stream_idx, frame);
+
+    return ret;
+}
+
+int sq_add_stream(SyncQueue *sq, int limiting)
+{
+    SyncQueueStream *tmp, *st;
+
+    tmp = av_realloc_array(sq->streams, sq->nb_streams + 1, sizeof(*sq->streams));
+    if (!tmp)
+        return AVERROR(ENOMEM);
+    sq->streams = tmp;
+
+    st = &sq->streams[sq->nb_streams];
+    memset(st, 0, sizeof(*st));
+
+    st->fifo = av_fifo_alloc2(1, sizeof(SyncQueueFrame), AV_FIFO_FLAG_AUTO_GROW);
+    if (!st->fifo)
+        return AVERROR(ENOMEM);
+
+    /* we set a valid default, so that a pathological stream that never
+     * receives even a real timebase (and no frames) won't stall all other
+     * streams forever; cf. overflow_heartbeat() */
+    st->tb      = (AVRational){ 1, 1 };
+    st->head_ts = AV_NOPTS_VALUE;
+    st->frames_max = UINT64_MAX;
+    st->limiting   = limiting;
+
+    return sq->nb_streams++;
+}
+
+void sq_set_tb(SyncQueue *sq, unsigned int stream_idx, AVRational tb)
+{
+    SyncQueueStream *st;
+
+    av_assert0(stream_idx < sq->nb_streams);
+    st = &sq->streams[stream_idx];
+
+    av_assert0(!av_fifo_can_read(st->fifo));
+
+    if (st->head_ts != AV_NOPTS_VALUE)
+        st->head_ts = av_rescale_q(st->head_ts, st->tb, tb);
+
+    st->tb = tb;
+}
+
+void sq_limit_frames(SyncQueue *sq, unsigned int stream_idx, uint64_t frames)
+{
+    SyncQueueStream *st;
+
+    av_assert0(stream_idx < sq->nb_streams);
+    st = &sq->streams[stream_idx];
+
+    st->frames_max = frames;
+    if (st->frames_sent >= st->frames_max)
+        finish_stream(sq, stream_idx);
+}
+
+SyncQueue *sq_alloc(enum SyncQueueType type, int64_t buf_size_us)
+{
+    SyncQueue *sq = av_mallocz(sizeof(*sq));
+
+    if (!sq)
+        return NULL;
+
+    sq->type                 = type;
+    sq->buf_size_us          = buf_size_us;
+
+    sq->head_stream          = -1;
+    sq->head_finished_stream = -1;
+
+    sq->pool = (type == SYNC_QUEUE_PACKETS) ? objpool_alloc_packets() :
+                                              objpool_alloc_frames();
+    if (!sq->pool) {
+        av_freep(&sq);
+        return NULL;
+    }
+
+    return sq;
+}
+
+void sq_free(SyncQueue **psq)
+{
+    SyncQueue *sq = *psq;
+
+    if (!sq)
+        return;
+
+    for (unsigned int i = 0; i < sq->nb_streams; i++) {
+        SyncQueueFrame frame;
+        while (av_fifo_read(sq->streams[i].fifo, &frame, 1) >= 0)
+            objpool_release(sq->pool, (void**)&frame);
+
+        av_fifo_freep2(&sq->streams[i].fifo);
+    }
+
+    av_freep(&sq->streams);
+
+    objpool_free(&sq->pool);
+
+    av_freep(psq);
+}
diff --git a/fftools/sync_queue.h b/fftools/sync_queue.h
new file mode 100644
index 0000000..3f823ff
--- /dev/null
+++ b/fftools/sync_queue.h
@@ -0,0 +1,109 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFTOOLS_SYNC_QUEUE_H
+#define FFTOOLS_SYNC_QUEUE_H
+
+#include <stdint.h>
+
+#include "libavcodec/packet.h"
+
+#include "libavutil/frame.h"
+
+enum SyncQueueType {
+    SYNC_QUEUE_PACKETS,
+    SYNC_QUEUE_FRAMES,
+};
+
+typedef union SyncQueueFrame {
+    AVFrame  *f;
+    AVPacket *p;
+} SyncQueueFrame;
+
+#define SQFRAME(frame) ((SyncQueueFrame){ .f = (frame) })
+#define SQPKT(pkt)     ((SyncQueueFrame){ .p = (pkt) })
+
+typedef struct SyncQueue SyncQueue;
+
+/**
+ * Allocate a sync queue of the given type.
+ *
+ * @param buf_size_us maximum duration that will be buffered in microseconds
+ */
+SyncQueue *sq_alloc(enum SyncQueueType type, int64_t buf_size_us);
+void       sq_free(SyncQueue **sq);
+
+/**
+ * Add a new stream to the sync queue.
+ *
+ * @param limiting whether the stream is limiting, i.e. no other stream can be
+ *                 longer than this one
+ * @return
+ * - a non-negative stream index on success
+ * - a negative error code on error
+ */
+int sq_add_stream(SyncQueue *sq, int limiting);
+
+/**
+ * Set the timebase for the stream with index stream_idx. Should be called
+ * before sending any frames for this stream.
+ */
+void sq_set_tb(SyncQueue *sq, unsigned int stream_idx, AVRational tb);
+
+/**
+ * Limit the number of output frames for stream with index stream_idx
+ * to max_frames.
+ */
+void sq_limit_frames(SyncQueue *sq, unsigned int stream_idx,
+                     uint64_t max_frames);
+
+/**
+ * Submit a frame for the stream with index stream_idx.
+ *
+ * On success, the sync queue takes ownership of the frame and will reset the
+ * contents of the supplied frame. On failure, the frame remains owned by the
+ * caller.
+ *
+ * Sending a frame with NULL contents marks the stream as finished.
+ *
+ * @return
+ * - 0 on success
+ * - AVERROR_EOF when no more frames should be submitted for this stream
+ * - another a negative error code on failure
+ */
+int sq_send(SyncQueue *sq, unsigned int stream_idx, SyncQueueFrame frame);
+
+/**
+ * Read a frame from the queue.
+ *
+ * @param stream_idx index of the stream to read a frame for. May be -1, then
+ *                   try to read a frame from any stream that is ready for
+ *                   output.
+ * @param frame output frame will be written here on success. The frame is owned
+ *              by the caller.
+ *
+ * @return
+ * - a non-negative index of the stream to which the returned frame belongs
+ * - AVERROR(EAGAIN) when more frames need to be submitted to the queue
+ * - AVERROR_EOF when no more frames will be available for this stream (for any
+ *               stream if stream_idx is -1)
+ * - another negative error code on failure
+ */
+int sq_receive(SyncQueue *sq, int stream_idx, SyncQueueFrame frame);
+
+#endif // FFTOOLS_SYNC_QUEUE_H
diff --git a/fftools/thread_queue.c b/fftools/thread_queue.c
new file mode 100644
index 0000000..a1ab4ce
--- /dev/null
+++ b/fftools/thread_queue.c
@@ -0,0 +1,245 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include <string.h>
+
+#include "libavutil/avassert.h"
+#include "libavutil/error.h"
+#include "libavutil/fifo.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/mem.h"
+#include "libavutil/thread.h"
+
+#include "objpool.h"
+#include "thread_queue.h"
+
+enum {
+    FINISHED_SEND = (1 << 0),
+    FINISHED_RECV = (1 << 1),
+};
+
+typedef struct FifoElem {
+    void        *obj;
+    unsigned int stream_idx;
+} FifoElem;
+
+struct ThreadQueue {
+    int              *finished;
+    unsigned int    nb_streams;
+
+    AVFifo  *fifo;
+
+    ObjPool *obj_pool;
+    void   (*obj_move)(void *dst, void *src);
+
+    pthread_mutex_t lock;
+    pthread_cond_t  cond;
+};
+
+void tq_free(ThreadQueue **ptq)
+{
+    ThreadQueue *tq = *ptq;
+
+    if (!tq)
+        return;
+
+    if (tq->fifo) {
+        FifoElem elem;
+        while (av_fifo_read(tq->fifo, &elem, 1) >= 0)
+            objpool_release(tq->obj_pool, &elem.obj);
+    }
+    av_fifo_freep2(&tq->fifo);
+
+    objpool_free(&tq->obj_pool);
+
+    av_freep(&tq->finished);
+
+    pthread_cond_destroy(&tq->cond);
+    pthread_mutex_destroy(&tq->lock);
+
+    av_freep(ptq);
+}
+
+ThreadQueue *tq_alloc(unsigned int nb_streams, size_t queue_size,
+                      ObjPool *obj_pool, void (*obj_move)(void *dst, void *src))
+{
+    ThreadQueue *tq;
+    int ret;
+
+    tq = av_mallocz(sizeof(*tq));
+    if (!tq)
+        return NULL;
+
+    ret = pthread_cond_init(&tq->cond, NULL);
+    if (ret) {
+        av_freep(&tq);
+        return NULL;
+    }
+
+    ret = pthread_mutex_init(&tq->lock, NULL);
+    if (ret) {
+        pthread_cond_destroy(&tq->cond);
+        av_freep(&tq);
+        return NULL;
+    }
+
+    tq->finished = av_calloc(nb_streams, sizeof(*tq->finished));
+    if (!tq->finished)
+        goto fail;
+    tq->nb_streams = nb_streams;
+
+    tq->fifo = av_fifo_alloc2(queue_size, sizeof(FifoElem), 0);
+    if (!tq->fifo)
+        goto fail;
+
+    tq->obj_pool = obj_pool;
+    tq->obj_move = obj_move;
+
+    return tq;
+fail:
+    tq_free(&tq);
+    return NULL;
+}
+
+int tq_send(ThreadQueue *tq, unsigned int stream_idx, void *data)
+{
+    int *finished;
+    int ret;
+
+    av_assert0(stream_idx < tq->nb_streams);
+    finished = &tq->finished[stream_idx];
+
+    pthread_mutex_lock(&tq->lock);
+
+    if (*finished & FINISHED_SEND) {
+        ret = AVERROR(EINVAL);
+        goto finish;
+    }
+
+    while (!(*finished & FINISHED_RECV) && !av_fifo_can_write(tq->fifo))
+        pthread_cond_wait(&tq->cond, &tq->lock);
+
+    if (*finished & FINISHED_RECV) {
+        ret = AVERROR_EOF;
+        *finished |= FINISHED_SEND;
+    } else {
+        FifoElem elem = { .stream_idx = stream_idx };
+
+        ret = objpool_get(tq->obj_pool, &elem.obj);
+        if (ret < 0)
+            goto finish;
+
+        tq->obj_move(elem.obj, data);
+
+        ret = av_fifo_write(tq->fifo, &elem, 1);
+        av_assert0(ret >= 0);
+        pthread_cond_broadcast(&tq->cond);
+    }
+
+finish:
+    pthread_mutex_unlock(&tq->lock);
+
+    return ret;
+}
+
+static int receive_locked(ThreadQueue *tq, int *stream_idx,
+                          void *data)
+{
+    FifoElem elem;
+    unsigned int nb_finished = 0;
+
+    if (av_fifo_read(tq->fifo, &elem, 1) >= 0) {
+        tq->obj_move(data, elem.obj);
+        objpool_release(tq->obj_pool, &elem.obj);
+        *stream_idx = elem.stream_idx;
+        return 0;
+    }
+
+    for (unsigned int i = 0; i < tq->nb_streams; i++) {
+        if (!(tq->finished[i] & FINISHED_SEND))
+            continue;
+
+        /* return EOF to the consumer at most once for each stream */
+        if (!(tq->finished[i] & FINISHED_RECV)) {
+            tq->finished[i] |= FINISHED_RECV;
+            *stream_idx   = i;
+            return AVERROR_EOF;
+        }
+
+        nb_finished++;
+    }
+
+    return nb_finished == tq->nb_streams ? AVERROR_EOF : AVERROR(EAGAIN);
+}
+
+int tq_receive(ThreadQueue *tq, int *stream_idx, void *data)
+{
+    int ret;
+
+    *stream_idx = -1;
+
+    pthread_mutex_lock(&tq->lock);
+
+    while (1) {
+        ret = receive_locked(tq, stream_idx, data);
+        if (ret == AVERROR(EAGAIN)) {
+            pthread_cond_wait(&tq->cond, &tq->lock);
+            continue;
+        }
+
+        break;
+    }
+
+    if (ret == 0)
+        pthread_cond_broadcast(&tq->cond);
+
+    pthread_mutex_unlock(&tq->lock);
+
+    return ret;
+}
+
+void tq_send_finish(ThreadQueue *tq, unsigned int stream_idx)
+{
+    av_assert0(stream_idx < tq->nb_streams);
+
+    pthread_mutex_lock(&tq->lock);
+
+    /* mark the stream as send-finished;
+     * next time the consumer thread tries to read this stream it will get
+     * an EOF and recv-finished flag will be set */
+    tq->finished[stream_idx] |= FINISHED_SEND;
+    pthread_cond_broadcast(&tq->cond);
+
+    pthread_mutex_unlock(&tq->lock);
+}
+
+void tq_receive_finish(ThreadQueue *tq, unsigned int stream_idx)
+{
+    av_assert0(stream_idx < tq->nb_streams);
+
+    pthread_mutex_lock(&tq->lock);
+
+    /* mark the stream as recv-finished;
+     * next time the producer thread tries to send for this stream, it will
+     * get an EOF and send-finished flag will be set */
+    tq->finished[stream_idx] |= FINISHED_RECV;
+    pthread_cond_broadcast(&tq->cond);
+
+    pthread_mutex_unlock(&tq->lock);
+}
diff --git a/fftools/thread_queue.h b/fftools/thread_queue.h
new file mode 100644
index 0000000..0cc8c71
--- /dev/null
+++ b/fftools/thread_queue.h
@@ -0,0 +1,81 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef FFTOOLS_THREAD_QUEUE_H
+#define FFTOOLS_THREAD_QUEUE_H
+
+#include <string.h>
+
+#include "objpool.h"
+
+typedef struct ThreadQueue ThreadQueue;
+
+/**
+ * Allocate a queue for sending data between threads.
+ *
+ * @param nb_streams number of streams for which a distinct EOF state is
+ *                   maintained
+ * @param queue_size number of items that can be stored in the queue without
+ *                   blocking
+ * @param obj_pool object pool that will be used to allocate items stored in the
+ *                 queue; the pool becomes owned by the queue
+ * @param callback that moves the contents between two data pointers
+ */
+ThreadQueue *tq_alloc(unsigned int nb_streams, size_t queue_size,
+                      ObjPool *obj_pool, void (*obj_move)(void *dst, void *src));
+void         tq_free(ThreadQueue **tq);
+
+/**
+ * Send an item for the given stream to the queue.
+ *
+ * @param data the item to send, its contents will be moved using the callback
+ *             provided to tq_alloc(); on failure the item will be left
+ *             untouched
+ * @return
+ * - 0 the item was successfully sent
+ * - AVERROR(ENOMEM) could not allocate an item for writing to the FIFO
+ * - AVERROR(EINVAL) the sending side has previously been marked as finished
+ * - AVERROR_EOF the receiving side has marked the given stream as finished
+ */
+int tq_send(ThreadQueue *tq, unsigned int stream_idx, void *data);
+/**
+ * Mark the given stream finished from the sending side.
+ */
+void tq_send_finish(ThreadQueue *tq, unsigned int stream_idx);
+
+/**
+ * Read the next item from the queue.
+ *
+ * @param stream_idx the index of the stream that was processed or -1 will be
+ *                   written here
+ * @param data the data item will be written here on success using the
+ *             callback provided to tq_alloc()
+ * @return
+ * - 0 a data item was successfully read; *stream_idx contains a non-negative
+ *   stream index
+ * - AVERROR_EOF When *stream_idx is non-negative, this signals that the sending
+ *   side has marked the given stream as finished. This will happen at most once
+ *   for each stream. When *stream_idx is -1, all streams are done.
+ */
+int tq_receive(ThreadQueue *tq, int *stream_idx, void *data);
+/**
+ * Mark the given stream finished from the receiving side.
+ */
+void tq_receive_finish(ThreadQueue *tq, unsigned int stream_idx);
+
+#endif // FFTOOLS_THREAD_QUEUE_H
diff --git a/libavcodec/012v.c b/libavcodec/012v.c
index c03afd0..805aaed 100644
--- a/libavcodec/012v.c
+++ b/libavcodec/012v.c
@@ -152,5 +152,4 @@ const FFCodec ff_zero12v_decoder = {
     .init           = zero12v_decode_init,
     FF_CODEC_DECODE_CB(zero12v_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/4xm.c b/libavcodec/4xm.c
index 7b88631..8941d71 100644
--- a/libavcodec/4xm.c
+++ b/libavcodec/4xm.c
@@ -1036,5 +1036,5 @@ const FFCodec ff_fourxm_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/8bps.c b/libavcodec/8bps.c
index 292aa03..3bac9f6 100644
--- a/libavcodec/8bps.c
+++ b/libavcodec/8bps.c
@@ -71,9 +71,6 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
     unsigned char *planemap = c->planemap;
     int ret;
 
-    if (buf_size < planes * height *2)
-        return AVERROR_INVALIDDATA;
-
     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
         return ret;
 
@@ -185,5 +182,4 @@ const FFCodec ff_eightbps_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/8svx.c b/libavcodec/8svx.c
index 6eb9083..0af68d2 100644
--- a/libavcodec/8svx.c
+++ b/libavcodec/8svx.c
@@ -199,7 +199,6 @@ const FFCodec ff_eightsvx_fib_decoder = {
   .p.capabilities = AV_CODEC_CAP_DR1,
   .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,
                                                     AV_SAMPLE_FMT_NONE },
-  .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_EIGHTSVX_EXP_DECODER
@@ -215,6 +214,5 @@ const FFCodec ff_eightsvx_exp_decoder = {
   .p.capabilities = AV_CODEC_CAP_DR1,
   .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,
                                                     AV_SAMPLE_FMT_NONE },
-  .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 457ec58..9526e9f 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -91,7 +91,6 @@ OBJS-$(CONFIG_FDCTDSP)                 += fdctdsp.o jfdctfst.o jfdctint.o
 FFT-OBJS-$(CONFIG_HARDCODED_TABLES)    += cos_tables.o
 OBJS-$(CONFIG_FFT)                     += avfft.o fft_float.o fft_fixed_32.o \
                                           fft_init_table.o $(FFT-OBJS-yes)
-OBJS-$(CONFIG_FLACDSP)                 += flacdsp.o
 OBJS-$(CONFIG_FMTCONVERT)              += fmtconvert.o
 OBJS-$(CONFIG_GOLOMB)                  += golomb.o
 OBJS-$(CONFIG_H263DSP)                 += h263dsp.o
@@ -114,6 +113,7 @@ OBJS-$(CONFIG_INTRAX8)                 += intrax8.o intrax8dsp.o msmpeg4data.o
 OBJS-$(CONFIG_IVIDSP)                  += ivi_dsp.o
 OBJS-$(CONFIG_JNI)                     += ffjni.o jni.o
 OBJS-$(CONFIG_JPEGTABLES)              += jpegtables.o
+OBJS-$(CONFIG_LCMS2)                   += fflcms2.o
 OBJS-$(CONFIG_LLAUDDSP)                += lossless_audiodsp.o
 OBJS-$(CONFIG_LLVIDDSP)                += lossless_videodsp.o
 OBJS-$(CONFIG_LLVIDENCDSP)             += lossless_videoencdsp.o
@@ -140,6 +140,8 @@ OBJS-$(CONFIG_MPEGVIDEODEC)            += mpegvideo_dec.o mpegutils.o
 OBJS-$(CONFIG_MPEGVIDEOENC)            += mpegvideo_enc.o mpeg12data.o  \
                                           motion_est.o ratecontrol.o    \
                                           mpegvideoencdsp.o
+OBJS-$(CONFIG_MSMPEG4DEC)              += msmpeg4dec.o msmpeg4.o msmpeg4data.o
+OBJS-$(CONFIG_MSMPEG4ENC)              += msmpeg4enc.o msmpeg4.o msmpeg4data.o
 OBJS-$(CONFIG_MSS34DSP)                += mss34dsp.o
 OBJS-$(CONFIG_PIXBLOCKDSP)             += pixblockdsp.o
 OBJS-$(CONFIG_QPELDSP)                 += qpeldsp.o
@@ -241,6 +243,7 @@ OBJS-$(CONFIG_AURA_DECODER)            += cyuv.o
 OBJS-$(CONFIG_AURA2_DECODER)           += aura.o
 OBJS-$(CONFIG_AV1_DECODER)             += av1dec.o
 OBJS-$(CONFIG_AV1_CUVID_DECODER)       += cuviddec.o
+OBJS-$(CONFIG_AV1_RKMPP_DECODER)       += rkmppdec.o
 OBJS-$(CONFIG_AVRN_DECODER)            += avrndec.o
 OBJS-$(CONFIG_AVRP_DECODER)            += r210dec.o
 OBJS-$(CONFIG_AVRP_ENCODER)            += r210enc.o
@@ -344,8 +347,8 @@ OBJS-$(CONFIG_FFWAVESYNTH_DECODER)     += ffwavesynth.o
 OBJS-$(CONFIG_FIC_DECODER)             += fic.o
 OBJS-$(CONFIG_FITS_DECODER)            += fitsdec.o fits.o
 OBJS-$(CONFIG_FITS_ENCODER)            += fitsenc.o
-OBJS-$(CONFIG_FLAC_DECODER)            += flacdec.o flacdata.o flac.o
-OBJS-$(CONFIG_FLAC_ENCODER)            += flacenc.o flacdata.o flac.o
+OBJS-$(CONFIG_FLAC_DECODER)            += flacdec.o flacdata.o flacdsp.o flac.o
+OBJS-$(CONFIG_FLAC_ENCODER)            += flacenc.o flacdata.o flacencdsp.o flac.o
 OBJS-$(CONFIG_FLASHSV_DECODER)         += flashsv.o
 OBJS-$(CONFIG_FLASHSV_ENCODER)         += flashsvenc.o
 OBJS-$(CONFIG_FLASHSV2_ENCODER)        += flashsv2enc.o
@@ -380,6 +383,7 @@ OBJS-$(CONFIG_H263_ENCODER)            += mpeg4video.o  \
                                           h263.o ituh263enc.o h263data.o
 OBJS-$(CONFIG_H263_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
 OBJS-$(CONFIG_H263_V4L2M2M_ENCODER)    += v4l2_m2m_enc.o
+OBJS-$(CONFIG_H263_RKMPP_DECODER)      += rkmppdec.o
 OBJS-$(CONFIG_H264_DECODER)            += h264dec.o h264_cabac.o h264_cavlc.o \
                                           h264_direct.o h264_loopfilter.o  \
                                           h264_mb.o h264_picture.o \
@@ -395,6 +399,7 @@ OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
 OBJS-$(CONFIG_H264_RKMPP_DECODER)      += rkmppdec.o
+OBJS-$(CONFIG_H264_RKMPP_ENCODER)      += rkmppenc.o
 OBJS-$(CONFIG_H264_VAAPI_ENCODER)      += vaapi_encode_h264.o h264_levels.o
 OBJS-$(CONFIG_H264_VIDEOTOOLBOX_ENCODER) += videotoolboxenc.o
 OBJS-$(CONFIG_H264_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
@@ -403,6 +408,8 @@ OBJS-$(CONFIG_HAP_DECODER)             += hapdec.o hap.o
 OBJS-$(CONFIG_HAP_ENCODER)             += hapenc.o hap.o
 OBJS-$(CONFIG_HCA_DECODER)             += hcadec.o
 OBJS-$(CONFIG_HCOM_DECODER)            += hcom.o
+OBJS-$(CONFIG_HDR_DECODER)             += hdrdec.o
+OBJS-$(CONFIG_HDR_ENCODER)             += hdrenc.o
 OBJS-$(CONFIG_HEVC_DECODER)            += hevcdec.o hevc_mvs.o \
                                           hevc_cabac.o hevc_refs.o hevcpred.o    \
                                           hevcdsp.o hevc_filter.o hevc_data.o \
@@ -505,6 +512,7 @@ OBJS-$(CONFIG_MPEG1VIDEO_DECODER)      += mpeg12dec.o mpeg12.o mpeg12data.o
 OBJS-$(CONFIG_MPEG1VIDEO_ENCODER)      += mpeg12enc.o mpeg12.o
 OBJS-$(CONFIG_MPEG1_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG1_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG1_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG2_MMAL_DECODER)      += mmaldec.o
 OBJS-$(CONFIG_MPEG2_QSV_DECODER)       += qsvdec.o
 OBJS-$(CONFIG_MPEG2_QSV_ENCODER)       += qsvenc_mpeg2.o
@@ -514,6 +522,7 @@ OBJS-$(CONFIG_MPEG2_CUVID_DECODER)     += cuviddec.o
 OBJS-$(CONFIG_MPEG2_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG2_VAAPI_ENCODER)     += vaapi_encode_mpeg2.o
 OBJS-$(CONFIG_MPEG2_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
+OBJS-$(CONFIG_MPEG2_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPEG4_DECODER)           += xvididct.o
 OBJS-$(CONFIG_MPEG4_ENCODER)           += mpeg4videoenc.o
 OBJS-$(CONFIG_MPEG4_CUVID_DECODER)     += cuviddec.o
@@ -521,14 +530,10 @@ OBJS-$(CONFIG_MPEG4_MEDIACODEC_DECODER) += mediacodecdec.o
 OBJS-$(CONFIG_MPEG4_OMX_ENCODER)       += omx.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_DECODER)   += v4l2_m2m_dec.o
 OBJS-$(CONFIG_MPEG4_V4L2M2M_ENCODER)   += v4l2_m2m_enc.o
+OBJS-$(CONFIG_MPEG4_RKMPP_DECODER)     += rkmppdec.o
 OBJS-$(CONFIG_MPL2_DECODER)            += mpl2dec.o ass.o
 OBJS-$(CONFIG_MSA1_DECODER)            += mss3.o
 OBJS-$(CONFIG_MSCC_DECODER)            += mscc.o
-OBJS-$(CONFIG_MSMPEG4V1_DECODER)       += msmpeg4dec.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSMPEG4V2_DECODER)       += msmpeg4dec.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSMPEG4V2_ENCODER)       += msmpeg4enc.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSMPEG4V3_DECODER)       += msmpeg4dec.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_MSMPEG4V3_ENCODER)       += msmpeg4enc.o msmpeg4.o msmpeg4data.o
 OBJS-$(CONFIG_MSNSIREN_DECODER)        += siren.o
 OBJS-$(CONFIG_MSP2_DECODER)            += msp2dec.o
 OBJS-$(CONFIG_MSRLE_DECODER)           += msrle.o msrledec.o
@@ -719,8 +724,7 @@ OBJS-$(CONFIG_VBN_ENCODER)             += vbnenc.o
 OBJS-$(CONFIG_VBLE_DECODER)            += vble.o
 OBJS-$(CONFIG_VC1_DECODER)             += vc1dec.o vc1_block.o vc1_loopfilter.o \
                                           vc1_mc.o vc1_pred.o vc1.o vc1data.o \
-                                          msmpeg4dec.o msmpeg4.o msmpeg4data.o \
-                                          wmv2dsp.o wmv2data.o
+                                          wmv2data.o
 OBJS-$(CONFIG_VC1_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VC1_MMAL_DECODER)        += mmaldec.o
 OBJS-$(CONFIG_VC1_QSV_DECODER)         += qsvdec.o
@@ -735,11 +739,11 @@ OBJS-$(CONFIG_VORBIS_DECODER)          += vorbisdec.o vorbisdsp.o vorbis.o \
 OBJS-$(CONFIG_VORBIS_ENCODER)          += vorbisenc.o vorbis.o \
                                           vorbis_data.o
 OBJS-$(CONFIG_VP3_DECODER)             += vp3.o
-OBJS-$(CONFIG_VP5_DECODER)             += vp5.o vp56.o vp56data.o vp56rac.o
+OBJS-$(CONFIG_VP5_DECODER)             += vp5.o vp56.o vp56data.o vpx_rac.o
 OBJS-$(CONFIG_VP6_DECODER)             += vp6.o vp56.o vp56data.o \
-                                          vp6dsp.o vp56rac.o
-OBJS-$(CONFIG_VP7_DECODER)             += vp8.o vp56rac.o
-OBJS-$(CONFIG_VP8_DECODER)             += vp8.o vp56rac.o
+                                          vp6dsp.o vpx_rac.o
+OBJS-$(CONFIG_VP7_DECODER)             += vp8.o vpx_rac.o
+OBJS-$(CONFIG_VP8_DECODER)             += vp8.o vpx_rac.o
 OBJS-$(CONFIG_VP8_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VP8_MEDIACODEC_DECODER)  += mediacodecdec.o
 OBJS-$(CONFIG_VP8_QSV_DECODER)         += qsvdec.o
@@ -748,7 +752,7 @@ OBJS-$(CONFIG_VP8_VAAPI_ENCODER)       += vaapi_encode_vp8.o
 OBJS-$(CONFIG_VP8_V4L2M2M_DECODER)     += v4l2_m2m_dec.o
 OBJS-$(CONFIG_VP8_V4L2M2M_ENCODER)     += v4l2_m2m_enc.o
 OBJS-$(CONFIG_VP9_DECODER)             += vp9.o vp9data.o vp9dsp.o vp9lpf.o vp9recon.o \
-                                          vp9block.o vp9prob.o vp9mvs.o vp56rac.o \
+                                          vp9block.o vp9prob.o vp9mvs.o vpx_rac.o \
                                           vp9dsp_8bpp.o vp9dsp_10bpp.o vp9dsp_12bpp.o
 OBJS-$(CONFIG_VP9_CUVID_DECODER)       += cuviddec.o
 OBJS-$(CONFIG_VP9_MEDIACODEC_DECODER)  += mediacodecdec.o
@@ -760,6 +764,8 @@ OBJS-$(CONFIG_VP9_V4L2M2M_DECODER)     += v4l2_m2m_dec.o
 OBJS-$(CONFIG_VQA_DECODER)             += vqavideo.o
 OBJS-$(CONFIG_WAVPACK_DECODER)         += wavpack.o wavpackdata.o dsd.o
 OBJS-$(CONFIG_WAVPACK_ENCODER)         += wavpackdata.o wavpackenc.o
+OBJS-$(CONFIG_WBMP_DECODER)            += wbmpdec.o
+OBJS-$(CONFIG_WBMP_ENCODER)            += wbmpenc.o
 OBJS-$(CONFIG_WCMV_DECODER)            += wcmv.o
 OBJS-$(CONFIG_WEBP_DECODER)            += webp.o
 OBJS-$(CONFIG_WEBVTT_DECODER)          += webvttdec.o ass.o
@@ -773,12 +779,8 @@ OBJS-$(CONFIG_WMAV2_ENCODER)           += wmaenc.o wma.o wma_common.o aactab.o
 OBJS-$(CONFIG_WMAVOICE_DECODER)        += wmavoice.o \
                                           celp_filters.o \
                                           acelp_vectors.o acelp_filters.o
-OBJS-$(CONFIG_WMV1_DECODER)            += msmpeg4dec.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_WMV1_ENCODER)            += msmpeg4enc.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_WMV2_DECODER)            += wmv2dec.o wmv2.o wmv2data.o \
-                                          msmpeg4dec.o msmpeg4.o msmpeg4data.o
-OBJS-$(CONFIG_WMV2_ENCODER)            += wmv2enc.o wmv2.o wmv2data.o \
-                                          msmpeg4.o msmpeg4enc.o msmpeg4data.o
+OBJS-$(CONFIG_WMV2_DECODER)            += wmv2dec.o wmv2.o wmv2data.o
+OBJS-$(CONFIG_WMV2_ENCODER)            += wmv2enc.o wmv2.o wmv2data.o
 OBJS-$(CONFIG_WNV1_DECODER)            += wnv1.o
 OBJS-$(CONFIG_WRAPPED_AVFRAME_DECODER) += wrapped_avframe.o
 OBJS-$(CONFIG_WRAPPED_AVFRAME_ENCODER) += wrapped_avframe.o
@@ -1052,8 +1054,8 @@ OBJS-$(CONFIG_ALAC_AT_ENCODER)            += audiotoolboxenc.o
 OBJS-$(CONFIG_ILBC_AT_ENCODER)            += audiotoolboxenc.o
 OBJS-$(CONFIG_PCM_ALAW_AT_ENCODER)        += audiotoolboxenc.o
 OBJS-$(CONFIG_PCM_MULAW_AT_ENCODER)       += audiotoolboxenc.o
-OBJS-$(CONFIG_LIBAOM_AV1_DECODER)         += libaomdec.o
-OBJS-$(CONFIG_LIBAOM_AV1_ENCODER)         += libaomenc.o
+OBJS-$(CONFIG_LIBAOM_AV1_DECODER)         += libaomdec.o libaom.o
+OBJS-$(CONFIG_LIBAOM_AV1_ENCODER)         += libaomenc.o libaom.o
 OBJS-$(CONFIG_LIBARIBB24_DECODER)         += libaribb24.o ass.o
 OBJS-$(CONFIG_LIBCELT_DECODER)            += libcelt_dec.o
 OBJS-$(CONFIG_LIBCODEC2_DECODER)          += libcodec2.o
@@ -1142,6 +1144,7 @@ OBJS-$(CONFIG_H261_PARSER)             += h261_parser.o
 OBJS-$(CONFIG_H263_PARSER)             += h263_parser.o
 OBJS-$(CONFIG_H264_PARSER)             += h264_parser.o h264_sei.o h264data.o
 OBJS-$(CONFIG_HEVC_PARSER)             += hevc_parser.o hevc_data.o
+OBJS-$(CONFIG_HDR_PARSER)              += hdr_parser.o
 OBJS-$(CONFIG_IPU_PARSER)              += ipu_parser.o
 OBJS-$(CONFIG_JPEG2000_PARSER)         += jpeg2000_parser.o
 OBJS-$(CONFIG_MJPEG_PARSER)            += mjpeg_parser.o
@@ -1221,7 +1224,7 @@ OBJS-$(HAVE_THREADS)                   += pthread.o pthread_slice.o pthread_fram
 OBJS-$(CONFIG_FRAME_THREAD_ENCODER)    += frame_thread_encoder.o
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES)           += avcodecres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES)           += avcodecres.o
 
 SKIPHEADERS                            += %_tablegen.h                  \
                                           %_tables.h                    \
@@ -1231,12 +1234,14 @@ SKIPHEADERS                            += %_tablegen.h                  \
                                           aaccoder_trellis.h            \
                                           aacenc_quantization.h         \
                                           aacenc_quantization_misc.h    \
-                                          $(ARCH)/vp56_arith.h          \
+                                          $(ARCH)/vpx_arith.h          \
 
 SKIPHEADERS-$(CONFIG_AMF)              += amfenc.h
 SKIPHEADERS-$(CONFIG_D3D11VA)          += d3d11va.h dxva2_internal.h
 SKIPHEADERS-$(CONFIG_DXVA2)            += dxva2.h dxva2_internal.h
 SKIPHEADERS-$(CONFIG_JNI)              += ffjni.h
+SKIPHEADERS-$(CONFIG_LCMS2)            += fflcms2.h
+SKIPHEADERS-$(CONFIG_LIBAOM)           += libaom.h
 SKIPHEADERS-$(CONFIG_LIBJXL)           += libjxl.h
 SKIPHEADERS-$(CONFIG_LIBVPX)           += libvpx.h
 SKIPHEADERS-$(CONFIG_LIBWEBP_ENCODER)  += libwebpenc_common.h
@@ -1251,6 +1256,7 @@ SKIPHEADERS-$(CONFIG_VAAPI)            += vaapi_decode.h vaapi_hevc.h vaapi_enco
 SKIPHEADERS-$(CONFIG_VDPAU)            += vdpau.h vdpau_internal.h
 SKIPHEADERS-$(CONFIG_VIDEOTOOLBOX)     += videotoolbox.h vt_internal.h
 SKIPHEADERS-$(CONFIG_V4L2_M2M)         += v4l2_buffers.h v4l2_context.h v4l2_m2m.h
+SKIPHEADERS-$(CONFIG_ZLIB)             += zlib_wrapper.h
 
 TESTPROGS = avcodec                                                     \
             avpacket                                                    \
diff --git a/libavcodec/a64multienc.c b/libavcodec/a64multienc.c
index e80139e..043ffab 100644
--- a/libavcodec/a64multienc.c
+++ b/libavcodec/a64multienc.c
@@ -76,7 +76,7 @@ static void to_meta_with_crop(AVCodecContext *avctx,
     int luma = 0;
     int height = FFMIN(avctx->height, C64YRES);
     int width  = FFMIN(avctx->width , C64XRES);
-    uint8_t *src = p->data[0];
+    const uint8_t *src = p->data[0];
 
     for (blocky = 0; blocky < C64YRES; blocky += 8) {
         for (blockx = 0; blockx < C64XRES; blockx += 8) {
@@ -404,7 +404,7 @@ const FFCodec ff_a64multi_encoder = {
     FF_CODEC_ENCODE_CB(a64multi_encode_frame),
     .close          = a64multi_close_encoder,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE},
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
 #if CONFIG_A64MULTI5_ENCODER
@@ -419,6 +419,6 @@ const FFCodec ff_a64multi5_encoder = {
     FF_CODEC_ENCODE_CB(a64multi_encode_frame),
     .close          = a64multi_close_encoder,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE},
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/aac.h b/libavcodec/aac.h
index 53be546..c8d6b17 100644
--- a/libavcodec/aac.h
+++ b/libavcodec/aac.h
@@ -366,6 +366,7 @@ struct AACContext {
     int warned_960_sbr;
     unsigned warned_71_wide;
     int warned_gain_control;
+    int warned_he_aac_mono;
 
     /* aacdec functions pointers */
     void (*imdct_and_windowing)(AACContext *ac, SingleChannelElement *sce);
diff --git a/libavcodec/aaccoder.c b/libavcodec/aaccoder.c
index f460479..e3b6b2f 100644
--- a/libavcodec/aaccoder.c
+++ b/libavcodec/aaccoder.c
@@ -62,6 +62,229 @@
 
 #include "libavcodec/aaccoder_trellis.h"
 
+typedef float (*quantize_and_encode_band_func)(struct AACEncContext *s, PutBitContext *pb,
+                                               const float *in, float *quant, const float *scaled,
+                                               int size, int scale_idx, int cb,
+                                               const float lambda, const float uplim,
+                                               int *bits, float *energy);
+
+/**
+ * Calculate rate distortion cost for quantizing with given codebook
+ *
+ * @return quantization distortion
+ */
+static av_always_inline float quantize_and_encode_band_cost_template(
+                                struct AACEncContext *s,
+                                PutBitContext *pb, const float *in, float *out,
+                                const float *scaled, int size, int scale_idx,
+                                int cb, const float lambda, const float uplim,
+                                int *bits, float *energy, int BT_ZERO, int BT_UNSIGNED,
+                                int BT_PAIR, int BT_ESC, int BT_NOISE, int BT_STEREO,
+                                const float ROUNDING)
+{
+    const int q_idx = POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512;
+    const float Q   = ff_aac_pow2sf_tab [q_idx];
+    const float Q34 = ff_aac_pow34sf_tab[q_idx];
+    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];
+    const float CLIPPED_ESCAPE = 165140.0f*IQ;
+    float cost = 0;
+    float qenergy = 0;
+    const int dim = BT_PAIR ? 2 : 4;
+    int resbits = 0;
+    int off;
+
+    if (BT_ZERO || BT_NOISE || BT_STEREO) {
+        for (int i = 0; i < size; i++)
+            cost += in[i]*in[i];
+        if (bits)
+            *bits = 0;
+        if (energy)
+            *energy = qenergy;
+        if (out) {
+            for (int i = 0; i < size; i += dim)
+                for (int j = 0; j < dim; j++)
+                    out[i+j] = 0.0f;
+        }
+        return cost * lambda;
+    }
+    if (!scaled) {
+        s->abs_pow34(s->scoefs, in, size);
+        scaled = s->scoefs;
+    }
+    s->quant_bands(s->qcoefs, in, scaled, size, !BT_UNSIGNED, aac_cb_maxval[cb], Q34, ROUNDING);
+    if (BT_UNSIGNED) {
+        off = 0;
+    } else {
+        off = aac_cb_maxval[cb];
+    }
+    for (int i = 0; i < size; i += dim) {
+        const float *vec;
+        int *quants = s->qcoefs + i;
+        int curidx = 0;
+        int curbits;
+        float quantized, rd = 0.0f;
+        for (int j = 0; j < dim; j++) {
+            curidx *= aac_cb_range[cb];
+            curidx += quants[j] + off;
+        }
+        curbits =  ff_aac_spectral_bits[cb-1][curidx];
+        vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];
+        if (BT_UNSIGNED) {
+            for (int j = 0; j < dim; j++) {
+                float t = fabsf(in[i+j]);
+                float di;
+                if (BT_ESC && vec[j] == 64.0f) { //FIXME: slow
+                    if (t >= CLIPPED_ESCAPE) {
+                        quantized = CLIPPED_ESCAPE;
+                        curbits += 21;
+                    } else {
+                        int c = av_clip_uintp2(quant(t, Q, ROUNDING), 13);
+                        quantized = c*cbrtf(c)*IQ;
+                        curbits += av_log2(c)*2 - 4 + 1;
+                    }
+                } else {
+                    quantized = vec[j]*IQ;
+                }
+                di = t - quantized;
+                if (out)
+                    out[i+j] = in[i+j] >= 0 ? quantized : -quantized;
+                if (vec[j] != 0.0f)
+                    curbits++;
+                qenergy += quantized*quantized;
+                rd += di*di;
+            }
+        } else {
+            for (int j = 0; j < dim; j++) {
+                quantized = vec[j]*IQ;
+                qenergy += quantized*quantized;
+                if (out)
+                    out[i+j] = quantized;
+                rd += (in[i+j] - quantized)*(in[i+j] - quantized);
+            }
+        }
+        cost    += rd * lambda + curbits;
+        resbits += curbits;
+        if (cost >= uplim)
+            return uplim;
+        if (pb) {
+            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);
+            if (BT_UNSIGNED)
+                for (int j = 0; j < dim; j++)
+                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)
+                        put_bits(pb, 1, in[i+j] < 0.0f);
+            if (BT_ESC) {
+                for (int j = 0; j < 2; j++) {
+                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {
+                        int coef = av_clip_uintp2(quant(fabsf(in[i+j]), Q, ROUNDING), 13);
+                        int len = av_log2(coef);
+
+                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);
+                        put_sbits(pb, len, coef);
+                    }
+                }
+            }
+        }
+    }
+
+    if (bits)
+        *bits = resbits;
+    if (energy)
+        *energy = qenergy;
+    return cost;
+}
+
+static inline float quantize_and_encode_band_cost_NONE(struct AACEncContext *s, PutBitContext *pb,
+                                                const float *in, float *quant, const float *scaled,
+                                                int size, int scale_idx, int cb,
+                                                const float lambda, const float uplim,
+                                                int *bits, float *energy) {
+    av_assert0(0);
+    return 0.0f;
+}
+
+#define QUANTIZE_AND_ENCODE_BAND_COST_FUNC(NAME, BT_ZERO, BT_UNSIGNED, BT_PAIR, BT_ESC, BT_NOISE, BT_STEREO, ROUNDING) \
+static float quantize_and_encode_band_cost_ ## NAME(                                         \
+                                struct AACEncContext *s,                                     \
+                                PutBitContext *pb, const float *in, float *quant,            \
+                                const float *scaled, int size, int scale_idx,                \
+                                int cb, const float lambda, const float uplim,               \
+                                int *bits, float *energy) {                                  \
+    return quantize_and_encode_band_cost_template(                                           \
+                                s, pb, in, quant, scaled, size, scale_idx,                   \
+                                BT_ESC ? ESC_BT : cb, lambda, uplim, bits, energy,           \
+                                BT_ZERO, BT_UNSIGNED, BT_PAIR, BT_ESC, BT_NOISE, BT_STEREO,  \
+                                ROUNDING);                                                   \
+}
+
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(ZERO,  1, 0, 0, 0, 0, 0, ROUND_STANDARD)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(SQUAD, 0, 0, 0, 0, 0, 0, ROUND_STANDARD)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(UQUAD, 0, 1, 0, 0, 0, 0, ROUND_STANDARD)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(SPAIR, 0, 0, 1, 0, 0, 0, ROUND_STANDARD)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(UPAIR, 0, 1, 1, 0, 0, 0, ROUND_STANDARD)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(ESC,   0, 1, 1, 1, 0, 0, ROUND_STANDARD)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(ESC_RTZ, 0, 1, 1, 1, 0, 0, ROUND_TO_ZERO)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(NOISE, 0, 0, 0, 0, 1, 0, ROUND_STANDARD)
+QUANTIZE_AND_ENCODE_BAND_COST_FUNC(STEREO,0, 0, 0, 0, 0, 1, ROUND_STANDARD)
+
+static quantize_and_encode_band_func quantize_and_encode_band_cost_arr[] =
+{
+    quantize_and_encode_band_cost_ZERO,
+    quantize_and_encode_band_cost_SQUAD,
+    quantize_and_encode_band_cost_SQUAD,
+    quantize_and_encode_band_cost_UQUAD,
+    quantize_and_encode_band_cost_UQUAD,
+    quantize_and_encode_band_cost_SPAIR,
+    quantize_and_encode_band_cost_SPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_ESC,
+    quantize_and_encode_band_cost_NONE,     /* CB 12 doesn't exist */
+    quantize_and_encode_band_cost_NOISE,
+    quantize_and_encode_band_cost_STEREO,
+    quantize_and_encode_band_cost_STEREO,
+};
+
+static quantize_and_encode_band_func quantize_and_encode_band_cost_rtz_arr[] =
+{
+    quantize_and_encode_band_cost_ZERO,
+    quantize_and_encode_band_cost_SQUAD,
+    quantize_and_encode_band_cost_SQUAD,
+    quantize_and_encode_band_cost_UQUAD,
+    quantize_and_encode_band_cost_UQUAD,
+    quantize_and_encode_band_cost_SPAIR,
+    quantize_and_encode_band_cost_SPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_UPAIR,
+    quantize_and_encode_band_cost_ESC_RTZ,
+    quantize_and_encode_band_cost_NONE,     /* CB 12 doesn't exist */
+    quantize_and_encode_band_cost_NOISE,
+    quantize_and_encode_band_cost_STEREO,
+    quantize_and_encode_band_cost_STEREO,
+};
+
+float ff_quantize_and_encode_band_cost(struct AACEncContext *s, PutBitContext *pb,
+                                       const float *in, float *quant, const float *scaled,
+                                       int size, int scale_idx, int cb,
+                                       const float lambda, const float uplim,
+                                       int *bits, float *energy)
+{
+    return quantize_and_encode_band_cost_arr[cb](s, pb, in, quant, scaled, size,
+                                                 scale_idx, cb, lambda, uplim,
+                                                 bits, energy);
+}
+
+static inline void quantize_and_encode_band(struct AACEncContext *s, PutBitContext *pb,
+                                            const float *in, float *out, int size, int scale_idx,
+                                            int cb, const float lambda, int rtz)
+{
+    (rtz ? quantize_and_encode_band_cost_rtz_arr : quantize_and_encode_band_cost_arr)[cb](s, pb, in, out, NULL, size, scale_idx, cb,
+                                     lambda, INFINITY, NULL, NULL);
+}
+
 /**
  * structure used in optimal codebook search
  */
@@ -123,7 +346,7 @@ static void encode_window_bands_info(AACEncContext *s, SingleChannelElement *sce
                     rd += quantize_band_cost(s, &sce->coeffs[start + w*128],
                                              &s->scoefs[start + w*128], size,
                                              sce->sf_idx[(win+w)*16+swb], aac_cb_out_map[cb],
-                                             lambda / band->threshold, INFINITY, NULL, NULL, 0);
+                                             lambda / band->threshold, INFINITY, NULL, NULL);
                 }
                 cost_stay_here = path[swb][cb].cost + rd;
                 cost_get_here  = minrd              + rd + run_bits + 4;
@@ -346,7 +569,7 @@ static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,
                     for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {
                         FFPsyBand *band = &s->psy.ch[s->cur_channel].psy_bands[(w+w2)*16+g];
                         dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],
-                                                   q + q0, cb, lambda / band->threshold, INFINITY, NULL, NULL, 0);
+                                                   q + q0, cb, lambda / band->threshold, INFINITY, NULL, NULL);
                     }
                     minrd = FFMIN(minrd, dist);
 
@@ -658,7 +881,7 @@ static void search_for_pns(AACEncContext *s, AVCodecContext *avctx, SingleChanne
                                             sce->ics.swb_sizes[g],
                                             sce->sf_idx[(w+w2)*16+g],
                                             sce->band_alt[(w+w2)*16+g],
-                                            lambda/band->threshold, INFINITY, NULL, NULL, 0);
+                                            lambda/band->threshold, INFINITY, NULL, NULL);
                 /* Estimate rd on average as 5 bits for SF, 4 for the CB, plus spread energy * lambda/thr */
                 dist2 += band->energy/(band->spread*band->spread)*lambda*dist_thresh/band->threshold;
             }
@@ -842,25 +1065,25 @@ static void search_for_ms(AACEncContext *s, ChannelElement *cpe)
                                                     sce0->ics.swb_sizes[g],
                                                     sce0->sf_idx[w*16+g],
                                                     sce0->band_type[w*16+g],
-                                                    lambda / (band0->threshold + FLT_MIN), INFINITY, &b1, NULL, 0);
+                                                    lambda / (band0->threshold + FLT_MIN), INFINITY, &b1, NULL);
                         dist1 += quantize_band_cost(s, &sce1->coeffs[start + (w+w2)*128],
                                                     R34,
                                                     sce1->ics.swb_sizes[g],
                                                     sce1->sf_idx[w*16+g],
                                                     sce1->band_type[w*16+g],
-                                                    lambda / (band1->threshold + FLT_MIN), INFINITY, &b2, NULL, 0);
+                                                    lambda / (band1->threshold + FLT_MIN), INFINITY, &b2, NULL);
                         dist2 += quantize_band_cost(s, M,
                                                     M34,
                                                     sce0->ics.swb_sizes[g],
                                                     mididx,
                                                     midcb,
-                                                    lambda / (minthr + FLT_MIN), INFINITY, &b3, NULL, 0);
+                                                    lambda / (minthr + FLT_MIN), INFINITY, &b3, NULL);
                         dist2 += quantize_band_cost(s, S,
                                                     S34,
                                                     sce1->ics.swb_sizes[g],
                                                     sididx,
                                                     sidcb,
-                                                    mslambda / (minthr * bmax + FLT_MIN), INFINITY, &b4, NULL, 0);
+                                                    mslambda / (minthr * bmax + FLT_MIN), INFINITY, &b4, NULL);
                         B0 += b1+b2;
                         B1 += b3+b4;
                         dist1 -= b1+b2;
diff --git a/libavcodec/aaccoder_trellis.h b/libavcodec/aaccoder_trellis.h
index 940ebf0..4810ff3 100644
--- a/libavcodec/aaccoder_trellis.h
+++ b/libavcodec/aaccoder_trellis.h
@@ -127,7 +127,7 @@ static void codebook_trellis_rate(AACEncContext *s, SingleChannelElement *sce,
                                                &s->scoefs[start + w*128], size,
                                                sce->sf_idx[win*16+swb],
                                                aac_cb_out_map[cb],
-                                               0, INFINITY, NULL, NULL, 0);
+                                               0, INFINITY, NULL, NULL);
                 }
                 cost_stay_here = path[swb][cb].cost + bits;
                 cost_get_here  = minbits            + bits + run_bits + 4;
diff --git a/libavcodec/aacdec.c b/libavcodec/aacdec.c
index 88c128f..c09c3ee 100644
--- a/libavcodec/aacdec.c
+++ b/libavcodec/aacdec.c
@@ -565,7 +565,7 @@ const FFCodec ff_aac_decoder = {
         AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE
     },
     .p.capabilities  = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts = aac_channel_layout,
 #endif
@@ -593,7 +593,7 @@ const FFCodec ff_aac_latm_decoder = {
         AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE
     },
     .p.capabilities  = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts = aac_channel_layout,
 #endif
diff --git a/libavcodec/aacdec_fixed.c b/libavcodec/aacdec_fixed.c
index c7ac750..ddfa160 100644
--- a/libavcodec/aacdec_fixed.c
+++ b/libavcodec/aacdec_fixed.c
@@ -463,11 +463,12 @@ const FFCodec ff_aac_fixed_decoder = {
         AV_SAMPLE_FMT_S32P, AV_SAMPLE_FMT_NONE
     },
     .p.capabilities  = AV_CODEC_CAP_CHANNEL_CONF | AV_CODEC_CAP_DR1,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts = aac_channel_layout,
 #endif
     .p.ch_layouts    = aac_ch_layout,
+    .p.priv_class    = &aac_decoder_class,
     .p.profiles      = NULL_IF_CONFIG_SMALL(ff_aac_profiles),
     .flush = flush,
 };
diff --git a/libavcodec/aacdec_template.c b/libavcodec/aacdec_template.c
index 10fba3d..149c171 100644
--- a/libavcodec/aacdec_template.c
+++ b/libavcodec/aacdec_template.c
@@ -2584,6 +2584,10 @@ static int decode_extension_payload(AACContext *ac, GetBitContext *gb, int cnt,
             ac->avctx->profile = FF_PROFILE_AAC_HE;
         }
         res = AAC_RENAME(ff_decode_sbr_extension)(ac, &che->sbr, gb, crc_flag, cnt, elem_type);
+        if (ac->oc[1].m4ac.ps == 1 && !ac->warned_he_aac_mono) {
+            av_log(ac->avctx, AV_LOG_VERBOSE, "Treating HE-AAC mono as stereo.\n");
+            ac->warned_he_aac_mono = 1;
+        }
         break;
     case EXT_DYNAMIC_RANGE:
         res = decode_dynamic_range(&ac->che_drc, gb);
@@ -3091,7 +3095,7 @@ static void spectral_to_sample(AACContext *ac, int samples)
                     /* preparation for resampler */
                     for(j = 0; j<samples; j++){
                         che->ch[0].ret[j] = (int32_t)av_clip64((int64_t)che->ch[0].ret[j]*128, INT32_MIN, INT32_MAX-0x8000)+0x8000;
-                        if(type == TYPE_CPE)
+                        if (type == TYPE_CPE || (type == TYPE_SCE && ac->oc[1].m4ac.ps == 1))
                             che->ch[1].ret[j] = (int32_t)av_clip64((int64_t)che->ch[1].ret[j]*128, INT32_MIN, INT32_MAX-0x8000)+0x8000;
                     }
                 }
@@ -3418,9 +3422,6 @@ static int aac_decode_frame_int(AVCodecContext *avctx, AVFrame *frame,
         ac->oc[1].status = OC_LOCKED;
     }
 
-    if (multiplier)
-        avctx->internal->skip_samples_multiplier = 2;
-
     if (!ac->frame->data[0] && samples) {
         av_log(avctx, AV_LOG_ERROR, "no frame data found\n");
         err = AVERROR_INVALIDDATA;
diff --git a/libavcodec/aacenc.c b/libavcodec/aacenc.c
index 408c031..4f51485 100644
--- a/libavcodec/aacenc.c
+++ b/libavcodec/aacenc.c
@@ -51,6 +51,279 @@
 
 #include "psymodel.h"
 
+/**
+ * List of PCE (Program Configuration Element) for the channel layouts listed
+ * in channel_layout.h
+ *
+ * For those wishing in the future to add other layouts:
+ *
+ * - num_ele: number of elements in each group of front, side, back, lfe channels
+ *            (an element is of type SCE (single channel), CPE (channel pair) for
+ *            the first 3 groups; and is LFE for LFE group).
+ *
+ * - pairing: 0 for an SCE element or 1 for a CPE; does not apply to LFE group
+ *
+ * - index: there are three independent indices for SCE, CPE and LFE;
+ *     they are incremented irrespective of the group to which the element belongs;
+ *     they are not reset when going from one group to another
+ *
+ *     Example: for 7.0 channel layout,
+ *        .pairing = { { 1, 0 }, { 1 }, { 1 }, }, (3 CPE and 1 SCE in front group)
+ *        .index = { { 0, 0 }, { 1 }, { 2 }, },
+ *               (index is 0 for the single SCE but goes from 0 to 2 for the CPEs)
+ *
+ *     The index order impacts the channel ordering. But is otherwise arbitrary
+ *     (the sequence could have been 2, 0, 1 instead of 0, 1, 2).
+ *
+ *     Spec allows for discontinuous indices, e.g. if one has a total of two SCE,
+ *     SCE.0 SCE.15 is OK per spec; BUT it won't be decoded by our AAC decoder
+ *     which at this time requires that indices fully cover some range starting
+ *     from 0 (SCE.1 SCE.0 is OK but not SCE.0 SCE.15).
+ *
+ * - config_map: total number of elements and their types. Beware, the way the
+ *               types are ordered impacts the final channel ordering.
+ *
+ * - reorder_map: reorders the channels.
+ *
+ */
+static const AACPCEInfo aac_pce_configs[] = {
+    {
+        .layout = AV_CHANNEL_LAYOUT_MONO,
+        .num_ele = { 1, 0, 0, 0 },
+        .pairing = { { 0 }, },
+        .index = { { 0 }, },
+        .config_map = { 1, TYPE_SCE, },
+        .reorder_map = { 0 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_STEREO,
+        .num_ele = { 1, 0, 0, 0 },
+        .pairing = { { 1 }, },
+        .index = { { 0 }, },
+        .config_map = { 1, TYPE_CPE, },
+        .reorder_map = { 0, 1 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_2POINT1,
+        .num_ele = { 1, 0, 0, 1 },
+        .pairing = { { 1 }, },
+        .index = { { 0 },{ 0 },{ 0 },{ 0 } },
+        .config_map = { 2, TYPE_CPE, TYPE_LFE },
+        .reorder_map = { 0, 1, 2 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_2_1,
+        .num_ele = { 1, 0, 1, 0 },
+        .pairing = { { 1 },{ 0 },{ 0 } },
+        .index = { { 0 },{ 0 },{ 0 }, },
+        .config_map = { 2, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_SURROUND,
+        .num_ele = { 2, 0, 0, 0 },
+        .pairing = { { 1, 0 }, },
+        .index = { { 0, 0 }, },
+        .config_map = { 2, TYPE_CPE, TYPE_SCE, },
+        .reorder_map = { 0, 1, 2 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_3POINT1,
+        .num_ele = { 2, 0, 0, 1 },
+        .pairing = { { 1, 0 }, },
+        .index = { { 0, 0 }, { 0 }, { 0 }, { 0 }, },
+        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_LFE },
+        .reorder_map = { 0, 1, 2, 3 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_4POINT0,
+        .num_ele = { 2, 0, 1, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 0 }, },
+        .index = { { 0, 0 }, { 0 }, { 1 } },
+        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_SCE },
+        .reorder_map = {  0, 1, 2, 3 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_4POINT1,
+        .num_ele = { 2, 1, 1, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 0 }, },
+        .index = { { 0, 0 }, { 1 }, { 2 }, { 0 } },
+        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_2_2,
+        .num_ele = { 1, 1, 0, 0 },
+        .pairing = { { 1 }, { 1 }, },
+        .index = { { 0 }, { 1 }, },
+        .config_map = { 2, TYPE_CPE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_QUAD,
+        .num_ele = { 1, 0, 1, 0 },
+        .pairing = { { 1 }, { 0 }, { 1 }, },
+        .index = { { 0 }, { 0 }, { 1 } },
+        .config_map = { 2, TYPE_CPE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_5POINT0,
+        .num_ele = { 2, 1, 0, 0 },
+        .pairing = { { 1, 0 }, { 1 }, },
+        .index = { { 0, 0 }, { 1 } },
+        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_5POINT1,
+        .num_ele = { 2, 1, 1, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 1 }, },
+        .index = { { 0, 0 }, { 1 }, { 1 } },
+        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_5POINT0_BACK,
+        .num_ele = { 2, 0, 1, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 1 } },
+        .index = { { 0, 0 }, { 0 }, { 1 } },
+        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_5POINT1_BACK,
+        .num_ele = { 2, 1, 1, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 1 }, },
+        .index = { { 0, 0 }, { 1 }, { 1 } },
+        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_6POINT0,
+        .num_ele = { 2, 1, 1, 0 },
+        .pairing = { { 1, 0 }, { 1 }, { 0 }, },
+        .index = { { 0, 0 }, { 1 }, { 1 } },
+        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_6POINT0_FRONT,
+        .num_ele = { 2, 1, 0, 0 },
+        .pairing = { { 1, 1 }, { 1 } },
+        .index = { { 1, 0 }, { 2 }, },
+        .config_map = { 3, TYPE_CPE, TYPE_CPE, TYPE_CPE, },
+        .reorder_map = { 0, 1, 2, 3, 4, 5 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_HEXAGONAL,
+        .num_ele = { 2, 0, 2, 0 },
+        .pairing = { { 1, 0 },{ 0 },{ 1, 0 }, },
+        .index = { { 0, 0 },{ 0 },{ 1, 1 } },
+        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE, },
+        .reorder_map = { 0, 1, 2, 3, 4, 5 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_6POINT1,
+        .num_ele = { 2, 1, 2, 0 },
+        .pairing = { { 1, 0 },{ 0 },{ 1, 0 }, },
+        .index = { { 0, 0 },{ 1 },{ 1, 2 } },
+        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_6POINT1_BACK,
+        .num_ele = { 2, 1, 2, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 1, 0 }, },
+        .index = { { 0, 0 }, { 1 }, { 1, 2 } },
+        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_6POINT1_FRONT,
+        .num_ele = { 2, 1, 2, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 1, 0 }, },
+        .index = { { 0, 0 }, { 1 }, { 1, 2 } },
+        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_7POINT0,
+        .num_ele = { 2, 1, 1, 0 },
+        .pairing = { { 1, 0 }, { 1 }, { 1 }, },
+        .index = { { 0, 0 }, { 1 }, { 2 }, },
+        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_7POINT0_FRONT,
+        .num_ele = { 2, 1, 1, 0 },
+        .pairing = { { 1, 0 }, { 1 }, { 1 }, },
+        .index = { { 0, 0 }, { 1 }, { 2 }, },
+        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_7POINT1,
+        .num_ele = { 2, 1, 2, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 1, 1 }, },
+        .index = { { 0, 0 }, { 1 }, { 1, 2 }, { 0 } },
+        .config_map = { 5, TYPE_CPE, TYPE_SCE,  TYPE_SCE, TYPE_CPE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_7POINT1_WIDE,
+        .num_ele = { 2, 1, 2, 0 },
+        .pairing = { { 1, 0 }, { 0 },{  1, 1 }, },
+        .index = { { 0, 0 }, { 1 }, { 1, 2 }, { 0 } },
+        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK,
+        .num_ele = { 2, 1, 2, 0 },
+        .pairing = { { 1, 0 }, { 0 }, { 1, 1 }, },
+        .index = { { 0, 0 }, { 1 }, { 1, 2 }, { 0 } },
+        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_OCTAGONAL,
+        .num_ele = { 2, 1, 2, 0 },
+        .pairing = { { 1, 0 }, { 1 }, { 1, 0 }, },
+        .index = { { 0, 0 }, { 1 }, { 2, 1 } },
+        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
+    },
+    {   /* Meant for order 2/mixed ambisonics */
+        .layout = { .order = AV_CHANNEL_ORDER_NATIVE, .nb_channels = 9,
+                    .u.mask = AV_CH_LAYOUT_OCTAGONAL | AV_CH_TOP_CENTER },
+        .num_ele = { 2, 2, 2, 0 },
+        .pairing = { { 1, 0 }, { 1, 0 }, { 1, 0 }, },
+        .index = { { 0, 0 }, { 1, 1 }, { 2, 2 } },
+        .config_map = { 6, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
+    },
+    {   /* Meant for order 2/mixed ambisonics */
+        .layout = { .order = AV_CHANNEL_ORDER_NATIVE, .nb_channels = 10,
+                    .u.mask = AV_CH_LAYOUT_6POINT0_FRONT | AV_CH_BACK_CENTER |
+                              AV_CH_BACK_LEFT | AV_CH_BACK_RIGHT | AV_CH_TOP_CENTER },
+        .num_ele = { 2, 2, 2, 0 },
+        .pairing = { { 1, 1 }, { 1, 0 }, { 1, 0 }, },
+        .index = { { 0, 1 }, { 2, 0 }, { 3, 1 } },
+        .config_map = { 6, TYPE_CPE, TYPE_CPE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },
+    },
+    {
+        .layout = AV_CHANNEL_LAYOUT_HEXADECAGONAL,
+        .num_ele = { 4, 2, 4, 0 },
+        .pairing = { { 1, 0, 1, 0 }, { 1, 1 }, { 1, 0, 1, 0 }, },
+        .index = { { 0, 0, 1, 1 }, { 2, 3 }, { 4, 2, 5, 3 } },
+        .config_map = { 10, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
+        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
+    },
+};
+
 static void put_pce(PutBitContext *pb, AVCodecContext *avctx)
 {
     int i, j;
@@ -1150,7 +1423,7 @@ const FFCodec ff_aac_encoder = {
     .close          = aac_encode_end,
     .defaults       = aac_encode_defaults,
     .p.supported_samplerates = ff_mpeg4audio_sample_rates,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.capabilities = AV_CODEC_CAP_SMALL_LAST_FRAME | AV_CODEC_CAP_DELAY,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLTP,
                                                      AV_SAMPLE_FMT_NONE },
diff --git a/libavcodec/aacenc.h b/libavcodec/aacenc.h
index a001c7c..f5a2b78 100644
--- a/libavcodec/aacenc.h
+++ b/libavcodec/aacenc.h
@@ -102,279 +102,6 @@ typedef struct AACPCEInfo {
     uint8_t reorder_map[16];                     ///< maps channels from lavc to aac order
 } AACPCEInfo;
 
-/**
- * List of PCE (Program Configuration Element) for the channel layouts listed
- * in channel_layout.h
- *
- * For those wishing in the future to add other layouts:
- *
- * - num_ele: number of elements in each group of front, side, back, lfe channels
- *            (an element is of type SCE (single channel), CPE (channel pair) for
- *            the first 3 groups; and is LFE for LFE group).
- *
- * - pairing: 0 for an SCE element or 1 for a CPE; does not apply to LFE group
- *
- * - index: there are three independent indices for SCE, CPE and LFE;
- *     they are incremented irrespective of the group to which the element belongs;
- *     they are not reset when going from one group to another
- *
- *     Example: for 7.0 channel layout,
- *        .pairing = { { 1, 0 }, { 1 }, { 1 }, }, (3 CPE and 1 SCE in front group)
- *        .index = { { 0, 0 }, { 1 }, { 2 }, },
- *               (index is 0 for the single SCE but goes from 0 to 2 for the CPEs)
- *
- *     The index order impacts the channel ordering. But is otherwise arbitrary
- *     (the sequence could have been 2, 0, 1 instead of 0, 1, 2).
- *
- *     Spec allows for discontinuous indices, e.g. if one has a total of two SCE,
- *     SCE.0 SCE.15 is OK per spec; BUT it won't be decoded by our AAC decoder
- *     which at this time requires that indices fully cover some range starting
- *     from 0 (SCE.1 SCE.0 is OK but not SCE.0 SCE.15).
- *
- * - config_map: total number of elements and their types. Beware, the way the
- *               types are ordered impacts the final channel ordering.
- *
- * - reorder_map: reorders the channels.
- *
- */
-static const AACPCEInfo aac_pce_configs[] = {
-    {
-        .layout = AV_CHANNEL_LAYOUT_MONO,
-        .num_ele = { 1, 0, 0, 0 },
-        .pairing = { { 0 }, },
-        .index = { { 0 }, },
-        .config_map = { 1, TYPE_SCE, },
-        .reorder_map = { 0 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_STEREO,
-        .num_ele = { 1, 0, 0, 0 },
-        .pairing = { { 1 }, },
-        .index = { { 0 }, },
-        .config_map = { 1, TYPE_CPE, },
-        .reorder_map = { 0, 1 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_2POINT1,
-        .num_ele = { 1, 0, 0, 1 },
-        .pairing = { { 1 }, },
-        .index = { { 0 },{ 0 },{ 0 },{ 0 } },
-        .config_map = { 2, TYPE_CPE, TYPE_LFE },
-        .reorder_map = { 0, 1, 2 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_2_1,
-        .num_ele = { 1, 0, 1, 0 },
-        .pairing = { { 1 },{ 0 },{ 0 } },
-        .index = { { 0 },{ 0 },{ 0 }, },
-        .config_map = { 2, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_SURROUND,
-        .num_ele = { 2, 0, 0, 0 },
-        .pairing = { { 1, 0 }, },
-        .index = { { 0, 0 }, },
-        .config_map = { 2, TYPE_CPE, TYPE_SCE, },
-        .reorder_map = { 0, 1, 2 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_3POINT1,
-        .num_ele = { 2, 0, 0, 1 },
-        .pairing = { { 1, 0 }, },
-        .index = { { 0, 0 }, { 0 }, { 0 }, { 0 }, },
-        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_LFE },
-        .reorder_map = { 0, 1, 2, 3 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_4POINT0,
-        .num_ele = { 2, 0, 1, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 0 }, },
-        .index = { { 0, 0 }, { 0 }, { 1 } },
-        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_SCE },
-        .reorder_map = {  0, 1, 2, 3 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_4POINT1,
-        .num_ele = { 2, 1, 1, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 0 }, },
-        .index = { { 0, 0 }, { 1 }, { 2 }, { 0 } },
-        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_2_2,
-        .num_ele = { 1, 1, 0, 0 },
-        .pairing = { { 1 }, { 1 }, },
-        .index = { { 0 }, { 1 }, },
-        .config_map = { 2, TYPE_CPE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_QUAD,
-        .num_ele = { 1, 0, 1, 0 },
-        .pairing = { { 1 }, { 0 }, { 1 }, },
-        .index = { { 0 }, { 0 }, { 1 } },
-        .config_map = { 2, TYPE_CPE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_5POINT0,
-        .num_ele = { 2, 1, 0, 0 },
-        .pairing = { { 1, 0 }, { 1 }, },
-        .index = { { 0, 0 }, { 1 } },
-        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_5POINT1,
-        .num_ele = { 2, 1, 1, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 1 }, },
-        .index = { { 0, 0 }, { 1 }, { 1 } },
-        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_5POINT0_BACK,
-        .num_ele = { 2, 0, 1, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 1 } },
-        .index = { { 0, 0 }, { 0 }, { 1 } },
-        .config_map = { 3, TYPE_CPE, TYPE_SCE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_5POINT1_BACK,
-        .num_ele = { 2, 1, 1, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 1 }, },
-        .index = { { 0, 0 }, { 1 }, { 1 } },
-        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_6POINT0,
-        .num_ele = { 2, 1, 1, 0 },
-        .pairing = { { 1, 0 }, { 1 }, { 0 }, },
-        .index = { { 0, 0 }, { 1 }, { 1 } },
-        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_6POINT0_FRONT,
-        .num_ele = { 2, 1, 0, 0 },
-        .pairing = { { 1, 1 }, { 1 } },
-        .index = { { 1, 0 }, { 2 }, },
-        .config_map = { 3, TYPE_CPE, TYPE_CPE, TYPE_CPE, },
-        .reorder_map = { 0, 1, 2, 3, 4, 5 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_HEXAGONAL,
-        .num_ele = { 2, 0, 2, 0 },
-        .pairing = { { 1, 0 },{ 0 },{ 1, 0 }, },
-        .index = { { 0, 0 },{ 0 },{ 1, 1 } },
-        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE, },
-        .reorder_map = { 0, 1, 2, 3, 4, 5 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_6POINT1,
-        .num_ele = { 2, 1, 2, 0 },
-        .pairing = { { 1, 0 },{ 0 },{ 1, 0 }, },
-        .index = { { 0, 0 },{ 1 },{ 1, 2 } },
-        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_6POINT1_BACK,
-        .num_ele = { 2, 1, 2, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 1, 0 }, },
-        .index = { { 0, 0 }, { 1 }, { 1, 2 } },
-        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_6POINT1_FRONT,
-        .num_ele = { 2, 1, 2, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 1, 0 }, },
-        .index = { { 0, 0 }, { 1 }, { 1, 2 } },
-        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_7POINT0,
-        .num_ele = { 2, 1, 1, 0 },
-        .pairing = { { 1, 0 }, { 1 }, { 1 }, },
-        .index = { { 0, 0 }, { 1 }, { 2 }, },
-        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_7POINT0_FRONT,
-        .num_ele = { 2, 1, 1, 0 },
-        .pairing = { { 1, 0 }, { 1 }, { 1 }, },
-        .index = { { 0, 0 }, { 1 }, { 2 }, },
-        .config_map = { 4, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_7POINT1,
-        .num_ele = { 2, 1, 2, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 1, 1 }, },
-        .index = { { 0, 0 }, { 1 }, { 1, 2 }, { 0 } },
-        .config_map = { 5, TYPE_CPE, TYPE_SCE,  TYPE_SCE, TYPE_CPE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_7POINT1_WIDE,
-        .num_ele = { 2, 1, 2, 0 },
-        .pairing = { { 1, 0 }, { 0 },{  1, 1 }, },
-        .index = { { 0, 0 }, { 1 }, { 1, 2 }, { 0 } },
-        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_7POINT1_WIDE_BACK,
-        .num_ele = { 2, 1, 2, 0 },
-        .pairing = { { 1, 0 }, { 0 }, { 1, 1 }, },
-        .index = { { 0, 0 }, { 1 }, { 1, 2 }, { 0 } },
-        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_SCE, TYPE_CPE, TYPE_CPE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_OCTAGONAL,
-        .num_ele = { 2, 1, 2, 0 },
-        .pairing = { { 1, 0 }, { 1 }, { 1, 0 }, },
-        .index = { { 0, 0 }, { 1 }, { 2, 1 } },
-        .config_map = { 5, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7 },
-    },
-    {   /* Meant for order 2/mixed ambisonics */
-        .layout = { .order = AV_CHANNEL_ORDER_NATIVE, .nb_channels = 9,
-                    .u.mask = AV_CH_LAYOUT_OCTAGONAL | AV_CH_TOP_CENTER },
-        .num_ele = { 2, 2, 2, 0 },
-        .pairing = { { 1, 0 }, { 1, 0 }, { 1, 0 }, },
-        .index = { { 0, 0 }, { 1, 1 }, { 2, 2 } },
-        .config_map = { 6, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
-    },
-    {   /* Meant for order 2/mixed ambisonics */
-        .layout = { .order = AV_CHANNEL_ORDER_NATIVE, .nb_channels = 10,
-                    .u.mask = AV_CH_LAYOUT_6POINT0_FRONT | AV_CH_BACK_CENTER |
-                              AV_CH_BACK_LEFT | AV_CH_BACK_RIGHT | AV_CH_TOP_CENTER },
-        .num_ele = { 2, 2, 2, 0 },
-        .pairing = { { 1, 1 }, { 1, 0 }, { 1, 0 }, },
-        .index = { { 0, 1 }, { 2, 0 }, { 3, 1 } },
-        .config_map = { 6, TYPE_CPE, TYPE_CPE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },
-    },
-    {
-        .layout = AV_CHANNEL_LAYOUT_HEXADECAGONAL,
-        .num_ele = { 4, 2, 4, 0 },
-        .pairing = { { 1, 0, 1, 0 }, { 1, 1 }, { 1, 0, 1, 0 }, },
-        .index = { { 0, 0, 1, 1 }, { 2, 3 }, { 4, 2, 5, 3 } },
-        .config_map = { 10, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_CPE, TYPE_CPE, TYPE_SCE, TYPE_CPE, TYPE_SCE },
-        .reorder_map = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },
-    },
-};
-
 /**
  * AAC encoder context
  */
diff --git a/libavcodec/aacenc_is.c b/libavcodec/aacenc_is.c
index 2f5b7eb..1810790 100644
--- a/libavcodec/aacenc_is.c
+++ b/libavcodec/aacenc_is.c
@@ -68,15 +68,15 @@ struct AACISError ff_aac_is_encoding_err(AACEncContext *s, ChannelElement *cpe,
                                     sce0->ics.swb_sizes[g],
                                     sce0->sf_idx[w*16+g],
                                     sce0->band_type[w*16+g],
-                                    s->lambda / band0->threshold, INFINITY, NULL, NULL, 0);
+                                    s->lambda / band0->threshold, INFINITY, NULL, NULL);
         dist1 += quantize_band_cost(s, &R[start + (w+w2)*128], R34,
                                     sce1->ics.swb_sizes[g],
                                     sce1->sf_idx[w*16+g],
                                     sce1->band_type[w*16+g],
-                                    s->lambda / band1->threshold, INFINITY, NULL, NULL, 0);
+                                    s->lambda / band1->threshold, INFINITY, NULL, NULL);
         dist2 += quantize_band_cost(s, IS, I34, sce0->ics.swb_sizes[g],
                                     is_sf_idx, is_band_type,
-                                    s->lambda / minthr, INFINITY, NULL, NULL, 0);
+                                    s->lambda / minthr, INFINITY, NULL, NULL);
         for (i = 0; i < sce0->ics.swb_sizes[g]; i++) {
             dist_spec_err += (L34[i] - I34[i])*(L34[i] - I34[i]);
             dist_spec_err += (R34[i] - I34[i]*e01_34)*(R34[i] - I34[i]*e01_34);
diff --git a/libavcodec/aacenc_ltp.c b/libavcodec/aacenc_ltp.c
index f77f0b6..f7fb85b 100644
--- a/libavcodec/aacenc_ltp.c
+++ b/libavcodec/aacenc_ltp.c
@@ -194,11 +194,11 @@ void ff_aac_search_for_ltp(AACEncContext *s, SingleChannelElement *sce,
                 s->abs_pow34(PCD34, PCD, sce->ics.swb_sizes[g]);
                 dist1 += quantize_band_cost(s, &sce->coeffs[start+(w+w2)*128], C34, sce->ics.swb_sizes[g],
                                             sce->sf_idx[(w+w2)*16+g], sce->band_type[(w+w2)*16+g],
-                                            s->lambda/band->threshold, INFINITY, &bits_tmp1, NULL, 0);
+                                            s->lambda/band->threshold, INFINITY, &bits_tmp1, NULL);
                 dist2 += quantize_band_cost(s, PCD, PCD34, sce->ics.swb_sizes[g],
                                             sce->sf_idx[(w+w2)*16+g],
                                             sce->band_type[(w+w2)*16+g],
-                                            s->lambda/band->threshold, INFINITY, &bits_tmp2, NULL, 0);
+                                            s->lambda/band->threshold, INFINITY, &bits_tmp2, NULL);
                 bits1 += bits_tmp1;
                 bits2 += bits_tmp2;
             }
diff --git a/libavcodec/aacenc_pred.c b/libavcodec/aacenc_pred.c
index d111192..447444c 100644
--- a/libavcodec/aacenc_pred.c
+++ b/libavcodec/aacenc_pred.c
@@ -271,9 +271,9 @@ void ff_aac_search_for_pred(AACEncContext *s, SingleChannelElement *sce)
 
         /* Normal coefficients */
         s->abs_pow34(O34, &sce->coeffs[start_coef], num_coeffs);
-        dist1 = quantize_and_encode_band_cost(s, NULL, &sce->coeffs[start_coef], NULL,
-                                              O34, num_coeffs, sce->sf_idx[sfb],
-                                              cb_n, s->lambda / band->threshold, INFINITY, &cost1, NULL, 0);
+        dist1 = ff_quantize_and_encode_band_cost(s, NULL, &sce->coeffs[start_coef], NULL,
+                                                 O34, num_coeffs, sce->sf_idx[sfb],
+                                                 cb_n, s->lambda / band->threshold, INFINITY, &cost1, NULL);
         cost_coeffs += cost1;
 
         /* Encoded coefficients - needed for #bits, band type and quant. error */
@@ -284,9 +284,9 @@ void ff_aac_search_for_pred(AACEncContext *s, SingleChannelElement *sce)
             cb_p = av_clip(find_min_book(find_max_val(1, num_coeffs, S34), sce->sf_idx[sfb]), cb_min, cb_max);
         else
             cb_p = cb_n;
-        quantize_and_encode_band_cost(s, NULL, SENT, QERR, S34, num_coeffs,
-                                      sce->sf_idx[sfb], cb_p, s->lambda / band->threshold, INFINITY,
-                                      &cost2, NULL, 0);
+        ff_quantize_and_encode_band_cost(s, NULL, SENT, QERR, S34, num_coeffs,
+                                         sce->sf_idx[sfb], cb_p, s->lambda / band->threshold, INFINITY,
+                                         &cost2, NULL);
 
         /* Reconstructed coefficients - needed for distortion measurements */
         for (i = 0; i < num_coeffs; i++)
@@ -296,9 +296,9 @@ void ff_aac_search_for_pred(AACEncContext *s, SingleChannelElement *sce)
             cb_p = av_clip(find_min_book(find_max_val(1, num_coeffs, P34), sce->sf_idx[sfb]), cb_min, cb_max);
         else
             cb_p = cb_n;
-        dist2 = quantize_and_encode_band_cost(s, NULL, &sce->prcoeffs[start_coef], NULL,
-                                              P34, num_coeffs, sce->sf_idx[sfb],
-                                              cb_p, s->lambda / band->threshold, INFINITY, NULL, NULL, 0);
+        dist2 = ff_quantize_and_encode_band_cost(s, NULL, &sce->prcoeffs[start_coef], NULL,
+                                                 P34, num_coeffs, sce->sf_idx[sfb],
+                                                 cb_p, s->lambda / band->threshold, INFINITY, NULL, NULL);
         for (i = 0; i < num_coeffs; i++)
             dist_spec_err += (O34[i] - P34[i])*(O34[i] - P34[i]);
         dist_spec_err *= s->lambda / band->threshold;
diff --git a/libavcodec/aacenc_quantization.h b/libavcodec/aacenc_quantization.h
index fc5a46b..185430b 100644
--- a/libavcodec/aacenc_quantization.h
+++ b/libavcodec/aacenc_quantization.h
@@ -28,256 +28,41 @@
 #ifndef AVCODEC_AACENC_QUANTIZATION_H
 #define AVCODEC_AACENC_QUANTIZATION_H
 
-#include "aactab.h"
-#include "aacenc.h"
-#include "aacenctab.h"
-#include "aacenc_utils.h"
-
-/**
- * Calculate rate distortion cost for quantizing with given codebook
- *
- * @return quantization distortion
- */
-static av_always_inline float quantize_and_encode_band_cost_template(
-                                struct AACEncContext *s,
-                                PutBitContext *pb, const float *in, float *out,
-                                const float *scaled, int size, int scale_idx,
-                                int cb, const float lambda, const float uplim,
-                                int *bits, float *energy, int BT_ZERO, int BT_UNSIGNED,
-                                int BT_PAIR, int BT_ESC, int BT_NOISE, int BT_STEREO,
-                                const float ROUNDING)
-{
-    const int q_idx = POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512;
-    const float Q   = ff_aac_pow2sf_tab [q_idx];
-    const float Q34 = ff_aac_pow34sf_tab[q_idx];
-    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];
-    const float CLIPPED_ESCAPE = 165140.0f*IQ;
-    int i, j;
-    float cost = 0;
-    float qenergy = 0;
-    const int dim = BT_PAIR ? 2 : 4;
-    int resbits = 0;
-    int off;
+#include <stddef.h>
 
-    if (BT_ZERO || BT_NOISE || BT_STEREO) {
-        for (i = 0; i < size; i++)
-            cost += in[i]*in[i];
-        if (bits)
-            *bits = 0;
-        if (energy)
-            *energy = qenergy;
-        if (out) {
-            for (i = 0; i < size; i += dim)
-                for (j = 0; j < dim; j++)
-                    out[i+j] = 0.0f;
-        }
-        return cost * lambda;
-    }
-    if (!scaled) {
-        s->abs_pow34(s->scoefs, in, size);
-        scaled = s->scoefs;
-    }
-    s->quant_bands(s->qcoefs, in, scaled, size, !BT_UNSIGNED, aac_cb_maxval[cb], Q34, ROUNDING);
-    if (BT_UNSIGNED) {
-        off = 0;
-    } else {
-        off = aac_cb_maxval[cb];
-    }
-    for (i = 0; i < size; i += dim) {
-        const float *vec;
-        int *quants = s->qcoefs + i;
-        int curidx = 0;
-        int curbits;
-        float quantized, rd = 0.0f;
-        for (j = 0; j < dim; j++) {
-            curidx *= aac_cb_range[cb];
-            curidx += quants[j] + off;
-        }
-        curbits =  ff_aac_spectral_bits[cb-1][curidx];
-        vec     = &ff_aac_codebook_vectors[cb-1][curidx*dim];
-        if (BT_UNSIGNED) {
-            for (j = 0; j < dim; j++) {
-                float t = fabsf(in[i+j]);
-                float di;
-                if (BT_ESC && vec[j] == 64.0f) { //FIXME: slow
-                    if (t >= CLIPPED_ESCAPE) {
-                        quantized = CLIPPED_ESCAPE;
-                        curbits += 21;
-                    } else {
-                        int c = av_clip_uintp2(quant(t, Q, ROUNDING), 13);
-                        quantized = c*cbrtf(c)*IQ;
-                        curbits += av_log2(c)*2 - 4 + 1;
-                    }
-                } else {
-                    quantized = vec[j]*IQ;
-                }
-                di = t - quantized;
-                if (out)
-                    out[i+j] = in[i+j] >= 0 ? quantized : -quantized;
-                if (vec[j] != 0.0f)
-                    curbits++;
-                qenergy += quantized*quantized;
-                rd += di*di;
-            }
-        } else {
-            for (j = 0; j < dim; j++) {
-                quantized = vec[j]*IQ;
-                qenergy += quantized*quantized;
-                if (out)
-                    out[i+j] = quantized;
-                rd += (in[i+j] - quantized)*(in[i+j] - quantized);
-            }
-        }
-        cost    += rd * lambda + curbits;
-        resbits += curbits;
-        if (cost >= uplim)
-            return uplim;
-        if (pb) {
-            put_bits(pb, ff_aac_spectral_bits[cb-1][curidx], ff_aac_spectral_codes[cb-1][curidx]);
-            if (BT_UNSIGNED)
-                for (j = 0; j < dim; j++)
-                    if (ff_aac_codebook_vectors[cb-1][curidx*dim+j] != 0.0f)
-                        put_bits(pb, 1, in[i+j] < 0.0f);
-            if (BT_ESC) {
-                for (j = 0; j < 2; j++) {
-                    if (ff_aac_codebook_vectors[cb-1][curidx*2+j] == 64.0f) {
-                        int coef = av_clip_uintp2(quant(fabsf(in[i+j]), Q, ROUNDING), 13);
-                        int len = av_log2(coef);
-
-                        put_bits(pb, len - 4 + 1, (1 << (len - 4 + 1)) - 2);
-                        put_sbits(pb, len, coef);
-                    }
-                }
-            }
-        }
-    }
-
-    if (bits)
-        *bits = resbits;
-    if (energy)
-        *energy = qenergy;
-    return cost;
-}
-
-static inline float quantize_and_encode_band_cost_NONE(struct AACEncContext *s, PutBitContext *pb,
-                                                const float *in, float *quant, const float *scaled,
-                                                int size, int scale_idx, int cb,
-                                                const float lambda, const float uplim,
-                                                int *bits, float *energy) {
-    av_assert0(0);
-    return 0.0f;
-}
-
-#define QUANTIZE_AND_ENCODE_BAND_COST_FUNC(NAME, BT_ZERO, BT_UNSIGNED, BT_PAIR, BT_ESC, BT_NOISE, BT_STEREO, ROUNDING) \
-static float quantize_and_encode_band_cost_ ## NAME(                                         \
-                                struct AACEncContext *s,                                     \
-                                PutBitContext *pb, const float *in, float *quant,            \
-                                const float *scaled, int size, int scale_idx,                \
-                                int cb, const float lambda, const float uplim,               \
-                                int *bits, float *energy) {                                  \
-    return quantize_and_encode_band_cost_template(                                           \
-                                s, pb, in, quant, scaled, size, scale_idx,                   \
-                                BT_ESC ? ESC_BT : cb, lambda, uplim, bits, energy,           \
-                                BT_ZERO, BT_UNSIGNED, BT_PAIR, BT_ESC, BT_NOISE, BT_STEREO,  \
-                                ROUNDING);                                                   \
-}
-
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(ZERO,  1, 0, 0, 0, 0, 0, ROUND_STANDARD)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(SQUAD, 0, 0, 0, 0, 0, 0, ROUND_STANDARD)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(UQUAD, 0, 1, 0, 0, 0, 0, ROUND_STANDARD)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(SPAIR, 0, 0, 1, 0, 0, 0, ROUND_STANDARD)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(UPAIR, 0, 1, 1, 0, 0, 0, ROUND_STANDARD)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(ESC,   0, 1, 1, 1, 0, 0, ROUND_STANDARD)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(ESC_RTZ, 0, 1, 1, 1, 0, 0, ROUND_TO_ZERO)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(NOISE, 0, 0, 0, 0, 1, 0, ROUND_STANDARD)
-QUANTIZE_AND_ENCODE_BAND_COST_FUNC(STEREO,0, 0, 0, 0, 0, 1, ROUND_STANDARD)
-
-static float (*const quantize_and_encode_band_cost_arr[])(
-                                struct AACEncContext *s,
-                                PutBitContext *pb, const float *in, float *quant,
-                                const float *scaled, int size, int scale_idx,
-                                int cb, const float lambda, const float uplim,
-                                int *bits, float *energy) = {
-    quantize_and_encode_band_cost_ZERO,
-    quantize_and_encode_band_cost_SQUAD,
-    quantize_and_encode_band_cost_SQUAD,
-    quantize_and_encode_band_cost_UQUAD,
-    quantize_and_encode_band_cost_UQUAD,
-    quantize_and_encode_band_cost_SPAIR,
-    quantize_and_encode_band_cost_SPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_ESC,
-    quantize_and_encode_band_cost_NONE,     /* CB 12 doesn't exist */
-    quantize_and_encode_band_cost_NOISE,
-    quantize_and_encode_band_cost_STEREO,
-    quantize_and_encode_band_cost_STEREO,
-};
+#include "aacenc.h"
+#include "put_bits.h"
 
-static float (*const quantize_and_encode_band_cost_rtz_arr[])(
-                                struct AACEncContext *s,
-                                PutBitContext *pb, const float *in, float *quant,
-                                const float *scaled, int size, int scale_idx,
-                                int cb, const float lambda, const float uplim,
-                                int *bits, float *energy) = {
-    quantize_and_encode_band_cost_ZERO,
-    quantize_and_encode_band_cost_SQUAD,
-    quantize_and_encode_band_cost_SQUAD,
-    quantize_and_encode_band_cost_UQUAD,
-    quantize_and_encode_band_cost_UQUAD,
-    quantize_and_encode_band_cost_SPAIR,
-    quantize_and_encode_band_cost_SPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_UPAIR,
-    quantize_and_encode_band_cost_ESC_RTZ,
-    quantize_and_encode_band_cost_NONE,     /* CB 12 doesn't exist */
-    quantize_and_encode_band_cost_NOISE,
-    quantize_and_encode_band_cost_STEREO,
-    quantize_and_encode_band_cost_STEREO,
-};
 
-#define quantize_and_encode_band_cost(                                  \
-                                s, pb, in, quant, scaled, size, scale_idx, cb, \
-                                lambda, uplim, bits, energy, rtz)               \
-    ((rtz) ? quantize_and_encode_band_cost_rtz_arr : quantize_and_encode_band_cost_arr)[cb]( \
-                                s, pb, in, quant, scaled, size, scale_idx, cb, \
-                                lambda, uplim, bits, energy)
+float ff_quantize_and_encode_band_cost(AACEncContext *s, PutBitContext *pb,
+                                       const float *in, float *quant, const float *scaled,
+                                       int size, int scale_idx, int cb,
+                                       const float lambda, const float uplim,
+                                       int *bits, float *energy);
 
 static inline float quantize_band_cost(struct AACEncContext *s, const float *in,
                                 const float *scaled, int size, int scale_idx,
                                 int cb, const float lambda, const float uplim,
-                                int *bits, float *energy, int rtz)
+                                int *bits, float *energy)
 {
-    return quantize_and_encode_band_cost(s, NULL, in, NULL, scaled, size, scale_idx,
-                                         cb, lambda, uplim, bits, energy, rtz);
+    return ff_quantize_and_encode_band_cost(s, NULL, in, NULL, scaled, size, scale_idx,
+                                            cb, lambda, uplim, bits, energy);
 }
 
 static inline int quantize_band_cost_bits(struct AACEncContext *s, const float *in,
                                 const float *scaled, int size, int scale_idx,
                                 int cb, const float lambda, const float uplim,
-                                int *bits, float *energy, int rtz)
+                                int *bits, float *energy)
 {
     int auxbits;
-    quantize_and_encode_band_cost(s, NULL, in, NULL, scaled, size, scale_idx,
-                                         cb, 0.0f, uplim, &auxbits, energy, rtz);
+    ff_quantize_and_encode_band_cost(s, NULL, in, NULL, scaled, size, scale_idx,
+                                     cb, 0.0f, uplim, &auxbits, energy);
     if (bits) {
         *bits = auxbits;
     }
     return auxbits;
 }
 
-static inline void quantize_and_encode_band(struct AACEncContext *s, PutBitContext *pb,
-                                            const float *in, float *out, int size, int scale_idx,
-                                            int cb, const float lambda, int rtz)
-{
-    quantize_and_encode_band_cost(s, pb, in, out, NULL, size, scale_idx, cb, lambda,
-                                  INFINITY, NULL, NULL, rtz);
-}
-
 #include "aacenc_quantization_misc.h"
 
 #endif /* AVCODEC_AACENC_QUANTIZATION_H */
diff --git a/libavcodec/aacenc_quantization_misc.h b/libavcodec/aacenc_quantization_misc.h
index 28676ca..c789754 100644
--- a/libavcodec/aacenc_quantization_misc.h
+++ b/libavcodec/aacenc_quantization_misc.h
@@ -38,7 +38,7 @@ static inline float quantize_band_cost_cached(struct AACEncContext *s, int w, in
     entry = &s->quantize_band_cost_cache[scale_idx][w*16+g];
     if (entry->generation != s->quantize_band_cost_cache_generation || entry->cb != cb || entry->rtz != rtz) {
         entry->rd = quantize_band_cost(s, in, scaled, size, scale_idx,
-                                       cb, lambda, uplim, &entry->bits, &entry->energy, rtz);
+                                       cb, lambda, uplim, &entry->bits, &entry->energy);
         entry->cb = cb;
         entry->rtz = rtz;
         entry->generation = s->quantize_band_cost_cache_generation;
diff --git a/libavcodec/aacenc_tns.c b/libavcodec/aacenc_tns.c
index 2ffe1f8..195ff5e 100644
--- a/libavcodec/aacenc_tns.c
+++ b/libavcodec/aacenc_tns.c
@@ -30,7 +30,6 @@
 #include "aacenc_tns.h"
 #include "aactab.h"
 #include "aacenc_utils.h"
-#include "aacenc_quantization.h"
 
 /* Could be set to 3 to save an additional bit at the cost of little quality */
 #define TNS_Q_BITS 4
diff --git a/libavcodec/aacsbr_template.c b/libavcodec/aacsbr_template.c
index b72c94b..dccae05 100644
--- a/libavcodec/aacsbr_template.c
+++ b/libavcodec/aacsbr_template.c
@@ -955,6 +955,8 @@ static void read_sbr_extension(AACContext *ac, SpectralBandReplication *sbr,
         } else {
             *num_bits_left -= ff_ps_read_data(ac->avctx, gb, &sbr->ps.common, *num_bits_left);
             ac->avctx->profile = FF_PROFILE_AAC_HE_V2;
+            // ensure the warning is not printed if PS extension is present
+            ac->warned_he_aac_mono = 1;
         }
         break;
     default:
diff --git a/libavcodec/aarch64/h264chroma_init_aarch64.c b/libavcodec/aarch64/h264chroma_init_aarch64.c
index fa6e0ea..00fc7b2 100644
--- a/libavcodec/aarch64/h264chroma_init_aarch64.c
+++ b/libavcodec/aarch64/h264chroma_init_aarch64.c
@@ -28,18 +28,18 @@
 
 #include "config.h"
 
-void ff_put_h264_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_put_h264_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_put_h264_chroma_mc2_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc2_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
-void ff_avg_h264_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_avg_h264_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_avg_h264_chroma_mc2_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc2_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
 av_cold void ff_h264chroma_init_aarch64(H264ChromaContext *c, int bit_depth)
diff --git a/libavcodec/aarch64/h264cmc_neon.S b/libavcodec/aarch64/h264cmc_neon.S
index f8e9407..88ccd72 100644
--- a/libavcodec/aarch64/h264cmc_neon.S
+++ b/libavcodec/aarch64/h264cmc_neon.S
@@ -23,7 +23,7 @@
 
 #include "libavutil/aarch64/asm.S"
 
-/* chroma_mc8(uint8_t *dst, uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
+/* chroma_mc8(uint8_t *dst, const uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
 .macro  h264_chroma_mc8 type, codec=h264
 function ff_\type\()_\codec\()_chroma_mc8_neon, export=1
   .ifc \type,avg
@@ -193,7 +193,7 @@ function ff_\type\()_\codec\()_chroma_mc8_neon, export=1
 endfunc
 .endm
 
-/* chroma_mc4(uint8_t *dst, uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
+/* chroma_mc4(uint8_t *dst, const uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
 .macro  h264_chroma_mc4 type, codec=h264
 function ff_\type\()_\codec\()_chroma_mc4_neon, export=1
   .ifc \type,avg
diff --git a/libavcodec/aarch64/hevcdsp_idct_neon.S b/libavcodec/aarch64/hevcdsp_idct_neon.S
index 0869431..484eea8 100644
--- a/libavcodec/aarch64/hevcdsp_idct_neon.S
+++ b/libavcodec/aarch64/hevcdsp_idct_neon.S
@@ -27,21 +27,21 @@
 #include "libavutil/aarch64/asm.S"
 
 const trans, align=4
-        .short 64, 83, 64, 36
-        .short 89, 75, 50, 18
-        .short 90, 87, 80, 70
-        .short 57, 43, 25, 9
-        .short 90, 90, 88, 85
-        .short 82, 78, 73, 67
-        .short 61, 54, 46, 38
-        .short 31, 22, 13, 4
+        .short          64, 83, 64, 36
+        .short          89, 75, 50, 18
+        .short          90, 87, 80, 70
+        .short          57, 43, 25, 9
+        .short          90, 90, 88, 85
+        .short          82, 78, 73, 67
+        .short          61, 54, 46, 38
+        .short          31, 22, 13, 4
 endconst
 
 .macro clip10 in1, in2, c1, c2
-        smax        \in1, \in1, \c1
-        smax        \in2, \in2, \c1
-        smin        \in1, \in1, \c2
-        smin        \in2, \in2, \c2
+        smax            \in1, \in1, \c1
+        smax            \in2, \in2, \c1
+        smin            \in1, \in1, \c2
+        smin            \in2, \in2, \c2
 .endm
 
 function ff_hevc_add_residual_4x4_8_neon, export=1
@@ -50,13 +50,13 @@ function ff_hevc_add_residual_4x4_8_neon, export=1
         ld1             {v2.s}[1], [x0], x2
         ld1             {v2.s}[2], [x0], x2
         ld1             {v2.s}[3], [x0], x2
-        sub              x0,  x0,  x2, lsl #2
-        uxtl             v6.8h,  v2.8b
-        uxtl2            v7.8h,  v2.16b
-        sqadd            v0.8h,  v0.8h, v6.8h
-        sqadd            v1.8h,  v1.8h, v7.8h
-        sqxtun           v0.8b,  v0.8h
-        sqxtun2          v0.16b, v1.8h
+        sub             x0, x0, x2, lsl #2
+        uxtl            v6.8h,  v2.8b
+        uxtl2           v7.8h,  v2.16b
+        sqadd           v0.8h,  v0.8h, v6.8h
+        sqadd           v1.8h,  v1.8h, v7.8h
+        sqxtun          v0.8b,  v0.8h
+        sqxtun2         v0.16b, v1.8h
         st1             {v0.s}[0], [x0], x2
         st1             {v0.s}[1], [x0], x2
         st1             {v0.s}[2], [x0], x2
@@ -70,63 +70,63 @@ function ff_hevc_add_residual_4x4_10_neon, export=1
         ld1             {v2.d}[0], [x12], x2
         ld1             {v2.d}[1], [x12], x2
         ld1             {v3.d}[0], [x12], x2
-        sqadd            v0.8h, v0.8h, v2.8h
+        sqadd           v0.8h, v0.8h, v2.8h
         ld1             {v3.d}[1], [x12], x2
-        movi             v4.8h, #0
-        sqadd            v1.8h, v1.8h, v3.8h
-        mvni             v5.8h, #0xFC, lsl #8 // movi #0x3FF
-        clip10           v0.8h, v1.8h, v4.8h, v5.8h
-        st1             {v0.d}[0],  [x0], x2
-        st1             {v0.d}[1],  [x0], x2
-        st1             {v1.d}[0],  [x0], x2
-        st1             {v1.d}[1],  [x0], x2
+        movi            v4.8h, #0
+        sqadd           v1.8h, v1.8h, v3.8h
+        mvni            v5.8h, #0xFC, lsl #8 // movi #0x3FF
+        clip10          v0.8h, v1.8h, v4.8h, v5.8h
+        st1             {v0.d}[0], [x0],  x2
+        st1             {v0.d}[1], [x0],  x2
+        st1             {v1.d}[0], [x0],  x2
+        st1             {v1.d}[1], [x0],  x2
         ret
 endfunc
 
 function ff_hevc_add_residual_8x8_8_neon, export=1
-        add             x12,  x0, x2
-        add              x2,  x2, x2
-        mov              x3,  #8
-1:      subs             x3,  x3, #2
-        ld1             {v2.d}[0],     [x0]
-        ld1             {v2.d}[1],    [x12]
-        uxtl             v3.8h,  v2.8b
+        add             x12, x0, x2
+        add             x2, x2, x2
+        mov             x3, #8
+1:      subs            x3, x3, #2
+        ld1             {v2.d}[0], [x0]
+        ld1             {v2.d}[1], [x12]
+        uxtl            v3.8h,  v2.8b
         ld1             {v0.8h-v1.8h}, [x1], #32
-        uxtl2            v2.8h,  v2.16b
-        sqadd            v0.8h,  v0.8h,   v3.8h
-        sqadd            v1.8h,  v1.8h,   v2.8h
-        sqxtun           v0.8b,  v0.8h
-        sqxtun2          v0.16b, v1.8h
-        st1             {v0.d}[0],     [x0], x2
-        st1             {v0.d}[1],    [x12], x2
-        bne              1b
+        uxtl2           v2.8h,  v2.16b
+        sqadd           v0.8h,  v0.8h, v3.8h
+        sqadd           v1.8h,  v1.8h, v2.8h
+        sqxtun          v0.8b,  v0.8h
+        sqxtun2         v0.16b, v1.8h
+        st1             {v0.d}[0], [x0],  x2
+        st1             {v0.d}[1], [x12], x2
+        bne             1b
         ret
 endfunc
 
 function ff_hevc_add_residual_8x8_10_neon, export=1
-        add             x12,  x0, x2
-        add              x2,  x2, x2
-        mov              x3,  #8
-        movi             v4.8h, #0
-        mvni             v5.8h, #0xFC, lsl #8 // movi #0x3FF
-1:      subs             x3,  x3, #2
+        add             x12, x0, x2
+        add             x2,  x2, x2
+        mov             x3,  #8
+        movi            v4.8h, #0
+        mvni            v5.8h, #0xFC, lsl #8 // movi #0x3FF
+1:      subs            x3,  x3, #2
         ld1             {v0.8h-v1.8h}, [x1], #32
-        ld1             {v2.8h},       [x0]
-        sqadd            v0.8h, v0.8h, v2.8h
-        ld1             {v3.8h},      [x12]
-        sqadd            v1.8h, v1.8h, v3.8h
-        clip10           v0.8h, v1.8h, v4.8h, v5.8h
-        st1             {v0.8h},       [x0], x2
-        st1             {v1.8h},      [x12], x2
-        bne              1b
+        ld1             {v2.8h}, [x0]
+        sqadd           v0.8h, v0.8h, v2.8h
+        ld1             {v3.8h}, [x12]
+        sqadd           v1.8h, v1.8h, v3.8h
+        clip10          v0.8h, v1.8h, v4.8h, v5.8h
+        st1             {v0.8h}, [x0],  x2
+        st1             {v1.8h}, [x12], x2
+        bne             1b
         ret
 endfunc
 
 function ff_hevc_add_residual_16x16_8_neon, export=1
-        mov              x3,  #16
+        mov             x3,  #16
         add             x12, x0, x2
-        add              x2,  x2, x2
-1:      subs             x3,  x3, #2
+        add             x2,  x2, x2
+1:      subs            x3,  x3, #2
         ld1             {v16.16b},     [x0]
         ld1             {v0.8h-v3.8h}, [x1], #64
         ld1             {v19.16b},    [x12]
@@ -134,47 +134,47 @@ function ff_hevc_add_residual_16x16_8_neon, export=1
         uxtl2           v18.8h, v16.16b
         uxtl            v20.8h, v19.8b
         uxtl2           v21.8h, v19.16b
-        sqadd            v0.8h,  v0.8h, v17.8h
-        sqadd            v1.8h,  v1.8h, v18.8h
-        sqadd            v2.8h,  v2.8h, v20.8h
-        sqadd            v3.8h,  v3.8h, v21.8h
-        sqxtun           v0.8b,  v0.8h
+        sqadd           v0.8h,  v0.8h, v17.8h
+        sqadd           v1.8h,  v1.8h, v18.8h
+        sqadd           v2.8h,  v2.8h, v20.8h
+        sqadd           v3.8h,  v3.8h, v21.8h
+        sqxtun          v0.8b,  v0.8h
         sqxtun2         v0.16b,  v1.8h
-        sqxtun           v1.8b,  v2.8h
+        sqxtun          v1.8b,  v2.8h
         sqxtun2         v1.16b,  v3.8h
         st1             {v0.16b},     [x0], x2
         st1             {v1.16b},    [x12], x2
-        bne              1b
+        bne             1b
         ret
 endfunc
 
 function ff_hevc_add_residual_16x16_10_neon, export=1
-        mov              x3,  #16
+        mov             x3,  #16
         movi            v20.8h, #0
         mvni            v21.8h, #0xFC, lsl #8 // movi #0x3FF
         add             x12,  x0, x2
-        add              x2,  x2, x2
-1:      subs             x3,  x3, #2
+        add             x2,  x2, x2
+1:      subs            x3,  x3, #2
         ld1             {v16.8h-v17.8h}, [x0]
-        ld1             {v0.8h-v3.8h},  [x1], #64
-        sqadd            v0.8h, v0.8h, v16.8h
+        ld1             {v0.8h-v3.8h},   [x1], #64
+        sqadd           v0.8h, v0.8h, v16.8h
         ld1             {v18.8h-v19.8h}, [x12]
-        sqadd            v1.8h, v1.8h, v17.8h
-        sqadd            v2.8h, v2.8h, v18.8h
-        sqadd            v3.8h, v3.8h, v19.8h
-        clip10           v0.8h, v1.8h, v20.8h, v21.8h
-        clip10           v2.8h, v3.8h, v20.8h, v21.8h
-        st1             {v0.8h-v1.8h},   [x0], x2
-        st1             {v2.8h-v3.8h},  [x12], x2
-        bne              1b
+        sqadd           v1.8h, v1.8h, v17.8h
+        sqadd           v2.8h, v2.8h, v18.8h
+        sqadd           v3.8h, v3.8h, v19.8h
+        clip10          v0.8h, v1.8h, v20.8h, v21.8h
+        clip10          v2.8h, v3.8h, v20.8h, v21.8h
+        st1             {v0.8h-v1.8h}, [x0],  x2
+        st1             {v2.8h-v3.8h}, [x12], x2
+        bne             1b
         ret
 endfunc
 
 function ff_hevc_add_residual_32x32_8_neon, export=1
         add             x12,  x0, x2
-        add              x2,  x2, x2
-        mov              x3,  #32
-1:      subs             x3,  x3, #2
+        add             x2,  x2, x2
+        mov             x3,  #32
+1:      subs            x3,  x3, #2
         ld1             {v20.16b, v21.16b}, [x0]
         uxtl            v16.8h,  v20.8b
         uxtl2           v17.8h,  v20.16b
@@ -187,43 +187,43 @@ function ff_hevc_add_residual_32x32_8_neon, export=1
         uxtl2           v21.8h,  v22.16b
         uxtl            v22.8h,  v23.8b
         uxtl2           v23.8h,  v23.16b
-        sqadd            v0.8h,  v0.8h,  v16.8h
-        sqadd            v1.8h,  v1.8h,  v17.8h
-        sqadd            v2.8h,  v2.8h,  v18.8h
-        sqadd            v3.8h,  v3.8h,  v19.8h
-        sqadd            v4.8h,  v4.8h,  v20.8h
-        sqadd            v5.8h,  v5.8h,  v21.8h
-        sqadd            v6.8h,  v6.8h,  v22.8h
-        sqadd            v7.8h,  v7.8h,  v23.8h
-        sqxtun           v0.8b,  v0.8h
+        sqadd           v0.8h,   v0.8h,   v16.8h
+        sqadd           v1.8h,   v1.8h,   v17.8h
+        sqadd           v2.8h,   v2.8h,   v18.8h
+        sqadd           v3.8h,   v3.8h,   v19.8h
+        sqadd           v4.8h,   v4.8h,   v20.8h
+        sqadd           v5.8h,   v5.8h,   v21.8h
+        sqadd           v6.8h,   v6.8h,   v22.8h
+        sqadd           v7.8h,   v7.8h,   v23.8h
+        sqxtun          v0.8b,   v0.8h
         sqxtun2         v0.16b,  v1.8h
-        sqxtun           v1.8b,  v2.8h
+        sqxtun          v1.8b,   v2.8h
         sqxtun2         v1.16b,  v3.8h
-        sqxtun           v2.8b,  v4.8h
+        sqxtun          v2.8b,   v4.8h
         sqxtun2         v2.16b,  v5.8h
-        st1             {v0.16b, v1.16b},  [x0], x2
-        sqxtun           v3.8b,  v6.8h
+        st1             {v0.16b, v1.16b}, [x0],  x2
+        sqxtun          v3.8b,   v6.8h
         sqxtun2         v3.16b,  v7.8h
         st1             {v2.16b, v3.16b}, [x12], x2
-        bne              1b
+        bne             1b
         ret
 endfunc
 
 function ff_hevc_add_residual_32x32_10_neon, export=1
-        mov              x3,  #32
+        mov             x3, #32
         movi            v20.8h, #0
         mvni            v21.8h, #0xFC, lsl #8 // movi #0x3FF
-1:      subs             x3,  x3, #1
-        ld1             {v0.8h-v3.8h},   [x1], #64
+1:      subs            x3, x3, #1
+        ld1             {v0.8h -v3.8h},  [x1], #64
         ld1             {v16.8h-v19.8h}, [x0]
-        sqadd            v0.8h, v0.8h, v16.8h
-        sqadd            v1.8h, v1.8h, v17.8h
-        sqadd            v2.8h, v2.8h, v18.8h
-        sqadd            v3.8h, v3.8h, v19.8h
-        clip10           v0.8h, v1.8h, v20.8h, v21.8h
-        clip10           v2.8h, v3.8h, v20.8h, v21.8h
-        st1             {v0.8h-v3.8h},   [x0], x2
-        bne              1b
+        sqadd           v0.8h, v0.8h, v16.8h
+        sqadd           v1.8h, v1.8h, v17.8h
+        sqadd           v2.8h, v2.8h, v18.8h
+        sqadd           v3.8h, v3.8h, v19.8h
+        clip10          v0.8h, v1.8h, v20.8h, v21.8h
+        clip10          v2.8h, v3.8h, v20.8h, v21.8h
+        st1             {v0.8h-v3.8h}, [x0], x2
+        bne             1b
         ret
 endfunc
 
diff --git a/libavcodec/aarch64/hevcdsp_init_aarch64.c b/libavcodec/aarch64/hevcdsp_init_aarch64.c
index 2002530..9cbe983 100644
--- a/libavcodec/aarch64/hevcdsp_init_aarch64.c
+++ b/libavcodec/aarch64/hevcdsp_init_aarch64.c
@@ -25,21 +25,21 @@
 #include "libavutil/aarch64/cpu.h"
 #include "libavcodec/hevcdsp.h"
 
-void ff_hevc_add_residual_4x4_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_4x4_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                      ptrdiff_t stride);
-void ff_hevc_add_residual_4x4_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_4x4_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                       ptrdiff_t stride);
-void ff_hevc_add_residual_8x8_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_8x8_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                      ptrdiff_t stride);
-void ff_hevc_add_residual_8x8_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_8x8_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                       ptrdiff_t stride);
-void ff_hevc_add_residual_16x16_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_16x16_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                        ptrdiff_t stride);
-void ff_hevc_add_residual_16x16_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_16x16_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                         ptrdiff_t stride);
-void ff_hevc_add_residual_32x32_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_32x32_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                        ptrdiff_t stride);
-void ff_hevc_add_residual_32x32_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_32x32_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                         ptrdiff_t stride);
 void ff_hevc_idct_8x8_8_neon(int16_t *coeffs, int col_limit);
 void ff_hevc_idct_8x8_10_neon(int16_t *coeffs, int col_limit);
@@ -53,14 +53,14 @@ void ff_hevc_idct_4x4_dc_10_neon(int16_t *coeffs);
 void ff_hevc_idct_8x8_dc_10_neon(int16_t *coeffs);
 void ff_hevc_idct_16x16_dc_10_neon(int16_t *coeffs);
 void ff_hevc_idct_32x32_dc_10_neon(int16_t *coeffs);
-void ff_hevc_sao_band_filter_8x8_8_neon(uint8_t *_dst, uint8_t *_src,
+void ff_hevc_sao_band_filter_8x8_8_neon(uint8_t *_dst, const uint8_t *_src,
                                   ptrdiff_t stride_dst, ptrdiff_t stride_src,
-                                  int16_t *sao_offset_val, int sao_left_class,
+                                  const int16_t *sao_offset_val, int sao_left_class,
                                   int width, int height);
-void ff_hevc_sao_edge_filter_16x16_8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride_dst,
-                                          int16_t *sao_offset_val, int eo, int width, int height);
-void ff_hevc_sao_edge_filter_8x8_8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride_dst,
-                                          int16_t *sao_offset_val, int eo, int width, int height);
+void ff_hevc_sao_edge_filter_16x16_8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride_dst,
+                                          const int16_t *sao_offset_val, int eo, int width, int height);
+void ff_hevc_sao_edge_filter_8x8_8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride_dst,
+                                        const int16_t *sao_offset_val, int eo, int width, int height);
 
 av_cold void ff_hevc_dsp_init_aarch64(HEVCDSPContext *c, const int bit_depth)
 {
diff --git a/libavcodec/aarch64/me_cmp_init_aarch64.c b/libavcodec/aarch64/me_cmp_init_aarch64.c
index bec9148..79c7399 100644
--- a/libavcodec/aarch64/me_cmp_init_aarch64.c
+++ b/libavcodec/aarch64/me_cmp_init_aarch64.c
@@ -23,9 +23,11 @@
 #include "libavutil/aarch64/cpu.h"
 #include "libavcodec/mpegvideo.h"
 
-int ff_pix_abs16_neon(MpegEncContext *s, uint8_t *blk1, uint8_t *blk2,
+int ff_pix_abs16_neon(MpegEncContext *s, const uint8_t *blk1, const uint8_t *blk2,
                       ptrdiff_t stride, int h);
-int ff_pix_abs16_xy2_neon(MpegEncContext *s, uint8_t *blk1, uint8_t *blk2,
+int ff_pix_abs16_xy2_neon(MpegEncContext *s, const uint8_t *blk1, const uint8_t *blk2,
+                      ptrdiff_t stride, int h);
+int ff_pix_abs16_x2_neon(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                       ptrdiff_t stride, int h);
 
 av_cold void ff_me_cmp_init_aarch64(MECmpContext *c, AVCodecContext *avctx)
@@ -34,6 +36,7 @@ av_cold void ff_me_cmp_init_aarch64(MECmpContext *c, AVCodecContext *avctx)
 
     if (have_neon(cpu_flags)) {
         c->pix_abs[0][0] = ff_pix_abs16_neon;
+        c->pix_abs[0][1] = ff_pix_abs16_x2_neon;
         c->pix_abs[0][3] = ff_pix_abs16_xy2_neon;
 
         c->sad[0] = ff_pix_abs16_neon;
diff --git a/libavcodec/aarch64/me_cmp_neon.S b/libavcodec/aarch64/me_cmp_neon.S
index a7937bd..cda7ce0 100644
--- a/libavcodec/aarch64/me_cmp_neon.S
+++ b/libavcodec/aarch64/me_cmp_neon.S
@@ -27,15 +27,16 @@ function ff_pix_abs16_neon, export=1
         // x3           ptrdiff_t stride
         // w4           int h
         cmp             w4, #4                      // if h < 4, jump to completion section
-        movi            v18.4S, #0                  // clear result accumulator
+        movi            v16.8h, #0                  // clear result accumulator
+        movi            v17.8h, #0                  // clear result accumulator
         b.lt            2f
 1:
         ld1             {v0.16b}, [x1], x3          // load pix1
         ld1             {v4.16b}, [x2], x3          // load pix2
         ld1             {v1.16b}, [x1], x3          // load pix1
         ld1             {v5.16b}, [x2], x3          // load pix2
-        uabdl           v16.8h, v0.8b, v4.8b        // absolute difference accumulate
-        uabdl2          v17.8h, v0.16b, v4.16b
+        uabal           v16.8h, v0.8b, v4.8b        // absolute difference accumulate
+        uabal2          v17.8h, v0.16b, v4.16b
         ld1             {v2.16b}, [x1], x3          // load pix1
         ld1             {v6.16b}, [x2], x3          // load pix2
         uabal           v16.8h, v1.8b, v5.8b        // absolute difference accumulate
@@ -48,27 +49,26 @@ function ff_pix_abs16_neon, export=1
         uabal           v16.8h, v3.8b, v7.8b
         uabal2          v17.8h, v3.16b, v7.16b
         cmp             w4, #4                      // if h >= 4, loop
-        add             v16.8h, v16.8h, v17.8h
-        uaddlv          s16, v16.8h                 // add up everything in v16 accumulator
-        add             d18, d16, d18               // add to the end result register
 
         b.ge            1b
         cbnz            w4, 2f                      // if iterations remain, jump to completion section
 
-        fmov            w0, s18                     // copy result to general purpose register
+        add             v16.8h, v16.8h, v17.8h
+        uaddlv          s16, v16.8h                 // add up everything in v16 accumulator
+        fmov            w0, s16                     // copy result to general purpose register
         ret
 
 2:
         ld1             {v0.16b}, [x1], x3          // load pix1
         ld1             {v4.16b}, [x2], x3          // load pix2
-        uabdl           v16.8h, v0.8b, v4.8b        // absolute difference accumulate
-        uabal2          v16.8h, v0.16b, v4.16b
         subs            w4, w4, #1                  // h -= 1
-        addv            h16, v16.8h                 // add up v16
-        add             d18, d16, d18               // add to result
+        uabal           v16.8h, v0.8b, v4.8b        // absolute difference accumulate
+        uabal2          v17.8h, v0.16b, v4.16b
         b.ne            2b
 
-        fmov            w0, s18                     // copy result to general purpose register
+        add             v16.8h, v16.8h, v17.8h
+        uaddlv          s16, v16.8h                 // add up everything in v16 accumulator
+        fmov            w0, s16                     // copy result to general purpose register
         ret
 endfunc
 
@@ -80,7 +80,8 @@ function ff_pix_abs16_xy2_neon, export=1
         // w4           int h
 
         add             x5, x2, x3                  // use x5 to hold uint8_t *pix3
-        movi            v0.2d, #0                   // initialize the result register
+        movi            v21.8h, #0                  // initialize the result register
+        movi            v22.8h, #0                  // initialize the result register
 
         // Load initial pix2 values for either the unrolled version or completion version.
         ldur            q4, [x2, #1]                // load pix2+1
@@ -101,26 +102,35 @@ function ff_pix_abs16_xy2_neon, export=1
         ld1             {v6.16b}, [x5], x3          // load pix3
         ld1             {v16.16b}, [x1], x3         // load pix1
 
-        ldur            q19, [x5, #1]               // load pix3+1
-        ld1             {v18.16b}, [x5], x3         // load pix3
-        ld1             {v17.16b}, [x1], x3         // load pix1
-
-        ldur            q22, [x5, #1]               // load pix3+1
-        ld1             {v21.16b}, [x5], x3         // load pix3
-        ld1             {v20.16b}, [x1], x3         // load pix1
-
         // These blocks compute the average: avg(pix2[n], pix2[n+1], pix3[n], pix3[n+1])
         uaddl           v30.8h, v4.8b, v5.8b        // pix3 + pix3+1 0..7
         uaddl2          v31.8h, v4.16b, v5.16b      // pix3 + pix3+1 8..15
+
+        ldur            q19, [x5, #1]               // load pix3+1
+
         add             v23.8h, v2.8h, v30.8h       // add up 0..7, using pix2 + pix2+1 values from previous iteration
         add             v24.8h, v3.8h, v31.8h       // add up 8..15, using pix2 + pix2+1 values from previous iteration
+
+        ld1             {v18.16b}, [x5], x3         // load pix3
+        ld1             {v17.16b}, [x1], x3         // load pix1
+
         rshrn           v23.8b, v23.8h, #2          // shift right 2 0..7 (rounding shift right)
         rshrn2          v23.16b, v24.8h, #2         // shift right 2 8..15
 
         uaddl           v2.8h, v6.8b, v7.8b         // pix3 + pix3+1 0..7
         uaddl2          v3.8h, v6.16b, v7.16b       // pix3 + pix3+1 8..15
+
+        ldur            q7, [x5, #1]                // load pix3+1
+
         add             v26.8h, v30.8h, v2.8h       // add up 0..7, using pix2 + pix2+1 values from pix3 above
         add             v27.8h, v31.8h, v3.8h       // add up 8..15, using pix2 + pix2+1 values from pix3 above
+
+        uabal           v21.8h, v1.8b,  v23.8b      // absolute difference 0..7, i=0
+        uabal2          v22.8h, v1.16b, v23.16b     // absolute difference 8..15, i=0
+
+        ld1             {v6.16b}, [x5], x3          // load pix3
+        ld1             {v20.16b}, [x1], x3         // load pix1
+
         rshrn           v26.8b, v26.8h, #2          // shift right 2 0..7 (rounding shift right)
         rshrn2          v26.16b, v27.8h, #2         // shift right 2 8..15
 
@@ -131,46 +141,33 @@ function ff_pix_abs16_xy2_neon, export=1
         rshrn           v28.8b, v28.8h, #2          // shift right 2 0..7 (rounding shift right)
         rshrn2          v28.16b, v29.8h, #2         // shift right 2 8..15
 
-        uaddl           v2.8h, v21.8b, v22.8b       // pix3 + pix3+1 0..7
-        uaddl2          v3.8h, v21.16b, v22.16b     // pix3 + pix3+1 8..15
+        uabal           v21.8h, v16.8b,  v26.8b     // absolute difference 0..7, i=1
+        uabal2          v22.8h, v16.16b, v26.16b    // absolute difference 8..15, i=1
+
+        uaddl           v2.8h, v6.8b,  v7.8b        // pix3 + pix3+1 0..7
+        uaddl2          v3.8h, v6.16b, v7.16b       // pix3 + pix3+1 8..15
         add             v30.8h, v4.8h, v2.8h        // add up 0..7, using pix2 + pix2+1 values from pix3 above
         add             v31.8h, v5.8h, v3.8h        // add up 8..15, using pix2 + pix2+1 values from pix3 above
         rshrn           v30.8b, v30.8h, #2          // shift right 2 0..7 (rounding shift right)
         rshrn2          v30.16b, v31.8h, #2         // shift right 2 8..15
 
-        // Averages are now stored in these registers:
-        // v23, v16, v28, v30
-        // pix1 values in these registers:
-        // v1, v16, v17, v20
-        // available:
-        // v4, v5, v7, v18, v19, v24, v25, v27, v29, v31
-
         sub             w4, w4, #4                  // h -= 4
 
-        // Using absolute-difference instructions instead of absolute-difference-accumulate allows
-        // us to keep the results in 16b vectors instead of widening values with twice the instructions.
-        // This approach also has fewer data dependencies, allowing better instruction level parallelism.
-        uabd            v4.16b, v1.16b, v23.16b     // absolute difference 0..15, i=0
-        uabd            v5.16b, v16.16b, v26.16b    // absolute difference 0..15, i=1
-        uabd            v6.16b, v17.16b, v28.16b    // absolute difference 0..15, i=2
-        uabd            v7.16b, v20.16b, v30.16b    // absolute difference 0..15, i=3
+        uabal           v21.8h, v17.8b,  v28.8b     // absolute difference 0..7, i=2
+        uabal2          v22.8h, v17.16b, v28.16b    // absolute difference 8..15, i=2
 
         cmp             w4, #4                      // loop if h >= 4
 
-        // Now add up all the values in each vector, v4-v7 with widening adds
-        uaddl           v19.8h, v4.8b, v5.8b
-        uaddl2          v18.8h, v4.16b, v5.16b
-        uaddl           v4.8h, v6.8b, v7.8b
-        uaddl2          v5.8h, v6.16b, v7.16b
-        add             v4.8h, v4.8h, v5.8h
-        add             v4.8h, v4.8h, v18.8h
-        add             v4.8h, v4.8h, v19.8h
-        uaddlv          s4, v4.8h                   // finish adding up accumulated values
-        add             d0, d0, d4                  // add the value to the top level accumulator
+
+        uabal           v21.8h, v20.8b,  v30.8b     // absolute difference 0..7, i=3
+        uabal2          v22.8h, v20.16b, v30.16b    // absolute difference 8..15, i=3
 
         b.ge            1b
         cbnz            w4, 2f                      // if iterations remain jump to completion section
 
+        add             v4.8h, v21.8h, v22.8h
+        uaddlv          s0, v4.8h                   // finish adding up accumulated values
+
         fmov            w0, s0                      // copy result to general purpose register
         ret
 2:
@@ -186,20 +183,90 @@ function ff_pix_abs16_xy2_neon, export=1
         add             v16.8h, v2.8h, v18.8h       // add up 0..7, using pix2 + pix2+1 values from previous iteration
         add             v17.8h, v3.8h, v19.8h       // add up 8..15, using pix2 + pix2+1 values from previous iteration
         // divide by 4 to compute the average of values summed above
-        urshr           v16.8h, v16.8h, #2          // shift right by 2 0..7 (rounding shift right)
-        urshr           v17.8h, v17.8h, #2          // shift right by 2 8..15
+        rshrn           v16.8b,  v16.8h, #2         // shift right by 2 0..7 (rounding shift right)
+        rshrn2          v16.16b, v17.8h, #2         // shift right by 2 8..15
 
-        uxtl2           v8.8h, v1.16b               // 8->16 bits pix1 8..15
-        uxtl            v1.8h, v1.8b                // 8->16 bits pix1 0..7
-
-        uabd            v6.8h, v1.8h, v16.8h        // absolute difference 0..7
-        uaba            v6.8h, v8.8h, v17.8h        // absolute difference accumulate 8..15
+        uabal           v21.8h, v1.8b,  v16.8b      // absolute difference 0..7
+        uabal2          v22.8h, v1.16b, v16.16b     // absolute difference accumulate 8..15
         mov             v2.16b, v18.16b             // pix3 -> pix2
         mov             v3.16b, v19.16b             // pix3+1 -> pix2+1
-        uaddlv          s6, v6.8h                   // add up accumulator in v6
-        add             d0, d0, d6                  // add to the final result
 
         b.ne            2b                          // loop if h > 0
+
+        add             v4.8h, v21.8h, v22.8h
+        uaddlv          s0, v4.8h                   // finish adding up accumulated values
         fmov            w0, s0                      // copy result to general purpose register
         ret
 endfunc
+
+function ff_pix_abs16_x2_neon, export=1
+        // x0           unused
+        // x1           uint8_t *pix1
+        // x2           uint8_t *pix2
+        // x3           ptrdiff_t stride
+        // w4           int h
+
+        cmp             w4, #4
+        // initialize buffers
+        movi            v16.8h, #0
+        movi            v17.8h, #0
+        add             x5, x2, #1 // pix2 + 1
+        b.lt            2f
+
+// make 4 iterations at once
+1:
+
+        // abs(pix1[0] - avg2(pix2[0], pix2[1]))
+        // avg2(a,b) = (((a) + (b) + 1) >> 1)
+        // abs(x) = (x < 0 ? -x : x)
+
+        ld1             {v1.16b}, [x2], x3
+        ld1             {v2.16b}, [x5], x3
+        urhadd          v30.16b, v1.16b, v2.16b
+        ld1             {v0.16b}, [x1], x3
+        uabal           v16.8h, v0.8b, v30.8b
+        ld1             {v4.16b}, [x2], x3
+        uabal2          v17.8h, v0.16b, v30.16b
+        ld1             {v5.16b}, [x5], x3
+        urhadd          v29.16b, v4.16b, v5.16b
+        ld1             {v3.16b}, [x1], x3
+        uabal           v16.8h, v3.8b, v29.8b
+        ld1             {v7.16b}, [x2], x3
+        uabal2          v17.8h, v3.16b, v29.16b
+        ld1             {v22.16b}, [x5], x3
+        urhadd          v28.16b, v7.16b, v22.16b
+        ld1             {v6.16b}, [x1], x3
+        uabal           v16.8h, v6.8b, v28.8b
+        ld1             {v24.16b}, [x2], x3
+        sub             w4, w4, #4
+        uabal2          v17.8h, v6.16b, v28.16b
+        ld1             {v25.16b}, [x5], x3
+        urhadd          v27.16b, v24.16b, v25.16b
+        ld1             {v23.16b}, [x1], x3
+        cmp             w4, #4
+        uabal           v16.8h, v23.8b, v27.8b
+        uabal2          v17.8h, v23.16b, v27.16b
+
+        b.ge            1b
+        cbz             w4, 3f
+
+// iterate by one
+2:
+        ld1             {v1.16b}, [x2], x3
+        ld1             {v2.16b}, [x5], x3
+        subs            w4, w4, #1
+        urhadd          v29.16b, v1.16b, v2.16b
+        ld1             {v0.16b}, [x1], x3
+        uabal           v16.8h, v0.8b,  v29.8b
+        uabal2          v17.8h, v0.16b, v29.16b
+
+
+        b.ne            2b
+
+3:
+        add             v16.8h, v16.8h, v17.8h
+        uaddlv          s16, v16.8h
+        fmov            w0, s16
+
+        ret
+endfunc
diff --git a/libavcodec/aarch64/rv40dsp_init_aarch64.c b/libavcodec/aarch64/rv40dsp_init_aarch64.c
index 142705d..2b91d68 100644
--- a/libavcodec/aarch64/rv40dsp_init_aarch64.c
+++ b/libavcodec/aarch64/rv40dsp_init_aarch64.c
@@ -25,14 +25,14 @@
 
 #include "config.h"
 
-void ff_put_rv40_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_rv40_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_put_rv40_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_rv40_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
-void ff_avg_rv40_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_rv40_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_avg_rv40_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_rv40_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
 av_cold void ff_rv40dsp_init_aarch64(RV34DSPContext *c)
diff --git a/libavcodec/aarch64/vc1dsp_init_aarch64.c b/libavcodec/aarch64/vc1dsp_init_aarch64.c
index a7976fd..3bc0bd1 100644
--- a/libavcodec/aarch64/vc1dsp_init_aarch64.c
+++ b/libavcodec/aarch64/vc1dsp_init_aarch64.c
@@ -43,13 +43,13 @@ void ff_vc1_h_loop_filter8_neon(uint8_t *src, ptrdiff_t stride, int pq);
 void ff_vc1_v_loop_filter16_neon(uint8_t *src, ptrdiff_t stride, int pq);
 void ff_vc1_h_loop_filter16_neon(uint8_t *src, ptrdiff_t stride, int pq);
 
-void ff_put_vc1_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_vc1_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_avg_vc1_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_vc1_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_put_vc1_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_vc1_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_avg_vc1_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_vc1_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
 
 int ff_vc1_unescape_buffer_helper_neon(const uint8_t *src, int size, uint8_t *dst);
diff --git a/libavcodec/aarch64/videodsp_init.c b/libavcodec/aarch64/videodsp_init.c
index 6f667a6..1f77a91 100644
--- a/libavcodec/aarch64/videodsp_init.c
+++ b/libavcodec/aarch64/videodsp_init.c
@@ -21,7 +21,7 @@
 #include "libavutil/aarch64/cpu.h"
 #include "libavcodec/videodsp.h"
 
-void ff_prefetch_aarch64(uint8_t *mem, ptrdiff_t stride, int h);
+void ff_prefetch_aarch64(const uint8_t *mem, ptrdiff_t stride, int h);
 
 av_cold void ff_videodsp_init_aarch64(VideoDSPContext *ctx, int bpc)
 {
diff --git a/libavcodec/aasc.c b/libavcodec/aasc.c
index 528ee58..d6afa35 100644
--- a/libavcodec/aasc.c
+++ b/libavcodec/aasc.c
@@ -159,5 +159,4 @@ const FFCodec ff_aasc_decoder = {
     .close          = aasc_decode_end,
     FF_CODEC_DECODE_CB(aasc_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ac3dec_fixed.c b/libavcodec/ac3dec_fixed.c
index 4c0d4d6..29f2acc 100644
--- a/libavcodec/ac3dec_fixed.c
+++ b/libavcodec/ac3dec_fixed.c
@@ -183,5 +183,5 @@ const FFCodec ff_ac3_fixed_decoder = {
                       AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/ac3dec_float.c b/libavcodec/ac3dec_float.c
index 2147b36..26fbd78 100644
--- a/libavcodec/ac3dec_float.c
+++ b/libavcodec/ac3dec_float.c
@@ -73,7 +73,7 @@ const FFCodec ff_ac3_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
     .p.priv_class   = &ac3_eac3_decoder_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 #if CONFIG_EAC3_DECODER
@@ -91,6 +91,6 @@ const FFCodec ff_eac3_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
     .p.priv_class   = &ac3_eac3_decoder_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/ac3enc_fixed.c b/libavcodec/ac3enc_fixed.c
index 92bf31b..fe434af 100644
--- a/libavcodec/ac3enc_fixed.c
+++ b/libavcodec/ac3enc_fixed.c
@@ -133,7 +133,7 @@ const FFCodec ff_ac3_fixed_encoder = {
     .p.sample_fmts   = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S32P,
                                                       AV_SAMPLE_FMT_NONE },
     .p.priv_class    = &ff_ac3enc_class,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
     .p.supported_samplerates = ff_ac3_sample_rate_tab,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts = ff_ac3_channel_layouts,
diff --git a/libavcodec/ac3enc_float.c b/libavcodec/ac3enc_float.c
index 9f5341c..666b537 100644
--- a/libavcodec/ac3enc_float.c
+++ b/libavcodec/ac3enc_float.c
@@ -143,6 +143,6 @@ const FFCodec ff_ac3_encoder = {
 #endif
     .p.ch_layouts    = ff_ac3_ch_layouts,
     .defaults        = ff_ac3_enc_defaults,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 };
 FF_ENABLE_DEPRECATION_WARNINGS
diff --git a/libavcodec/acelp_filters.c b/libavcodec/acelp_filters.c
index 9182579..db4908f 100644
--- a/libavcodec/acelp_filters.c
+++ b/libavcodec/acelp_filters.c
@@ -20,8 +20,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <inttypes.h>
 #include <stddef.h>
+#include <stdint.h>
 
 #include "config.h"
 #include "libavutil/avassert.h"
diff --git a/libavcodec/acelp_pitch_delay.c b/libavcodec/acelp_pitch_delay.c
index 1eca97e..6cf880e 100644
--- a/libavcodec/acelp_pitch_delay.c
+++ b/libavcodec/acelp_pitch_delay.c
@@ -23,8 +23,6 @@
 #include "libavutil/common.h"
 #include "libavutil/ffmath.h"
 #include "libavutil/float_dsp.h"
-#include "libavutil/mathematics.h"
-#include "avcodec.h"
 #include "acelp_pitch_delay.h"
 #include "celp_math.h"
 #include "audiodsp.h"
diff --git a/libavcodec/acelp_vectors.c b/libavcodec/acelp_vectors.c
index b8a2b50..04cbffd 100644
--- a/libavcodec/acelp_vectors.c
+++ b/libavcodec/acelp_vectors.c
@@ -20,12 +20,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <inttypes.h>
+#include <stdint.h>
 
+#include "config.h"
 #include "libavutil/avassert.h"
 #include "libavutil/common.h"
 #include "libavutil/float_dsp.h"
-#include "avcodec.h"
 #include "acelp_vectors.h"
 
 const uint8_t ff_fc_2pulses_9bits_track1_gray[16] =
diff --git a/libavcodec/adpcm.c b/libavcodec/adpcm.c
index b2ef7df..c4bcafb 100644
--- a/libavcodec/adpcm.c
+++ b/libavcodec/adpcm.c
@@ -2296,7 +2296,6 @@ const FFCodec ff_ ## name_ ## _decoder = {                  \
     .init           = adpcm_decode_init,                    \
     FF_CODEC_DECODE_CB(adpcm_decode_frame),                 \
     .flush          = adpcm_flush,                          \
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,         \
 };
 #define ADPCM_DECODER_2(enabled, codec_id, name, sample_fmts, long_name) \
     ADPCM_DECODER_ ## enabled(codec_id, name, sample_fmts, long_name)
diff --git a/libavcodec/adpcmenc.c b/libavcodec/adpcmenc.c
index 4ff7766..e27febf 100644
--- a/libavcodec/adpcmenc.c
+++ b/libavcodec/adpcmenc.c
@@ -601,13 +601,13 @@ static int adpcm_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
 {
     int st, pkt_size, ret;
     const int16_t *samples;
-    int16_t **samples_p;
+    const int16_t *const *samples_p;
     uint8_t *dst;
     ADPCMEncodeContext *c = avctx->priv_data;
     int channels = avctx->ch_layout.nb_channels;
 
     samples = (const int16_t *)frame->data[0];
-    samples_p = (int16_t **)frame->extended_data;
+    samples_p = (const int16_t *const *)frame->extended_data;
     st = channels == 2;
 
     if (avctx->codec_id == AV_CODEC_ID_ADPCM_IMA_SSI ||
@@ -1009,7 +1009,7 @@ const FFCodec ff_ ## name_ ## _encoder = {                                 \
     .init           = adpcm_encode_init,                                   \
     FF_CODEC_ENCODE_CB(adpcm_encode_frame),                                \
     .close          = adpcm_encode_close,                                  \
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE, \
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,                           \
 };
 #define ADPCM_ENCODER_2(enabled, codec_id, name, sample_fmts, capabilities, long_name) \
     ADPCM_ENCODER_ ## enabled(codec_id, name, sample_fmts, capabilities, long_name)
diff --git a/libavcodec/adxdec.c b/libavcodec/adxdec.c
index 1ebc250..b5c09ea 100644
--- a/libavcodec/adxdec.c
+++ b/libavcodec/adxdec.c
@@ -203,5 +203,4 @@ const FFCodec ff_adpcm_adx_decoder = {
                       AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/adxenc.c b/libavcodec/adxenc.c
index 9277cab..0a2e509 100644
--- a/libavcodec/adxenc.c
+++ b/libavcodec/adxenc.c
@@ -200,5 +200,4 @@ const FFCodec ff_adpcm_adx_encoder = {
     FF_CODEC_ENCODE_CB(adx_encode_frame),
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/agm.c b/libavcodec/agm.c
index 27438dd..0f65a82 100644
--- a/libavcodec/agm.c
+++ b/libavcodec/agm.c
@@ -1296,7 +1296,6 @@ const FFCodec ff_agm_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .flush            = decode_flush,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP |
                         FF_CODEC_CAP_EXPORTS_CROPPING,
 };
diff --git a/libavcodec/aic.c b/libavcodec/aic.c
index 5f0eec6..21ce778 100644
--- a/libavcodec/aic.c
+++ b/libavcodec/aic.c
@@ -505,5 +505,4 @@ const FFCodec ff_aic_decoder = {
     .close          = aic_decode_close,
     FF_CODEC_DECODE_CB(aic_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/alac.c b/libavcodec/alac.c
index 4aab82d..8b87d78 100644
--- a/libavcodec/alac.c
+++ b/libavcodec/alac.c
@@ -622,6 +622,6 @@ const FFCodec ff_alac_decoder = {
     .close          = alac_decode_close,
     FF_CODEC_DECODE_CB(alac_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class   = &alac_class
 };
diff --git a/libavcodec/alacenc.c b/libavcodec/alacenc.c
index 72ce65e..10dab0a 100644
--- a/libavcodec/alacenc.c
+++ b/libavcodec/alacenc.c
@@ -667,6 +667,5 @@ const FFCodec ff_alac_encoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S32P,
                                                      AV_SAMPLE_FMT_S16P,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 FF_ENABLE_DEPRECATION_WARNINGS
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index bdfc2f6..ed59887 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -34,6 +34,17 @@
 #include "codec_id.h"
 #include "codec_internal.h"
 
+/* RKMPP */
+extern const FFCodec ff_mpeg4_rkmpp_decoder;
+extern const FFCodec ff_mpeg1_rkmpp_decoder;
+extern const FFCodec ff_mpeg2_rkmpp_decoder;
+extern const FFCodec ff_vp8_rkmpp_decoder;
+extern const FFCodec ff_vp9_rkmpp_decoder;
+extern const FFCodec ff_h263_rkmpp_decoder;
+extern const FFCodec ff_h264_rkmpp_decoder;
+extern const FFCodec ff_hevc_rkmpp_decoder;
+extern const FFCodec ff_av1_rkmpp_decoder;
+
 extern const FFCodec ff_a64multi_encoder;
 extern const FFCodec ff_a64multi5_encoder;
 extern const FFCodec ff_aasc_decoder;
@@ -154,12 +165,11 @@ extern const FFCodec ff_h264_v4l2m2m_decoder;
 extern const FFCodec ff_h264_mediacodec_decoder;
 extern const FFCodec ff_h264_mmal_decoder;
 extern const FFCodec ff_h264_qsv_decoder;
-extern const FFCodec ff_h264_rkmpp_decoder;
+extern const FFCodec ff_h264_rkmpp_encoder;
 extern const FFCodec ff_hap_encoder;
 extern const FFCodec ff_hap_decoder;
 extern const FFCodec ff_hevc_decoder;
 extern const FFCodec ff_hevc_qsv_decoder;
-extern const FFCodec ff_hevc_rkmpp_decoder;
 extern const FFCodec ff_hevc_v4l2m2m_decoder;
 extern const FFCodec ff_hnm4_video_decoder;
 extern const FFCodec ff_hq_hqa_decoder;
@@ -372,12 +382,12 @@ extern const FFCodec ff_vp6a_decoder;
 extern const FFCodec ff_vp6f_decoder;
 extern const FFCodec ff_vp7_decoder;
 extern const FFCodec ff_vp8_decoder;
-extern const FFCodec ff_vp8_rkmpp_decoder;
 extern const FFCodec ff_vp8_v4l2m2m_decoder;
 extern const FFCodec ff_vp9_decoder;
-extern const FFCodec ff_vp9_rkmpp_decoder;
 extern const FFCodec ff_vp9_v4l2m2m_decoder;
 extern const FFCodec ff_vqa_decoder;
+extern const FFCodec ff_wbmp_decoder;
+extern const FFCodec ff_wbmp_encoder;
 extern const FFCodec ff_webp_decoder;
 extern const FFCodec ff_wcmv_decoder;
 extern const FFCodec ff_wrapped_avframe_encoder;
@@ -469,6 +479,8 @@ extern const FFCodec ff_gsm_decoder;
 extern const FFCodec ff_gsm_ms_decoder;
 extern const FFCodec ff_hca_decoder;
 extern const FFCodec ff_hcom_decoder;
+extern const FFCodec ff_hdr_encoder;
+extern const FFCodec ff_hdr_decoder;
 extern const FFCodec ff_iac_decoder;
 extern const FFCodec ff_ilbc_decoder;
 extern const FFCodec ff_imc_decoder;
diff --git a/libavcodec/alpha/me_cmp_alpha.c b/libavcodec/alpha/me_cmp_alpha.c
index 8f36019..0c1a4a6 100644
--- a/libavcodec/alpha/me_cmp_alpha.c
+++ b/libavcodec/alpha/me_cmp_alpha.c
@@ -23,7 +23,8 @@
 #include "libavcodec/me_cmp.h"
 #include "asm.h"
 
-int pix_abs16x16_mvi_asm(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h);
+int pix_abs16x16_mvi_asm(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                         ptrdiff_t line_size, int h);
 
 static inline uint64_t avg2(uint64_t a, uint64_t b)
 {
@@ -44,7 +45,8 @@ static inline uint64_t avg4(uint64_t l1, uint64_t l2, uint64_t l3, uint64_t l4)
     return r1 + r2;
 }
 
-static int pix_abs8x8_mvi(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+static int pix_abs8x8_mvi(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                          ptrdiff_t line_size, int h)
 {
     int result = 0;
 
@@ -76,50 +78,8 @@ static int pix_abs8x8_mvi(void *v, uint8_t *pix1, uint8_t *pix2, int line_size,
     return result;
 }
 
-#if 0                           /* now done in assembly */
-int pix_abs16x16_mvi(uint8_t *pix1, uint8_t *pix2, int line_size)
-{
-    int result = 0;
-    int h = 16;
-
-    if ((size_t) pix2 & 0x7) {
-        /* works only when pix2 is actually unaligned */
-        do {                    /* do 16 pixel a time */
-            uint64_t p1_l, p1_r, p2_l, p2_r;
-            uint64_t t;
-
-            p1_l  = ldq(pix1);
-            p1_r  = ldq(pix1 + 8);
-            t     = ldq_u(pix2 + 8);
-            p2_l  = extql(ldq_u(pix2), pix2) | extqh(t, pix2);
-            p2_r  = extql(t, pix2) | extqh(ldq_u(pix2 + 16), pix2);
-            pix1 += line_size;
-            pix2 += line_size;
-
-            result += perr(p1_l, p2_l)
-                    + perr(p1_r, p2_r);
-        } while (--h);
-    } else {
-        do {
-            uint64_t p1_l, p1_r, p2_l, p2_r;
-
-            p1_l = ldq(pix1);
-            p1_r = ldq(pix1 + 8);
-            p2_l = ldq(pix2);
-            p2_r = ldq(pix2 + 8);
-            pix1 += line_size;
-            pix2 += line_size;
-
-            result += perr(p1_l, p2_l)
-                    + perr(p1_r, p2_r);
-        } while (--h);
-    }
-
-    return result;
-}
-#endif
-
-static int pix_abs16x16_x2_mvi(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+static int pix_abs16x16_x2_mvi(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                               ptrdiff_t line_size, int h)
 {
     int result = 0;
     uint64_t disalign = (size_t) pix2 & 0x7;
@@ -192,7 +152,8 @@ static int pix_abs16x16_x2_mvi(void *v, uint8_t *pix1, uint8_t *pix2, int line_s
     return result;
 }
 
-static int pix_abs16x16_y2_mvi(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+static int pix_abs16x16_y2_mvi(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                               ptrdiff_t line_size, int h)
 {
     int result = 0;
 
@@ -245,7 +206,8 @@ static int pix_abs16x16_y2_mvi(void *v, uint8_t *pix1, uint8_t *pix2, int line_s
     return result;
 }
 
-static int pix_abs16x16_xy2_mvi(void *v, uint8_t *pix1, uint8_t *pix2, int line_size, int h)
+static int pix_abs16x16_xy2_mvi(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
+                                ptrdiff_t line_size, int h)
 {
     int result = 0;
 
diff --git a/libavcodec/alpha/me_cmp_mvi_asm.S b/libavcodec/alpha/me_cmp_mvi_asm.S
index 2399085..183feeb 100644
--- a/libavcodec/alpha/me_cmp_mvi_asm.S
+++ b/libavcodec/alpha/me_cmp_mvi_asm.S
@@ -38,7 +38,7 @@
         .text
 
 /*****************************************************************************
- * int pix_abs16x16_mvi_asm(uint8_t *pix1, uint8_t *pix2, int line_size)
+ * int pix_abs16x16_mvi_asm(const uint8_t *pix1, const uint8_t *pix2, int line_size)
  *
  * This code is written with a pca56 in mind. For ev6, one should
  * really take the increased latency of 3 cycles for MVI instructions
diff --git a/libavcodec/alsdec.c b/libavcodec/alsdec.c
index 7031fa0..38c823f 100644
--- a/libavcodec/alsdec.c
+++ b/libavcodec/alsdec.c
@@ -2189,5 +2189,5 @@ const FFCodec ff_als_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .flush          = flush,
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/amfenc_h264.c b/libavcodec/amfenc_h264.c
index efb0458..eba8c23 100644
--- a/libavcodec/amfenc_h264.c
+++ b/libavcodec/amfenc_h264.c
@@ -391,7 +391,8 @@ const FFCodec ff_h264_amf_encoder = {
     .defaults       = defaults,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = ff_amf_pix_fmts,
     .p.wrapper_name = "amf",
     .hw_configs     = ff_amfenc_hw_configs,
diff --git a/libavcodec/amfenc_hevc.c b/libavcodec/amfenc_hevc.c
index 8ab9330..5aaaa83 100644
--- a/libavcodec/amfenc_hevc.c
+++ b/libavcodec/amfenc_hevc.c
@@ -323,7 +323,8 @@ const FFCodec ff_hevc_amf_encoder = {
     .defaults       = defaults,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = ff_amf_pix_fmts,
     .p.wrapper_name = "amf",
     .hw_configs     = ff_amfenc_hw_configs,
diff --git a/libavcodec/amrnbdec.c b/libavcodec/amrnbdec.c
index f67ed1d..8c10739 100644
--- a/libavcodec/amrnbdec.c
+++ b/libavcodec/amrnbdec.c
@@ -1107,5 +1107,4 @@ const FFCodec ff_amrnb_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLTP,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/amrwbdec.c b/libavcodec/amrwbdec.c
index 7566f25..6a5b79f 100644
--- a/libavcodec/amrwbdec.c
+++ b/libavcodec/amrwbdec.c
@@ -1303,5 +1303,4 @@ const FFCodec ff_amrwb_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLT,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/anm.c b/libavcodec/anm.c
index a9006be..a66ee1e 100644
--- a/libavcodec/anm.c
+++ b/libavcodec/anm.c
@@ -199,5 +199,4 @@ const FFCodec ff_anm_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ansi.c b/libavcodec/ansi.c
index ff4437c..a6b15c7 100644
--- a/libavcodec/ansi.c
+++ b/libavcodec/ansi.c
@@ -490,6 +490,5 @@ const FFCodec ff_ansi_decoder = {
     .close          = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .defaults       = ansi_defaults,
 };
diff --git a/libavcodec/apedec.c b/libavcodec/apedec.c
index 24877c5..2618306 100644
--- a/libavcodec/apedec.c
+++ b/libavcodec/apedec.c
@@ -934,7 +934,7 @@ static av_always_inline int filter_3800(APEPredictor *p,
     p->coeffsB[filter][0] += (((d3 >> 29) & 4) - 2) * sign;
     p->coeffsB[filter][1] -= (((d4 >> 30) & 2) - 1) * sign;
 
-    p->filterB[filter] = p->lastA[filter] + (unsigned)(predictionB >> shift);
+    p->filterB[filter] = p->lastA[filter] + (predictionB >> shift);
     p->filterA[filter] = p->filterB[filter] + (unsigned)((int)(p->filterA[filter] * 31U) >> 5);
 
     return p->filterA[filter];
@@ -1669,7 +1669,7 @@ const FFCodec ff_ape_decoder = {
     FF_CODEC_DECODE_CB(ape_decode_frame),
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DELAY |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .flush          = ape_flush,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_U8P,
                                                       AV_SAMPLE_FMT_S16P,
diff --git a/libavcodec/aptxdec.c b/libavcodec/aptxdec.c
index 6ac070b..27cf056 100644
--- a/libavcodec/aptxdec.c
+++ b/libavcodec/aptxdec.c
@@ -183,7 +183,6 @@ const FFCodec ff_aptx_decoder = {
     .init                  = ff_aptx_init,
     FF_CODEC_DECODE_CB(aptx_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
 #endif
@@ -203,7 +202,6 @@ const FFCodec ff_aptx_hd_decoder = {
     .init                  = ff_aptx_init,
     FF_CODEC_DECODE_CB(aptx_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
 #endif
diff --git a/libavcodec/aptxenc.c b/libavcodec/aptxenc.c
index 89ab397..453146f 100644
--- a/libavcodec/aptxenc.c
+++ b/libavcodec/aptxenc.c
@@ -255,7 +255,6 @@ const FFCodec ff_aptx_encoder = {
     .init                  = ff_aptx_init,
     FF_CODEC_ENCODE_CB(aptx_encode_frame),
     .close                 = aptx_close,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
 #endif
@@ -277,7 +276,6 @@ const FFCodec ff_aptx_hd_encoder = {
     .init                  = ff_aptx_init,
     FF_CODEC_ENCODE_CB(aptx_encode_frame),
     .close                 = aptx_close,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_STEREO, 0},
 #endif
diff --git a/libavcodec/arbc.c b/libavcodec/arbc.c
index 7860096..d981d22 100644
--- a/libavcodec/arbc.c
+++ b/libavcodec/arbc.c
@@ -222,5 +222,5 @@ const FFCodec ff_arbc_decoder = {
     .flush          = decode_flush,
     .close          = decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/argo.c b/libavcodec/argo.c
index efd1056..b772e9c 100644
--- a/libavcodec/argo.c
+++ b/libavcodec/argo.c
@@ -744,5 +744,5 @@ const FFCodec ff_argo_decoder = {
     .flush          = decode_flush,
     .close          = decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/arm/Makefile b/libavcodec/arm/Makefile
index c4ab93a..5d284bd 100644
--- a/libavcodec/arm/Makefile
+++ b/libavcodec/arm/Makefile
@@ -6,8 +6,6 @@ OBJS-$(CONFIG_AC3DSP)                  += arm/ac3dsp_init_arm.o         \
 OBJS-$(CONFIG_AUDIODSP)                += arm/audiodsp_init_arm.o
 OBJS-$(CONFIG_BLOCKDSP)                += arm/blockdsp_init_arm.o
 OBJS-$(CONFIG_FFT)                     += arm/fft_init_arm.o
-OBJS-$(CONFIG_FLACDSP)                 += arm/flacdsp_init_arm.o        \
-                                          arm/flacdsp_arm.o
 OBJS-$(CONFIG_FMTCONVERT)              += arm/fmtconvert_init_arm.o
 OBJS-$(CONFIG_G722DSP)                 += arm/g722dsp_init_arm.o
 OBJS-$(CONFIG_H264CHROMA)              += arm/h264chroma_init_arm.o
@@ -38,6 +36,8 @@ OBJS-$(CONFIG_VP8DSP)                  += arm/vp8dsp_init_arm.o
 OBJS-$(CONFIG_AAC_DECODER)             += arm/aacpsdsp_init_arm.o       \
                                           arm/sbrdsp_init_arm.o
 OBJS-$(CONFIG_DCA_DECODER)             += arm/synth_filter_init_arm.o
+OBJS-$(CONFIG_FLAC_DECODER)            += arm/flacdsp_init_arm.o        \
+                                          arm/flacdsp_arm.o
 OBJS-$(CONFIG_HEVC_DECODER)            += arm/hevcdsp_init_arm.o
 OBJS-$(CONFIG_MLP_DECODER)             += arm/mlpdsp_init_arm.o
 OBJS-$(CONFIG_RV40_DECODER)            += arm/rv40dsp_init_arm.o
diff --git a/libavcodec/arm/flacdsp_init_arm.c b/libavcodec/arm/flacdsp_init_arm.c
index bac9ff1..9962cc8 100644
--- a/libavcodec/arm/flacdsp_init_arm.c
+++ b/libavcodec/arm/flacdsp_init_arm.c
@@ -20,15 +20,11 @@
 
 #include "libavutil/attributes.h"
 #include "libavcodec/flacdsp.h"
-#include "config.h"
-#include "config_components.h"
 
 void ff_flac_lpc_16_arm(int32_t *samples, const int coeffs[32], int order,
                         int qlevel, int len);
 
-av_cold void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels,
-                                 int bps)
+av_cold void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels)
 {
-    if (CONFIG_FLAC_DECODER)
-        c->lpc16 = ff_flac_lpc_16_arm;
+    c->lpc16 = ff_flac_lpc_16_arm;
 }
diff --git a/libavcodec/arm/h264chroma_init_arm.c b/libavcodec/arm/h264chroma_init_arm.c
index aae804b..5c7d523 100644
--- a/libavcodec/arm/h264chroma_init_arm.c
+++ b/libavcodec/arm/h264chroma_init_arm.c
@@ -26,18 +26,18 @@
 #include "libavutil/arm/cpu.h"
 #include "libavcodec/h264chroma.h"
 
-void ff_put_h264_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_put_h264_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_put_h264_chroma_mc2_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc2_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
-void ff_avg_h264_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_avg_h264_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
-void ff_avg_h264_chroma_mc2_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc2_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int h, int x, int y);
 
 av_cold void ff_h264chroma_init_arm(H264ChromaContext *c, int bit_depth)
diff --git a/libavcodec/arm/h264cmc_neon.S b/libavcodec/arm/h264cmc_neon.S
index 3687b02..7272b57 100644
--- a/libavcodec/arm/h264cmc_neon.S
+++ b/libavcodec/arm/h264cmc_neon.S
@@ -22,7 +22,7 @@
 
 #include "libavutil/arm/asm.S"
 
-/* chroma_mc8(uint8_t *dst, uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
+/* chroma_mc8(uint8_t *dst, const uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
 .macro  h264_chroma_mc8 type, codec=h264
 function ff_\type\()_\codec\()_chroma_mc8_neon, export=1
         push            {r4-r7, lr}
@@ -197,7 +197,7 @@ T       cmp             r7,  #0
 endfunc
 .endm
 
-/* chroma_mc4(uint8_t *dst, uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
+/* chroma_mc4(uint8_t *dst, const uint8_t *src, ptrdiff_t stride, int h, int x, int y) */
 .macro  h264_chroma_mc4 type, codec=h264
 function ff_\type\()_\codec\()_chroma_mc4_neon, export=1
         push            {r4-r7, lr}
diff --git a/libavcodec/arm/hevcdsp_init_neon.c b/libavcodec/arm/hevcdsp_init_neon.c
index 112edb5..8094e6c 100644
--- a/libavcodec/arm/hevcdsp_init_neon.c
+++ b/libavcodec/arm/hevcdsp_init_neon.c
@@ -24,32 +24,32 @@
 #include "libavcodec/avcodec.h"
 #include "hevcdsp_arm.h"
 
-void ff_hevc_sao_band_filter_neon_8_wrapper(uint8_t *_dst, uint8_t *_src,
+void ff_hevc_sao_band_filter_neon_8_wrapper(uint8_t *_dst, const uint8_t *_src,
                                   ptrdiff_t stride_dst, ptrdiff_t stride_src,
-                                  int16_t *sao_offset_val, int sao_left_class,
+                                  const int16_t *sao_offset_val, int sao_left_class,
                                   int width, int height);
-void ff_hevc_sao_edge_filter_neon_8_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val,
+void ff_hevc_sao_edge_filter_neon_8_wrapper(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst, const int16_t *sao_offset_val,
                                   int eo, int width, int height);
 
-void ff_hevc_v_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
-void ff_hevc_h_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
-void ff_hevc_v_loop_filter_chroma_neon(uint8_t *_pix, ptrdiff_t _stride, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
-void ff_hevc_h_loop_filter_chroma_neon(uint8_t *_pix, ptrdiff_t _stride, int *_tc, uint8_t *_no_p, uint8_t *_no_q);
-void ff_hevc_add_residual_4x4_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_v_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, const int *_tc, const uint8_t *_no_p, const uint8_t *_no_q);
+void ff_hevc_h_loop_filter_luma_neon(uint8_t *_pix, ptrdiff_t _stride, int _beta, const int *_tc, const uint8_t *_no_p, const uint8_t *_no_q);
+void ff_hevc_v_loop_filter_chroma_neon(uint8_t *_pix, ptrdiff_t _stride, const int *_tc, const uint8_t *_no_p, const uint8_t *_no_q);
+void ff_hevc_h_loop_filter_chroma_neon(uint8_t *_pix, ptrdiff_t _stride, const int *_tc, const uint8_t *_no_p, const uint8_t *_no_q);
+void ff_hevc_add_residual_4x4_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                      ptrdiff_t stride);
-void ff_hevc_add_residual_4x4_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_4x4_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                       ptrdiff_t stride);
-void ff_hevc_add_residual_8x8_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_8x8_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                      ptrdiff_t stride);
-void ff_hevc_add_residual_8x8_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_8x8_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                       ptrdiff_t stride);
-void ff_hevc_add_residual_16x16_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_16x16_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                        ptrdiff_t stride);
-void ff_hevc_add_residual_16x16_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_16x16_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                         ptrdiff_t stride);
-void ff_hevc_add_residual_32x32_8_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_32x32_8_neon(uint8_t *_dst, const int16_t *coeffs,
                                        ptrdiff_t stride);
-void ff_hevc_add_residual_32x32_10_neon(uint8_t *_dst, int16_t *coeffs,
+void ff_hevc_add_residual_32x32_10_neon(uint8_t *_dst, const int16_t *coeffs,
                                         ptrdiff_t stride);
 void ff_hevc_idct_4x4_dc_8_neon(int16_t *coeffs);
 void ff_hevc_idct_8x8_dc_8_neon(int16_t *coeffs);
@@ -70,7 +70,7 @@ void ff_hevc_idct_32x32_10_neon(int16_t *coeffs, int col_limit);
 void ff_hevc_transform_luma_4x4_neon_8(int16_t *coeffs);
 
 #define PUT_PIXELS(name) \
-    void name(int16_t *dst, uint8_t *src, \
+    void name(int16_t *dst, const uint8_t *src, \
                                 ptrdiff_t srcstride, int height, \
                                 intptr_t mx, intptr_t my, int width)
 PUT_PIXELS(ff_hevc_put_pixels_w2_neon_8);
@@ -85,19 +85,19 @@ PUT_PIXELS(ff_hevc_put_pixels_w48_neon_8);
 PUT_PIXELS(ff_hevc_put_pixels_w64_neon_8);
 #undef PUT_PIXELS
 
-static void (*put_hevc_qpel_neon[4][4])(int16_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
+static void (*put_hevc_qpel_neon[4][4])(int16_t *dst, ptrdiff_t dststride, const uint8_t *src, ptrdiff_t srcstride,
                                    int height, int width);
-static void (*put_hevc_qpel_uw_neon[4][4])(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                   int width, int height, int16_t* src2, ptrdiff_t src2stride);
-void ff_hevc_put_qpel_neon_wrapper(int16_t *dst, uint8_t *src, ptrdiff_t srcstride,
+static void (*put_hevc_qpel_uw_neon[4][4])(uint8_t *dst, ptrdiff_t dststride, const uint8_t *_src, ptrdiff_t _srcstride,
+                                   int width, int height, const int16_t *src2, ptrdiff_t src2stride);
+void ff_hevc_put_qpel_neon_wrapper(int16_t *dst, const uint8_t *src, ptrdiff_t srcstride,
                                    int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_qpel_uni_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
+void ff_hevc_put_qpel_uni_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, const uint8_t *src, ptrdiff_t srcstride,
                                    int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_qpel_bi_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
-                                       int16_t *src2,
+void ff_hevc_put_qpel_bi_neon_wrapper(uint8_t *dst, ptrdiff_t dststride,
+                                      const uint8_t *src, ptrdiff_t srcstride, const int16_t *src2,
                                        int height, intptr_t mx, intptr_t my, int width);
 #define QPEL_FUNC(name) \
-    void name(int16_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride, \
+    void name(int16_t *dst, ptrdiff_t dststride, const uint8_t *src, ptrdiff_t srcstride, \
                                    int height, int width)
 
 QPEL_FUNC(ff_hevc_put_qpel_v1_neon_8);
@@ -118,7 +118,7 @@ QPEL_FUNC(ff_hevc_put_qpel_h3v3_neon_8);
 #undef QPEL_FUNC
 
 #define QPEL_FUNC_UW_PIX(name) \
-    void name(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride, \
+    void name(uint8_t *dst, ptrdiff_t dststride, const uint8_t *_src, ptrdiff_t _srcstride, \
                                    int height, intptr_t mx, intptr_t my, int width);
 QPEL_FUNC_UW_PIX(ff_hevc_put_qpel_uw_pixels_w4_neon_8);
 QPEL_FUNC_UW_PIX(ff_hevc_put_qpel_uw_pixels_w8_neon_8);
@@ -130,8 +130,8 @@ QPEL_FUNC_UW_PIX(ff_hevc_put_qpel_uw_pixels_w64_neon_8);
 #undef QPEL_FUNC_UW_PIX
 
 #define QPEL_FUNC_UW(name) \
-    void name(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride, \
-                                   int width, int height, int16_t* src2, ptrdiff_t src2stride);
+    void name(uint8_t *dst, ptrdiff_t dststride, const uint8_t *_src, ptrdiff_t _srcstride, \
+              int width, int height, const int16_t* src2, ptrdiff_t src2stride);
 QPEL_FUNC_UW(ff_hevc_put_qpel_uw_pixels_neon_8);
 QPEL_FUNC_UW(ff_hevc_put_qpel_uw_v1_neon_8);
 QPEL_FUNC_UW(ff_hevc_put_qpel_uw_v2_neon_8);
@@ -150,14 +150,14 @@ QPEL_FUNC_UW(ff_hevc_put_qpel_uw_h3v2_neon_8);
 QPEL_FUNC_UW(ff_hevc_put_qpel_uw_h3v3_neon_8);
 #undef QPEL_FUNC_UW
 
-void ff_hevc_sao_band_filter_neon_8(uint8_t *dst, uint8_t *src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int width, int height, int16_t *offset_table);
+void ff_hevc_sao_band_filter_neon_8(uint8_t *dst, const uint8_t *src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int width, int height, int16_t *offset_table);
 
-void ff_hevc_sao_band_filter_neon_8_wrapper(uint8_t *_dst, uint8_t *_src,
+void ff_hevc_sao_band_filter_neon_8_wrapper(uint8_t *_dst, const uint8_t *_src,
                                   ptrdiff_t stride_dst, ptrdiff_t stride_src,
-                                  int16_t *sao_offset_val, int sao_left_class,
+                                  const int16_t *sao_offset_val, int sao_left_class,
                                   int width, int height) {
     uint8_t *dst = _dst;
-    uint8_t *src = _src;
+    const uint8_t *src = _src;
     int16_t offset_table[32] = {0};
     int k;
 
@@ -168,10 +168,10 @@ void ff_hevc_sao_band_filter_neon_8_wrapper(uint8_t *_dst, uint8_t *_src,
     ff_hevc_sao_band_filter_neon_8(dst, src, stride_dst, stride_src, width, height, offset_table);
 }
 
-void ff_hevc_sao_edge_filter_neon_8(uint8_t *dst, uint8_t *src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int width, int height,
-                                    int a_stride, int b_stride, int16_t *sao_offset_val, uint8_t *edge_idx);
+void ff_hevc_sao_edge_filter_neon_8(uint8_t *dst, const uint8_t *src, ptrdiff_t stride_dst, ptrdiff_t stride_src, int width, int height,
+                                    int a_stride, int b_stride, const int16_t *sao_offset_val, const uint8_t *edge_idx);
 
-void ff_hevc_sao_edge_filter_neon_8_wrapper(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val,
+void ff_hevc_sao_edge_filter_neon_8_wrapper(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst, const int16_t *sao_offset_val,
                                   int eo, int width, int height) {
     static uint8_t edge_idx[] = { 1, 2, 0, 3, 4 };
     static const int8_t pos[4][2][2] = {
@@ -181,7 +181,7 @@ void ff_hevc_sao_edge_filter_neon_8_wrapper(uint8_t *_dst, uint8_t *_src, ptrdif
         { {  1, -1 }, { -1, 1 } }, // 135 degree
     };
     uint8_t *dst = _dst;
-    uint8_t *src = _src;
+    const uint8_t *src = _src;
     int a_stride, b_stride;
     ptrdiff_t stride_src = (2*MAX_PB_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);
 
@@ -191,20 +191,20 @@ void ff_hevc_sao_edge_filter_neon_8_wrapper(uint8_t *_dst, uint8_t *_src, ptrdif
     ff_hevc_sao_edge_filter_neon_8(dst, src, stride_dst, stride_src, width, height, a_stride, b_stride, sao_offset_val, edge_idx);
 }
 
-void ff_hevc_put_qpel_neon_wrapper(int16_t *dst, uint8_t *src, ptrdiff_t srcstride,
+void ff_hevc_put_qpel_neon_wrapper(int16_t *dst, const uint8_t *src, ptrdiff_t srcstride,
                                    int height, intptr_t mx, intptr_t my, int width) {
 
     put_hevc_qpel_neon[my][mx](dst, MAX_PB_SIZE, src, srcstride, height, width);
 }
 
-void ff_hevc_put_qpel_uni_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
+void ff_hevc_put_qpel_uni_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, const uint8_t *src, ptrdiff_t srcstride,
                                    int height, intptr_t mx, intptr_t my, int width) {
 
     put_hevc_qpel_uw_neon[my][mx](dst, dststride, src, srcstride, width, height, NULL, 0);
 }
 
-void ff_hevc_put_qpel_bi_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
-                                       int16_t *src2,
+void ff_hevc_put_qpel_bi_neon_wrapper(uint8_t *dst, ptrdiff_t dststride, const uint8_t *src, ptrdiff_t srcstride,
+                                       const int16_t *src2,
                                        int height, intptr_t mx, intptr_t my, int width) {
     put_hevc_qpel_uw_neon[my][mx](dst, dststride, src, srcstride, width, height, src2, MAX_PB_SIZE);
 }
diff --git a/libavcodec/arm/me_cmp_init_arm.c b/libavcodec/arm/me_cmp_init_arm.c
index 03870a2..8c556f1 100644
--- a/libavcodec/arm/me_cmp_init_arm.c
+++ b/libavcodec/arm/me_cmp_init_arm.c
@@ -25,17 +25,17 @@
 #include "libavcodec/me_cmp.h"
 #include "libavcodec/mpegvideo.h"
 
-int ff_pix_abs16_armv6(MpegEncContext *s, uint8_t *blk1, uint8_t *blk2,
+int ff_pix_abs16_armv6(MpegEncContext *s, const uint8_t *blk1, const uint8_t *blk2,
                        ptrdiff_t stride, int h);
-int ff_pix_abs16_x2_armv6(MpegEncContext *s, uint8_t *blk1, uint8_t *blk2,
+int ff_pix_abs16_x2_armv6(MpegEncContext *s, const uint8_t *blk1, const uint8_t *blk2,
                           ptrdiff_t stride, int h);
-int ff_pix_abs16_y2_armv6(MpegEncContext *s, uint8_t *blk1, uint8_t *blk2,
+int ff_pix_abs16_y2_armv6(MpegEncContext *s, const uint8_t *blk1, const uint8_t *blk2,
                           ptrdiff_t stride, int h);
 
-int ff_pix_abs8_armv6(MpegEncContext *s, uint8_t *blk1, uint8_t *blk2,
+int ff_pix_abs8_armv6(MpegEncContext *s, const uint8_t *blk1, const uint8_t *blk2,
                       ptrdiff_t stride, int h);
 
-int ff_sse16_armv6(MpegEncContext *s, uint8_t *blk1, uint8_t *blk2,
+int ff_sse16_armv6(MpegEncContext *s, const uint8_t *blk1, const uint8_t *blk2,
                    ptrdiff_t stride, int h);
 
 av_cold void ff_me_cmp_init_arm(MECmpContext *c, AVCodecContext *avctx)
diff --git a/libavcodec/arm/mpegvideoencdsp_init_arm.c b/libavcodec/arm/mpegvideoencdsp_init_arm.c
index 31d1474..a95b5be 100644
--- a/libavcodec/arm/mpegvideoencdsp_init_arm.c
+++ b/libavcodec/arm/mpegvideoencdsp_init_arm.c
@@ -24,8 +24,8 @@
 #include "libavcodec/avcodec.h"
 #include "libavcodec/mpegvideoencdsp.h"
 
-int ff_pix_norm1_armv6(uint8_t *pix, int line_size);
-int ff_pix_sum_armv6(uint8_t *pix, int line_size);
+int ff_pix_norm1_armv6(const uint8_t *pix, int line_size);
+int ff_pix_sum_armv6(const uint8_t *pix, int line_size);
 
 av_cold void ff_mpegvideoencdsp_init_arm(MpegvideoEncDSPContext *c,
                                          AVCodecContext *avctx)
diff --git a/libavcodec/arm/rv40dsp_init_arm.c b/libavcodec/arm/rv40dsp_init_arm.c
index c24854d..92d2867 100644
--- a/libavcodec/arm/rv40dsp_init_arm.c
+++ b/libavcodec/arm/rv40dsp_init_arm.c
@@ -49,11 +49,11 @@ DECL_QPEL_Y(1);
 DECL_QPEL_Y(2);
 DECL_QPEL_Y(3);
 
-void ff_put_rv40_chroma_mc8_neon(uint8_t *, uint8_t *, int, int, int, int);
-void ff_put_rv40_chroma_mc4_neon(uint8_t *, uint8_t *, int, int, int, int);
+void ff_put_rv40_chroma_mc8_neon(uint8_t *, const uint8_t *, int, int, int, int);
+void ff_put_rv40_chroma_mc4_neon(uint8_t *, const uint8_t *, int, int, int, int);
 
-void ff_avg_rv40_chroma_mc8_neon(uint8_t *, uint8_t *, int, int, int, int);
-void ff_avg_rv40_chroma_mc4_neon(uint8_t *, uint8_t *, int, int, int, int);
+void ff_avg_rv40_chroma_mc8_neon(uint8_t *, const uint8_t *, int, int, int, int);
+void ff_avg_rv40_chroma_mc4_neon(uint8_t *, const uint8_t *, int, int, int, int);
 
 void ff_rv40_weight_func_16_neon(uint8_t *, uint8_t *, uint8_t *, int, int, ptrdiff_t);
 void ff_rv40_weight_func_8_neon(uint8_t *, uint8_t *, uint8_t *, int, int, ptrdiff_t);
diff --git a/libavcodec/arm/sbcdsp_neon.S b/libavcodec/arm/sbcdsp_neon.S
index 914abfb..d83d21d 100644
--- a/libavcodec/arm/sbcdsp_neon.S
+++ b/libavcodec/arm/sbcdsp_neon.S
@@ -38,49 +38,49 @@ function ff_sbc_analyze_4_neon, export=1
         /* TODO: merge even and odd cases (or even merge all four calls to this
          * function) in order to have only aligned reads from 'in' array
          * and reduce number of load instructions */
-        vld1.16         {d16, d17}, [r0, :64]!
-        vld1.16         {d20, d21}, [r2, :128]!
+        vld1.16         {d4, d5}, [r0, :64]!
+        vld1.16         {d8, d9}, [r2, :128]!
 
-        vmull.s16       q0, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmull.s16       q1, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
+        vmull.s16       q0, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmull.s16       q1, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
 
-        vmlal.s16       q0, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q1, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
+        vmlal.s16       q0, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q1, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
 
-        vmlal.s16       q0, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q1, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
+        vmlal.s16       q0, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q1, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
 
-        vmlal.s16       q0, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q1, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
+        vmlal.s16       q0, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q1, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
 
-        vmlal.s16       q0, d16, d20
-        vmlal.s16       q1, d17, d21
+        vmlal.s16       q0, d4, d8
+        vmlal.s16       q1, d5, d9
 
         vpadd.s32       d0, d0, d1
         vpadd.s32       d1, d2, d3
 
         vrshrn.s32      d0, q0, SBC_PROTO_FIXED_SCALE
 
-        vld1.16         {d16, d17, d18, d19}, [r2, :128]!
+        vld1.16         {d2, d3, d4, d5}, [r2, :128]!
 
         vdup.i32        d1, d0[1]  /* TODO: can be eliminated */
         vdup.i32        d0, d0[0]  /* TODO: can be eliminated */
 
-        vmull.s16       q10, d16, d0
-        vmull.s16       q11, d17, d0
-        vmlal.s16       q10, d18, d1
-        vmlal.s16       q11, d19, d1
+        vmull.s16       q3, d2, d0
+        vmull.s16       q4, d3, d0
+        vmlal.s16       q3, d4, d1
+        vmlal.s16       q4, d5, d1
 
-        vpadd.s32       d0, d20, d21 /* TODO: can be eliminated */
-        vpadd.s32       d1, d22, d23 /* TODO: can be eliminated */
+        vpadd.s32       d0, d6, d7 /* TODO: can be eliminated */
+        vpadd.s32       d1, d8, d9 /* TODO: can be eliminated */
 
         vst1.32         {d0, d1}, [r1, :128]
 
@@ -91,57 +91,57 @@ function ff_sbc_analyze_8_neon, export=1
         /* TODO: merge even and odd cases (or even merge all four calls to this
          * function) in order to have only aligned reads from 'in' array
          * and reduce number of load instructions */
-        vld1.16         {d16, d17}, [r0, :64]!
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmull.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmull.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmull.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmull.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmlal.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmlal.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-        vmlal.s16       q14, d18, d22
-        vld1.16         {d16, d17}, [r0, :64]!
-        vmlal.s16       q15, d19, d23
-        vld1.16         {d20, d21}, [r2, :128]!
-
-        vmlal.s16       q12, d16, d20
-        vld1.16         {d18, d19}, [r0, :64]!
-        vmlal.s16       q13, d17, d21
-        vld1.16         {d22, d23}, [r2, :128]!
-
-        vmlal.s16       q14, d18, d22
-        vmlal.s16       q15, d19, d23
-
-        vpadd.s32       d0, d24, d25
-        vpadd.s32       d1, d26, d27
-        vpadd.s32       d2, d28, d29
-        vpadd.s32       d3, d30, d31
+        vld1.16         {d4, d5}, [r0, :64]!
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmull.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmull.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmull.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmull.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmlal.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmlal.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+        vmlal.s16       q8, d6, d10
+        vld1.16         {d4, d5}, [r0, :64]!
+        vmlal.s16       q9, d7, d11
+        vld1.16         {d8, d9}, [r2, :128]!
+
+        vmlal.s16       q6, d4, d8
+        vld1.16         {d6,  d7}, [r0, :64]!
+        vmlal.s16       q7, d5, d9
+        vld1.16         {d10, d11}, [r2, :128]!
+
+        vmlal.s16       q8, d6, d10
+        vmlal.s16       q9, d7, d11
+
+        vpadd.s32       d0, d12, d13
+        vpadd.s32       d1, d14, d15
+        vpadd.s32       d2, d16, d17
+        vpadd.s32       d3, d18, d19
 
         vrshr.s32       q0, q0, SBC_PROTO_FIXED_SCALE
         vrshr.s32       q1, q1, SBC_PROTO_FIXED_SCALE
@@ -153,38 +153,38 @@ function ff_sbc_analyze_8_neon, export=1
         vdup.i32        d1, d0[1]  /* TODO: can be eliminated */
         vdup.i32        d0, d0[0]  /* TODO: can be eliminated */
 
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmull.s16       q12, d16, d0
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmull.s16       q13, d17, d0
-        vmull.s16       q14, d18, d0
-        vmull.s16       q15, d19, d0
-
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmlal.s16       q12, d16, d1
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmlal.s16       q13, d17, d1
-        vmlal.s16       q14, d18, d1
-        vmlal.s16       q15, d19, d1
-
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmlal.s16       q12, d16, d2
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmlal.s16       q13, d17, d2
-        vmlal.s16       q14, d18, d2
-        vmlal.s16       q15, d19, d2
-
-        vld1.16         {d16, d17}, [r2, :128]!
-        vmlal.s16       q12, d16, d3
-        vld1.16         {d18, d19}, [r2, :128]!
-        vmlal.s16       q13, d17, d3
-        vmlal.s16       q14, d18, d3
-        vmlal.s16       q15, d19, d3
-
-        vpadd.s32       d0, d24, d25 /* TODO: can be eliminated */
-        vpadd.s32       d1, d26, d27 /* TODO: can be eliminated */
-        vpadd.s32       d2, d28, d29 /* TODO: can be eliminated */
-        vpadd.s32       d3, d30, d31 /* TODO: can be eliminated */
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmull.s16       q6, d4, d0
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmull.s16       q7, d5, d0
+        vmull.s16       q8, d6, d0
+        vmull.s16       q9, d7, d0
+
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmlal.s16       q6, d4, d1
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmlal.s16       q7, d5, d1
+        vmlal.s16       q8, d6, d1
+        vmlal.s16       q9, d7, d1
+
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmlal.s16       q6, d4, d2
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmlal.s16       q7, d5, d2
+        vmlal.s16       q8, d6, d2
+        vmlal.s16       q9, d7, d2
+
+        vld1.16         {d4, d5}, [r2, :128]!
+        vmlal.s16       q6, d4, d3
+        vld1.16         {d6, d7}, [r2, :128]!
+        vmlal.s16       q7, d5, d3
+        vmlal.s16       q8, d6, d3
+        vmlal.s16       q9, d7, d3
+
+        vpadd.s32       d0, d12, d13 /* TODO: can be eliminated */
+        vpadd.s32       d1, d14, d15 /* TODO: can be eliminated */
+        vpadd.s32       d2, d16, d17 /* TODO: can be eliminated */
+        vpadd.s32       d3, d18, d19 /* TODO: can be eliminated */
 
         vst1.32         {d0, d1, d2, d3}, [r1, :128]
 
diff --git a/libavcodec/arm/vc1dsp_init_neon.c b/libavcodec/arm/vc1dsp_init_neon.c
index 48cb816..46fd80a 100644
--- a/libavcodec/arm/vc1dsp_init_neon.c
+++ b/libavcodec/arm/vc1dsp_init_neon.c
@@ -76,13 +76,13 @@ DECL_PUT(3, 1)
 DECL_PUT(3, 2)
 DECL_PUT(3, 3)
 
-void ff_put_vc1_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_vc1_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_avg_vc1_chroma_mc8_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_vc1_chroma_mc8_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_put_vc1_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_vc1_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
-void ff_avg_vc1_chroma_mc4_neon(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_vc1_chroma_mc4_neon(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int h, int x, int y);
 
 int ff_vc1_unescape_buffer_helper_neon(const uint8_t *src, int size, uint8_t *dst);
diff --git a/libavcodec/arm/videodsp_init_armv5te.c b/libavcodec/arm/videodsp_init_armv5te.c
index 1ea1f34..eaa8c5b 100644
--- a/libavcodec/arm/videodsp_init_armv5te.c
+++ b/libavcodec/arm/videodsp_init_armv5te.c
@@ -23,7 +23,7 @@
 #include "libavcodec/videodsp.h"
 #include "videodsp_arm.h"
 
-void ff_prefetch_arm(uint8_t *mem, ptrdiff_t stride, int h);
+void ff_prefetch_arm(const uint8_t *mem, ptrdiff_t stride, int h);
 
 av_cold void ff_videodsp_init_armv5te(VideoDSPContext *ctx, int bpc)
 {
diff --git a/libavcodec/arm/vp8.h b/libavcodec/arm/vp8.h
index 965342d..7c59a7d 100644
--- a/libavcodec/arm/vp8.h
+++ b/libavcodec/arm/vp8.h
@@ -22,12 +22,12 @@
 #include <stdint.h>
 
 #include "config.h"
-#include "libavcodec/vp56.h"
+#include "libavcodec/vpx_rac.h"
 #include "libavcodec/vp8.h"
 
 #if HAVE_ARMV6_EXTERNAL
 #define vp8_decode_block_coeffs_internal ff_decode_block_coeffs_armv6
-int ff_decode_block_coeffs_armv6(VP56RangeCoder *rc, int16_t block[16],
+int ff_decode_block_coeffs_armv6(VPXRangeCoder *rc, int16_t block[16],
                                  uint8_t probs[8][3][NUM_DCT_TOKENS-1],
                                  int i, uint8_t *token_prob, int16_t qmul[2]);
 #endif
diff --git a/libavcodec/arm/vp8_armv6.S b/libavcodec/arm/vp8_armv6.S
index e7d25a4..7ecf264 100644
--- a/libavcodec/arm/vp8_armv6.S
+++ b/libavcodec/arm/vp8_armv6.S
@@ -65,7 +65,7 @@ T       orrcs           \cw, \cw, \t1
 
 function ff_decode_block_coeffs_armv6, export=1
         push            {r0,r1,r4-r11,lr}
-        movrelx         lr,  X(ff_vp56_norm_shift)
+        movrelx         lr,  X(ff_vpx_norm_shift)
         ldrd            r4,  r5,  [sp, #44]             @ token_prob, qmul
         cmp             r3,  #0
         ldr             r11, [r5]
diff --git a/libavcodec/arm/vpx_arith.h b/libavcodec/arm/vpx_arith.h
new file mode 100644
index 0000000..1ead228
--- /dev/null
+++ b/libavcodec/arm/vpx_arith.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2010 Mans Rullgard <mans@mansr.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_ARM_VPX_ARITH_H
+#define AVCODEC_ARM_VPX_ARITH_H
+
+#if CONFIG_THUMB
+#   define A(x)
+#   define T(x) x
+#else
+#   define A(x) x
+#   define T(x)
+#endif
+
+#if CONFIG_THUMB || defined __clang__
+#   define L(x)
+#   define U(x) x
+#else
+#   define L(x) x
+#   define U(x)
+#endif
+
+#if HAVE_ARMV6_INLINE
+
+#define vpx_rac_get_prob vp56_rac_get_prob_armv6
+static inline int vp56_rac_get_prob_armv6(VPXRangeCoder *c, int pr)
+{
+    unsigned shift     = ff_vpx_norm_shift[c->high];
+    unsigned code_word = c->code_word << shift;
+    unsigned high      = c->high << shift;
+    unsigned bit;
+
+    __asm__ ("adds    %3,  %3,  %0           \n"
+             "itt     cs                     \n"
+             "cmpcs   %7,  %4                \n"
+           L("ldrcsh  %2,  [%4], #2          \n")
+           U("ldrhcs  %2,  [%4], #2          \n")
+             "rsb     %0,  %6,  #256         \n"
+             "smlabb  %0,  %5,  %6,  %0      \n"
+           T("itttt   cs                     \n")
+             "rev16cs %2,  %2                \n"
+           T("lslcs   %2,  %2,  %3           \n")
+           T("orrcs   %1,  %1,  %2           \n")
+           A("orrcs   %1,  %1,  %2,  lsl %3  \n")
+             "subcs   %3,  %3,  #16          \n"
+             "lsr     %0,  %0,  #8           \n"
+             "cmp     %1,  %0,  lsl #16      \n"
+             "ittte   ge                     \n"
+             "subge   %1,  %1,  %0,  lsl #16 \n"
+             "subge   %0,  %5,  %0           \n"
+             "movge   %2,  #1                \n"
+             "movlt   %2,  #0                \n"
+             : "=&r"(c->high), "=&r"(c->code_word), "=&r"(bit),
+               "+&r"(c->bits), "+&r"(c->buffer)
+             : "r"(high), "r"(pr), "r"(c->end - 1),
+               "0"(shift), "1"(code_word)
+             : "cc");
+
+    return bit;
+}
+
+#define vpx_rac_get_prob_branchy vp56_rac_get_prob_branchy_armv6
+static inline int vp56_rac_get_prob_branchy_armv6(VPXRangeCoder *c, int pr)
+{
+    unsigned shift     = ff_vpx_norm_shift[c->high];
+    unsigned code_word = c->code_word << shift;
+    unsigned high      = c->high << shift;
+    unsigned low;
+    unsigned tmp;
+
+    __asm__ ("adds    %3,  %3,  %0           \n"
+             "itt     cs                     \n"
+             "cmpcs   %7,  %4                \n"
+           L("ldrcsh  %2,  [%4], #2          \n")
+           U("ldrhcs  %2,  [%4], #2          \n")
+             "rsb     %0,  %6,  #256         \n"
+             "smlabb  %0,  %5,  %6,  %0      \n"
+           T("itttt   cs                     \n")
+             "rev16cs %2,  %2                \n"
+           T("lslcs   %2,  %2,  %3           \n")
+           T("orrcs   %1,  %1,  %2           \n")
+           A("orrcs   %1,  %1,  %2,  lsl %3  \n")
+             "subcs   %3,  %3,  #16          \n"
+             "lsr     %0,  %0,  #8           \n"
+             "lsl     %2,  %0,  #16          \n"
+             : "=&r"(low), "+&r"(code_word), "=&r"(tmp),
+               "+&r"(c->bits), "+&r"(c->buffer)
+             : "r"(high), "r"(pr), "r"(c->end - 1), "0"(shift)
+             : "cc");
+
+    if (code_word >= tmp) {
+        c->high      = high - low;
+        c->code_word = code_word - tmp;
+        return 1;
+    }
+
+    c->high      = low;
+    c->code_word = code_word;
+    return 0;
+}
+
+#endif
+
+#endif /* AVCODEC_ARM_VPX_ARITH_H */
diff --git a/libavcodec/assdec.c b/libavcodec/assdec.c
index f43b500..b189645 100644
--- a/libavcodec/assdec.c
+++ b/libavcodec/assdec.c
@@ -69,7 +69,6 @@ const FFCodec ff_ssa_decoder = {
     .p.id         = AV_CODEC_ID_ASS,
     .init         = ass_decode_init,
     FF_CODEC_DECODE_SUB_CB(ass_decode_frame),
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -81,6 +80,5 @@ const FFCodec ff_ass_decoder = {
     .p.id         = AV_CODEC_ID_ASS,
     .init         = ass_decode_init,
     FF_CODEC_DECODE_SUB_CB(ass_decode_frame),
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/assenc.c b/libavcodec/assenc.c
index 2ac40d5..b024b1b 100644
--- a/libavcodec/assenc.c
+++ b/libavcodec/assenc.c
@@ -76,7 +76,6 @@ const FFCodec ff_ssa_encoder = {
     .p.id         = AV_CODEC_ID_ASS,
     .init         = ass_encode_init,
     FF_CODEC_ENCODE_SUB_CB(ass_encode_frame),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -88,6 +87,5 @@ const FFCodec ff_ass_encoder = {
     .p.id         = AV_CODEC_ID_ASS,
     .init         = ass_encode_init,
     FF_CODEC_ENCODE_SUB_CB(ass_encode_frame),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/asvdec.c b/libavcodec/asvdec.c
index 57ba4c5..5bb4600 100644
--- a/libavcodec/asvdec.c
+++ b/libavcodec/asvdec.c
@@ -338,7 +338,6 @@ const FFCodec ff_asv1_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -352,6 +351,5 @@ const FFCodec ff_asv2_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/asvenc.c b/libavcodec/asvenc.c
index 520173e..8b94868 100644
--- a/libavcodec/asvenc.c
+++ b/libavcodec/asvenc.c
@@ -190,9 +190,9 @@ static inline void dct_get(ASV1Context *a, const AVFrame *frame,
     int linesize = frame->linesize[0];
     int i;
 
-    uint8_t *ptr_y  = frame->data[0] + (mb_y * 16 * linesize)           + mb_x * 16;
-    uint8_t *ptr_cb = frame->data[1] + (mb_y *  8 * frame->linesize[1]) + mb_x *  8;
-    uint8_t *ptr_cr = frame->data[2] + (mb_y *  8 * frame->linesize[2]) + mb_x *  8;
+    const uint8_t *ptr_y  = frame->data[0] + (mb_y * 16 * linesize)           + mb_x * 16;
+    const uint8_t *ptr_cb = frame->data[1] + (mb_y *  8 * frame->linesize[1]) + mb_x *  8;
+    const uint8_t *ptr_cr = frame->data[2] + (mb_y *  8 * frame->linesize[2]) + mb_x *  8;
 
     a->pdsp.get_pixels(block[0], ptr_y,                    linesize);
     a->pdsp.get_pixels(block[1], ptr_y + 8,                linesize);
@@ -353,7 +353,6 @@ const FFCodec ff_asv1_encoder = {
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -368,6 +367,5 @@ const FFCodec ff_asv2_encoder = {
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/atrac1.c b/libavcodec/atrac1.c
index 7265891..a05fb6e 100644
--- a/libavcodec/atrac1.c
+++ b/libavcodec/atrac1.c
@@ -396,5 +396,5 @@ const FFCodec ff_atrac1_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/atrac3.c b/libavcodec/atrac3.c
index d5f6fea..93f5f4d 100644
--- a/libavcodec/atrac3.c
+++ b/libavcodec/atrac3.c
@@ -1027,7 +1027,7 @@ const FFCodec ff_atrac3_decoder = {
     .p.capabilities   = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1,
     .p.sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                         AV_SAMPLE_FMT_NONE },
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_atrac3al_decoder = {
@@ -1042,5 +1042,5 @@ const FFCodec ff_atrac3al_decoder = {
     .p.capabilities   = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1,
     .p.sample_fmts    = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                         AV_SAMPLE_FMT_NONE },
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/atrac3plusdec.c b/libavcodec/atrac3plusdec.c
index f87ffb8..644a7e8 100644
--- a/libavcodec/atrac3plusdec.c
+++ b/libavcodec/atrac3plusdec.c
@@ -396,7 +396,7 @@ const FFCodec ff_atrac3p_decoder = {
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_ATRAC3P,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(ATRAC3PContext),
     .init           = atrac3p_decode_init,
     .close          = atrac3p_decode_close,
@@ -409,7 +409,7 @@ const FFCodec ff_atrac3pal_decoder = {
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_ATRAC3PAL,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(ATRAC3PContext),
     .init           = atrac3p_decode_init,
     .close          = atrac3p_decode_close,
diff --git a/libavcodec/atrac9dec.c b/libavcodec/atrac9dec.c
index 6c1f0d1..3c57256 100644
--- a/libavcodec/atrac9dec.c
+++ b/libavcodec/atrac9dec.c
@@ -997,6 +997,6 @@ const FFCodec ff_atrac9_decoder = {
     .close          = atrac9_decode_close,
     FF_CODEC_DECODE_CB(atrac9_decode_frame),
     .flush          = atrac9_decode_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
 };
diff --git a/libavcodec/audiotoolboxdec.c b/libavcodec/audiotoolboxdec.c
index daccf4a..dc3f790 100644
--- a/libavcodec/audiotoolboxdec.c
+++ b/libavcodec/audiotoolboxdec.c
@@ -602,7 +602,7 @@ static av_cold int ffat_close_decoder(AVCodecContext *avctx)
         .p.priv_class   = &ffat_##NAME##_dec_class, \
         .bsfs           = bsf_name, \
         .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY | AV_CODEC_CAP_CHANNEL_CONF, \
-        .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP, \
+        .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP, \
         .p.wrapper_name = "at", \
     };
 
diff --git a/libavcodec/audiotoolboxenc.c b/libavcodec/audiotoolboxenc.c
index 0029315..d8cc624 100644
--- a/libavcodec/audiotoolboxenc.c
+++ b/libavcodec/audiotoolboxenc.c
@@ -634,7 +634,6 @@ static const AVOption options[] = {
             AV_SAMPLE_FMT_S16, \
             AV_SAMPLE_FMT_U8,  AV_SAMPLE_FMT_NONE \
         }, \
-        .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE, \
         .p.profiles     = PROFILES, \
         .p.wrapper_name = "at", \
     };
diff --git a/libavcodec/aura.c b/libavcodec/aura.c
index b4167ca..23e976f 100644
--- a/libavcodec/aura.c
+++ b/libavcodec/aura.c
@@ -104,5 +104,4 @@ const FFCodec ff_aura2_decoder = {
     .init           = aura_decode_init,
     FF_CODEC_DECODE_CB(aura_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/av1dec.c b/libavcodec/av1dec.c
index dd83373..8abb7b3 100644
--- a/libavcodec/av1dec.c
+++ b/libavcodec/av1dec.c
@@ -1255,8 +1255,7 @@ const FFCodec ff_av1_decoder = {
     .close                 = av1_decode_free,
     FF_CODEC_DECODE_CB(av1_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_AVOID_PROBING,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE |
-                             FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP |
                              FF_CODEC_CAP_SETS_PKT_DTS,
     .flush                 = av1_decode_flush,
     .p.profiles            = NULL_IF_CONFIG_SMALL(ff_av1_profiles),
diff --git a/libavcodec/avcodec.c b/libavcodec/avcodec.c
index 5f6e71a..2964319 100644
--- a/libavcodec/avcodec.c
+++ b/libavcodec/avcodec.c
@@ -72,13 +72,13 @@ static AVMutex codec_mutex = AV_MUTEX_INITIALIZER;
 
 static void lock_avcodec(const FFCodec *codec)
 {
-    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)
+    if (codec->caps_internal & FF_CODEC_CAP_NOT_INIT_THREADSAFE && codec->init)
         ff_mutex_lock(&codec_mutex);
 }
 
 static void unlock_avcodec(const FFCodec *codec)
 {
-    if (!(codec->caps_internal & FF_CODEC_CAP_INIT_THREADSAFE) && codec->init)
+    if (codec->caps_internal & FF_CODEC_CAP_NOT_INIT_THREADSAFE && codec->init)
         ff_mutex_unlock(&codec_mutex);
 }
 
@@ -161,8 +161,6 @@ int attribute_align_arg avcodec_open2(AVCodecContext *avctx, const AVCodec *code
         goto free_and_end;
     }
 
-    avci->skip_samples_multiplier = 1;
-
     if (codec2->priv_data_size > 0) {
         if (!avctx->priv_data) {
             avctx->priv_data = av_mallocz(codec2->priv_data_size);
@@ -285,14 +283,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
     if (ret < 0)
         goto free_and_end;
 
-    if (CONFIG_FRAME_THREAD_ENCODER && av_codec_is_encoder(avctx->codec)) {
-        ret = ff_frame_thread_encoder_init(avctx);
-        if (ret < 0)
-            goto free_and_end;
-    }
-
-    if (HAVE_THREADS
-        && !(avci->frame_thread_encoder && (avctx->active_thread_type&FF_THREAD_FRAME))) {
+    if (HAVE_THREADS && !avci->frame_thread_encoder) {
         /* Frame-threaded decoders call FFCodec.init for their child contexts. */
         lock_avcodec(codec2);
         ret = ff_thread_init(avctx);
@@ -390,6 +381,8 @@ void avcodec_flush_buffers(AVCodecContext *avctx)
         }
         if (avci->in_frame)
             av_frame_unref(avci->in_frame);
+        if (avci->recon_frame)
+            av_frame_unref(avci->recon_frame);
     } else {
         av_packet_unref(avci->last_pkt_props);
         while (av_fifo_read(avci->pkt_props, avci->last_pkt_props, 1) >= 0)
@@ -470,6 +463,7 @@ av_cold int avcodec_close(AVCodecContext *avctx)
 
         av_packet_free(&avci->in_pkt);
         av_frame_free(&avci->in_frame);
+        av_frame_free(&avci->recon_frame);
 
         av_buffer_unref(&avci->pool);
 
@@ -481,6 +475,10 @@ av_cold int avcodec_close(AVCodecContext *avctx)
 
         av_channel_layout_uninit(&avci->initial_ch_layout);
 
+#if CONFIG_LCMS2
+        ff_icc_context_uninit(&avci->icc);
+#endif
+
         av_freep(&avctx->internal);
     }
 
@@ -716,3 +714,12 @@ int avcodec_is_open(AVCodecContext *s)
 {
     return !!s->internal;
 }
+
+int attribute_align_arg avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    av_frame_unref(frame);
+
+    if (av_codec_is_decoder(avctx->codec))
+        return ff_decode_receive_frame(avctx, frame);
+    return ff_encode_receive_frame(avctx, frame);
+}
diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index cb5c25b..65c8535 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -231,6 +231,16 @@ typedef struct RcOverride{
  * decoded frame in stream.
  */
 #define AV_CODEC_FLAG_DROPCHANGED     (1 <<  5)
+/**
+ * Request the encoder to output reconstructed frames, i.e. frames that would be
+ * produced by decoding the encoded bistream. These frames may be retrieved by
+ * calling avcodec_receive_frame() immediately after a successful call to
+ * avcodec_receive_packet().
+ *
+ * Should only be used with encoders flagged with the
+ * AV_CODEC_CAP_ENCODER_RECON_FRAME capability.
+ */
+#define AV_CODEC_FLAG_RECON_FRAME     (1 <<  6)
 /**
  * Use internal 2pass ratecontrol in first pass mode.
  */
@@ -331,13 +341,12 @@ typedef struct RcOverride{
  * Do not reset ASS ReadOrder field on flush (subtitles decoding)
  */
 #define AV_CODEC_FLAG2_RO_FLUSH_NOOP  (1 << 30)
-
-/* Unsupported options :
- *              Syntax Arithmetic coding (SAC)
- *              Reference Picture Selection
- *              Independent Segment Decoding */
-/* /Fx */
-/* codec capabilities */
+/**
+ * Generate/parse ICC profiles on encode/decode, as appropriate for the type of
+ * file. No effect on codecs which cannot contain embedded ICC profiles, or
+ * when compiled without support for lcms2.
+ */
+#define AV_CODEC_FLAG2_ICC_PROFILES   (1U << 31)
 
 /* Exported side data.
    These flags can be passed in AVCodecContext.export_side_data before initialization.
@@ -2595,21 +2604,23 @@ int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,
 int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt);
 
 /**
- * Return decoded output data from a decoder.
+ * Return decoded output data from a decoder or encoder (when the
+ * AV_CODEC_FLAG_RECON_FRAME flag is used).
  *
  * @param avctx codec context
  * @param frame This will be set to a reference-counted video or audio
  *              frame (depending on the decoder type) allocated by the
- *              decoder. Note that the function will always call
+ *              codec. Note that the function will always call
  *              av_frame_unref(frame) before doing anything else.
  *
  * @return
  *      0:                 success, a frame was returned
  *      AVERROR(EAGAIN):   output is not available in this state - user must try
  *                         to send new input
- *      AVERROR_EOF:       the decoder has been fully flushed, and there will be
+ *      AVERROR_EOF:       the codec has been fully flushed, and there will be
  *                         no more output frames
- *      AVERROR(EINVAL):   codec not opened, or it is an encoder
+ *      AVERROR(EINVAL):   codec not opened, or it is an encoder without
+ *                         the AV_CODEC_FLAG_RECON_FRAME flag enabled
  *      AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters
  *                               with respect to first decoded frame. Applicable
  *                               when flag AV_CODEC_FLAG_DROPCHANGED is set.
diff --git a/libavcodec/avrndec.c b/libavcodec/avrndec.c
index 9bb0c1f..10bde74 100644
--- a/libavcodec/avrndec.c
+++ b/libavcodec/avrndec.c
@@ -98,5 +98,5 @@ const FFCodec ff_avrn_decoder = {
     .init           = init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/avs.c b/libavcodec/avs.c
index 6dda339..20c07ae 100644
--- a/libavcodec/avs.c
+++ b/libavcodec/avs.c
@@ -185,5 +185,4 @@ const FFCodec ff_avs_decoder = {
     FF_CODEC_DECODE_CB(avs_decode_frame),
     .close          = avs_decode_end,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/avuidec.c b/libavcodec/avuidec.c
index f545c41..ce96219 100644
--- a/libavcodec/avuidec.c
+++ b/libavcodec/avuidec.c
@@ -127,5 +127,4 @@ const FFCodec ff_avui_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .init         = avui_decode_init,
     FF_CODEC_DECODE_CB(avui_decode_frame),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/avuienc.c b/libavcodec/avuienc.c
index e2bd318..0357e68 100644
--- a/libavcodec/avuienc.c
+++ b/libavcodec/avuienc.c
@@ -72,7 +72,7 @@ static int avui_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     }
 
     for (i = 0; i <= interlaced; i++) {
-        uint8_t *src;
+        const uint8_t *src;
         if (interlaced && avctx->height == 486) {
             src = pic->data[0] + (1 - i) * pic->linesize[0];
         } else {
@@ -100,5 +100,4 @@ const FFCodec ff_avui_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_UYVY422, AV_PIX_FMT_NONE },
     .init         = avui_encode_init,
     FF_CODEC_ENCODE_CB(avui_encode_frame),
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/bethsoftvideo.c b/libavcodec/bethsoftvideo.c
index 9fc286f..a2e8f41 100644
--- a/libavcodec/bethsoftvideo.c
+++ b/libavcodec/bethsoftvideo.c
@@ -168,5 +168,4 @@ const FFCodec ff_bethsoftvid_decoder = {
     .close          = bethsoftvid_decode_end,
     FF_CODEC_DECODE_CB(bethsoftvid_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/bfi.c b/libavcodec/bfi.c
index 6f9fbb0..12eba8f 100644
--- a/libavcodec/bfi.c
+++ b/libavcodec/bfi.c
@@ -185,5 +185,4 @@ const FFCodec ff_bfi_decoder = {
     .close          = bfi_decode_close,
     FF_CODEC_DECODE_CB(bfi_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/bink.c b/libavcodec/bink.c
index 3ba3068..09be048 100644
--- a/libavcodec/bink.c
+++ b/libavcodec/bink.c
@@ -1088,7 +1088,7 @@ static int bink_decode_plane(BinkContext *c, AVFrame *frame, GetBitContext *gb,
         for (bx = 0; bx < bw; bx++, dst += 8, prev += 8) {
             blk = get_value(c, BINK_SRC_BLOCK_TYPES);
             // 16x16 block type on odd line means part of the already decoded block, so skip it
-            if (((by & 1) || (bx & 1)) && blk == SCALED_BLOCK) {
+            if ((by & 1) && blk == SCALED_BLOCK) {
                 bx++;
                 dst  += 8;
                 prev += 8;
@@ -1430,5 +1430,5 @@ const FFCodec ff_bink_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .flush          = flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/binkaudio.c b/libavcodec/binkaudio.c
index 8bac8e0..372c439 100644
--- a/libavcodec/binkaudio.c
+++ b/libavcodec/binkaudio.c
@@ -376,7 +376,7 @@ const FFCodec ff_binkaudio_rdft_decoder = {
     .close          = decode_end,
     FF_CODEC_RECEIVE_FRAME_CB(binkaudio_receive_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_binkaudio_dct_decoder = {
@@ -390,5 +390,5 @@ const FFCodec ff_binkaudio_dct_decoder = {
     .close          = decode_end,
     FF_CODEC_RECEIVE_FRAME_CB(binkaudio_receive_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/bintext.c b/libavcodec/bintext.c
index e153198..7039760 100644
--- a/libavcodec/bintext.c
+++ b/libavcodec/bintext.c
@@ -226,7 +226,6 @@ const FFCodec ff_bintext_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_XBIN_DECODER
@@ -239,7 +238,6 @@ const FFCodec ff_xbin_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_IDF_DECODER
@@ -252,6 +250,5 @@ const FFCodec ff_idf_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/bitpacked_dec.c b/libavcodec/bitpacked_dec.c
index 4723a3c..8a375fe 100644
--- a/libavcodec/bitpacked_dec.c
+++ b/libavcodec/bitpacked_dec.c
@@ -154,5 +154,4 @@ const FFCodec ff_bitpacked_decoder = {
         MKTAG('U', 'Y', 'V', 'Y'),
         FF_CODEC_TAGS_END,
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/bitpacked_enc.c b/libavcodec/bitpacked_enc.c
index 127f1af..f3ddbb2 100644
--- a/libavcodec/bitpacked_enc.c
+++ b/libavcodec/bitpacked_enc.c
@@ -115,5 +115,4 @@ const FFCodec ff_bitpacked_encoder = {
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV422P10,
                                                     AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/bmpenc.c b/libavcodec/bmpenc.c
index f28ce01..964f7cc 100644
--- a/libavcodec/bmpenc.c
+++ b/libavcodec/bmpenc.c
@@ -72,7 +72,8 @@ static int bmp_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     uint32_t palette256[256];
     int pad_bytes_per_row, pal_entries = 0, compression = BMP_RGB;
     int bit_count = avctx->bits_per_coded_sample;
-    uint8_t *ptr, *buf;
+    const uint8_t *ptr;
+    uint8_t *buf;
 
     switch (avctx->pix_fmt) {
     case AV_PIX_FMT_RGB444:
@@ -170,5 +171,4 @@ const FFCodec ff_bmp_encoder = {
         AV_PIX_FMT_MONOBLACK,
         AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/bmvaudio.c b/libavcodec/bmvaudio.c
index f57ece0..08f24c3 100644
--- a/libavcodec/bmvaudio.c
+++ b/libavcodec/bmvaudio.c
@@ -86,5 +86,4 @@ const FFCodec ff_bmv_audio_decoder = {
     .init           = bmv_aud_decode_init,
     FF_CODEC_DECODE_CB(bmv_aud_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/bmvvideo.c b/libavcodec/bmvvideo.c
index c492d7f..9872396 100644
--- a/libavcodec/bmvvideo.c
+++ b/libavcodec/bmvvideo.c
@@ -294,5 +294,4 @@ const FFCodec ff_bmv_video_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/c93.c b/libavcodec/c93.c
index 050bb42..196b95e 100644
--- a/libavcodec/c93.c
+++ b/libavcodec/c93.c
@@ -268,5 +268,5 @@ const FFCodec ff_c93_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cavsdec.c b/libavcodec/cavsdec.c
index 6c69c2c..7ac4359 100644
--- a/libavcodec/cavsdec.c
+++ b/libavcodec/cavsdec.c
@@ -1326,5 +1326,5 @@ const FFCodec ff_cavs_decoder = {
     FF_CODEC_DECODE_CB(cavs_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
     .flush          = cavs_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cbs.c b/libavcodec/cbs.c
index 8c0a5b5..07ae658 100644
--- a/libavcodec/cbs.c
+++ b/libavcodec/cbs.c
@@ -695,26 +695,6 @@ int ff_cbs_write_signed(CodedBitstreamContext *ctx, PutBitContext *pbc,
 }
 
 
-int ff_cbs_alloc_unit_content(CodedBitstreamUnit *unit,
-                              size_t size,
-                              void (*free)(void *opaque, uint8_t *data))
-{
-    av_assert0(!unit->content && !unit->content_ref);
-
-    unit->content = av_mallocz(size);
-    if (!unit->content)
-        return AVERROR(ENOMEM);
-
-    unit->content_ref = av_buffer_create(unit->content, size,
-                                         free, NULL, 0);
-    if (!unit->content_ref) {
-        av_freep(&unit->content);
-        return AVERROR(ENOMEM);
-    }
-
-    return 0;
-}
-
 static int cbs_insert_unit(CodedBitstreamFragment *frag,
                            int position)
 {
@@ -857,8 +837,8 @@ static void cbs_default_free_unit_content(void *opaque, uint8_t *data)
     const CodedBitstreamUnitTypeDescriptor *desc = opaque;
     if (desc->content_type == CBS_CONTENT_TYPE_INTERNAL_REFS) {
         int i;
-        for (i = 0; i < desc->nb_ref_offsets; i++) {
-            void **ptr = (void**)(data + desc->ref_offsets[i]);
+        for (i = 0; i < desc->type.ref.nb_offsets; i++) {
+            void **ptr = (void**)(data + desc->type.ref.offsets[i]);
             av_buffer_unref((AVBufferRef**)(ptr + 1));
         }
     }
@@ -880,12 +860,12 @@ static const CodedBitstreamUnitTypeDescriptor
         if (desc->nb_unit_types == 0)
             break;
         if (desc->nb_unit_types == CBS_UNIT_TYPE_RANGE) {
-            if (unit->type >= desc->unit_type_range_start &&
-                unit->type <= desc->unit_type_range_end)
+            if (unit->type >= desc->unit_type.range.start &&
+                unit->type <= desc->unit_type.range.end)
                 return desc;
         } else {
             for (j = 0; j < desc->nb_unit_types; j++) {
-                if (desc->unit_types[j] == unit->type)
+                if (desc->unit_type.list[j] == unit->type)
                     return desc;
             }
         }
@@ -893,8 +873,8 @@ static const CodedBitstreamUnitTypeDescriptor
     return NULL;
 }
 
-int ff_cbs_alloc_unit_content2(CodedBitstreamContext *ctx,
-                               CodedBitstreamUnit *unit)
+int ff_cbs_alloc_unit_content(CodedBitstreamContext *ctx,
+                              CodedBitstreamUnit *unit)
 {
     const CodedBitstreamUnitTypeDescriptor *desc;
 
@@ -910,7 +890,8 @@ int ff_cbs_alloc_unit_content2(CodedBitstreamContext *ctx,
 
     unit->content_ref =
         av_buffer_create(unit->content, desc->content_size,
-                         desc->content_free ? desc->content_free
+                         desc->content_type == CBS_CONTENT_TYPE_COMPLEX
+                                            ? desc->type.complex.content_free
                                             : cbs_default_free_unit_content,
                          (void*)desc, 0);
     if (!unit->content_ref) {
@@ -921,13 +902,12 @@ int ff_cbs_alloc_unit_content2(CodedBitstreamContext *ctx,
     return 0;
 }
 
-static int cbs_clone_unit_content(AVBufferRef **clone_ref,
-                                  CodedBitstreamUnit *unit,
-                                  const CodedBitstreamUnitTypeDescriptor *desc)
+static int cbs_clone_internal_refs_unit_content(AVBufferRef **clone_ref,
+                                                const CodedBitstreamUnit *unit,
+                                                const CodedBitstreamUnitTypeDescriptor *desc)
 {
-    uint8_t *src, *copy;
-    uint8_t **src_ptr, **copy_ptr;
-    AVBufferRef **src_buf, **copy_buf;
+    const uint8_t *src;
+    uint8_t *copy;
     int err, i;
 
     av_assert0(unit->content);
@@ -937,17 +917,17 @@ static int cbs_clone_unit_content(AVBufferRef **clone_ref,
     if (!copy)
         return AVERROR(ENOMEM);
 
-    for (i = 0; i < desc->nb_ref_offsets; i++) {
-        src_ptr  = (uint8_t**)(src + desc->ref_offsets[i]);
-        src_buf  = (AVBufferRef**)(src_ptr + 1);
-        copy_ptr = (uint8_t**)(copy + desc->ref_offsets[i]);
-        copy_buf = (AVBufferRef**)(copy_ptr + 1);
+    for (i = 0; i < desc->type.ref.nb_offsets; i++) {
+        const uint8_t *const *src_ptr = (const uint8_t* const*)(src + desc->type.ref.offsets[i]);
+        const AVBufferRef *src_buf = *(AVBufferRef**)(src_ptr + 1);
+        uint8_t **copy_ptr = (uint8_t**)(copy + desc->type.ref.offsets[i]);
+        AVBufferRef **copy_buf = (AVBufferRef**)(copy_ptr + 1);
 
         if (!*src_ptr) {
-            av_assert0(!*src_buf);
+            av_assert0(!src_buf);
             continue;
         }
-        if (!*src_buf) {
+        if (!src_buf) {
             // We can't handle a non-refcounted pointer here - we don't
             // have enough information to handle whatever structure lies
             // at the other end of it.
@@ -955,21 +935,14 @@ static int cbs_clone_unit_content(AVBufferRef **clone_ref,
             goto fail;
         }
 
-        // src_ptr is required to point somewhere inside src_buf.  If it
-        // doesn't, there is a bug somewhere.
-        av_assert0(*src_ptr >= (*src_buf)->data &&
-                   *src_ptr <  (*src_buf)->data + (*src_buf)->size);
-
-        *copy_buf = av_buffer_ref(*src_buf);
+        *copy_buf = av_buffer_ref(src_buf);
         if (!*copy_buf) {
             err = AVERROR(ENOMEM);
             goto fail;
         }
-        *copy_ptr = (*copy_buf)->data + (*src_ptr - (*src_buf)->data);
     }
 
     *clone_ref = av_buffer_create(copy, desc->content_size,
-                                  desc->content_free ? desc->content_free :
                                   cbs_default_free_unit_content,
                                   (void*)desc, 0);
     if (!*clone_ref) {
@@ -981,25 +954,24 @@ static int cbs_clone_unit_content(AVBufferRef **clone_ref,
 
 fail:
     for (--i; i >= 0; i--)
-        av_buffer_unref((AVBufferRef**)(copy + desc->ref_offsets[i]));
+        av_buffer_unref((AVBufferRef**)(copy + desc->type.ref.offsets[i]));
     av_freep(&copy);
     *clone_ref = NULL;
     return err;
 }
 
-int ff_cbs_make_unit_refcounted(CodedBitstreamContext *ctx,
-                                CodedBitstreamUnit *unit)
+/*
+ * On success, unit->content and unit->content_ref are updated with
+ * the new content; unit is untouched on failure.
+ * Any old content_ref is simply overwritten and not freed.
+ */
+static int cbs_clone_unit_content(CodedBitstreamContext *ctx,
+                                  CodedBitstreamUnit *unit)
 {
     const CodedBitstreamUnitTypeDescriptor *desc;
     AVBufferRef *ref;
     int err;
 
-    av_assert0(unit->content);
-    if (unit->content_ref) {
-        // Already refcounted, nothing to do.
-        return 0;
-    }
-
     desc = cbs_find_unit_type_desc(ctx, unit);
     if (!desc)
         return AVERROR(ENOSYS);
@@ -1014,13 +986,13 @@ int ff_cbs_make_unit_refcounted(CodedBitstreamContext *ctx,
         break;
 
     case CBS_CONTENT_TYPE_INTERNAL_REFS:
-        err = cbs_clone_unit_content(&ref, unit, desc);
+        err = cbs_clone_internal_refs_unit_content(&ref, unit, desc);
         break;
 
     case CBS_CONTENT_TYPE_COMPLEX:
-        if (!desc->content_clone)
+        if (!desc->type.complex.content_clone)
             return AVERROR_PATCHWELCOME;
-        err = desc->content_clone(&ref, unit);
+        err = desc->type.complex.content_clone(&ref, unit);
         break;
 
     default:
@@ -1035,51 +1007,28 @@ int ff_cbs_make_unit_refcounted(CodedBitstreamContext *ctx,
     return 0;
 }
 
+int ff_cbs_make_unit_refcounted(CodedBitstreamContext *ctx,
+                                CodedBitstreamUnit *unit)
+{
+    av_assert0(unit->content);
+    if (unit->content_ref)
+        return 0;
+    return cbs_clone_unit_content(ctx, unit);
+}
+
 int ff_cbs_make_unit_writable(CodedBitstreamContext *ctx,
                               CodedBitstreamUnit *unit)
 {
-    const CodedBitstreamUnitTypeDescriptor *desc;
-    AVBufferRef *ref;
+    AVBufferRef *ref = unit->content_ref;
     int err;
 
-    // This can only be applied to refcounted units.
-    err = ff_cbs_make_unit_refcounted(ctx, unit);
-    if (err < 0)
-        return err;
-    av_assert0(unit->content && unit->content_ref);
-
-    if (av_buffer_is_writable(unit->content_ref))
+    av_assert0(unit->content);
+    if (ref && av_buffer_is_writable(ref))
         return 0;
 
-    desc = cbs_find_unit_type_desc(ctx, unit);
-    if (!desc)
-        return AVERROR(ENOSYS);
-
-    switch (desc->content_type) {
-    case CBS_CONTENT_TYPE_POD:
-        err = av_buffer_make_writable(&unit->content_ref);
-        break;
-
-    case CBS_CONTENT_TYPE_INTERNAL_REFS:
-        err = cbs_clone_unit_content(&ref, unit, desc);
-        break;
-
-    case CBS_CONTENT_TYPE_COMPLEX:
-        if (!desc->content_clone)
-            return AVERROR_PATCHWELCOME;
-        err = desc->content_clone(&ref, unit);
-        break;
-
-    default:
-        av_assert0(0 && "Invalid content type.");
-    }
+    err = cbs_clone_unit_content(ctx, unit);
     if (err < 0)
         return err;
-
-    if (desc->content_type != CBS_CONTENT_TYPE_POD) {
-        av_buffer_unref(&unit->content_ref);
-        unit->content_ref = ref;
-    }
-    unit->content = unit->content_ref->data;
+    av_buffer_unref(&ref);
     return 0;
 }
diff --git a/libavcodec/cbs.h b/libavcodec/cbs.h
index 5583063..ee21623 100644
--- a/libavcodec/cbs.h
+++ b/libavcodec/cbs.h
@@ -363,22 +363,13 @@ void ff_cbs_fragment_reset(CodedBitstreamFragment *frag);
  */
 void ff_cbs_fragment_free(CodedBitstreamFragment *frag);
 
-/**
- * Allocate a new internal content buffer of the given size in the unit.
- *
- * The content will be zeroed.
- */
-int ff_cbs_alloc_unit_content(CodedBitstreamUnit *unit,
-                              size_t size,
-                              void (*free)(void *opaque, uint8_t *content));
-
 /**
  * Allocate a new internal content buffer matching the type of the unit.
  *
  * The content will be zeroed.
  */
-int ff_cbs_alloc_unit_content2(CodedBitstreamContext *ctx,
-                               CodedBitstreamUnit *unit);
+int ff_cbs_alloc_unit_content(CodedBitstreamContext *ctx,
+                              CodedBitstreamUnit *unit);
 
 /**
  * Insert a new unit into a fragment with the given content.
diff --git a/libavcodec/cbs_av1.c b/libavcodec/cbs_av1.c
index 1229480..154d915 100644
--- a/libavcodec/cbs_av1.c
+++ b/libavcodec/cbs_av1.c
@@ -878,7 +878,7 @@ static int cbs_av1_read_unit(CodedBitstreamContext *ctx,
     GetBitContext gbc;
     int err, start_pos, end_pos;
 
-    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    err = ff_cbs_alloc_unit_content(ctx, unit);
     if (err < 0)
         return err;
     obu = unit->content;
diff --git a/libavcodec/cbs_h2645.c b/libavcodec/cbs_h2645.c
index 12e38c8..4ee0600 100644
--- a/libavcodec/cbs_h2645.c
+++ b/libavcodec/cbs_h2645.c
@@ -666,13 +666,7 @@ static int cbs_h26 ## h26n ## _replace_ ## ps_var(CodedBitstreamContext *ctx, \
     CodedBitstreamH26 ## h26n ## Context *priv = ctx->priv_data; \
     H26 ## h26n ## Raw ## ps_name *ps_var = unit->content; \
     unsigned int id = ps_var->id_element; \
-    int err; \
-    if (id >= FF_ARRAY_ELEMS(priv->ps_var)) { \
-        av_log(ctx->log_ctx, AV_LOG_ERROR, "Invalid " #ps_name \
-               " id : %d.\n", id); \
-        return AVERROR_INVALIDDATA; \
-    } \
-    err = ff_cbs_make_unit_refcounted(ctx, unit); \
+    int err = ff_cbs_make_unit_refcounted(ctx, unit); \
     if (err < 0) \
         return err; \
     if (priv->ps_var[id] == priv->active_ ## ps_var) \
@@ -702,7 +696,7 @@ static int cbs_h264_read_nal_unit(CodedBitstreamContext *ctx,
     if (err < 0)
         return err;
 
-    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    err = ff_cbs_alloc_unit_content(ctx, unit);
     if (err < 0)
         return err;
 
@@ -821,7 +815,7 @@ static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx,
     if (err < 0)
         return err;
 
-    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    err = ff_cbs_alloc_unit_content(ctx, unit);
     if (err < 0)
         return err;
 
@@ -1396,18 +1390,9 @@ static const CodedBitstreamUnitTypeDescriptor cbs_h264_unit_types[] = {
 
     CBS_UNIT_TYPE_INTERNAL_REF(H264_NAL_PPS, H264RawPPS, slice_group_id),
 
-    {
-        .nb_unit_types  = 3,
-        .unit_types     = {
-            H264_NAL_IDR_SLICE,
-            H264_NAL_SLICE,
-            H264_NAL_AUXILIARY_SLICE,
-        },
-        .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS,
-        .content_size   = sizeof(H264RawSlice),
-        .nb_ref_offsets = 1,
-        .ref_offsets    = { offsetof(H264RawSlice, data) },
-    },
+    CBS_UNIT_TYPES_INTERNAL_REF((H264_NAL_IDR_SLICE,
+                                 H264_NAL_SLICE,
+                                 H264_NAL_AUXILIARY_SLICE), H264RawSlice, data),
 
     CBS_UNIT_TYPE_POD(H264_NAL_AUD,          H264RawAUD),
     CBS_UNIT_TYPE_POD(H264_NAL_FILLER_DATA,  H264RawFiller),
@@ -1433,40 +1418,15 @@ static const CodedBitstreamUnitTypeDescriptor cbs_h265_unit_types[] = {
 
     CBS_UNIT_TYPE_POD(HEVC_NAL_AUD, H265RawAUD),
 
-    {
-        // Slices of non-IRAP pictures.
-        .nb_unit_types         = CBS_UNIT_TYPE_RANGE,
-        .unit_type_range_start = HEVC_NAL_TRAIL_N,
-        .unit_type_range_end   = HEVC_NAL_RASL_R,
-
-        .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS,
-        .content_size   = sizeof(H265RawSlice),
-        .nb_ref_offsets = 1,
-        .ref_offsets    = { offsetof(H265RawSlice, data) },
-    },
+    // Slices of non-IRAP pictures.
+    CBS_UNIT_RANGE_INTERNAL_REF(HEVC_NAL_TRAIL_N, HEVC_NAL_RASL_R,
+                                H265RawSlice, data),
+    // Slices of IRAP pictures.
+    CBS_UNIT_RANGE_INTERNAL_REF(HEVC_NAL_BLA_W_LP, HEVC_NAL_CRA_NUT,
+                                H265RawSlice, data),
 
-    {
-        // Slices of IRAP pictures.
-        .nb_unit_types         = CBS_UNIT_TYPE_RANGE,
-        .unit_type_range_start = HEVC_NAL_BLA_W_LP,
-        .unit_type_range_end   = HEVC_NAL_CRA_NUT,
-
-        .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS,
-        .content_size   = sizeof(H265RawSlice),
-        .nb_ref_offsets = 1,
-        .ref_offsets    = { offsetof(H265RawSlice, data) },
-    },
-
-    {
-        .nb_unit_types  = 2,
-        .unit_types     = {
-            HEVC_NAL_SEI_PREFIX,
-            HEVC_NAL_SEI_SUFFIX
-        },
-        .content_type   = CBS_CONTENT_TYPE_COMPLEX,
-        .content_size   = sizeof(H265RawSEI),
-        .content_free   = &cbs_h265_free_sei,
-    },
+    CBS_UNIT_TYPES_COMPLEX((HEVC_NAL_SEI_PREFIX, HEVC_NAL_SEI_SUFFIX),
+                           H265RawSEI, cbs_h265_free_sei),
 
     CBS_UNIT_TYPE_END_OF_LIST
 };
diff --git a/libavcodec/cbs_internal.h b/libavcodec/cbs_internal.h
index f853086..5ccba3c 100644
--- a/libavcodec/cbs_internal.h
+++ b/libavcodec/cbs_internal.h
@@ -60,13 +60,16 @@ typedef const struct CodedBitstreamUnitTypeDescriptor {
     // used instead.
     int nb_unit_types;
 
-    // Array of unit types that this entry describes.
-    const CodedBitstreamUnitType unit_types[CBS_MAX_UNIT_TYPES];
-
-    // Start and end of unit type range, used if nb_unit_types is
-    // CBS_UNIT_TYPE_RANGE.
-    const CodedBitstreamUnitType unit_type_range_start;
-    const CodedBitstreamUnitType unit_type_range_end;
+    union {
+        // Array of unit types that this entry describes.
+        CodedBitstreamUnitType list[CBS_MAX_UNIT_TYPES];
+        // Start and end of unit type range, used if nb_unit_types is
+        // CBS_UNIT_TYPE_RANGE.
+        struct {
+            CodedBitstreamUnitType start;
+            CodedBitstreamUnitType end;
+        } range;
+    } unit_type;
 
     // The type of content described.
     enum CBSContentType content_type;
@@ -74,18 +77,24 @@ typedef const struct CodedBitstreamUnitTypeDescriptor {
     // the decomposed content of this type of unit.
     size_t content_size;
 
-    // Number of entries in the ref_offsets array.  Only used if the
-    // content_type is CBS_CONTENT_TYPE_INTERNAL_REFS.
-    int nb_ref_offsets;
-    // The structure must contain two adjacent elements:
-    //   type        *field;
-    //   AVBufferRef *field_ref;
-    // where field points to something in the buffer referred to by
-    // field_ref.  This offset is then set to offsetof(struct, field).
-    size_t ref_offsets[CBS_MAX_REF_OFFSETS];
-
-    void (*content_free)(void *opaque, uint8_t *data);
-    int  (*content_clone)(AVBufferRef **ref, CodedBitstreamUnit *unit);
+    union {
+        struct {
+            // Number of entries in the ref_offsets array.  Only nonzero
+            // if the content_type is CBS_CONTENT_TYPE_INTERNAL_REFS.
+            int nb_offsets;
+            // The structure must contain two adjacent elements:
+            //   type        *field;
+            //   AVBufferRef *field_ref;
+            // where field points to something in the buffer referred to by
+            // field_ref.  This offset is then set to offsetof(struct, field).
+            size_t offsets[CBS_MAX_REF_OFFSETS];
+        } ref;
+
+        struct {
+            void (*content_free)(void *opaque, uint8_t *data);
+            int  (*content_clone)(AVBufferRef **ref, CodedBitstreamUnit *unit);
+        } complex;
+    } type;
 } CodedBitstreamUnitTypeDescriptor;
 
 typedef struct CodedBitstreamType {
@@ -181,28 +190,52 @@ int ff_cbs_write_signed(CodedBitstreamContext *ctx, PutBitContext *pbc,
 // range_min in the above functions.
 #define MIN_INT_BITS(length) (-(INT64_C(1) << ((length) - 1)))
 
-
+#define TYPE_LIST(...) { __VA_ARGS__ }
 #define CBS_UNIT_TYPE_POD(type, structure) { \
         .nb_unit_types  = 1, \
-        .unit_types     = { type }, \
+        .unit_type.list = { type }, \
         .content_type   = CBS_CONTENT_TYPE_POD, \
         .content_size   = sizeof(structure), \
     }
-#define CBS_UNIT_TYPE_INTERNAL_REF(type, structure, ref_field) { \
-        .nb_unit_types  = 1, \
-        .unit_types     = { type }, \
+#define CBS_UNIT_RANGE_POD(range_start, range_end, structure) { \
+        .nb_unit_types         = CBS_UNIT_TYPE_RANGE, \
+        .unit_type.range.start = range_start, \
+        .unit_type.range.end   = range_end, \
+        .content_type          = CBS_CONTENT_TYPE_POD, \
+        .content_size          = sizeof(structure), \
+    }
+
+#define CBS_UNIT_TYPES_INTERNAL_REF(types, structure, ref_field) { \
+        .nb_unit_types  = FF_ARRAY_ELEMS((CodedBitstreamUnitType[])TYPE_LIST types), \
+        .unit_type.list = TYPE_LIST types, \
         .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS, \
         .content_size   = sizeof(structure), \
-        .nb_ref_offsets = 1, \
-        .ref_offsets    = { offsetof(structure, ref_field) }, \
+        .type.ref       = { .nb_offsets = 1, \
+                            .offsets    = { offsetof(structure, ref_field) } }, \
     }
-#define CBS_UNIT_TYPE_COMPLEX(type, structure, free_func) { \
-        .nb_unit_types  = 1, \
-        .unit_types     = { type }, \
+#define CBS_UNIT_TYPE_INTERNAL_REF(type, structure, ref_field) \
+    CBS_UNIT_TYPES_INTERNAL_REF((type), structure, ref_field)
+
+#define CBS_UNIT_RANGE_INTERNAL_REF(range_start, range_end, structure, ref_field) { \
+        .nb_unit_types         = CBS_UNIT_TYPE_RANGE, \
+        .unit_type.range.start = range_start, \
+        .unit_type.range.end   = range_end, \
+        .content_type          = CBS_CONTENT_TYPE_INTERNAL_REFS, \
+        .content_size          = sizeof(structure), \
+        .type.ref = { .nb_offsets = 1, \
+                      .offsets    = { offsetof(structure, ref_field) } }, \
+    }
+
+#define CBS_UNIT_TYPES_COMPLEX(types, structure, free_func) { \
+        .nb_unit_types  = FF_ARRAY_ELEMS((CodedBitstreamUnitType[])TYPE_LIST types), \
+        .unit_type.list = TYPE_LIST types, \
         .content_type   = CBS_CONTENT_TYPE_COMPLEX, \
         .content_size   = sizeof(structure), \
-        .content_free   = free_func, \
+        .type.complex   = { .content_free = free_func }, \
     }
+#define CBS_UNIT_TYPE_COMPLEX(type, structure, free_func) \
+    CBS_UNIT_TYPES_COMPLEX((type), structure, free_func)
+
 #define CBS_UNIT_TYPE_END_OF_LIST { .nb_unit_types = 0 }
 
 
diff --git a/libavcodec/cbs_jpeg.c b/libavcodec/cbs_jpeg.c
index da7ee80..5921d62 100644
--- a/libavcodec/cbs_jpeg.c
+++ b/libavcodec/cbs_jpeg.c
@@ -82,27 +82,6 @@
 #undef xu
 
 
-static void cbs_jpeg_free_application_data(void *opaque, uint8_t *content)
-{
-    JPEGRawApplicationData *ad = (JPEGRawApplicationData*)content;
-    av_buffer_unref(&ad->Ap_ref);
-    av_freep(&content);
-}
-
-static void cbs_jpeg_free_comment(void *opaque, uint8_t *content)
-{
-    JPEGRawComment *comment = (JPEGRawComment*)content;
-    av_buffer_unref(&comment->Cm_ref);
-    av_freep(&content);
-}
-
-static void cbs_jpeg_free_scan(void *opaque, uint8_t *content)
-{
-    JPEGRawScan *scan = (JPEGRawScan*)content;
-    av_buffer_unref(&scan->data_ref);
-    av_freep(&content);
-}
-
 static int cbs_jpeg_split_fragment(CodedBitstreamContext *ctx,
                                    CodedBitstreamFragment *frag,
                                    int header)
@@ -248,41 +227,26 @@ static int cbs_jpeg_read_unit(CodedBitstreamContext *ctx,
     if (err < 0)
         return err;
 
+    err = ff_cbs_alloc_unit_content(ctx, unit);
+    if (err < 0)
+        return err;
+
     if (unit->type >= JPEG_MARKER_SOF0 &&
         unit->type <= JPEG_MARKER_SOF3) {
-        err = ff_cbs_alloc_unit_content(unit,
-                                        sizeof(JPEGRawFrameHeader),
-                                        NULL);
-        if (err < 0)
-            return err;
-
         err = cbs_jpeg_read_frame_header(ctx, &gbc, unit->content);
         if (err < 0)
             return err;
 
     } else if (unit->type >= JPEG_MARKER_APPN &&
                unit->type <= JPEG_MARKER_APPN + 15) {
-        err = ff_cbs_alloc_unit_content(unit,
-                                        sizeof(JPEGRawApplicationData),
-                                        &cbs_jpeg_free_application_data);
-        if (err < 0)
-            return err;
-
         err = cbs_jpeg_read_application_data(ctx, &gbc, unit->content);
         if (err < 0)
             return err;
 
     } else if (unit->type == JPEG_MARKER_SOS) {
-        JPEGRawScan *scan;
+        JPEGRawScan *scan = unit->content;
         int pos;
 
-        err = ff_cbs_alloc_unit_content(unit,
-                                        sizeof(JPEGRawScan),
-                                        &cbs_jpeg_free_scan);
-        if (err < 0)
-            return err;
-        scan = unit->content;
-
         err = cbs_jpeg_read_scan_header(ctx, &gbc, &scan->header);
         if (err < 0)
             return err;
@@ -299,21 +263,17 @@ static int cbs_jpeg_read_unit(CodedBitstreamContext *ctx,
 
     } else {
         switch (unit->type) {
-#define SEGMENT(marker, type, func, free) \
+#define SEGMENT(marker, func) \
         case JPEG_MARKER_ ## marker: \
             { \
-                err = ff_cbs_alloc_unit_content(unit, \
-                                                sizeof(type), free); \
-                if (err < 0) \
-                    return err; \
                 err = cbs_jpeg_read_ ## func(ctx, &gbc, unit->content); \
                 if (err < 0) \
                     return err; \
             } \
             break
-            SEGMENT(DQT, JPEGRawQuantisationTableSpecification, dqt, NULL);
-            SEGMENT(DHT, JPEGRawHuffmanTableSpecification,      dht, NULL);
-            SEGMENT(COM, JPEGRawComment,  comment, &cbs_jpeg_free_comment);
+            SEGMENT(DQT, dqt);
+            SEGMENT(DHT, dht);
+            SEGMENT(COM, comment);
 #undef SEGMENT
         default:
             return AVERROR(ENOSYS);
@@ -456,9 +416,27 @@ static int cbs_jpeg_assemble_fragment(CodedBitstreamContext *ctx,
     return 0;
 }
 
+static const CodedBitstreamUnitTypeDescriptor cbs_jpeg_unit_types[] = {
+    CBS_UNIT_RANGE_POD(JPEG_MARKER_SOF0, JPEG_MARKER_SOF3, JPEGRawFrameHeader),
+
+    CBS_UNIT_RANGE_INTERNAL_REF(JPEG_MARKER_APPN, JPEG_MARKER_APPN + 15,
+                                JPEGRawApplicationData, Ap),
+
+    CBS_UNIT_TYPE_INTERNAL_REF(JPEG_MARKER_SOS, JPEGRawScan, data),
+
+    CBS_UNIT_TYPE_POD(JPEG_MARKER_DQT, JPEGRawQuantisationTableSpecification),
+    CBS_UNIT_TYPE_POD(JPEG_MARKER_DHT, JPEGRawHuffmanTableSpecification),
+
+    CBS_UNIT_TYPE_INTERNAL_REF(JPEG_MARKER_COM, JPEGRawComment, Cm),
+
+    CBS_UNIT_TYPE_END_OF_LIST
+};
+
 const CodedBitstreamType ff_cbs_type_jpeg = {
     .codec_id          = AV_CODEC_ID_MJPEG,
 
+    .unit_types        = cbs_jpeg_unit_types,
+
     .split_fragment    = &cbs_jpeg_split_fragment,
     .read_unit         = &cbs_jpeg_read_unit,
     .write_unit        = &cbs_jpeg_write_unit,
diff --git a/libavcodec/cbs_mpeg2.c b/libavcodec/cbs_mpeg2.c
index 33bd3e0..04b0c7f 100644
--- a/libavcodec/cbs_mpeg2.c
+++ b/libavcodec/cbs_mpeg2.c
@@ -204,7 +204,7 @@ static int cbs_mpeg2_read_unit(CodedBitstreamContext *ctx,
     if (err < 0)
         return err;
 
-    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    err = ff_cbs_alloc_unit_content(ctx, unit);
     if (err < 0)
         return err;
 
@@ -392,14 +392,14 @@ static const CodedBitstreamUnitTypeDescriptor cbs_mpeg2_unit_types[] = {
 
     {
         .nb_unit_types         = CBS_UNIT_TYPE_RANGE,
-        .unit_type_range_start = 0x01,
-        .unit_type_range_end   = 0xaf,
+        .unit_type.range.start = 0x01,
+        .unit_type.range.end   = 0xaf,
 
         .content_type   = CBS_CONTENT_TYPE_INTERNAL_REFS,
         .content_size   = sizeof(MPEG2RawSlice),
-        .nb_ref_offsets = 2,
-        .ref_offsets    = { offsetof(MPEG2RawSlice, header.extra_information_slice.extra_information),
-                            offsetof(MPEG2RawSlice, data) },
+        .type.ref = { .nb_offsets = 2,
+                      .offsets    = { offsetof(MPEG2RawSlice, header.extra_information_slice.extra_information),
+                                      offsetof(MPEG2RawSlice, data) } },
     },
 
     CBS_UNIT_TYPE_INTERNAL_REF(MPEG2_START_USER_DATA, MPEG2RawUserData,
diff --git a/libavcodec/cbs_sei.c b/libavcodec/cbs_sei.c
index 141e97e..50a513f 100644
--- a/libavcodec/cbs_sei.c
+++ b/libavcodec/cbs_sei.c
@@ -179,7 +179,7 @@ static int cbs_sei_get_unit(CodedBitstreamContext *ctx,
     unit = &au->units[position];
     unit->type = sei_type;
 
-    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    err = ff_cbs_alloc_unit_content(ctx, unit);
     if (err < 0)
         return err;
 
diff --git a/libavcodec/cbs_vp9.c b/libavcodec/cbs_vp9.c
index ae7f88a..184fdca 100644
--- a/libavcodec/cbs_vp9.c
+++ b/libavcodec/cbs_vp9.c
@@ -489,7 +489,7 @@ static int cbs_vp9_read_unit(CodedBitstreamContext *ctx,
     if (err < 0)
         return err;
 
-    err = ff_cbs_alloc_unit_content2(ctx, unit);
+    err = ff_cbs_alloc_unit_content(ctx, unit);
     if (err < 0)
         return err;
     frame = unit->content;
diff --git a/libavcodec/ccaption_dec.c b/libavcodec/ccaption_dec.c
index 34f0513..13648ff 100644
--- a/libavcodec/ccaption_dec.c
+++ b/libavcodec/ccaption_dec.c
@@ -956,5 +956,4 @@ const FFCodec ff_ccaption_decoder = {
     .close          = close_decoder,
     .flush          = flush_decoder,
     FF_CODEC_DECODE_SUB_CB(decode),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/cdgraphics.c b/libavcodec/cdgraphics.c
index 7365401..0070d9b 100644
--- a/libavcodec/cdgraphics.c
+++ b/libavcodec/cdgraphics.c
@@ -398,5 +398,4 @@ const FFCodec ff_cdgraphics_decoder = {
     FF_CODEC_DECODE_CB(cdg_decode_frame),
     .flush          = cdg_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/cdtoons.c b/libavcodec/cdtoons.c
index eb53a32..c1b4577 100644
--- a/libavcodec/cdtoons.c
+++ b/libavcodec/cdtoons.c
@@ -454,5 +454,4 @@ const FFCodec ff_cdtoons_decoder = {
     FF_CODEC_DECODE_CB(cdtoons_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .flush          = cdtoons_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/cdxl.c b/libavcodec/cdxl.c
index 1f25d8e..b005442 100644
--- a/libavcodec/cdxl.c
+++ b/libavcodec/cdxl.c
@@ -346,5 +346,4 @@ const FFCodec ff_cdxl_decoder = {
     .close          = cdxl_decode_end,
     FF_CODEC_DECODE_CB(cdxl_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/cfhd.c b/libavcodec/cfhd.c
index 5adb0b2..9f218f6 100644
--- a/libavcodec/cfhd.c
+++ b/libavcodec/cfhd.c
@@ -1466,5 +1466,5 @@ const FFCodec ff_cfhd_decoder = {
     FF_CODEC_DECODE_CB(cfhd_decode),
     .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cfhdenc.c b/libavcodec/cfhdenc.c
index 6b33b29..c2f42c1 100644
--- a/libavcodec/cfhdenc.c
+++ b/libavcodec/cfhdenc.c
@@ -437,7 +437,8 @@ static int cfhd_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         int a_width = s->plane[plane].band[2][0].a_width;
         int height = s->plane[plane].band[2][0].height;
         int act_plane = plane == 1 ? 2 : plane == 2 ? 1 : plane;
-        int16_t *input = (int16_t *)frame->data[act_plane];
+        const int16_t *input = (int16_t *)frame->data[act_plane];
+        int16_t *buf;
         int16_t *low = s->plane[plane].l_h[6];
         int16_t *high = s->plane[plane].l_h[7];
         ptrdiff_t in_stride = frame->linesize[act_plane] / 2;
@@ -481,13 +482,13 @@ static int cfhd_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         high = s->plane[plane].l_h[4];
         high_stride = s->plane[plane].band[1][0].a_width;
 
+        buf = s->plane[plane].l_h[7];
         for (int i = 0; i < height * 2; i++) {
             for (int j = 0; j < width * 2; j++)
-                input[j] /= 4;
-            input += a_width * 2;
+                buf[j] /= 4;
+            buf += a_width * 2;
         }
 
-        input = s->plane[plane].l_h[7];
         dsp->horiz_filter(input, low, high,
                           a_width * 2, low_stride, high_stride,
                           width * 2, height * 2);
@@ -518,14 +519,14 @@ static int cfhd_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         high_stride = s->plane[plane].band[0][0].a_width;
 
         if (avctx->pix_fmt != AV_PIX_FMT_YUV422P10) {
+            int16_t *buf = s->plane[plane].l_h[4];
             for (int i = 0; i < height * 2; i++) {
                 for (int j = 0; j < width * 2; j++)
-                    input[j] /= 4;
-                input += a_width * 2;
+                    buf[j] /= 4;
+                buf += a_width * 2;
             }
         }
 
-        input = s->plane[plane].l_h[4];
         dsp->horiz_filter(input, low, high,
                           a_width * 2, low_stride, high_stride,
                           width * 2, height * 2);
@@ -862,5 +863,5 @@ const FFCodec ff_cfhd_encoder = {
                           AV_PIX_FMT_GBRAP12,
                           AV_PIX_FMT_NONE
                         },
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cfhdencdsp.c b/libavcodec/cfhdencdsp.c
index 3a35522..a122bca 100644
--- a/libavcodec/cfhdencdsp.c
+++ b/libavcodec/cfhdencdsp.c
@@ -23,7 +23,7 @@
 
 #include "cfhdencdsp.h"
 
-static av_always_inline void filter(int16_t *input, ptrdiff_t in_stride,
+static av_always_inline void filter(const int16_t *input, ptrdiff_t in_stride,
                           int16_t *low, ptrdiff_t low_stride,
                           int16_t *high, ptrdiff_t high_stride,
                           int len)
@@ -46,7 +46,7 @@ static av_always_inline void filter(int16_t *input, ptrdiff_t in_stride,
                                                       1 * input[((len-2)-3)*in_stride] + 1 * input[((len-2)-4)*in_stride] + 4) >> 3);
 }
 
-static void horiz_filter(int16_t *input, int16_t *low, int16_t *high,
+static void horiz_filter(const int16_t *input, int16_t *low, int16_t *high,
                          ptrdiff_t in_stride, ptrdiff_t low_stride,
                          ptrdiff_t high_stride,
                          int width, int height)
@@ -59,7 +59,7 @@ static void horiz_filter(int16_t *input, int16_t *low, int16_t *high,
     }
 }
 
-static void vert_filter(int16_t *input, int16_t *low, int16_t *high,
+static void vert_filter(const int16_t *input, int16_t *low, int16_t *high,
                         ptrdiff_t in_stride, ptrdiff_t low_stride,
                         ptrdiff_t high_stride,
                         int width, int height)
diff --git a/libavcodec/cfhdencdsp.h b/libavcodec/cfhdencdsp.h
index b3aac8d..d234b93 100644
--- a/libavcodec/cfhdencdsp.h
+++ b/libavcodec/cfhdencdsp.h
@@ -23,12 +23,12 @@
 #include <stdint.h>
 
 typedef struct CFHDEncDSPContext {
-    void (*horiz_filter)(int16_t *input, int16_t *low, int16_t *high,
+    void (*horiz_filter)(const int16_t *input, int16_t *low, int16_t *high,
                          ptrdiff_t in_stride, ptrdiff_t low_stride,
                          ptrdiff_t high_stride,
                          int width, int height);
 
-    void (*vert_filter)(int16_t *input, int16_t *low, int16_t *high,
+    void (*vert_filter)(const int16_t *input, int16_t *low, int16_t *high,
                         ptrdiff_t in_stride, ptrdiff_t low_stride,
                         ptrdiff_t high_stride,
                         int width, int height);
diff --git a/libavcodec/cinepak.c b/libavcodec/cinepak.c
index e69232e..4cbbac8 100644
--- a/libavcodec/cinepak.c
+++ b/libavcodec/cinepak.c
@@ -516,5 +516,4 @@ const FFCodec ff_cinepak_decoder = {
     .close          = cinepak_decode_end,
     FF_CODEC_DECODE_CB(cinepak_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/cinepakenc.c b/libavcodec/cinepakenc.c
index 6cfe8de..5e59af1 100644
--- a/libavcodec/cinepakenc.c
+++ b/libavcodec/cinepakenc.c
@@ -429,7 +429,7 @@ static int encode_codebook(CinepakEncContext *s, int *codebook, int size,
 
 // sets out to the sub picture starting at (x,y) in in
 static void get_sub_picture(CinepakEncContext *s, int x, int y,
-                            uint8_t * in_data[4], int  in_linesize[4],
+                            uint8_t *const in_data[4], const int in_linesize[4],
                             uint8_t *out_data[4], int out_linesize[4])
 {
     out_data[0]     = in_data[0] + x + y * in_linesize[0];
@@ -1019,7 +1019,7 @@ static int rd_frame(CinepakEncContext *s, const AVFrame *frame,
         // build a copy of the given frame in the correct colorspace
         for (y = 0; y < s->h; y += 2)
             for (x = 0; x < s->w; x += 2) {
-                uint8_t *ir[2];
+                const uint8_t *ir[2];
                 int32_t r, g, b, rr, gg, bb;
                 ir[0] = frame->data[0] + x * 3 + y * frame->linesize[0];
                 ir[1] = ir[0] + frame->linesize[0];
@@ -1097,7 +1097,7 @@ static int rd_frame(CinepakEncContext *s, const AVFrame *frame,
                                 data, linesize);
             else
                 get_sub_picture(s, 0, y,
-                                (uint8_t **)frame->data, (int *)frame->linesize,
+                                frame->data, frame->linesize,
                                 data, linesize);
             get_sub_picture(s, 0, y,
                             s->last_frame->data, s->last_frame->linesize,
@@ -1225,5 +1225,5 @@ const FFCodec ff_cinepak_encoder = {
     .close          = cinepak_encode_end,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_RGB24, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE },
     .p.priv_class   = &cinepak_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/clearvideo.c b/libavcodec/clearvideo.c
index 075c6e9..47570a9 100644
--- a/libavcodec/clearvideo.c
+++ b/libavcodec/clearvideo.c
@@ -777,5 +777,5 @@ const FFCodec ff_clearvideo_decoder = {
     .close          = clv_decode_end,
     FF_CODEC_DECODE_CB(clv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cljrdec.c b/libavcodec/cljrdec.c
index bb7c9bf..21fa8ee 100644
--- a/libavcodec/cljrdec.c
+++ b/libavcodec/cljrdec.c
@@ -89,6 +89,5 @@ const FFCodec ff_cljr_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 
diff --git a/libavcodec/cljrenc.c b/libavcodec/cljrenc.c
index 2d171a9..f84191b 100644
--- a/libavcodec/cljrenc.c
+++ b/libavcodec/cljrenc.c
@@ -63,9 +63,9 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     init_put_bits(&pb, pkt->data, pkt->size);
 
     for (y = 0; y < avctx->height; y++) {
-        uint8_t *luma = &p->data[0][y * p->linesize[0]];
-        uint8_t *cb   = &p->data[1][y * p->linesize[1]];
-        uint8_t *cr   = &p->data[2][y * p->linesize[2]];
+        const uint8_t *luma = &p->data[0][y * p->linesize[0]];
+        const uint8_t *cb   = &p->data[1][y * p->linesize[1]];
+        const uint8_t *cr   = &p->data[2][y * p->linesize[2]];
         uint8_t luma_tmp[4];
         for (x = 0; x < avctx->width; x += 4) {
             switch (a->dither_type) {
diff --git a/libavcodec/cllc.c b/libavcodec/cllc.c
index 4866c5b..1b9fdb8 100644
--- a/libavcodec/cllc.c
+++ b/libavcodec/cllc.c
@@ -501,5 +501,4 @@ const FFCodec ff_cllc_decoder = {
     FF_CODEC_DECODE_CB(cllc_decode_frame),
     .close          = cllc_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/cngdec.c b/libavcodec/cngdec.c
index d549ff4..c89dfee 100644
--- a/libavcodec/cngdec.c
+++ b/libavcodec/cngdec.c
@@ -175,6 +175,5 @@ const FFCodec ff_comfortnoise_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cngenc.c b/libavcodec/cngenc.c
index 1f5d25e..7bb4bee 100644
--- a/libavcodec/cngenc.c
+++ b/libavcodec/cngenc.c
@@ -67,7 +67,7 @@ static int cng_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
     int ret, i;
     double energy = 0;
     int qdbov;
-    int16_t *samples = (int16_t*) frame->data[0];
+    const int16_t *samples = (const int16_t*) frame->data[0];
 
     if ((ret = ff_get_encode_buffer(avctx, avpkt, 1 + p->order, 0))) {
         av_log(avctx, AV_LOG_ERROR, "Error getting output packet\n");
@@ -109,5 +109,5 @@ const FFCodec ff_comfortnoise_encoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
     .p.ch_layouts   = (const AVChannelLayout[]){ AV_CHANNEL_LAYOUT_MONO, { 0 } },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/codec.h b/libavcodec/codec.h
index 03e8be9..77a1a3f 100644
--- a/libavcodec/codec.h
+++ b/libavcodec/codec.h
@@ -182,6 +182,14 @@
  */
 #define AV_CODEC_CAP_ENCODER_FLUSH   (1 << 21)
 
+/**
+ * The encoder is able to output reconstructed frame data, i.e. raw frames that
+ * would be produced by decoding the encoded bitstream.
+ *
+ * Reconstructed frame output is enabled by the AV_CODEC_FLAG_RECON_FRAME flag.
+ */
+#define AV_CODEC_CAP_ENCODER_RECON_FRAME (1 << 22)
+
 /**
  * AVProfile.
  */
diff --git a/libavcodec/codec_desc.c b/libavcodec/codec_desc.c
index 44ad2d1..c1a177c 100644
--- a/libavcodec/codec_desc.c
+++ b/libavcodec/codec_desc.c
@@ -1893,6 +1893,20 @@ static const AVCodecDescriptor codec_descriptors[] = {
         .long_name = NULL_IF_CONFIG_SMALL("PHM (Portable HalfFloatMap) image"),
         .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
     },
+    {
+        .id        = AV_CODEC_ID_RADIANCE_HDR,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "hdr",
+        .long_name = NULL_IF_CONFIG_SMALL("HDR (Radiance RGBE format) image"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSY,
+    },
+    {
+        .id        = AV_CODEC_ID_WBMP,
+        .type      = AVMEDIA_TYPE_VIDEO,
+        .name      = "wbmp",
+        .long_name = NULL_IF_CONFIG_SMALL("WBMP (Wireless Application Protocol Bitmap) image"),
+        .props     = AV_CODEC_PROP_INTRA_ONLY | AV_CODEC_PROP_LOSSLESS,
+    },
 
     /* various PCM "codecs" */
     {
diff --git a/libavcodec/codec_id.h b/libavcodec/codec_id.h
index 81fb316..386a00a 100644
--- a/libavcodec/codec_id.h
+++ b/libavcodec/codec_id.h
@@ -312,6 +312,8 @@ enum AVCodecID {
     AV_CODEC_ID_JPEGXL,
     AV_CODEC_ID_QOI,
     AV_CODEC_ID_PHM,
+    AV_CODEC_ID_RADIANCE_HDR,
+    AV_CODEC_ID_WBMP,
 
     /* various PCM "codecs" */
     AV_CODEC_ID_FIRST_AUDIO = 0x10000,     ///< A dummy id pointing at the start of audio codecs
diff --git a/libavcodec/codec_internal.h b/libavcodec/codec_internal.h
index 5df286c..88bf5d4 100644
--- a/libavcodec/codec_internal.h
+++ b/libavcodec/codec_internal.h
@@ -25,10 +25,12 @@
 #include "codec.h"
 
 /**
- * The codec does not modify any global variables in the init function,
- * allowing to call the init function without locking any global mutexes.
+ * The codec is not known to be init-threadsafe (i.e. it might be unsafe
+ * to initialize this codec and another codec concurrently, typically because
+ * the codec calls external APIs that are not known to be thread-safe).
+ * Therefore calling the codec's init function needs to be guarded with a lock.
  */
-#define FF_CODEC_CAP_INIT_THREADSAFE        (1 << 0)
+#define FF_CODEC_CAP_NOT_INIT_THREADSAFE    (1 << 0)
 /**
  * The codec allows calling the close function for deallocation even if
  * the init function returned a failure. Without this capability flag, a
@@ -73,6 +75,14 @@
  * internal logic derive them from AVCodecInternal.last_pkt_props.
  */
 #define FF_CODEC_CAP_SETS_FRAME_PROPS       (1 << 8)
+/**
+ * Codec supports embedded ICC profiles (AV_FRAME_DATA_ICC_PROFILE).
+ */
+#define FF_CODEC_CAP_ICC_PROFILES           (1 << 9)
+/**
+ * The decoder requires contiguous buffers.
+ */
+#define FF_CODEC_CAP_CONTIGUOUS_BUFFERS     (1 << 28)
 
 /**
  * FFCodec.codec_tags termination value
diff --git a/libavcodec/cook.c b/libavcodec/cook.c
index 7161209..01005d3 100644
--- a/libavcodec/cook.c
+++ b/libavcodec/cook.c
@@ -1308,5 +1308,5 @@ const FFCodec ff_cook_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cpia.c b/libavcodec/cpia.c
index fcf2621..8b8c59f 100644
--- a/libavcodec/cpia.c
+++ b/libavcodec/cpia.c
@@ -232,5 +232,4 @@ const FFCodec ff_cpia_decoder = {
     .close          = cpia_decode_end,
     FF_CODEC_DECODE_CB(cpia_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/cri.c b/libavcodec/cri.c
index 7289837..2ac0457 100644
--- a/libavcodec/cri.c
+++ b/libavcodec/cri.c
@@ -432,6 +432,6 @@ const FFCodec ff_cri_decoder = {
     FF_CODEC_DECODE_CB(cri_decode_frame),
     .close          = cri_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.long_name    = NULL_IF_CONFIG_SMALL("Cintel RAW"),
 };
diff --git a/libavcodec/crystalhd.c b/libavcodec/crystalhd.c
index cf74f22..bdc2ecc 100644
--- a/libavcodec/crystalhd.c
+++ b/libavcodec/crystalhd.c
@@ -546,7 +546,7 @@ static inline CopyRet copy_frame(AVCodecContext *avctx,
     frame->pts = pkt_pts;
 
     frame->pkt_pos = -1;
-    frame->pkt_duration = 0;
+    frame->duration = 0;
     frame->pkt_size = -1;
 
     if (!priv->need_second_field) {
@@ -787,7 +787,8 @@ static int crystalhd_receive_frame(AVCodecContext *avctx, AVFrame *frame)
         .flush          = flush, \
         .bsfs           = bsf_name, \
         .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
-        .caps_internal  = FF_CODEC_CAP_SETS_FRAME_PROPS, \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
+                          FF_CODEC_CAP_SETS_FRAME_PROPS, \
         .p.pix_fmts     = (const enum AVPixelFormat[]){AV_PIX_FMT_YUYV422, AV_PIX_FMT_NONE}, \
         .p.wrapper_name = "crystalhd", \
     };
diff --git a/libavcodec/cscd.c b/libavcodec/cscd.c
index ea84711..64d29a9 100644
--- a/libavcodec/cscd.c
+++ b/libavcodec/cscd.c
@@ -177,5 +177,5 @@ const FFCodec ff_cscd_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/cuviddec.c b/libavcodec/cuviddec.c
index b544b33..82c40fc 100644
--- a/libavcodec/cuviddec.c
+++ b/libavcodec/cuviddec.c
@@ -624,7 +624,7 @@ static int cuvid_output_frame(AVCodecContext *avctx, AVFrame *frame)
          * So set pkt_pts and clear all the other pkt_ fields.
          */
         frame->pkt_pos = -1;
-        frame->pkt_duration = 0;
+        frame->duration = 0;
         frame->pkt_size = -1;
 
         frame->interlaced_frame = !parsed_frame.is_deinterlacing && !parsed_frame.dispinfo.progressive_frame;
@@ -1129,7 +1129,8 @@ static const AVCodecHWConfigInternal *const cuvid_hw_configs[] = {
         .flush          = cuvid_flush, \
         .bsfs           = bsf_name, \
         .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
-        .caps_internal  = FF_CODEC_CAP_SETS_FRAME_PROPS, \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
+                          FF_CODEC_CAP_SETS_FRAME_PROPS, \
         .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_CUDA, \
                                                         AV_PIX_FMT_NV12, \
                                                         AV_PIX_FMT_P010, \
diff --git a/libavcodec/cyuv.c b/libavcodec/cyuv.c
index 8fa4d1f..48846b5 100644
--- a/libavcodec/cyuv.c
+++ b/libavcodec/cyuv.c
@@ -186,7 +186,6 @@ const FFCodec ff_aura_decoder = {
     .init           = cyuv_decode_init,
     FF_CODEC_DECODE_CB(cyuv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -200,6 +199,5 @@ const FFCodec ff_cyuv_decoder = {
     .init           = cyuv_decode_init,
     FF_CODEC_DECODE_CB(cyuv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/dcadec.c b/libavcodec/dcadec.c
index 498e0c8..46d3650 100644
--- a/libavcodec/dcadec.c
+++ b/libavcodec/dcadec.c
@@ -425,5 +425,5 @@ const FFCodec ff_dca_decoder = {
                                                       AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE },
     .p.priv_class   = &dcadec_class,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_dca_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/dcaenc.c b/libavcodec/dcaenc.c
index aad06ad..2481c4d 100644
--- a/libavcodec/dcaenc.c
+++ b/libavcodec/dcaenc.c
@@ -1250,7 +1250,7 @@ const FFCodec ff_dca_encoder = {
     .init                  = encode_init,
     .close                 = encode_close,
     FF_CODEC_ENCODE_CB(encode_frame),
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP,
     .p.sample_fmts         = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S32,
                                                             AV_SAMPLE_FMT_NONE },
     .p.supported_samplerates = sample_rates,
diff --git a/libavcodec/dds.c b/libavcodec/dds.c
index 30788f1..1e39011 100644
--- a/libavcodec/dds.c
+++ b/libavcodec/dds.c
@@ -717,5 +717,4 @@ const FFCodec ff_dds_decoder = {
     FF_CODEC_DECODE_CB(dds_decode),
     .priv_data_size = sizeof(DDSContext),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE
 };
diff --git a/libavcodec/decode.c b/libavcodec/decode.c
index 1893caa..7537398 100644
--- a/libavcodec/decode.c
+++ b/libavcodec/decode.c
@@ -359,7 +359,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
         side= av_packet_get_side_data(avci->last_pkt_props, AV_PKT_DATA_SKIP_SAMPLES, &side_size);
         if(side && side_size>=10) {
-            avci->skip_samples = AV_RL32(side) * avci->skip_samples_multiplier;
+            avci->skip_samples = AV_RL32(side);
             avci->skip_samples = FFMAX(0, avci->skip_samples);
             discard_padding = AV_RL32(side + 4);
             av_log(avctx, AV_LOG_DEBUG, "skip %d / discard %d samples due to side data\n",
@@ -394,8 +394,8 @@ FF_ENABLE_DEPRECATION_WARNINGS
                         frame->pts += diff_ts;
                     if(frame->pkt_dts!=AV_NOPTS_VALUE)
                         frame->pkt_dts += diff_ts;
-                    if (frame->pkt_duration >= diff_ts)
-                        frame->pkt_duration -= diff_ts;
+                    if (frame->duration >= diff_ts)
+                        frame->duration -= diff_ts;
                 } else {
                     av_log(avctx, AV_LOG_WARNING, "Could not update timestamps for skipped samples.\n");
                 }
@@ -417,7 +417,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
                     int64_t diff_ts = av_rescale_q(frame->nb_samples - discard_padding,
                                                    (AVRational){1, avctx->sample_rate},
                                                    avctx->pkt_timebase);
-                    frame->pkt_duration = diff_ts;
+                    frame->duration = diff_ts;
                 } else {
                     av_log(avctx, AV_LOG_WARNING, "Could not update timestamps for discarded samples.\n");
                 }
@@ -504,6 +504,54 @@ FF_ENABLE_DEPRECATION_WARNINGS
     return ret < 0 ? ret : 0;
 }
 
+#if CONFIG_LCMS2
+static int detect_colorspace(AVCodecContext *avctx, AVFrame *frame)
+{
+    AVCodecInternal *avci = avctx->internal;
+    enum AVColorTransferCharacteristic trc;
+    AVColorPrimariesDesc coeffs;
+    enum AVColorPrimaries prim;
+    cmsHPROFILE profile;
+    AVFrameSideData *sd;
+    int ret;
+    if (!(avctx->flags2 & AV_CODEC_FLAG2_ICC_PROFILES))
+        return 0;
+
+    sd = av_frame_get_side_data(frame, AV_FRAME_DATA_ICC_PROFILE);
+    if (!sd || !sd->size)
+        return 0;
+
+    if (!avci->icc.avctx) {
+        ret = ff_icc_context_init(&avci->icc, avctx);
+        if (ret < 0)
+            return ret;
+    }
+
+    profile = cmsOpenProfileFromMemTHR(avci->icc.ctx, sd->data, sd->size);
+    if (!profile)
+        return AVERROR_INVALIDDATA;
+
+    ret = ff_icc_profile_read_primaries(&avci->icc, profile, &coeffs);
+    if (!ret)
+        ret = ff_icc_profile_detect_transfer(&avci->icc, profile, &trc);
+    cmsCloseProfile(profile);
+    if (ret < 0)
+        return ret;
+
+    prim = av_csp_primaries_id_from_desc(&coeffs);
+    if (prim != AVCOL_PRI_UNSPECIFIED)
+        frame->color_primaries = prim;
+    if (trc != AVCOL_TRC_UNSPECIFIED)
+        frame->color_trc = trc;
+    return 0;
+}
+#else /* !CONFIG_LCMS2 */
+static int detect_colorspace(av_unused AVCodecContext *c, av_unused AVFrame *f)
+{
+    return 0;
+}
+#endif
+
 static int decode_simple_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
     int ret;
@@ -524,7 +572,7 @@ static int decode_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
 {
     AVCodecInternal *avci = avctx->internal;
     const FFCodec *const codec = ffcodec(avctx->codec);
-    int ret;
+    int ret, ok;
 
     av_assert0(!frame->buf[0]);
 
@@ -538,6 +586,13 @@ static int decode_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
     if (ret == AVERROR_EOF)
         avci->draining_done = 1;
 
+    /* preserve ret */
+    ok = detect_colorspace(avctx, frame);
+    if (ok < 0) {
+        av_frame_unref(frame);
+        return ok;
+    }
+
     if (!(codec->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS) &&
         IS_EMPTY(avci->last_pkt_props)) {
         // May fail if the FIFO is empty.
@@ -549,6 +604,12 @@ static int decode_receive_frame_internal(AVCodecContext *avctx, AVFrame *frame)
                                                          frame->pts,
                                                          frame->pkt_dts);
 
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+        frame->pkt_duration = frame->duration;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
         /* the only case where decode data is not set should be decoders
          * that do not call ff_get_buffer() */
         av_assert0((frame->private_ref && frame->private_ref->size == sizeof(FrameDecodeData)) ||
@@ -636,13 +697,11 @@ static int apply_cropping(AVCodecContext *avctx, AVFrame *frame)
                                           AV_FRAME_CROP_UNALIGNED : 0);
 }
 
-int attribute_align_arg avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+int ff_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
     AVCodecInternal *avci = avctx->internal;
     int ret, changed;
 
-    av_frame_unref(frame);
-
     if (!avcodec_is_open(avctx) || !av_codec_is_decoder(avctx->codec))
         return AVERROR(EINVAL);
 
@@ -1267,7 +1326,7 @@ int ff_decode_frame_props(AVCodecContext *avctx, AVFrame *frame)
     if (!(ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_SETS_FRAME_PROPS)) {
         frame->pts = pkt->pts;
         frame->pkt_pos      = pkt->pos;
-        frame->pkt_duration = pkt->duration;
+        frame->duration     = pkt->duration;
         frame->pkt_size     = pkt->size;
 
         for (int i = 0; i < FF_ARRAY_ELEMS(sd); i++) {
diff --git a/libavcodec/decode.h b/libavcodec/decode.h
index 1b40f71..f7828fb 100644
--- a/libavcodec/decode.h
+++ b/libavcodec/decode.h
@@ -53,6 +53,11 @@ typedef struct FrameDecodeData {
     void (*hwaccel_priv_free)(void *priv);
 } FrameDecodeData;
 
+/**
+ * avcodec_receive_frame() implementation for decoders.
+ */
+int ff_decode_receive_frame(AVCodecContext *avctx, AVFrame *frame);
+
 /**
  * Called by decoders to get the next packet for decoding.
  *
diff --git a/libavcodec/dfa.c b/libavcodec/dfa.c
index 057dfff..0996bf5 100644
--- a/libavcodec/dfa.c
+++ b/libavcodec/dfa.c
@@ -431,5 +431,4 @@ const FFCodec ff_dfa_decoder = {
     .close          = dfa_decode_end,
     FF_CODEC_DECODE_CB(dfa_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dfpwmdec.c b/libavcodec/dfpwmdec.c
index d013d4c..c036f8e 100644
--- a/libavcodec/dfpwmdec.c
+++ b/libavcodec/dfpwmdec.c
@@ -134,5 +134,4 @@ const FFCodec ff_dfpwm_decoder = {
     .init           = dfpwm_dec_init,
     FF_CODEC_DECODE_CB(dfpwm_dec_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dfpwmenc.c b/libavcodec/dfpwmenc.c
index 85ee1a9..41ad645 100644
--- a/libavcodec/dfpwmenc.c
+++ b/libavcodec/dfpwmenc.c
@@ -39,7 +39,7 @@ typedef struct {
 // Licensed in the public domain
 
 // note, len denotes how many compressed bytes there are (uncompressed bytes / 8).
-static void au_compress(DFPWMState *state, int len, uint8_t *outbuf, uint8_t *inbuf)
+static void au_compress(DFPWMState *state, int len, uint8_t *outbuf, const uint8_t *inbuf)
 {
     unsigned d = 0;
     for (int i = 0; i < len; i++) {
@@ -117,5 +117,4 @@ const FFCodec ff_dfpwm_encoder = {
     FF_CODEC_ENCODE_CB(dfpwm_enc_frame),
     .p.sample_fmts   = (const enum AVSampleFormat[]){AV_SAMPLE_FMT_U8, AV_SAMPLE_FMT_NONE},
     .p.capabilities  = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_VARIABLE_FRAME_SIZE,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/diracdec.c b/libavcodec/diracdec.c
index 50d1d2e..aef6ab2 100644
--- a/libavcodec/diracdec.c
+++ b/libavcodec/diracdec.c
@@ -486,7 +486,7 @@ UNPACK_ARITH(10, int32_t)
  * Decode the coeffs in the rectangle defined by left, right, top, bottom
  * [DIRAC_STD] 13.4.3.2 Codeblock unpacking loop. codeblock()
  */
-static inline int codeblock(DiracContext *s, SubBand *b,
+static inline int codeblock(const DiracContext *s, SubBand *b,
                              GetBitContext *gb, DiracArith *c,
                              int left, int right, int top, int bottom,
                              int blockcnt_one, int is_arith)
@@ -596,7 +596,8 @@ INTRA_DC_PRED(10, uint32_t)
  * Dirac Specification ->
  * 13.4.2 Non-skipped subbands.  subband_coeffs()
  */
-static av_always_inline int decode_subband_internal(DiracContext *s, SubBand *b, int is_arith)
+static av_always_inline int decode_subband_internal(const DiracContext *s,
+                                                    SubBand *b, int is_arith)
 {
     int cb_x, cb_y, left, right, top, bottom;
     DiracArith c;
@@ -640,13 +641,13 @@ static av_always_inline int decode_subband_internal(DiracContext *s, SubBand *b,
 
 static int decode_subband_arith(AVCodecContext *avctx, void *b)
 {
-    DiracContext *s = avctx->priv_data;
+    const DiracContext *s = avctx->priv_data;
     return decode_subband_internal(s, b, 1);
 }
 
 static int decode_subband_golomb(AVCodecContext *avctx, void *arg)
 {
-    DiracContext *s = avctx->priv_data;
+    const DiracContext *s = avctx->priv_data;
     SubBand **b     = arg;
     return decode_subband_internal(s, *b, 0);
 }
@@ -721,9 +722,9 @@ static int decode_component(DiracContext *s, int comp)
             return; \
     } \
 
-static void decode_subband(DiracContext *s, GetBitContext *gb, int quant,
+static void decode_subband(const DiracContext *s, GetBitContext *gb, int quant,
                            int slice_x, int slice_y, int bits_end,
-                           SubBand *b1, SubBand *b2)
+                           const SubBand *b1, const SubBand *b2)
 {
     int left   = b1->width  * slice_x    / s->num_x;
     int right  = b1->width  *(slice_x+1) / s->num_x;
@@ -775,7 +776,7 @@ static void decode_subband(DiracContext *s, GetBitContext *gb, int quant,
  */
 static int decode_lowdelay_slice(AVCodecContext *avctx, void *arg)
 {
-    DiracContext *s = avctx->priv_data;
+    const DiracContext *s = avctx->priv_data;
     DiracSlice *slice = arg;
     GetBitContext *gb = &slice->gb;
     enum dirac_subband orientation;
@@ -819,13 +820,13 @@ typedef struct SliceCoeffs {
     int tot;
 } SliceCoeffs;
 
-static int subband_coeffs(DiracContext *s, int x, int y, int p,
+static int subband_coeffs(const DiracContext *s, int x, int y, int p,
                           SliceCoeffs c[MAX_DWT_LEVELS])
 {
     int level, coef = 0;
     for (level = 0; level < s->wavelet_depth; level++) {
         SliceCoeffs *o = &c[level];
-        SubBand *b = &s->plane[p].band[level][3]; /* orientation doens't matter */
+        const SubBand *b = &s->plane[p].band[level][3]; /* orientation doens't matter */
         o->top   = b->height * y / s->num_y;
         o->left  = b->width  * x / s->num_x;
         o->tot_h = ((b->width  * (x + 1)) / s->num_x) - o->left;
@@ -840,7 +841,7 @@ static int subband_coeffs(DiracContext *s, int x, int y, int p,
  * VC-2 Specification ->
  * 13.5.3 hq_slice(sx,sy)
  */
-static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf)
+static int decode_hq_slice(const DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf)
 {
     int i, level, orientation, quant_idx;
     int qfactor[MAX_DWT_LEVELS][4], qoffset[MAX_DWT_LEVELS][4];
@@ -917,7 +918,7 @@ static int decode_hq_slice(DiracContext *s, DiracSlice *slice, uint8_t *tmp_buf)
 static int decode_hq_slice_row(AVCodecContext *avctx, void *arg, int jobnr, int threadnr)
 {
     int i;
-    DiracContext *s = avctx->priv_data;
+    const DiracContext *s = avctx->priv_data;
     DiracSlice *slices = ((DiracSlice *)arg) + s->num_x*jobnr;
     uint8_t *thread_buf = &s->thread_buf[s->thread_buf_size*threadnr];
     for (i = 0; i < s->num_x; i++)
@@ -2366,6 +2367,5 @@ const FFCodec ff_dirac_decoder = {
     .close          = dirac_decode_end,
     FF_CODEC_DECODE_CB(dirac_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .flush          = dirac_decode_flush,
 };
diff --git a/libavcodec/diracdsp.c b/libavcodec/diracdsp.c
index aafdddc..284f914 100644
--- a/libavcodec/diracdsp.c
+++ b/libavcodec/diracdsp.c
@@ -139,7 +139,7 @@ ADD_OBMC(32)
 static void put_signed_rect_clamped_8bit_c(uint8_t *dst, int dst_stride, const uint8_t *_src, int src_stride, int width, int height)
 {
     int x, y;
-    int16_t *src = (int16_t *)_src;
+    const int16_t *src = (const int16_t *)_src;
     for (y = 0; y < height; y++) {
         for (x = 0; x < width; x+=4) {
             dst[x  ] = av_clip_uint8(src[x  ] + 128);
@@ -158,7 +158,7 @@ static void put_signed_rect_clamped_ ## PX ## bit_c(uint8_t *_dst, int dst_strid
 {                                                                                                       \
     int x, y;                                                                                           \
     uint16_t *dst = (uint16_t *)_dst;                                                                   \
-    int32_t *src = (int32_t *)_src;                                                                     \
+    const int32_t *src = (const int32_t *)_src;                                                         \
     for (y = 0; y < height; y++) {                                                                      \
         for (x = 0; x < width; x+=4) {                                                                  \
             dst[x  ] = av_clip_uintp2(src[x  ] + (1U << (PX - 1)), PX);                                  \
diff --git a/libavcodec/dnxhddec.c b/libavcodec/dnxhddec.c
index 65cd6d9..8b6c473 100644
--- a/libavcodec/dnxhddec.c
+++ b/libavcodec/dnxhddec.c
@@ -736,5 +736,4 @@ const FFCodec ff_dnxhd_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
                       AV_CODEC_CAP_SLICE_THREADS,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_dnxhd_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dnxhdenc.c b/libavcodec/dnxhdenc.c
index 481793c..5029e51 100644
--- a/libavcodec/dnxhdenc.c
+++ b/libavcodec/dnxhdenc.c
@@ -944,7 +944,7 @@ static int dnxhd_mb_var_thread(AVCodecContext *avctx, void *arg,
 
     ctx = ctx->thread[threadnr];
     if (ctx->bit_depth == 8) {
-        uint8_t *pix = ctx->thread[0]->src[0] + ((mb_y << 4) * ctx->m.linesize);
+        const uint8_t *pix = ctx->thread[0]->src[0] + ((mb_y << 4) * ctx->m.linesize);
         for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x, pix += 16) {
             unsigned mb = mb_y * ctx->m.mb_width + mb_x;
             int sum;
@@ -973,8 +973,8 @@ static int dnxhd_mb_var_thread(AVCodecContext *avctx, void *arg,
     } else { // 10-bit
         const int linesize = ctx->m.linesize >> 1;
         for (mb_x = 0; mb_x < ctx->m.mb_width; ++mb_x) {
-            uint16_t *pix = (uint16_t *)ctx->thread[0]->src[0] +
-                            ((mb_y << 4) * linesize) + (mb_x << 4);
+            const uint16_t *pix = (const uint16_t *)ctx->thread[0]->src[0] +
+                                     ((mb_y << 4) * linesize) + (mb_x << 4);
             unsigned mb  = mb_y * ctx->m.mb_width + mb_x;
             int sum = 0;
             int sqsum = 0;
@@ -1374,5 +1374,5 @@ const FFCodec ff_dnxhd_encoder = {
     .p.priv_class   = &dnxhd_class,
     .defaults       = dnxhd_defaults,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_dnxhd_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/dnxhdenc.h b/libavcodec/dnxhdenc.h
index 7726a39..e581312 100644
--- a/libavcodec/dnxhdenc.h
+++ b/libavcodec/dnxhdenc.h
@@ -86,7 +86,7 @@ typedef struct DNXHDEncContext {
     uint16_t (*qmatrix_c16)[2][64];
 
     unsigned frame_bits;
-    uint8_t *src[3];
+    const uint8_t *src[3];
 
     uint32_t *orig_vlc_codes;
     uint8_t  *orig_vlc_bits;
diff --git a/libavcodec/dolby_e.c b/libavcodec/dolby_e.c
index a734af8..e6a2624 100644
--- a/libavcodec/dolby_e.c
+++ b/libavcodec/dolby_e.c
@@ -1310,5 +1310,5 @@ const FFCodec ff_dolby_e_decoder = {
     .flush          = dolby_e_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP, AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/dpcm.c b/libavcodec/dpcm.c
index ad020b5..e360045 100644
--- a/libavcodec/dpcm.c
+++ b/libavcodec/dpcm.c
@@ -419,7 +419,6 @@ const FFCodec ff_ ## name_ ## _decoder = {                  \
     .priv_data_size = sizeof(DPCMContext),                  \
     .init           = dpcm_decode_init,                     \
     FF_CODEC_DECODE_CB(dpcm_decode_frame),                  \
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,         \
 }
 
 DPCM_DECODER(AV_CODEC_ID_DERF_DPCM,      derf_dpcm,      "DPCM Xilam DERF");
diff --git a/libavcodec/dpxenc.c b/libavcodec/dpxenc.c
index 1f2b1b8..c261d05 100644
--- a/libavcodec/dpxenc.c
+++ b/libavcodec/dpxenc.c
@@ -292,5 +292,4 @@ const FFCodec ff_dpx_encoder = {
         AV_PIX_FMT_GBRP10LE, AV_PIX_FMT_GBRP10BE,
         AV_PIX_FMT_GBRP12LE, AV_PIX_FMT_GBRP12BE,
         AV_PIX_FMT_NONE},
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dsddec.c b/libavcodec/dsddec.c
index f0e54db..d724e42 100644
--- a/libavcodec/dsddec.c
+++ b/libavcodec/dsddec.c
@@ -125,7 +125,6 @@ const FFCodec ff_ ## name_ ## _decoder = { \
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS, \
     .p.sample_fmts = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLTP, \
                                                    AV_SAMPLE_FMT_NONE }, \
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE, \
 };
 
 DSD_DECODER(DSD_LSBF, dsd_lsbf, "DSD (Direct Stream Digital), least significant bit first")
diff --git a/libavcodec/dsicinaudio.c b/libavcodec/dsicinaudio.c
index 2cfaebc..8be4350 100644
--- a/libavcodec/dsicinaudio.c
+++ b/libavcodec/dsicinaudio.c
@@ -130,5 +130,4 @@ const FFCodec ff_dsicinaudio_decoder = {
     .init           = cinaudio_decode_init,
     FF_CODEC_DECODE_CB(cinaudio_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dsicinvideo.c b/libavcodec/dsicinvideo.c
index 71f6071..e8d79bf 100644
--- a/libavcodec/dsicinvideo.c
+++ b/libavcodec/dsicinvideo.c
@@ -330,6 +330,6 @@ const FFCodec ff_dsicinvideo_decoder = {
     .init           = cinvideo_decode_init,
     .close          = cinvideo_decode_end,
     FF_CODEC_DECODE_CB(cinvideo_decode_frame),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.capabilities = AV_CODEC_CAP_DR1,
 };
diff --git a/libavcodec/dss_sp.c b/libavcodec/dss_sp.c
index b465bfe..d2f71a4 100644
--- a/libavcodec/dss_sp.c
+++ b/libavcodec/dss_sp.c
@@ -781,5 +781,4 @@ const FFCodec ff_dss_sp_decoder = {
     .init           = dss_sp_decode_init,
     FF_CODEC_DECODE_CB(dss_sp_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dstdec.c b/libavcodec/dstdec.c
index ba6651b..9ad763a 100644
--- a/libavcodec/dstdec.c
+++ b/libavcodec/dstdec.c
@@ -216,7 +216,7 @@ static uint8_t prob_dst_x_bit(int c)
     return (ff_reverse[c & 127] >> 1) + 1;
 }
 
-static int build_filter(int16_t table[DST_MAX_ELEMENTS][16][256], const Table *fsets)
+static void build_filter(int16_t table[DST_MAX_ELEMENTS][16][256], const Table *fsets)
 {
     int i, j, k, l;
 
@@ -227,17 +227,14 @@ static int build_filter(int16_t table[DST_MAX_ELEMENTS][16][256], const Table *f
             int total = av_clip(length - j * 8, 0, 8);
 
             for (k = 0; k < 256; k++) {
-                int64_t v = 0;
+                int v = 0;
 
                 for (l = 0; l < total; l++)
                     v += (((k >> l) & 1) * 2 - 1) * fsets->coeff[i][j * 8 + l];
-                if ((int16_t)v != v)
-                    return AVERROR_INVALIDDATA;
                 table[i][j][k] = v;
             }
         }
     }
-    return 0;
 }
 
 static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
@@ -332,9 +329,7 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
         return AVERROR_INVALIDDATA;
     ac_init(ac, gb);
 
-    ret = build_filter(s->filter, &s->fsets);
-    if (ret < 0)
-        return ret;
+    build_filter(s->filter, &s->fsets);
 
     memset(s->status, 0xAA, sizeof(s->status));
     memset(dsd, 0, frame->nb_samples * 4 * channels);
@@ -395,5 +390,4 @@ const FFCodec ff_dst_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLT,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dv.h b/libavcodec/dv.h
index 855afcc..331b8e8 100644
--- a/libavcodec/dv.h
+++ b/libavcodec/dv.h
@@ -109,8 +109,8 @@ static inline int dv_work_pool_size(const AVDVProfile *d)
     return size;
 }
 
-static inline void dv_calculate_mb_xy(DVVideoContext *s,
-                                      DVwork_chunk *work_chunk,
+static inline void dv_calculate_mb_xy(const DVVideoContext *s,
+                                      const DVwork_chunk *work_chunk,
                                       int m, int *mb_x, int *mb_y)
 {
     *mb_x = work_chunk->mb_coordinates[m] & 0xff;
diff --git a/libavcodec/dvaudiodec.c b/libavcodec/dvaudiodec.c
index 56d9c35..d65fc46 100644
--- a/libavcodec/dvaudiodec.c
+++ b/libavcodec/dvaudiodec.c
@@ -127,5 +127,4 @@ const FFCodec ff_dvaudio_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .priv_data_size = sizeof(DVAudioContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dvbsubdec.c b/libavcodec/dvbsubdec.c
index 4d4007f..90c0625 100644
--- a/libavcodec/dvbsubdec.c
+++ b/libavcodec/dvbsubdec.c
@@ -1579,5 +1579,4 @@ const FFCodec ff_dvbsub_decoder = {
     .close          = dvbsub_close_decoder,
     FF_CODEC_DECODE_SUB_CB(dvbsub_decode),
     .p.priv_class   = &dvbsubdec_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dvdec.c b/libavcodec/dvdec.c
index d6f0730..f742358 100644
--- a/libavcodec/dvdec.c
+++ b/libavcodec/dvdec.c
@@ -345,7 +345,7 @@ static av_always_inline void put_block_8x4(int16_t *block, uint8_t *av_restrict
     }
 }
 
-static void dv100_idct_put_last_row_field_chroma(DVVideoContext *s, uint8_t *data,
+static void dv100_idct_put_last_row_field_chroma(const DVVideoContext *s, uint8_t *data,
                                                  int stride, int16_t *blocks)
 {
     s->idsp.idct(blocks + 0*64);
@@ -357,7 +357,7 @@ static void dv100_idct_put_last_row_field_chroma(DVVideoContext *s, uint8_t *dat
     put_block_8x4(blocks+1*64 + 4*8, data + 8 + stride, stride<<1);
 }
 
-static void dv100_idct_put_last_row_field_luma(DVVideoContext *s, uint8_t *data,
+static void dv100_idct_put_last_row_field_luma(const DVVideoContext *s, uint8_t *data,
                                                int stride, int16_t *blocks)
 {
     s->idsp.idct(blocks + 0*64);
@@ -378,7 +378,7 @@ static void dv100_idct_put_last_row_field_luma(DVVideoContext *s, uint8_t *data,
 /* mb_x and mb_y are in units of 8 pixels */
 static int dv_decode_video_segment(AVCodecContext *avctx, void *arg)
 {
-    DVVideoContext *s = avctx->priv_data;
+    const DVVideoContext *s = avctx->priv_data;
     DVwork_chunk *work_chunk = arg;
     int quant, dc, dct_mode, class1, j;
     int mb_index, mb_x, mb_y, last_index;
@@ -691,5 +691,4 @@ const FFCodec ff_dvvideo_decoder = {
     FF_CODEC_DECODE_CB(dvvideo_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS,
     .p.max_lowres   = 3,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dvdsubdec.c b/libavcodec/dvdsubdec.c
index 97f366c..7fa3363 100644
--- a/libavcodec/dvdsubdec.c
+++ b/libavcodec/dvdsubdec.c
@@ -715,5 +715,4 @@ const FFCodec ff_dvdsub_decoder = {
     FF_CODEC_DECODE_SUB_CB(dvdsub_decode),
     .flush          = dvdsub_flush,
     .p.priv_class   = &dvdsub_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dvdsubenc.c b/libavcodec/dvdsubenc.c
index d29db7d..3fe50ae 100644
--- a/libavcodec/dvdsubenc.c
+++ b/libavcodec/dvdsubenc.c
@@ -509,5 +509,4 @@ const FFCodec ff_dvdsub_encoder = {
     FF_CODEC_ENCODE_SUB_CB(dvdsub_encode),
     .p.priv_class   = &dvdsubenc_class,
     .priv_data_size = sizeof(DVDSubtitleContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dvenc.c b/libavcodec/dvenc.c
index 2922829..5ba4de3 100644
--- a/libavcodec/dvenc.c
+++ b/libavcodec/dvenc.c
@@ -217,7 +217,7 @@ static av_always_inline PutBitContext *dv_encode_ac(EncBlockInfo *bi,
     return pb;
 }
 
-static av_always_inline int dv_guess_dct_mode(DVVideoContext *s, uint8_t *data,
+static av_always_inline int dv_guess_dct_mode(DVVideoContext *s, const uint8_t *data,
                                               ptrdiff_t linesize)
 {
     if (s->avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {
@@ -506,7 +506,7 @@ static inline void dv_set_class_number_hd(DVVideoContext *s,
     bi->cno = 0;
 }
 
-static av_always_inline int dv_init_enc_block(EncBlockInfo* bi, uint8_t *data, int linesize,
+static av_always_inline int dv_init_enc_block(EncBlockInfo* bi, const uint8_t *data, int linesize,
                                               DVVideoContext *s, int chroma)
 {
     LOCAL_ALIGNED_16(int16_t, blk, [64]);
@@ -849,7 +849,7 @@ static int dv_encode_video_segment(AVCodecContext *avctx, void *arg)
     int mb_index, i, j;
     int mb_x, mb_y, c_offset;
     ptrdiff_t linesize, y_stride;
-    uint8_t *y_ptr;
+    const uint8_t *y_ptr;
     uint8_t *dif, *p;
     LOCAL_ALIGNED_8(uint8_t, scratch, [128]);
     EncBlockInfo enc_blks[5 * DV_MAX_BPM];
@@ -908,14 +908,13 @@ static int dv_encode_video_segment(AVCodecContext *avctx, void *arg)
         c_offset = ((mb_y >>  (s->sys->pix_fmt == AV_PIX_FMT_YUV420P)) * s->frame->linesize[1] +
                     (mb_x >> ((s->sys->pix_fmt == AV_PIX_FMT_YUV411P) ? 2 : 1))) * 8;
         for (j = 2; j; j--) {
-            uint8_t *c_ptr = s->frame->data[j] + c_offset;
+            const uint8_t *c_ptr = s->frame->data[j] + c_offset;
             linesize = s->frame->linesize[j];
             y_stride = (mb_y == 134) ? 8 : (s->frame->linesize[j] * (1 << (3*!enc_blk->dct_mode)));
             if (s->sys->pix_fmt == AV_PIX_FMT_YUV411P && mb_x >= (704 / 8)) {
-                uint8_t *d;
                 uint8_t *b = scratch;
                 for (i = 0; i < 8; i++) {
-                    d      = c_ptr + linesize * 8;
+                    const uint8_t *d = c_ptr + linesize * 8;
                     b[0]   = c_ptr[0];
                     b[1]   = c_ptr[1];
                     b[2]   = c_ptr[2];
@@ -1221,5 +1220,4 @@ const FFCodec ff_dvvideo_encoder = {
         AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE
     },
     .p.priv_class   = &dvvideo_encode_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/dxa.c b/libavcodec/dxa.c
index 93a1724..fa633cd 100644
--- a/libavcodec/dxa.c
+++ b/libavcodec/dxa.c
@@ -371,5 +371,5 @@ const FFCodec ff_dxa_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/dxv.c b/libavcodec/dxv.c
index d75f8b0..13c028d 100644
--- a/libavcodec/dxv.c
+++ b/libavcodec/dxv.c
@@ -193,7 +193,7 @@ static int yao_block(uint8_t *plane0, ptrdiff_t stride0,
 static int decompress_texture_thread(AVCodecContext *avctx, void *arg,
                                      int slice, int thread_nb)
 {
-    DXVContext *ctx = avctx->priv_data;
+    const DXVContext *ctx = avctx->priv_data;
     AVFrame *frame = arg;
     const uint8_t *d = ctx->tex_data;
     int w_block = avctx->coded_width / ctx->texture_block_w;
@@ -432,7 +432,7 @@ static int get_opcodes(GetByteContext *gb, uint32_t *table, uint8_t *dst, int op
     int64_t size_in_bits;
     unsigned endoffset, newoffset, offset;
     unsigned next;
-    uint8_t *src = (uint8_t *)gb->buffer;
+    const uint8_t *src = gb->buffer;
 
     ret = fill_optable(table, optable, nb_elements);
     if (ret < 0)
@@ -1272,6 +1272,5 @@ const FFCodec ff_dxv_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 |
                       AV_CODEC_CAP_SLICE_THREADS |
                       AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/eac3enc.c b/libavcodec/eac3enc.c
index 79611ce..9f87044 100644
--- a/libavcodec/eac3enc.c
+++ b/libavcodec/eac3enc.c
@@ -269,6 +269,6 @@ const FFCodec ff_eac3_encoder = {
 #endif
     .p.ch_layouts    = ff_ac3_ch_layouts,
     .defaults        = ff_ac3_enc_defaults,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 };
 FF_ENABLE_DEPRECATION_WARNINGS
diff --git a/libavcodec/eacmv.c b/libavcodec/eacmv.c
index 0a13a74..b05d0f3 100644
--- a/libavcodec/eacmv.c
+++ b/libavcodec/eacmv.c
@@ -239,5 +239,5 @@ const FFCodec ff_eacmv_decoder = {
     .close          = cmv_decode_end,
     FF_CODEC_DECODE_CB(cmv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/eamad.c b/libavcodec/eamad.c
index 337a9c1..ce74bf0 100644
--- a/libavcodec/eamad.c
+++ b/libavcodec/eamad.c
@@ -350,5 +350,4 @@ const FFCodec ff_eamad_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/eatgq.c b/libavcodec/eatgq.c
index 2e9d2fe..a28cc52 100644
--- a/libavcodec/eatgq.c
+++ b/libavcodec/eatgq.c
@@ -255,5 +255,4 @@ const FFCodec ff_eatgq_decoder = {
     .init           = tgq_decode_init,
     FF_CODEC_DECODE_CB(tgq_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/eatgv.c b/libavcodec/eatgv.c
index 23cf730..a6af789 100644
--- a/libavcodec/eatgv.c
+++ b/libavcodec/eatgv.c
@@ -368,5 +368,4 @@ const FFCodec ff_eatgv_decoder = {
     .close          = tgv_decode_end,
     FF_CODEC_DECODE_CB(tgv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/eatqi.c b/libavcodec/eatqi.c
index 305ea4b..a19202a 100644
--- a/libavcodec/eatqi.c
+++ b/libavcodec/eatqi.c
@@ -191,5 +191,4 @@ const FFCodec ff_eatqi_decoder = {
     .close          = tqi_decode_end,
     FF_CODEC_DECODE_CB(tqi_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/encode.c b/libavcodec/encode.c
index 1f39ab1..bd66f13 100644
--- a/libavcodec/encode.c
+++ b/libavcodec/encode.c
@@ -308,6 +308,53 @@ static int encode_receive_packet_internal(AVCodecContext *avctx, AVPacket *avpkt
     return ret;
 }
 
+#if CONFIG_LCMS2
+static int encode_generate_icc_profile(AVCodecContext *avctx, AVFrame *frame)
+{
+    enum AVColorTransferCharacteristic trc = frame->color_trc;
+    enum AVColorPrimaries prim = frame->color_primaries;
+    const FFCodec *const codec = ffcodec(avctx->codec);
+    AVCodecInternal *avci = avctx->internal;
+    cmsHPROFILE profile;
+    int ret;
+
+    /* don't generate ICC profiles if disabled or unsupported */
+    if (!(avctx->flags2 & AV_CODEC_FLAG2_ICC_PROFILES))
+        return 0;
+    if (!(codec->caps_internal & FF_CODEC_CAP_ICC_PROFILES))
+        return 0;
+
+    if (trc == AVCOL_TRC_UNSPECIFIED)
+        trc = avctx->color_trc;
+    if (prim == AVCOL_PRI_UNSPECIFIED)
+        prim = avctx->color_primaries;
+    if (trc == AVCOL_TRC_UNSPECIFIED || prim == AVCOL_PRI_UNSPECIFIED)
+        return 0; /* can't generate ICC profile with missing csp tags */
+
+    if (av_frame_get_side_data(frame, AV_FRAME_DATA_ICC_PROFILE))
+        return 0; /* don't overwrite existing ICC profile */
+
+    if (!avci->icc.avctx) {
+        ret = ff_icc_context_init(&avci->icc, avctx);
+        if (ret < 0)
+            return ret;
+    }
+
+    ret = ff_icc_profile_generate(&avci->icc, prim, trc, &profile);
+    if (ret < 0)
+        return ret;
+
+    ret = ff_icc_profile_attach(&avci->icc, profile, frame);
+    cmsCloseProfile(profile);
+    return ret;
+}
+#else /* !CONFIG_LCMS2 */
+static int encode_generate_icc_profile(av_unused AVCodecContext *c, av_unused AVFrame *f)
+{
+    return 0;
+}
+#endif
+
 static int encode_send_frame_internal(AVCodecContext *avctx, const AVFrame *src)
 {
     AVCodecInternal *avci = avctx->internal;
@@ -339,7 +386,7 @@ static int encode_send_frame_internal(AVCodecContext *avctx, const AVFrame *src)
                     return ret;
 
                 avctx->internal->last_audio_frame = 1;
-                return 0;
+                goto finish;
             } else if (src->nb_samples > avctx->frame_size) {
                 av_log(avctx, AV_LOG_ERROR, "nb_samples (%d) != frame_size (%d)\n", src->nb_samples, avctx->frame_size);
                 return AVERROR(EINVAL);
@@ -351,6 +398,21 @@ static int encode_send_frame_internal(AVCodecContext *avctx, const AVFrame *src)
     if (ret < 0)
         return ret;
 
+finish:
+
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (dst->pkt_duration && dst->pkt_duration != dst->duration)
+        dst->duration = dst->pkt_duration;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
+    if (avctx->codec->type == AVMEDIA_TYPE_VIDEO) {
+        ret = encode_generate_icc_profile(avctx, dst);
+        if (ret < 0)
+            return ret;
+    }
+
     return 0;
 }
 
@@ -594,6 +656,24 @@ int ff_encode_preinit(AVCodecContext *avctx)
             return AVERROR(ENOMEM);
     }
 
+    if ((avctx->flags & AV_CODEC_FLAG_RECON_FRAME)) {
+        if (!(avctx->codec->capabilities & AV_CODEC_CAP_ENCODER_RECON_FRAME)) {
+            av_log(avctx, AV_LOG_ERROR, "Reconstructed frame output requested "
+                   "from an encoder not supporting it\n");
+            return AVERROR(ENOSYS);
+        }
+
+        avci->recon_frame = av_frame_alloc();
+        if (!avci->recon_frame)
+            return AVERROR(ENOMEM);
+    }
+
+    if (CONFIG_FRAME_THREAD_ENCODER) {
+        ret = ff_frame_thread_encoder_init(avctx);
+        if (ret < 0)
+            return ret;
+    }
+
     return 0;
 }
 
@@ -630,3 +710,16 @@ int ff_encode_alloc_frame(AVCodecContext *avctx, AVFrame *frame)
 
     return 0;
 }
+
+int ff_encode_receive_frame(AVCodecContext *avctx, AVFrame *frame)
+{
+    AVCodecInternal *avci = avctx->internal;
+
+    if (!avci->recon_frame)
+        return AVERROR(EINVAL);
+    if (!avci->recon_frame->buf[0])
+        return avci->draining_done ? AVERROR_EOF : AVERROR(EAGAIN);
+
+    av_frame_move_ref(frame, avci->recon_frame);
+    return 0;
+}
diff --git a/libavcodec/encode.h b/libavcodec/encode.h
index b2536bf..bc77918 100644
--- a/libavcodec/encode.h
+++ b/libavcodec/encode.h
@@ -26,6 +26,11 @@
 #include "avcodec.h"
 #include "packet.h"
 
+/**
+ * avcodec_receive_frame() implementation for encoders.
+ */
+int ff_encode_receive_frame(AVCodecContext *avctx, AVFrame *frame);
+
 /**
  * Called by encoders to get the next frame for encoding.
  *
diff --git a/libavcodec/error_resilience.c b/libavcodec/error_resilience.c
index f957c68..2aa6f1d 100644
--- a/libavcodec/error_resilience.c
+++ b/libavcodec/error_resilience.c
@@ -946,17 +946,17 @@ void ff_er_frame_end(ERContext *s)
         av_log(s->avctx, AV_LOG_ERROR, "Warning MVs not available\n");
 
         for (i = 0; i < 2; i++) {
-            s->ref_index_buf[i]  = av_buffer_allocz(s->mb_stride * s->mb_height * 4 * sizeof(uint8_t));
-            s->motion_val_buf[i] = av_buffer_allocz((size + 4) * 2 * sizeof(uint16_t));
-            if (!s->ref_index_buf[i] || !s->motion_val_buf[i])
+            s->ref_index[i]       = av_calloc(s->mb_stride * s->mb_height, 4 * sizeof(uint8_t));
+            s->motion_val_base[i] = av_calloc(size + 4, 2 * sizeof(uint16_t));
+            if (!s->ref_index[i] || !s->motion_val_base[i])
                 break;
-            s->cur_pic.ref_index[i]  = s->ref_index_buf[i]->data;
-            s->cur_pic.motion_val[i] = (int16_t (*)[2])s->motion_val_buf[i]->data + 4;
+            s->cur_pic.ref_index[i]  = s->ref_index[i];
+            s->cur_pic.motion_val[i] = s->motion_val_base[i] + 4;
         }
         if (i < 2) {
             for (i = 0; i < 2; i++) {
-                av_buffer_unref(&s->ref_index_buf[i]);
-                av_buffer_unref(&s->motion_val_buf[i]);
+                av_freep(&s->ref_index[i]);
+                av_freep(&s->motion_val_base[i]);
                 s->cur_pic.ref_index[i]  = NULL;
                 s->cur_pic.motion_val[i] = NULL;
             }
@@ -1343,8 +1343,8 @@ void ff_er_frame_end(ERContext *s)
     }
 
     for (i = 0; i < 2; i++) {
-        av_buffer_unref(&s->ref_index_buf[i]);
-        av_buffer_unref(&s->motion_val_buf[i]);
+        av_freep(&s->ref_index[i]);
+        av_freep(&s->motion_val_base[i]);
         s->cur_pic.ref_index[i]  = NULL;
         s->cur_pic.motion_val[i] = NULL;
     }
diff --git a/libavcodec/error_resilience.h b/libavcodec/error_resilience.h
index 53e5cf2..47cc8a4 100644
--- a/libavcodec/error_resilience.h
+++ b/libavcodec/error_resilience.h
@@ -75,8 +75,8 @@ typedef struct ERContext {
     ERPicture last_pic;
     ERPicture next_pic;
 
-    AVBufferRef *ref_index_buf[2];
-    AVBufferRef *motion_val_buf[2];
+    int8_t *ref_index[2];
+    int16_t (*motion_val_base[2])[2];
 
     uint16_t pp_time;
     uint16_t pb_time;
diff --git a/libavcodec/escape124.c b/libavcodec/escape124.c
index 2fdffff..170d76f 100644
--- a/libavcodec/escape124.c
+++ b/libavcodec/escape124.c
@@ -385,5 +385,4 @@ const FFCodec ff_escape124_decoder = {
     .close          = escape124_decode_close,
     FF_CODEC_DECODE_CB(escape124_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/escape130.c b/libavcodec/escape130.c
index cd6dd76..b292343 100644
--- a/libavcodec/escape130.c
+++ b/libavcodec/escape130.c
@@ -355,5 +355,5 @@ const FFCodec ff_escape130_decoder = {
     .close          = escape130_decode_close,
     FF_CODEC_DECODE_CB(escape130_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/evrcdec.c b/libavcodec/evrcdec.c
index a647519..19e7e58 100644
--- a/libavcodec/evrcdec.c
+++ b/libavcodec/evrcdec.c
@@ -939,5 +939,4 @@ const FFCodec ff_evrc_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .priv_data_size = sizeof(EVRCContext),
     .p.priv_class   = &evrcdec_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/exr.c b/libavcodec/exr.c
index 91a567c..3a6b9c3 100644
--- a/libavcodec/exr.c
+++ b/libavcodec/exr.c
@@ -196,7 +196,7 @@ typedef struct EXRContext {
     uint16_t offsettable[64];
 } EXRContext;
 
-static int zip_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,
+static int zip_uncompress(const EXRContext *s, const uint8_t *src, int compressed_size,
                           int uncompressed_size, EXRThreadData *td)
 {
     unsigned long dest_len = uncompressed_size;
@@ -255,7 +255,7 @@ static int rle(uint8_t *dst, const uint8_t *src,
     return 0;
 }
 
-static int rle_uncompress(EXRContext *ctx, const uint8_t *src, int compressed_size,
+static int rle_uncompress(const EXRContext *ctx, const uint8_t *src, int compressed_size,
                           int uncompressed_size, EXRThreadData *td)
 {
     rle(td->tmp, src, compressed_size, uncompressed_size);
@@ -365,7 +365,7 @@ static int huf_unpack_enc_table(GetByteContext *gb,
     return 0;
 }
 
-static int huf_build_dec_table(EXRContext *s,
+static int huf_build_dec_table(const EXRContext *s,
                                EXRThreadData *td, int im, int iM)
 {
     int j = 0;
@@ -440,7 +440,7 @@ static int huf_decode(VLC *vlc, GetByteContext *gb, int nbits, int run_sym,
     return 0;
 }
 
-static int huf_uncompress(EXRContext *s,
+static int huf_uncompress(const EXRContext *s,
                           EXRThreadData *td,
                           GetByteContext *gb,
                           uint16_t *dst, int dst_size)
@@ -588,7 +588,7 @@ static void wav_decode(uint16_t *in, int nx, int ox,
     }
 }
 
-static int piz_uncompress(EXRContext *s, const uint8_t *src, int ssize,
+static int piz_uncompress(const EXRContext *s, const uint8_t *src, int ssize,
                           int dsize, EXRThreadData *td)
 {
     GetByteContext gb;
@@ -674,7 +674,7 @@ static int piz_uncompress(EXRContext *s, const uint8_t *src, int ssize,
     return 0;
 }
 
-static int pxr24_uncompress(EXRContext *s, const uint8_t *src,
+static int pxr24_uncompress(const EXRContext *s, const uint8_t *src,
                             int compressed_size, int uncompressed_size,
                             EXRThreadData *td)
 {
@@ -809,7 +809,7 @@ static void unpack_3(const uint8_t b[3], uint16_t s[16])
 }
 
 
-static int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,
+static int b44_uncompress(const EXRContext *s, const uint8_t *src, int compressed_size,
                           int uncompressed_size, EXRThreadData *td) {
     const int8_t *sr = src;
     int stay_to_uncompress = compressed_size;
@@ -833,7 +833,7 @@ static int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size
             for (iY = 0; iY < nb_b44_block_h; iY++) {
                 for (iX = 0; iX < nb_b44_block_w; iX++) {/* For each B44 block */
                     if (stay_to_uncompress < 3) {
-                        av_log(s, AV_LOG_ERROR, "Not enough data for B44A block: %d", stay_to_uncompress);
+                        av_log(s->avctx, AV_LOG_ERROR, "Not enough data for B44A block: %d", stay_to_uncompress);
                         return AVERROR_INVALIDDATA;
                     }
 
@@ -843,7 +843,7 @@ static int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size
                         stay_to_uncompress -= 3;
                     }  else {/* B44 Block */
                         if (stay_to_uncompress < 14) {
-                            av_log(s, AV_LOG_ERROR, "Not enough data for B44 block: %d", stay_to_uncompress);
+                            av_log(s->avctx, AV_LOG_ERROR, "Not enough data for B44 block: %d", stay_to_uncompress);
                             return AVERROR_INVALIDDATA;
                         }
                         unpack_14(sr, tmp_buffer);
@@ -868,7 +868,7 @@ static int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size
             target_channel_offset += 2;
         } else {/* Float or UINT 32 channel */
             if (stay_to_uncompress < td->ysize * td->xsize * 4) {
-                av_log(s, AV_LOG_ERROR, "Not enough data for uncompress channel: %d", stay_to_uncompress);
+                av_log(s->avctx, AV_LOG_ERROR, "Not enough data for uncompress channel: %d", stay_to_uncompress);
                 return AVERROR_INVALIDDATA;
             }
 
@@ -886,7 +886,7 @@ static int b44_uncompress(EXRContext *s, const uint8_t *src, int compressed_size
     return 0;
 }
 
-static int ac_uncompress(EXRContext *s, GetByteContext *gb, float *block)
+static int ac_uncompress(const EXRContext *s, GetByteContext *gb, float *block)
 {
     int ret = 0, n = 1;
 
@@ -986,7 +986,7 @@ static float to_linear(float x, float scale)
     }
 }
 
-static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size,
+static int dwa_uncompress(const EXRContext *s, const uint8_t *src, int compressed_size,
                           int uncompressed_size, EXRThreadData *td)
 {
     int64_t version, lo_usize, lo_size;
@@ -1181,7 +1181,7 @@ static int dwa_uncompress(EXRContext *s, const uint8_t *src, int compressed_size
 static int decode_block(AVCodecContext *avctx, void *tdata,
                         int jobnr, int threadnr)
 {
-    EXRContext *s = avctx->priv_data;
+    const EXRContext *s = avctx->priv_data;
     AVFrame *const p = s->picture;
     EXRThreadData *td = &s->thread_data[threadnr];
     const uint8_t *channel_buffer[4] = { 0 };
@@ -1951,12 +1951,9 @@ static int decode_header(EXRContext *s, AVFrame *frame)
                                                      "preview", 16)) >= 0) {
             uint32_t pw = bytestream2_get_le32(gb);
             uint32_t ph = bytestream2_get_le32(gb);
-            uint64_t psize = pw * ph;
-            if (psize > INT64_MAX / 4)
-                return AVERROR_INVALIDDATA;
-            psize *= 4;
+            int64_t psize = 4LL * pw * ph;
 
-            if ((int64_t)psize >= bytestream2_get_bytes_left(gb))
+            if (psize >= bytestream2_get_bytes_left(gb))
                 return AVERROR_INVALIDDATA;
 
             bytestream2_skip(gb, psize);
@@ -2356,6 +2353,5 @@ const FFCodec ff_exr_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
                         AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.priv_class     = &exr_class,
 };
diff --git a/libavcodec/exrenc.c b/libavcodec/exrenc.c
index 8eb138e..8cf7827 100644
--- a/libavcodec/exrenc.c
+++ b/libavcodec/exrenc.c
@@ -253,7 +253,7 @@ static int encode_scanline_rle(EXRContext *s, const AVFrame *frame)
             for (int p = 0; p < s->planes; p++) {
                 int ch = s->ch_order[p];
                 uint16_t *dst = (uint16_t *)(scanline->uncompressed_data + frame->width * 2 * p);
-                uint32_t *src = (uint32_t *)(frame->data[ch] + y * frame->linesize[ch]);
+                const uint32_t *src = (const uint32_t *)(frame->data[ch] + y * frame->linesize[ch]);
 
                 for (int x = 0; x < frame->width; x++)
                     dst[x] = float2half(src[x], s->basetable, s->shifttable);
@@ -321,7 +321,7 @@ static int encode_scanline_zip(EXRContext *s, const AVFrame *frame)
                 for (int p = 0; p < s->planes; p++) {
                     int ch = s->ch_order[p];
                     uint16_t *dst = (uint16_t *)(scanline->uncompressed_data + scanline_size * l + p * frame->width * 2);
-                    uint32_t *src = (uint32_t *)(frame->data[ch] + (y * s->scanline_height + l) * frame->linesize[ch]);
+                    const uint32_t *src = (const uint32_t *)(frame->data[ch] + (y * s->scanline_height + l) * frame->linesize[ch]);
 
                     for (int x = 0; x < frame->width; x++)
                         dst[x] = float2half(src[x], s->basetable, s->shifttable);
@@ -479,7 +479,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                 bytestream2_put_le32(pb, s->planes * avctx->width * 2);
                 for (int p = 0; p < s->planes; p++) {
                     int ch = s->ch_order[p];
-                    uint32_t *src = (uint32_t *)(frame->data[ch] + y * frame->linesize[ch]);
+                    const uint32_t *src = (const uint32_t *)(frame->data[ch] + y * frame->linesize[ch]);
 
                     for (int x = 0; x < frame->width; x++)
                         bytestream2_put_le16(pb, float2half(src[x], s->basetable, s->shifttable));
@@ -557,5 +557,4 @@ const FFCodec ff_exr_encoder = {
                                                  AV_PIX_FMT_GBRPF32,
                                                  AV_PIX_FMT_GBRAPF32,
                                                  AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/fastaudio.c b/libavcodec/fastaudio.c
index 46fffaf..6093a06 100644
--- a/libavcodec/fastaudio.c
+++ b/libavcodec/fastaudio.c
@@ -199,5 +199,4 @@ const FFCodec ff_fastaudio_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/fflcms2.c b/libavcodec/fflcms2.c
new file mode 100644
index 0000000..fd370fb
--- /dev/null
+++ b/libavcodec/fflcms2.c
@@ -0,0 +1,311 @@
+/*
+ * Copyright (c) 2022 Niklas Haas
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/color_utils.h"
+#include "libavutil/csp.h"
+
+#include "fflcms2.h"
+
+static void log_cb(cmsContext ctx, cmsUInt32Number error, const char *str)
+{
+    FFIccContext *s = cmsGetContextUserData(ctx);
+    av_log(s->avctx, AV_LOG_ERROR, "lcms2: [%"PRIu32"] %s\n", error, str);
+}
+
+int ff_icc_context_init(FFIccContext *s, void *avctx)
+{
+    memset(s, 0, sizeof(*s));
+    s->avctx = avctx;
+    s->ctx = cmsCreateContext(NULL, s);
+    if (!s->ctx)
+        return AVERROR(ENOMEM);
+
+    cmsSetLogErrorHandlerTHR(s->ctx, log_cb);
+    return 0;
+}
+
+void ff_icc_context_uninit(FFIccContext *s)
+{
+    for (int i = 0; i < FF_ARRAY_ELEMS(s->curves); i++)
+        cmsFreeToneCurve(s->curves[i]);
+    cmsDeleteContext(s->ctx);
+    memset(s, 0, sizeof(*s));
+}
+
+static int get_curve(FFIccContext *s, enum AVColorTransferCharacteristic trc,
+                     cmsToneCurve **out_curve)
+{
+    if (trc >= AVCOL_TRC_NB)
+        return AVERROR_INVALIDDATA;
+
+    if (s->curves[trc])
+        goto done;
+
+    switch (trc) {
+    case AVCOL_TRC_LINEAR:
+        s->curves[trc] = cmsBuildGamma(s->ctx, 1.0);
+        break;
+    case AVCOL_TRC_GAMMA22:
+        s->curves[trc] = cmsBuildGamma(s->ctx, 2.2);
+        break;
+    case AVCOL_TRC_GAMMA28:
+        s->curves[trc] = cmsBuildGamma(s->ctx, 2.8);
+        break;
+    case AVCOL_TRC_BT709:
+    case AVCOL_TRC_SMPTE170M:
+    case AVCOL_TRC_BT2020_10:
+    case AVCOL_TRC_BT2020_12:
+        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 4, (double[5]) {
+            /*  = */ 1/0.45,
+            /* a = */ 1/1.099296826809442,
+            /* b = */ 1 - 1/1.099296826809442,
+            /* c = */ 1/4.5,
+            /* d = */ 4.5 * 0.018053968510807,
+        });
+        break;
+    case AVCOL_TRC_SMPTE240M:
+        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 4, (double[5]) {
+            /*  = */ 1/0.45,
+            /* a = */ 1/1.1115,
+            /* b = */ 1 - 1/1.1115,
+            /* c = */ 1/4.0,
+            /* d = */ 4.0 * 0.0228,
+        });
+        break;
+    case AVCOL_TRC_LOG:
+        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 8, (double[5]) {
+            /* a = */ 1.0,
+            /* b = */ 10.0,
+            /* c = */ 2.0,
+            /* d = */ -1.0,
+            /* e = */ 0.0
+        });
+        break;
+    case AVCOL_TRC_LOG_SQRT:
+        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 8, (double[5]) {
+            /* a = */ 1.0,
+            /* b = */ 10.0,
+            /* c = */ 2.5,
+            /* d = */ -1.0,
+            /* e = */ 0.0
+        });
+        break;
+    case AVCOL_TRC_IEC61966_2_1:
+        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 4, (double[5]) {
+            /*  = */ 2.4,
+            /* a = */ 1/1.055,
+            /* b = */ 1 - 1/1.055,
+            /* c = */ 1/12.92,
+            /* d = */ 12.92 * 0.0031308,
+        });
+        break;
+    case AVCOL_TRC_SMPTE428:
+        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 2, (double[3]) {
+            /*  = */ 2.6,
+            /* a = */ pow(52.37/48.0, 1/2.6),
+            /* b = */ 0.0
+        });
+        break;
+
+    /* Can't be represented using the existing parametric tone curves.
+     * FIXME: use cmsBuildTabulatedToneCurveFloat instead */
+    case AVCOL_TRC_IEC61966_2_4:
+    case AVCOL_TRC_BT1361_ECG:
+    case AVCOL_TRC_SMPTE2084:
+    case AVCOL_TRC_ARIB_STD_B67:
+        return AVERROR_PATCHWELCOME;
+
+    default:
+        return AVERROR_INVALIDDATA;
+    }
+
+    if (!s->curves[trc])
+        return AVERROR(ENOMEM);
+
+done:
+    *out_curve = s->curves[trc];
+    return 0;
+}
+
+int ff_icc_profile_generate(FFIccContext *s,
+                            enum AVColorPrimaries color_prim,
+                            enum AVColorTransferCharacteristic color_trc,
+                            cmsHPROFILE *out_profile)
+{
+    cmsToneCurve *tonecurve;
+    const AVColorPrimariesDesc *prim;
+    int ret;
+
+    if (!(prim = av_csp_primaries_desc_from_id(color_prim)))
+        return AVERROR_INVALIDDATA;
+    if ((ret = get_curve(s, color_trc, &tonecurve)) < 0)
+        return ret;
+
+    *out_profile = cmsCreateRGBProfileTHR(s->ctx,
+        &(cmsCIExyY) { av_q2d(prim->wp.x), av_q2d(prim->wp.y), 1.0 },
+        &(cmsCIExyYTRIPLE) {
+            .Red    = { av_q2d(prim->prim.r.x), av_q2d(prim->prim.r.y), 1.0 },
+            .Green  = { av_q2d(prim->prim.g.x), av_q2d(prim->prim.g.y), 1.0 },
+            .Blue   = { av_q2d(prim->prim.b.x), av_q2d(prim->prim.b.y), 1.0 },
+        },
+        (cmsToneCurve *[3]) { tonecurve, tonecurve, tonecurve }
+    );
+
+    return *out_profile == NULL ? AVERROR(ENOMEM) : 0;
+}
+
+int ff_icc_profile_attach(FFIccContext *s, cmsHPROFILE profile, AVFrame *frame)
+{
+    cmsUInt32Number size;
+    AVBufferRef *buf;
+
+    if (!cmsSaveProfileToMem(profile, NULL, &size))
+        return AVERROR_EXTERNAL;
+
+    buf = av_buffer_alloc(size);
+    if (!buf)
+        return AVERROR(ENOMEM);
+
+    if (!cmsSaveProfileToMem(profile, buf->data, &size) || size != buf->size) {
+        av_buffer_unref(&buf);
+        return AVERROR_EXTERNAL;
+    }
+
+    if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_ICC_PROFILE, buf)) {
+        av_buffer_unref(&buf);
+        return AVERROR(ENOMEM);
+    }
+
+    return 0;
+}
+
+static av_always_inline void XYZ_xy(cmsCIEXYZ XYZ, AVCIExy *xy)
+{
+    double k = 1.0 / (XYZ.X + XYZ.Y + XYZ.Z);
+    xy->x = av_d2q(k * XYZ.X, 100000);
+    xy->y = av_d2q(k * XYZ.Y, 100000);
+}
+
+int ff_icc_profile_read_primaries(FFIccContext *s, cmsHPROFILE profile,
+                                  AVColorPrimariesDesc *out_primaries)
+{
+    static const uint8_t testprimaries[4][3] = {
+        { 0xFF,    0,    0 }, /* red */
+        {    0, 0xFF,    0 }, /* green */
+        {    0,    0, 0xFF }, /* blue */
+        { 0xFF, 0xFF, 0xFF }, /* white */
+    };
+
+    AVWhitepointCoefficients *wp = &out_primaries->wp;
+    AVPrimaryCoefficients *prim = &out_primaries->prim;
+    cmsFloat64Number prev_adapt;
+    cmsHPROFILE xyz;
+    cmsHTRANSFORM tf;
+    cmsCIEXYZ dst[4];
+
+    xyz = cmsCreateXYZProfileTHR(s->ctx);
+    if (!xyz)
+        return AVERROR(ENOMEM);
+
+    /* We need to use an unadapted observer to get the raw values */
+    prev_adapt = cmsSetAdaptationStateTHR(s->ctx, 0.0);
+    tf = cmsCreateTransformTHR(s->ctx, profile, TYPE_RGB_8, xyz, TYPE_XYZ_DBL,
+                               INTENT_ABSOLUTE_COLORIMETRIC,
+                               /* Note: These flags mostly don't do anything
+                                * anyway, but specify them regardless */
+                               cmsFLAGS_NOCACHE |
+                               cmsFLAGS_NOOPTIMIZE |
+                               cmsFLAGS_LOWRESPRECALC |
+                               cmsFLAGS_GRIDPOINTS(2));
+    cmsSetAdaptationStateTHR(s->ctx, prev_adapt);
+    cmsCloseProfile(xyz);
+    if (!tf) {
+        av_log(s->avctx, AV_LOG_ERROR, "Invalid ICC profile (e.g. CMYK)\n");
+        return AVERROR_INVALIDDATA;
+    }
+
+    cmsDoTransform(tf, testprimaries, dst, 4);
+    cmsDeleteTransform(tf);
+    XYZ_xy(dst[0], &prim->r);
+    XYZ_xy(dst[1], &prim->g);
+    XYZ_xy(dst[2], &prim->b);
+    XYZ_xy(dst[3], wp);
+    return 0;
+}
+
+int ff_icc_profile_detect_transfer(FFIccContext *s, cmsHPROFILE profile,
+                                   enum AVColorTransferCharacteristic *out_trc)
+{
+    /* 8-bit linear grayscale ramp */
+    static const uint8_t testramp[16][3] = {
+        {  1,   1,   1}, /* avoid exact zero due to log100 etc. */
+        { 17,  17,  17},
+        { 34,  34,  34},
+        { 51,  51,  51},
+        { 68,  68,  68},
+        { 85,  85,  85},
+        { 02,  02,  02},
+        {119, 119, 119},
+        {136, 136, 136},
+        {153, 153, 153},
+        {170, 170, 170},
+        {187, 187, 187},
+        {204, 204, 204},
+        {221, 221, 221},
+        {238, 238, 238},
+        {255, 255, 255},
+    };
+
+    double dst[FF_ARRAY_ELEMS(testramp)];
+
+    for (enum AVColorTransferCharacteristic trc = 0; trc < AVCOL_TRC_NB; trc++) {
+        cmsToneCurve *tonecurve;
+        cmsHPROFILE ref;
+        cmsHTRANSFORM tf;
+        double delta = 0.0;
+        if (get_curve(s, trc, &tonecurve) < 0)
+            continue;
+
+        ref = cmsCreateGrayProfileTHR(s->ctx, cmsD50_xyY(), tonecurve);
+        if (!ref)
+            return AVERROR(ENOMEM);
+
+        tf = cmsCreateTransformTHR(s->ctx, profile, TYPE_RGB_8, ref, TYPE_GRAY_DBL,
+                                   INTENT_RELATIVE_COLORIMETRIC,
+                                   cmsFLAGS_NOCACHE | cmsFLAGS_NOOPTIMIZE);
+        cmsCloseProfile(ref);
+        if (!tf) {
+            av_log(s->avctx, AV_LOG_ERROR, "Invalid ICC profile (e.g. CMYK)\n");
+            return AVERROR_INVALIDDATA;
+        }
+
+        cmsDoTransform(tf, testramp, dst, FF_ARRAY_ELEMS(dst));
+        cmsDeleteTransform(tf);
+
+        for (int i = 0; i < FF_ARRAY_ELEMS(dst); i++)
+            delta += fabs(testramp[i][0] / 255.0 - dst[i]);
+        if (delta < 0.01) {
+            *out_trc = trc;
+            return 0;
+        }
+    }
+
+    *out_trc = AVCOL_TRC_UNSPECIFIED;
+    return 0;
+}
diff --git a/libavcodec/fflcms2.h b/libavcodec/fflcms2.h
new file mode 100644
index 0000000..af63c9a
--- /dev/null
+++ b/libavcodec/fflcms2.h
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2022 Niklas Haas
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Various functions for dealing with ICC profiles
+ */
+
+#ifndef AVCODEC_FFLCMS2_H
+#define AVCODEC_FFLCMS2_H
+
+#include "libavutil/csp.h"
+#include "libavutil/frame.h"
+#include "libavutil/pixfmt.h"
+
+#include <lcms2.h>
+
+typedef struct FFIccContext {
+    void *avctx;
+    cmsContext ctx;
+    cmsToneCurve *curves[AVCOL_TRC_NB]; /* tone curve cache */
+} FFIccContext;
+
+/**
+ * Initializes an FFIccContext. This must be done prior to using it.
+ *
+ * Returns 0 on success, or a negative error code.
+ */
+int ff_icc_context_init(FFIccContext *s, void *avctx);
+void ff_icc_context_uninit(FFIccContext *s);
+
+/**
+ * Generate an ICC profile for a given combination of color primaries and
+ * transfer function. Both values must be set to valid entries (not
+ * "undefined") for this function to work.
+ *
+ * Returns 0 on success, or a negative error code.
+ */
+int ff_icc_profile_generate(FFIccContext *s,
+                            enum AVColorPrimaries color_prim,
+                            enum AVColorTransferCharacteristic color_trc,
+                            cmsHPROFILE *out_profile);
+
+/**
+ * Attach an ICC profile to a frame. Helper wrapper around cmsSaveProfileToMem
+ * and av_frame_new_side_data_from_buf.
+ *
+ * Returns 0 on success, or a negative error code.
+ */
+int ff_icc_profile_attach(FFIccContext *s, cmsHPROFILE profile, AVFrame *frame);
+
+/**
+ * Read the color primaries and white point coefficients encoded by an ICC
+ * profile, and return the raw values in `out_primaries`.
+ *
+ * Returns 0 on success, or a negative error code.
+ */
+int ff_icc_profile_read_primaries(FFIccContext *s, cmsHPROFILE profile,
+                                  AVColorPrimariesDesc *out_primaries);
+
+/**
+ * Attempt detecting the transfer characteristic that best approximates the
+ * transfer function encoded by an ICC profile. Sets `out_trc` to
+ * AVCOL_TRC_UNSPECIFIED if no clear match can be identified.
+ *
+ * Returns 0 on success (including no match), or a negative error code.
+ */
+int ff_icc_profile_detect_transfer(FFIccContext *s, cmsHPROFILE profile,
+                                   enum AVColorTransferCharacteristic *out_trc);
+
+#endif /* AVCODEC_FFLCMS2_H */
diff --git a/libavcodec/ffv1dec.c b/libavcodec/ffv1dec.c
index 9300297..4fe1738 100644
--- a/libavcodec/ffv1dec.c
+++ b/libavcodec/ffv1dec.c
@@ -1082,6 +1082,6 @@ const FFCodec ff_ffv1_decoder = {
     .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),
     .p.capabilities = AV_CODEC_CAP_DR1 /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/ |
                       AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
diff --git a/libavcodec/ffv1enc.c b/libavcodec/ffv1enc.c
index 9849082..ec06636 100644
--- a/libavcodec/ffv1enc.c
+++ b/libavcodec/ffv1enc.c
@@ -270,7 +270,7 @@ static inline void put_vlc_symbol(PutBitContext *pb, VlcState *const state,
 #define RENAME(name) name ## 32
 #include "ffv1enc_template.c"
 
-static int encode_plane(FFV1Context *s, uint8_t *src, int w, int h,
+static int encode_plane(FFV1Context *s, const uint8_t *src, int w, int h,
                          int stride, int plane_index, int pixel_stride)
 {
     int x, y, i, ret;
@@ -1310,5 +1310,5 @@ const FFCodec ff_ffv1_encoder = {
 
     },
     .p.priv_class   = &ffv1_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/ffwavesynth.c b/libavcodec/ffwavesynth.c
index 67e867b..04be776 100644
--- a/libavcodec/ffwavesynth.c
+++ b/libavcodec/ffwavesynth.c
@@ -469,5 +469,5 @@ const FFCodec ff_ffwavesynth_decoder = {
     .close          = wavesynth_close,
     FF_CODEC_DECODE_CB(wavesynth_decode),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/fic.c b/libavcodec/fic.c
index 491f63e..3a0211e 100644
--- a/libavcodec/fic.c
+++ b/libavcodec/fic.c
@@ -495,5 +495,4 @@ const FFCodec ff_fic_decoder = {
     .close          = fic_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS,
     .p.priv_class   = &fic_decoder_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/fitsenc.c b/libavcodec/fitsenc.c
index 5e9100b..30395b0 100644
--- a/libavcodec/fitsenc.c
+++ b/libavcodec/fitsenc.c
@@ -36,10 +36,9 @@
 #include "encode.h"
 
 static int fits_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
-                            const AVFrame *pict, int *got_packet)
+                             const AVFrame *p, int *got_packet)
 {
-    AVFrame * const p = (AVFrame *)pict;
-    uint8_t *bytestream, *ptr;
+    uint8_t *bytestream;
     const uint16_t flip = (1 << 15);
     uint64_t data_size = 0, padded_data_size = 0;
     int ret, bitpix, naxis3 = 1, i, j, k, bytes_left;
@@ -88,7 +87,7 @@ static int fits_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
 
     for (k = 0; k < naxis3; k++) {
         for (i = 0; i < avctx->height; i++) {
-            ptr = p->data[map[k]] + (avctx->height - i - 1) * p->linesize[map[k]];
+            const uint8_t *ptr = p->data[map[k]] + (avctx->height - i - 1) * p->linesize[map[k]];
             if (bitpix == 16) {
                 for (j = 0; j < avctx->width; j++) {
                     // subtracting bzero is equivalent to first bit flip
diff --git a/libavcodec/flacdec.c b/libavcodec/flacdec.c
index 87f20c7..5ddc5a3 100644
--- a/libavcodec/flacdec.c
+++ b/libavcodec/flacdec.c
@@ -117,7 +117,7 @@ static av_cold int flac_decode_init(AVCodecContext *avctx)
         return ret;
     flac_set_bps(s);
     ff_flacdsp_init(&s->dsp, avctx->sample_fmt,
-                    s->flac_stream_info.channels, s->flac_stream_info.bps);
+                    s->flac_stream_info.channels);
     s->got_streaminfo = 1;
 
     return 0;
@@ -185,7 +185,7 @@ static int parse_streaminfo(FLACContext *s, const uint8_t *buf, int buf_size)
         return ret;
     flac_set_bps(s);
     ff_flacdsp_init(&s->dsp, s->avctx->sample_fmt,
-                    s->flac_stream_info.channels, s->flac_stream_info.bps);
+                    s->flac_stream_info.channels);
     s->got_streaminfo = 1;
 
     return 0;
@@ -536,7 +536,7 @@ static int decode_frame(FLACContext *s)
         dump_headers(s->avctx, &s->flac_stream_info);
     }
     ff_flacdsp_init(&s->dsp, s->avctx->sample_fmt,
-                    s->flac_stream_info.channels, s->flac_stream_info.bps);
+                    s->flac_stream_info.channels);
 
 //    dump_headers(s->avctx, &s->flac_stream_info);
 
@@ -675,5 +675,4 @@ const FFCodec ff_flac_decoder = {
                                                       AV_SAMPLE_FMT_S32P,
                                                       AV_SAMPLE_FMT_NONE },
     .p.priv_class   = &flac_decoder_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/flacdsp.c b/libavcodec/flacdsp.c
index 79002dc..42e231d 100644
--- a/libavcodec/flacdsp.c
+++ b/libavcodec/flacdsp.c
@@ -27,7 +27,6 @@
 #define SAMPLE_SIZE 16
 #define PLANAR 0
 #include "flacdsp_template.c"
-#include "flacdsp_lpc_template.c"
 
 #undef  PLANAR
 #define PLANAR 1
@@ -38,7 +37,6 @@
 #define SAMPLE_SIZE 32
 #define PLANAR 0
 #include "flacdsp_template.c"
-#include "flacdsp_lpc_template.c"
 
 #undef  PLANAR
 #define PLANAR 1
@@ -86,13 +84,10 @@ static void flac_lpc_32_c(int32_t *decoded, const int coeffs[32],
 
 }
 
-av_cold void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels,
-                             int bps)
+av_cold void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels)
 {
     c->lpc16        = flac_lpc_16_c;
     c->lpc32        = flac_lpc_32_c;
-    c->lpc16_encode = flac_lpc_encode_c_16;
-    c->lpc32_encode = flac_lpc_encode_c_32;
 
     switch (fmt) {
     case AV_SAMPLE_FMT_S32:
@@ -125,8 +120,8 @@ av_cold void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int cha
     }
 
 #if ARCH_ARM
-    ff_flacdsp_init_arm(c, fmt, channels, bps);
+    ff_flacdsp_init_arm(c, fmt, channels);
 #elif ARCH_X86
-    ff_flacdsp_init_x86(c, fmt, channels, bps);
+    ff_flacdsp_init_x86(c, fmt, channels);
 #endif
 }
diff --git a/libavcodec/flacdsp.h b/libavcodec/flacdsp.h
index 4a7a360..9f8ed38 100644
--- a/libavcodec/flacdsp.h
+++ b/libavcodec/flacdsp.h
@@ -36,8 +36,8 @@ typedef struct FLACDSPContext {
                          const int32_t coefs[32], int shift);
 } FLACDSPContext;
 
-void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels, int bps);
-void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels, int bps);
-void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels, int bps);
+void ff_flacdsp_init(FLACDSPContext *c, enum AVSampleFormat fmt, int channels);
+void ff_flacdsp_init_arm(FLACDSPContext *c, enum AVSampleFormat fmt, int channels);
+void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels);
 
 #endif /* AVCODEC_FLACDSP_H */
diff --git a/libavcodec/flacenc.c b/libavcodec/flacenc.c
index e9edd84..00f78fc 100644
--- a/libavcodec/flacenc.c
+++ b/libavcodec/flacenc.c
@@ -36,7 +36,7 @@
 #include "lpc.h"
 #include "flac.h"
 #include "flacdata.h"
-#include "flacdsp.h"
+#include "flacencdsp.h"
 
 #define FLAC_SUBFRAME_CONSTANT  0
 #define FLAC_SUBFRAME_VERBATIM  1
@@ -125,7 +125,7 @@ typedef struct FlacEncodeContext {
     uint8_t *md5_buffer;
     unsigned int md5_buffer_size;
     BswapDSPContext bdsp;
-    FLACDSPContext flac_dsp;
+    FLACEncDSPContext flac_dsp;
 
     int flushed;
     int64_t next_pts;
@@ -425,8 +425,7 @@ static av_cold int flac_encode_init(AVCodecContext *avctx)
                       s->options.max_prediction_order, FF_LPC_TYPE_LEVINSON);
 
     ff_bswapdsp_init(&s->bdsp);
-    ff_flacdsp_init(&s->flac_dsp, avctx->sample_fmt, channels,
-                    avctx->bits_per_raw_sample);
+    ff_flacencdsp_init(&s->flac_dsp);
 
     dprint_compression_options(s);
 
@@ -1473,5 +1472,5 @@ const FFCodec ff_flac_encoder = {
                                                      AV_SAMPLE_FMT_S32,
                                                      AV_SAMPLE_FMT_NONE },
     .p.priv_class   = &flac_encoder_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/flacencdsp.c b/libavcodec/flacencdsp.c
new file mode 100644
index 0000000..46e5a03
--- /dev/null
+++ b/libavcodec/flacencdsp.c
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2012 Mans Rullgard <mans@mansr.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "flacencdsp.h"
+
+#define SAMPLE_SIZE 16
+#include "flacdsp_lpc_template.c"
+
+#undef  SAMPLE_SIZE
+#define SAMPLE_SIZE 32
+#include "flacdsp_lpc_template.c"
+
+
+av_cold void ff_flacencdsp_init(FLACEncDSPContext *c)
+{
+    c->lpc16_encode = flac_lpc_encode_c_16;
+    c->lpc32_encode = flac_lpc_encode_c_32;
+
+#if ARCH_X86
+    ff_flacencdsp_init_x86(c);
+#endif
+}
diff --git a/libavcodec/flacencdsp.h b/libavcodec/flacencdsp.h
new file mode 100644
index 0000000..39811e2
--- /dev/null
+++ b/libavcodec/flacencdsp.h
@@ -0,0 +1,34 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_FLACENCDSP_H
+#define AVCODEC_FLACENCDSP_H
+
+#include <stdint.h>
+
+typedef struct FLACEncDSPContext {
+    void (*lpc16_encode)(int32_t *res, const int32_t *smp, int len, int order,
+                         const int32_t coefs[32], int shift);
+    void (*lpc32_encode)(int32_t *res, const int32_t *smp, int len, int order,
+                         const int32_t coefs[32], int shift);
+} FLACEncDSPContext;
+
+void ff_flacencdsp_init(FLACEncDSPContext *c);
+void ff_flacencdsp_init_x86(FLACEncDSPContext *c);
+
+#endif /* AVCODEC_FLACDSP_H */
diff --git a/libavcodec/flashsv.c b/libavcodec/flashsv.c
index 4357b25..8215d04 100644
--- a/libavcodec/flashsv.c
+++ b/libavcodec/flashsv.c
@@ -511,7 +511,7 @@ const FFCodec ff_flashsv_decoder = {
     .close          = flashsv_decode_end,
     FF_CODEC_DECODE_CB(flashsv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },
 };
 #endif /* CONFIG_FLASHSV_DECODER */
@@ -579,7 +579,7 @@ const FFCodec ff_flashsv2_decoder = {
     .close          = flashsv2_decode_end,
     FF_CODEC_DECODE_CB(flashsv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },
 };
 #endif /* CONFIG_FLASHSV2_DECODER */
diff --git a/libavcodec/flashsv2enc.c b/libavcodec/flashsv2enc.c
index 07fa994..b2a15fd 100644
--- a/libavcodec/flashsv2enc.c
+++ b/libavcodec/flashsv2enc.c
@@ -920,5 +920,5 @@ const FFCodec ff_flashsv2_encoder = {
     FF_CODEC_ENCODE_CB(flashsv2_encode_frame),
     .close          = flashsv2_encode_end,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/flashsvenc.c b/libavcodec/flashsvenc.c
index 592bb06..30c4e43 100644
--- a/libavcodec/flashsvenc.c
+++ b/libavcodec/flashsvenc.c
@@ -66,16 +66,15 @@ typedef struct FlashSVContext {
     uint8_t         tmpblock[3 * 256 * 256];
 } FlashSVContext;
 
-static int copy_region_enc(uint8_t *sptr, uint8_t *dptr, int dx, int dy,
+static int copy_region_enc(const uint8_t *sptr, uint8_t *dptr, int dx, int dy,
                            int h, int w, int stride, uint8_t *pfptr)
 {
     int i, j;
-    uint8_t *nsptr;
     uint8_t *npfptr;
     int diff = 0;
 
     for (i = dx + h; i > dx; i--) {
-        nsptr  = sptr  + i * stride + dy * 3;
+        const uint8_t *nsptr = sptr + i * stride + dy * 3;
         npfptr = pfptr + i * stride + dy * 3;
         for (j = 0; j < w * 3; j++) {
             diff    |= npfptr[j] ^ nsptr[j];
@@ -267,5 +266,4 @@ const FFCodec ff_flashsv_encoder = {
     FF_CODEC_ENCODE_CB(flashsv_encode_frame),
     .close          = flashsv_encode_end,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/flicvideo.c b/libavcodec/flicvideo.c
index b841050..50b317d 100644
--- a/libavcodec/flicvideo.c
+++ b/libavcodec/flicvideo.c
@@ -1114,5 +1114,4 @@ const FFCodec ff_flic_decoder = {
     .close          = flic_decode_end,
     FF_CODEC_DECODE_CB(flic_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/flvdec.c b/libavcodec/flvdec.c
index cc016d1..a991048 100644
--- a/libavcodec/flvdec.c
+++ b/libavcodec/flvdec.c
@@ -123,8 +123,7 @@ const FFCodec ff_flv_decoder = {
     .close          = ff_h263_decode_end,
     FF_CODEC_DECODE_CB(ff_h263_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.max_lowres   = 3,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
diff --git a/libavcodec/flvenc.c b/libavcodec/flvenc.c
index 74ed321..453182b 100644
--- a/libavcodec/flvenc.c
+++ b/libavcodec/flvenc.c
@@ -102,7 +102,7 @@ const FFCodec ff_flv_encoder = {
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
     .close          = ff_mpv_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE},
 };
diff --git a/libavcodec/fmvc.c b/libavcodec/fmvc.c
index 912ad8f..fe86204 100644
--- a/libavcodec/fmvc.c
+++ b/libavcodec/fmvc.c
@@ -401,17 +401,20 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
     GetByteContext *gb = &s->gb;
     PutByteContext *pb = &s->pb;
     int ret, y, x;
-    int key_frame;
 
     if (avpkt->size < 8)
         return AVERROR_INVALIDDATA;
 
+    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
+        return ret;
+
     bytestream2_init(gb, avpkt->data, avpkt->size);
     bytestream2_skip(gb, 2);
 
-    key_frame = !!bytestream2_get_le16(gb);
+    frame->key_frame = !!bytestream2_get_le16(gb);
+    frame->pict_type = frame->key_frame ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;
 
-    if (key_frame) {
+    if (frame->key_frame) {
         const uint8_t *src;
         unsigned type, size;
         uint8_t *dst;
@@ -431,12 +434,6 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
             return AVERROR_PATCHWELCOME;
         }
 
-        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
-            return ret;
-
-        frame->key_frame = 1;
-        frame->pict_type = AV_PICTURE_TYPE_I;
-
         src = s->buffer;
         dst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];
         for (y = 0; y < avctx->height; y++) {
@@ -517,12 +514,6 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *frame,
             dst = &rect[block_h * s->stride];
         }
 
-        if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
-            return ret;
-
-        frame->key_frame = 0;
-        frame->pict_type = AV_PICTURE_TYPE_P;
-
         ssrc = s->buffer;
         ddst = frame->data[0] + (avctx->height - 1) * frame->linesize[0];
         for (y = 0; y < avctx->height; y++) {
@@ -645,6 +636,5 @@ const FFCodec ff_fmvc_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/fraps.c b/libavcodec/fraps.c
index 7f69530..92a1963 100644
--- a/libavcodec/fraps.c
+++ b/libavcodec/fraps.c
@@ -349,5 +349,4 @@ const FFCodec ff_fraps_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/frwu.c b/libavcodec/frwu.c
index 766fda7..e6ee050 100644
--- a/libavcodec/frwu.c
+++ b/libavcodec/frwu.c
@@ -125,5 +125,4 @@ const FFCodec ff_frwu_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.priv_class   = &frwu_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/g2meet.c b/libavcodec/g2meet.c
index 0096436..66ccd9a 100644
--- a/libavcodec/g2meet.c
+++ b/libavcodec/g2meet.c
@@ -1632,5 +1632,5 @@ const FFCodec ff_g2m_decoder = {
     .close          = g2m_decode_end,
     FF_CODEC_DECODE_CB(g2m_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/g722dec.c b/libavcodec/g722dec.c
index 8a02ec5..de2f666 100644
--- a/libavcodec/g722dec.c
+++ b/libavcodec/g722dec.c
@@ -149,5 +149,4 @@ const FFCodec ff_adpcm_g722_decoder = {
     FF_CODEC_DECODE_CB(g722_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.priv_class   = &g722_decoder_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/g722enc.c b/libavcodec/g722enc.c
index 325c392..2c0a501 100644
--- a/libavcodec/g722enc.c
+++ b/libavcodec/g722enc.c
@@ -388,5 +388,5 @@ const FFCodec ff_adpcm_g722_encoder = {
     .p.ch_layouts   = (const AVChannelLayout[]){
         AV_CHANNEL_LAYOUT_MONO, { 0 }
     },
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/g723_1dec.c b/libavcodec/g723_1dec.c
index d095f09..257a4e6 100644
--- a/libavcodec/g723_1dec.c
+++ b/libavcodec/g723_1dec.c
@@ -1121,5 +1121,4 @@ const FFCodec ff_g723_1_decoder = {
     FF_CODEC_DECODE_CB(g723_1_decode_frame),
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1,
     .p.priv_class   = &g723_1dec_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/g723_1enc.c b/libavcodec/g723_1enc.c
index e8fb842..4dc5dcd 100644
--- a/libavcodec/g723_1enc.c
+++ b/libavcodec/g723_1enc.c
@@ -1254,5 +1254,4 @@ const FFCodec ff_g723_1_encoder = {
     .p.ch_layouts   = (const AVChannelLayout[]){
         AV_CHANNEL_LAYOUT_MONO, { 0 }
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/g726.c b/libavcodec/g726.c
index 3bf0da3..6c9406d 100644
--- a/libavcodec/g726.c
+++ b/libavcodec/g726.c
@@ -413,7 +413,6 @@ const FFCodec ff_adpcm_g726_encoder = {
                                                      AV_SAMPLE_FMT_NONE },
     .p.priv_class   = &g726_class,
     .defaults       = defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -431,7 +430,6 @@ const FFCodec ff_adpcm_g726le_encoder = {
                                                      AV_SAMPLE_FMT_NONE },
     .p.priv_class   = &g726_class,
     .defaults       = defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -512,7 +510,6 @@ const FFCodec ff_adpcm_g726_decoder = {
     FF_CODEC_DECODE_CB(g726_decode_frame),
     .flush          = g726_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -527,6 +524,5 @@ const FFCodec ff_adpcm_g726le_decoder = {
     .flush          = g726_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.long_name    = NULL_IF_CONFIG_SMALL("G.726 ADPCM little-endian"),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/g729dec.c b/libavcodec/g729dec.c
index a306456..b678510 100644
--- a/libavcodec/g729dec.c
+++ b/libavcodec/g729dec.c
@@ -762,7 +762,6 @@ const FFCodec ff_g729_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .close          = decode_close,
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 
 const FFCodec ff_acelp_kelvin_decoder = {
@@ -775,5 +774,4 @@ const FFCodec ff_acelp_kelvin_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .close          = decode_close,
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/gdv.c b/libavcodec/gdv.c
index 70c2ad4..148204d 100644
--- a/libavcodec/gdv.c
+++ b/libavcodec/gdv.c
@@ -570,5 +570,4 @@ const FFCodec ff_gdv_decoder = {
     .close          = gdv_decode_close,
     FF_CODEC_DECODE_CB(gdv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/get_buffer.c b/libavcodec/get_buffer.c
index 3e45a04..05983e4 100644
--- a/libavcodec/get_buffer.c
+++ b/libavcodec/get_buffer.c
@@ -32,6 +32,7 @@
 
 #include "avcodec.h"
 #include "internal.h"
+#include "codec_internal.h"
 
 typedef struct FramePool {
     /**
@@ -147,6 +148,14 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
         for (i = 0; i < 4; i++) {
             pool->linesize[i] = linesize[i];
+
+            if (ffcodec(avctx->codec)->caps_internal & FF_CODEC_CAP_CONTIGUOUS_BUFFERS) {
+                if (!i)
+                    size[0] += size[1] + size[2] + size[3];
+                else
+                    continue;
+            }
+
             if (size[i]) {
                 if (size[i] > INT_MAX - (16 + STRIDE_ALIGN - 1)) {
                     ret = AVERROR(EINVAL);
@@ -273,6 +282,21 @@ static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
 
         pic->data[i] = pic->buf[i]->data;
     }
+
+    if (ffcodec(s->codec)->caps_internal & FF_CODEC_CAP_CONTIGUOUS_BUFFERS) {
+        int size;
+
+        for (i = 1; i < 4; i++) {
+            pic->linesize[i] = pool->linesize[i];
+            av_buffer_unref(&pic->buf[i]);
+        }
+
+        size = av_image_fill_pointers(pic->data, pic->format, pic->height,
+                                      pic->buf[0]->data, pic->linesize);
+        if (size < 0 || size > pic->buf[0]->size)
+            goto fail;
+    }
+
     for (; i < AV_NUM_DATA_POINTERS; i++) {
         pic->data[i] = NULL;
         pic->linesize[i] = 0;
diff --git a/libavcodec/gif.c b/libavcodec/gif.c
index 8c52c86..8e84b79 100644
--- a/libavcodec/gif.c
+++ b/libavcodec/gif.c
@@ -508,7 +508,7 @@ static int gif_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
 
     if (!s->image) {
         av_frame_unref(s->last_frame);
-        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);
+        ret = av_frame_ref(s->last_frame, pict);
         if (ret < 0)
             return ret;
     }
@@ -566,5 +566,5 @@ const FFCodec ff_gif_encoder = {
         AV_PIX_FMT_GRAY8, AV_PIX_FMT_PAL8, AV_PIX_FMT_NONE
     },
     .p.priv_class   = &gif_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/gifdec.c b/libavcodec/gifdec.c
index 3936de1..84ff8aa 100644
--- a/libavcodec/gifdec.c
+++ b/libavcodec/gifdec.c
@@ -475,7 +475,7 @@ static int gif_decode_frame(AVCodecContext *avctx, AVFrame *rframe,
 
     s->frame->pts     = avpkt->pts;
     s->frame->pkt_dts = avpkt->dts;
-    s->frame->pkt_duration = avpkt->duration;
+    s->frame->duration = avpkt->duration;
 
     if (avpkt->size >= 6) {
         s->keyframe = memcmp(avpkt->data, gif87a_sig, 6) == 0 ||
@@ -566,7 +566,6 @@ const FFCodec ff_gif_decoder = {
     .close          = gif_decode_close,
     FF_CODEC_DECODE_CB(gif_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class   = &decoder_class,
 };
diff --git a/libavcodec/gsmdec.c b/libavcodec/gsmdec.c
index e5b8d6f..dd8d80e 100644
--- a/libavcodec/gsmdec.c
+++ b/libavcodec/gsmdec.c
@@ -123,7 +123,6 @@ const FFCodec ff_gsm_decoder = {
     FF_CODEC_DECODE_CB(gsm_decode_frame),
     .flush          = gsm_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_GSM_MS_DECODER
@@ -137,6 +136,5 @@ const FFCodec ff_gsm_ms_decoder = {
     FF_CODEC_DECODE_CB(gsm_decode_frame),
     .flush          = gsm_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/h261dec.c b/libavcodec/h261dec.c
index 1699172..97c126a 100644
--- a/libavcodec/h261dec.c
+++ b/libavcodec/h261dec.c
@@ -214,7 +214,7 @@ static int h261_decode_mb_skipped(H261DecContext *h, int mba1, int mba2)
         s->mb_y = ((h->gob_number - 1) / 2) * 3 + i / 11;
         xy      = s->mb_x + s->mb_y * s->mb_stride;
         ff_init_block_index(s);
-        ff_update_block_index(s);
+        ff_update_block_index(s, 8, s->avctx->lowres, 1);
 
         for (j = 0; j < 6; j++)
             s->block_last_index[j] = -1;
@@ -400,7 +400,7 @@ static int h261_decode_mb(H261DecContext *h)
     s->mb_y = ((h->gob_number - 1) / 2) * 3 + ((h->current_mba - 1) / 11);
     xy      = s->mb_x + s->mb_y * s->mb_stride;
     ff_init_block_index(s);
-    ff_update_block_index(s);
+    ff_update_block_index(s, 8, s->avctx->lowres, 1);
 
     // Read mtype
     com->mtype = get_vlc2(&s->gb, h261_mtype_vlc.table, H261_MTYPE_VLC_BITS, 2);
@@ -690,6 +690,5 @@ const FFCodec ff_h261_decoder = {
     .close          = h261_decode_end,
     FF_CODEC_DECODE_CB(h261_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.max_lowres   = 3,
 };
diff --git a/libavcodec/h261enc.c b/libavcodec/h261enc.c
index 007bb4a..a1fba96 100644
--- a/libavcodec/h261enc.c
+++ b/libavcodec/h261enc.c
@@ -139,7 +139,7 @@ void ff_h261_reorder_mb_index(MpegEncContext *s)
         s->mb_y += 3 * index;
 
         ff_init_block_index(s);
-        ff_update_block_index(s);
+        ff_update_block_index(s, 8, 0, 1);
     }
 }
 
@@ -410,7 +410,7 @@ const FFCodec ff_h261_encoder = {
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
     .close          = ff_mpv_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
 };
diff --git a/libavcodec/h263dec.c b/libavcodec/h263dec.c
index d411bae..8db0ecc 100644
--- a/libavcodec/h263dec.c
+++ b/libavcodec/h263dec.c
@@ -258,7 +258,8 @@ static int decode_slice(MpegEncContext *s)
         for (; s->mb_x < s->mb_width; s->mb_x++) {
             int ret;
 
-            ff_update_block_index(s);
+            ff_update_block_index(s, s->avctx->bits_per_raw_sample,
+                                  s->avctx->lowres, s->chroma_x_shift);
 
             if (s->resync_mb_x == s->mb_x && s->resync_mb_y + 1 == s->mb_y)
                 s->first_slice_line = 0;
@@ -501,7 +502,7 @@ retry:
     /* let's go :-) */
     if (CONFIG_WMV2_DECODER && s->msmpeg4_version == 5) {
         ret = ff_wmv2_decode_picture_header(s);
-    } else if (CONFIG_MSMPEG4_DECODER && s->msmpeg4_version) {
+    } else if (CONFIG_MSMPEG4DEC && s->msmpeg4_version) {
         ret = ff_msmpeg4_decode_picture_header(s);
     } else if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {
         if (s->avctx->extradata_size && s->picture_number == 0) {
@@ -552,8 +553,6 @@ retry:
     avctx->has_b_frames = !s->low_delay;
 
     if (CONFIG_MPEG4_DECODER && avctx->codec_id == AV_CODEC_ID_MPEG4) {
-        if (s->pict_type != AV_PICTURE_TYPE_B && s->mb_num/2 > get_bits_left(&s->gb))
-            return AVERROR_INVALIDDATA;
         if (ff_mpeg4_workaround_bugs(avctx) == 1)
             goto retry;
         if (s->studio_profile != (s->idsp.idct == NULL))
@@ -667,7 +666,7 @@ retry:
 
     if (s->msmpeg4_version && s->msmpeg4_version < 4 &&
         s->pict_type == AV_PICTURE_TYPE_I)
-        if (!CONFIG_MSMPEG4_DECODER ||
+        if (!CONFIG_MSMPEG4DEC ||
             ff_msmpeg4_decode_ext_header(s, buf_size) < 0)
             s->er.error_status_table[s->mb_num - 1] = ER_MB_ERROR;
 
@@ -770,8 +769,7 @@ const FFCodec ff_h263_decoder = {
                       AV_CODEC_CAP_TRUNCATED |
 #endif
                       AV_CODEC_CAP_DELAY,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .flush          = ff_mpeg_flush,
     .p.max_lowres   = 3,
     .p.pix_fmts     = ff_h263_hwaccel_pixfmt_list_420,
@@ -792,8 +790,7 @@ const FFCodec ff_h263p_decoder = {
                       AV_CODEC_CAP_TRUNCATED |
 #endif
                       AV_CODEC_CAP_DELAY,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .flush          = ff_mpeg_flush,
     .p.max_lowres   = 3,
     .p.pix_fmts     = ff_h263_hwaccel_pixfmt_list_420,
diff --git a/libavcodec/h264_loopfilter.c b/libavcodec/h264_loopfilter.c
index 2440cfa..c164a28 100644
--- a/libavcodec/h264_loopfilter.c
+++ b/libavcodec/h264_loopfilter.c
@@ -143,7 +143,7 @@ static av_always_inline void filter_mb_edgecv(uint8_t *pix, int stride,
 
 static av_always_inline void filter_mb_mbaff_edgev(const H264Context *h, uint8_t *pix,
                                                    int stride,
-                                                   const int16_t bS[7], int bsi,
+                                                   const int16_t bS[ /* 1 + 2 * bsi */ ], int bsi,
                                                    int qp, int a, int b,
                                                    int intra)
 {
@@ -166,7 +166,7 @@ static av_always_inline void filter_mb_mbaff_edgev(const H264Context *h, uint8_t
 
 static av_always_inline void filter_mb_mbaff_edgecv(const H264Context *h,
                                                     uint8_t *pix, int stride,
-                                                    const int16_t bS[7],
+                                                    const int16_t bS[ /* 1 + 2 * bsi */ ],
                                                     int bsi, int qp, int a,
                                                     int b, int intra)
 {
diff --git a/libavcodec/h264_slice.c b/libavcodec/h264_slice.c
index d56722a..8f9d0a6 100644
--- a/libavcodec/h264_slice.c
+++ b/libavcodec/h264_slice.c
@@ -1649,7 +1649,7 @@ static int h264_field_start(H264Context *h, const H264SliceContext *sl,
 
     while (h->poc.frame_num != h->poc.prev_frame_num && !h->first_field &&
            h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {
-        H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;
+        const H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;
         av_log(h->avctx, AV_LOG_DEBUG, "Frame num gap %d %d\n",
                h->poc.frame_num, h->poc.prev_frame_num);
         if (!sps->gaps_in_frame_num_allowed_flag)
diff --git a/libavcodec/h264chroma.h b/libavcodec/h264chroma.h
index 3259b49..b8f9c8f 100644
--- a/libavcodec/h264chroma.h
+++ b/libavcodec/h264chroma.h
@@ -22,7 +22,7 @@
 #include <stddef.h>
 #include <stdint.h>
 
-typedef void (*h264_chroma_mc_func)(uint8_t *dst /*align 8*/, uint8_t *src /*align 1*/, ptrdiff_t srcStride, int h, int x, int y);
+typedef void (*h264_chroma_mc_func)(uint8_t *dst /*align 8*/, const uint8_t *src /*align 1*/, ptrdiff_t srcStride, int h, int x, int y);
 
 typedef struct H264ChromaContext {
     h264_chroma_mc_func put_h264_chroma_pixels_tab[4];
diff --git a/libavcodec/h264chroma_template.c b/libavcodec/h264chroma_template.c
index a3ca07b..b9d24f5 100644
--- a/libavcodec/h264chroma_template.c
+++ b/libavcodec/h264chroma_template.c
@@ -26,9 +26,9 @@
 #include "bit_depth_template.c"
 
 #define H264_CHROMA_MC(OPNAME, OP)\
-static void FUNCC(OPNAME ## h264_chroma_mc1)(uint8_t *_dst /*align 8*/, uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y){\
+static void FUNCC(OPNAME ## h264_chroma_mc1)(uint8_t *_dst /*align 8*/, const uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y){\
     pixel *dst = (pixel*)_dst;\
-    pixel *src = (pixel*)_src;\
+    const pixel *src = (const pixel*)_src;\
     const int A=(8-x)*(8-y);\
     const int B=(  x)*(8-y);\
     const int C=(8-x)*(  y);\
@@ -60,10 +60,10 @@ static void FUNCC(OPNAME ## h264_chroma_mc1)(uint8_t *_dst /*align 8*/, uint8_t
         }\
     }\
 }\
-static void FUNCC(OPNAME ## h264_chroma_mc2)(uint8_t *_dst /*align 8*/, uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y)\
+static void FUNCC(OPNAME ## h264_chroma_mc2)(uint8_t *_dst /*align 8*/, const uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y)\
 {\
     pixel *dst = (pixel*)_dst;\
-    pixel *src = (pixel*)_src;\
+    const pixel *src = (const pixel*)_src;\
     const int A=(8-x)*(8-y);\
     const int B=(  x)*(8-y);\
     const int C=(8-x)*(  y);\
@@ -99,10 +99,10 @@ static void FUNCC(OPNAME ## h264_chroma_mc2)(uint8_t *_dst /*align 8*/, uint8_t
     }\
 }\
 \
-static void FUNCC(OPNAME ## h264_chroma_mc4)(uint8_t *_dst /*align 8*/, uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y)\
+static void FUNCC(OPNAME ## h264_chroma_mc4)(uint8_t *_dst /*align 8*/, const uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y)\
 {\
     pixel *dst = (pixel*)_dst;\
-    pixel *src = (pixel*)_src;\
+    const pixel *src = (const pixel*)_src;\
     const int A=(8-x)*(8-y);\
     const int B=(  x)*(8-y);\
     const int C=(8-x)*(  y);\
@@ -144,10 +144,10 @@ static void FUNCC(OPNAME ## h264_chroma_mc4)(uint8_t *_dst /*align 8*/, uint8_t
     }\
 }\
 \
-static void FUNCC(OPNAME ## h264_chroma_mc8)(uint8_t *_dst /*align 8*/, uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y)\
+static void FUNCC(OPNAME ## h264_chroma_mc8)(uint8_t *_dst /*align 8*/, const uint8_t *_src /*align 1*/, ptrdiff_t stride, int h, int x, int y)\
 {\
     pixel *dst = (pixel*)_dst;\
-    pixel *src = (pixel*)_src;\
+    const pixel *src = (const pixel*)_src;\
     const int A=(8-x)*(8-y);\
     const int B=(  x)*(8-y);\
     const int C=(8-x)*(  y);\
diff --git a/libavcodec/h264dec.c b/libavcodec/h264dec.c
index 2a5b53e..fc7b2c7 100644
--- a/libavcodec/h264dec.c
+++ b/libavcodec/h264dec.c
@@ -1102,7 +1102,7 @@ const FFCodec ff_h264_decoder = {
 #endif
                                NULL
                            },
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_EXPORTS_CROPPING |
+    .caps_internal         = FF_CODEC_CAP_EXPORTS_CROPPING |
                              FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP,
     .flush                 = h264_decode_flush,
     .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_h264_update_thread_context),
diff --git a/libavcodec/half2float.h b/libavcodec/half2float.h
index fd11caf..7df6747 100644
--- a/libavcodec/half2float.h
+++ b/libavcodec/half2float.h
@@ -61,8 +61,8 @@ static void half2float_table(uint32_t *mantissatable, uint32_t *exponenttable,
     offsettable[32] = 0;
 }
 
-static uint32_t half2float(uint16_t h, uint32_t *mantissatable, uint32_t *exponenttable,
-                           uint16_t *offsettable)
+static uint32_t half2float(uint16_t h, const uint32_t *mantissatable, const uint32_t *exponenttable,
+                           const uint16_t *offsettable)
 {
     uint32_t f;
 
diff --git a/libavcodec/hapdec.c b/libavcodec/hapdec.c
index 0aab1ab..beb0688 100644
--- a/libavcodec/hapdec.c
+++ b/libavcodec/hapdec.c
@@ -423,8 +423,7 @@ const FFCodec ff_hap_decoder = {
     .priv_data_size = sizeof(HapContext),
     .p.capabilities = AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .codec_tags     = (const uint32_t []){
         MKTAG('H','a','p','1'),
         MKTAG('H','a','p','5'),
diff --git a/libavcodec/hapenc.c b/libavcodec/hapenc.c
index 6a9d4e0..3dca25b 100644
--- a/libavcodec/hapenc.c
+++ b/libavcodec/hapenc.c
@@ -360,6 +360,5 @@ const FFCodec ff_hap_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_RGBA, AV_PIX_FMT_NONE,
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/hcadec.c b/libavcodec/hcadec.c
index 7054575..4c81aa4 100644
--- a/libavcodec/hcadec.c
+++ b/libavcodec/hcadec.c
@@ -450,7 +450,7 @@ const FFCodec ff_hca_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .close          = decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
 };
diff --git a/libavcodec/hcom.c b/libavcodec/hcom.c
index 74a13e0..9fd47b4 100644
--- a/libavcodec/hcom.c
+++ b/libavcodec/hcom.c
@@ -144,5 +144,5 @@ const FFCodec ff_hcom_decoder = {
     .close          = hcom_close,
     FF_CODEC_DECODE_CB(hcom_decode),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/hdr_parser.c b/libavcodec/hdr_parser.c
new file mode 100644
index 0000000..915fd38
--- /dev/null
+++ b/libavcodec/hdr_parser.c
@@ -0,0 +1,79 @@
+/*
+ * Radiance HDR parser
+ * Copyright (c) 2022 Paul B Mahol
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Radiance HDR parser
+ */
+
+#include "libavutil/intreadwrite.h"
+#include "parser.h"
+
+typedef struct HDRParseContext {
+    ParseContext pc;
+} HDRParseContext;
+
+static int hdr_parse(AVCodecParserContext *s, AVCodecContext *avctx,
+                     const uint8_t **poutbuf, int *poutbuf_size,
+                     const uint8_t *buf, int buf_size)
+{
+    HDRParseContext *ipc = s->priv_data;
+    uint64_t state = ipc->pc.state64;
+    int next = END_NOT_FOUND, i = 0;
+
+    *poutbuf_size = 0;
+    *poutbuf = NULL;
+
+    if (s->flags & PARSER_FLAG_COMPLETE_FRAMES) {
+        next = buf_size;
+    } else {
+        for (; i < buf_size; i++) {
+            state = (state << 8) | buf[i];
+            if (state == AV_RB64("ADIANCE\n") && (i > 10 || ipc->pc.index > 10)) {
+                next = i - 10;
+                break;
+            }
+        }
+
+        ipc->pc.state64 = state;
+        if (ff_combine_frame(&ipc->pc, next, &buf, &buf_size) < 0) {
+            *poutbuf = NULL;
+            *poutbuf_size = 0;
+            return buf_size;
+        }
+    }
+
+    *poutbuf      = buf;
+    *poutbuf_size = buf_size;
+
+    s->pict_type = AV_PICTURE_TYPE_I;
+    s->key_frame = 1;
+    s->duration  = 1;
+
+    return next;
+}
+
+const AVCodecParser ff_hdr_parser = {
+    .codec_ids      = { AV_CODEC_ID_RADIANCE_HDR },
+    .priv_data_size = sizeof(HDRParseContext),
+    .parser_parse   = hdr_parse,
+    .parser_close   = ff_parse_close,
+};
diff --git a/libavcodec/hdrdec.c b/libavcodec/hdrdec.c
new file mode 100644
index 0000000..29e8705
--- /dev/null
+++ b/libavcodec/hdrdec.c
@@ -0,0 +1,222 @@
+/*
+ * Radiance HDR image format
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdlib.h>
+
+#include "libavutil/imgutils.h"
+#include "avcodec.h"
+#include "internal.h"
+#include "bytestream.h"
+#include "codec_internal.h"
+#include "thread.h"
+
+#define MINELEN 8
+#define MAXELEN 0x7fff
+
+static int hdr_get_line(GetByteContext *gb, uint8_t *buffer, int size)
+{
+    int n = 0, c;
+
+    memset(buffer, 0, size);
+
+    do {
+        c = bytestream2_get_byte(gb);
+        if (n < size - 1)
+            buffer[n++] = c;
+    } while (bytestream2_get_bytes_left(gb) > 0 && c != '\n');
+
+    return 0;
+}
+
+static float convert(int expo, int val)
+{
+    if (expo == -128) {
+        return 0.f;
+    } else {
+        const float v = val / 256.f;
+
+        return ldexpf(v, expo);
+    }
+}
+
+static int decompress(uint8_t *scanline, int w, GetByteContext *gb, const uint8_t *start)
+{
+    int rshift = 0;
+
+    while (w > 0) {
+        scanline[0] = bytestream2_get_byte(gb);
+        scanline[1] = bytestream2_get_byte(gb);
+        scanline[2] = bytestream2_get_byte(gb);
+        scanline[3] = bytestream2_get_byte(gb);
+
+        if (scanline[0] == 1 &&
+            scanline[1] == 1 &&
+            scanline[2] == 1) {
+            int run = scanline[3];
+            for (int i = run << rshift; i > 0 && w > 0 && scanline >= start + 4; i--) {
+                memcpy(scanline, scanline - 4, 4);
+                scanline += 4;
+            }
+            w -= run << rshift;
+            rshift += 8;
+            if (rshift > 16)
+                break;
+        } else {
+            scanline += 4;
+            w--;
+            rshift = 0;
+        }
+    }
+
+    return 1;
+}
+
+static int hdr_decode_frame(AVCodecContext *avctx, AVFrame *p,
+                            int *got_frame, AVPacket *avpkt)
+{
+    const uint8_t *buf = avpkt->data;
+    int ret, buf_size = avpkt->size;
+    int width = 0, height = 0;
+    GetByteContext gb;
+    uint8_t line[512];
+    float sar;
+
+    bytestream2_init(&gb, buf, buf_size);
+    hdr_get_line(&gb, line, sizeof(line));
+    if (memcmp("#?RADIANCE\n", line, 11))
+        return AVERROR_INVALIDDATA;
+
+    do {
+        hdr_get_line(&gb, line, sizeof(line));
+        if (sscanf(line, "PIXASPECT=%f\n", &sar) == 1)
+            avctx->sample_aspect_ratio = p->sample_aspect_ratio = av_inv_q(av_d2q(sar, 4096));
+    } while (line[0] != '\n' && line[0]);
+
+    hdr_get_line(&gb, line, sizeof(line));
+    if (sscanf(line, "-Y %d +X %d\n", &height, &width) == 2) {
+        ;
+    } else if (sscanf(line, "+Y %d +X %d\n", &height, &width) == 2) {
+        ;
+    } else if (sscanf(line, "-Y %d -X %d\n", &height, &width) == 2) {
+        ;
+    } else if (sscanf(line, "+Y %d -X %d\n", &height, &width) == 2) {
+        ;
+    } else if (sscanf(line, "-X %d +Y %d\n", &width, &height) == 2) {
+        ;
+    } else if (sscanf(line, "+X %d +Y %d\n", &width, &height) == 2) {
+        ;
+    } else if (sscanf(line, "-X %d -Y %d\n", &width, &height) == 2) {
+        ;
+    } else if (sscanf(line, "+X %d -Y %d\n", &width, &height) == 2) {
+        ;
+    }
+
+    if ((ret = ff_set_dimensions(avctx, width, height)) < 0)
+        return ret;
+
+    avctx->pix_fmt = AV_PIX_FMT_GBRPF32;
+    if ((ret = ff_thread_get_buffer(avctx, p, 0)) < 0)
+        return ret;
+
+    for (int y = 0; y < height; y++) {
+        float *dst_r = (float *)(p->data[2] + y * p->linesize[2]);
+        float *dst_g = (float *)(p->data[0] + y * p->linesize[0]);
+        float *dst_b = (float *)(p->data[1] + y * p->linesize[1]);
+        uint8_t *scanline = p->data[0] + y * p->linesize[0];
+        int i;
+
+        if (width < MINELEN || width > MAXELEN) {
+            decompress(scanline, width, &gb, scanline);
+            goto convert;
+        }
+
+        i = bytestream2_peek_byte(&gb);
+        if (i != 2) {
+            decompress(scanline, width, &gb, scanline);
+            goto convert;
+        }
+        bytestream2_skip(&gb, 1);
+
+        scanline[1] = bytestream2_get_byte(&gb);
+        scanline[2] = bytestream2_get_byte(&gb);
+        i = bytestream2_get_byte(&gb);
+
+        if (scanline[1] != 2 || scanline[2] & 128) {
+            scanline[0] = 2;
+            scanline[3] = i;
+            decompress(scanline + 4, width - 1, &gb, scanline);
+            goto convert;
+        }
+
+        for (int i = 0; i < 4; i++) {
+            uint8_t *scanline = p->data[0] + y * p->linesize[0] + i;
+
+            for (int j = 0; j < width * 4 && bytestream2_get_bytes_left(&gb) > 0;) {
+                int run = bytestream2_get_byte(&gb);
+                if (run > 128) {
+                    uint8_t val = bytestream2_get_byte(&gb);
+                    run &= 127;
+                    while (run--) {
+                        if (j >= width * 4)
+                            break;
+                        scanline[j] = val;
+                        j += 4;
+                    }
+                } else if (run > 0) {
+                    while (run--) {
+                        if (j >= width * 4)
+                            break;
+                        scanline[j] = bytestream2_get_byte(&gb);
+                        j += 4;
+                    }
+                }
+            }
+        }
+
+convert:
+        for (int x = 0; x < width; x++) {
+            uint8_t rgbe[4];
+            int expo;
+
+            memcpy(rgbe, p->data[0] + y * p->linesize[0] + x * 4, 4);
+            expo = rgbe[3] - 128;
+
+            dst_r[x] = convert(expo, rgbe[0]);
+            dst_b[x] = convert(expo, rgbe[2]);
+            dst_g[x] = convert(expo, rgbe[1]);
+        }
+    }
+
+    p->key_frame = 1;
+    p->pict_type = AV_PICTURE_TYPE_I;
+
+    *got_frame   = 1;
+
+    return buf_size;
+}
+
+const FFCodec ff_hdr_decoder = {
+    .p.name         = "hdr",
+    .p.long_name    = NULL_IF_CONFIG_SMALL("HDR (Radiance RGBE format) image"),
+    .p.type         = AVMEDIA_TYPE_VIDEO,
+    .p.id           = AV_CODEC_ID_RADIANCE_HDR,
+    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
+    FF_CODEC_DECODE_CB(hdr_decode_frame),
+};
diff --git a/libavcodec/hdrenc.c b/libavcodec/hdrenc.c
new file mode 100644
index 0000000..0da89c0
--- /dev/null
+++ b/libavcodec/hdrenc.c
@@ -0,0 +1,189 @@
+/*
+ * Radiance HDR image format
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavutil/imgutils.h"
+#include "avcodec.h"
+#include "bytestream.h"
+#include "codec_internal.h"
+#include "encode.h"
+
+typedef struct HDREncContext {
+    uint8_t *scanline;
+} HDREncContext;
+
+static av_cold int hdr_encode_init(AVCodecContext *avctx)
+{
+    HDREncContext *s = avctx->priv_data;
+
+    s->scanline = av_calloc(avctx->width * 4, sizeof(*s->scanline));
+    if (!s->scanline)
+        return AVERROR(ENOMEM);
+
+    return 0;
+}
+
+static av_cold int hdr_encode_close(AVCodecContext *avctx)
+{
+    HDREncContext *s = avctx->priv_data;
+
+    av_freep(&s->scanline);
+
+    return 0;
+}
+
+static void bytestream_put_str(uint8_t **buf, const char *const line)
+{
+    bytestream_put_buffer(buf, line, strlen(line));
+}
+
+static void float2rgbe(uint8_t *rgbe, float red, float green, float blue)
+{
+    float v;
+    int e;
+
+    v = FFMAX3(red, green, blue);
+
+    if (v < 1e-32f) {
+        rgbe[0] = rgbe[1] = rgbe[2] = rgbe[3] = 0;
+    } else {
+        v = frexpf(v, &e) * 256.f / v;
+
+        rgbe[0] = av_clip_uint8(red * v);
+        rgbe[1] = av_clip_uint8(green * v);
+        rgbe[2] = av_clip_uint8(blue * v);
+        rgbe[3] = av_clip_uint8(e + 128);
+    }
+}
+
+static void rle(uint8_t **buffer, const uint8_t *data, int width)
+{
+#define MIN_RLE 4
+    int cur = 0;
+
+    while (cur < width) {
+        int run_count = 0, old_run_count = 0;
+        int beg_run = cur;
+        uint8_t buf[2];
+
+        while (run_count < MIN_RLE && beg_run < width) {
+            beg_run += run_count;
+            old_run_count = run_count;
+            run_count = 1;
+            while ((beg_run + run_count < width) && (run_count < 127) &&
+                   (data[beg_run * 4] == data[(beg_run + run_count) * 4]))
+                run_count++;
+        }
+
+        if ((old_run_count > 1) && (old_run_count == beg_run - cur)) {
+            buf[0] = 128 + old_run_count;
+            buf[1] = data[cur * 4];
+            bytestream_put_buffer(buffer, buf, sizeof(buf));
+            cur = beg_run;
+        }
+
+        while (cur < beg_run) {
+            int nonrun_count = FFMIN(128, beg_run - cur);
+            buf[0] = nonrun_count;
+            bytestream_put_byte(buffer, buf[0]);
+            for (int n = 0; n < nonrun_count; n++)
+                bytestream_put_byte(buffer, data[(cur + n) * 4]);
+            cur += nonrun_count;
+        }
+
+        if (run_count >= MIN_RLE) {
+            buf[0] = 128 + run_count;
+            buf[1] = data[beg_run * 4];
+            bytestream_put_buffer(buffer, buf, sizeof(buf));
+            cur += run_count;
+        }
+    }
+}
+
+static int hdr_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
+                            const AVFrame *frame, int *got_packet)
+{
+    HDREncContext *s = avctx->priv_data;
+    int64_t packet_size;
+    uint8_t *buf;
+    int ret;
+
+    packet_size = avctx->width * avctx->height * 4LL + 1024LL;
+    if ((ret = ff_get_encode_buffer(avctx, pkt, packet_size, 0)) < 0)
+        return ret;
+
+    buf = pkt->data;
+    bytestream_put_str(&buf, "#?RADIANCE\n");
+    bytestream_put_str(&buf, "SOFTWARE=lavc\n");
+    ret = snprintf(buf, 32, "PIXASPECT=%f\n", av_q2d(av_inv_q(avctx->sample_aspect_ratio)));
+    if (ret > 0)
+        buf += ret;
+    bytestream_put_str(&buf, "FORMAT=32-bit_rle_rgbe\n\n");
+    ret = snprintf(buf, 32, "-Y %d +X %d\n", avctx->height, avctx->width);
+    if (ret > 0)
+        buf += ret;
+
+    for (int y = 0; y < avctx->height; y++) {
+        const float *red   = (const float *)(frame->data[2] + y * frame->linesize[2]);
+        const float *green = (const float *)(frame->data[0] + y * frame->linesize[0]);
+        const float *blue  = (const float *)(frame->data[1] + y * frame->linesize[1]);
+
+        if (avctx->width < 8 || avctx->width > 0x7fff) {
+            for (int x = 0; x < avctx->width; x++) {
+                float2rgbe(buf, red[x], green[x], blue[x]);
+                buf += 4;
+            }
+        } else {
+            bytestream_put_byte(&buf, 2);
+            bytestream_put_byte(&buf, 2);
+            bytestream_put_byte(&buf, avctx->width >> 8);
+            bytestream_put_byte(&buf, avctx->width & 0xFF);
+
+            for (int x = 0; x < avctx->width; x++)
+                float2rgbe(s->scanline + 4 * x, red[x], green[x], blue[x]);
+            for (int p = 0; p < 4; p++)
+                rle(&buf, s->scanline + p, avctx->width);
+        }
+    }
+
+    pkt->flags |= AV_PKT_FLAG_KEY;
+
+    av_shrink_packet(pkt, buf - pkt->data);
+
+    *got_packet = 1;
+
+    return 0;
+}
+
+const FFCodec ff_hdr_encoder = {
+    .p.name         = "hdr",
+    .p.long_name    = NULL_IF_CONFIG_SMALL("HDR (Radiance RGBE format) image"),
+    .priv_data_size = sizeof(HDREncContext),
+    .p.type         = AVMEDIA_TYPE_VIDEO,
+    .p.id           = AV_CODEC_ID_RADIANCE_HDR,
+    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
+    .init           = hdr_encode_init,
+    FF_CODEC_ENCODE_CB(hdr_encode_frame),
+    .close          = hdr_encode_close,
+    .p.pix_fmts     = (const enum AVPixelFormat[]){
+        AV_PIX_FMT_GBRPF32,
+        AV_PIX_FMT_NONE
+    },
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+};
diff --git a/libavcodec/hevc_cabac.c b/libavcodec/hevc_cabac.c
index a194f8a..6b38da8 100644
--- a/libavcodec/hevc_cabac.c
+++ b/libavcodec/hevc_cabac.c
@@ -447,25 +447,26 @@ static const uint8_t diag_scan8x8_inv[8][8] = {
     { 28, 36, 43, 49, 54, 58, 61, 63, },
 };
 
-void ff_hevc_save_states(HEVCContext *s, int ctb_addr_ts)
+void ff_hevc_save_states(HEVCLocalContext *lc, int ctb_addr_ts)
 {
+    const HEVCContext *const s = lc->parent;
+
     if (s->ps.pps->entropy_coding_sync_enabled_flag &&
         (ctb_addr_ts % s->ps.sps->ctb_width == 2 ||
          (s->ps.sps->ctb_width == 2 &&
           ctb_addr_ts % s->ps.sps->ctb_width == 0))) {
-        memcpy(s->cabac_state, s->HEVClc->cabac_state, HEVC_CONTEXTS);
+        memcpy(lc->common_cabac_state->state, lc->cabac_state, HEVC_CONTEXTS);
         if (s->ps.sps->persistent_rice_adaptation_enabled_flag) {
-            memcpy(s->stat_coeff, s->HEVClc->stat_coeff, HEVC_STAT_COEFFS);
+            memcpy(lc->common_cabac_state->stat_coeff, lc->stat_coeff, HEVC_STAT_COEFFS);
         }
     }
 }
 
-static void load_states(HEVCContext *s, int thread)
+static void load_states(HEVCLocalContext *lc, const HEVCContext *s)
 {
-    memcpy(s->HEVClc->cabac_state, s->cabac_state, HEVC_CONTEXTS);
+    memcpy(lc->cabac_state, lc->common_cabac_state->state, HEVC_CONTEXTS);
     if (s->ps.sps->persistent_rice_adaptation_enabled_flag) {
-        const HEVCContext *prev = s->sList[(thread + s->threads_number - 1) % s->threads_number];
-        memcpy(s->HEVClc->stat_coeff, prev->stat_coeff, HEVC_STAT_COEFFS);
+        memcpy(lc->stat_coeff, lc->common_cabac_state->stat_coeff, HEVC_STAT_COEFFS);
     }
 }
 
@@ -474,17 +475,17 @@ static int cabac_reinit(HEVCLocalContext *lc)
     return skip_bytes(&lc->cc, 0) == NULL ? AVERROR_INVALIDDATA : 0;
 }
 
-static int cabac_init_decoder(HEVCContext *s)
+static int cabac_init_decoder(HEVCLocalContext *lc)
 {
-    GetBitContext *gb = &s->HEVClc->gb;
+    GetBitContext *gb = &lc->gb;
     skip_bits(gb, 1);
     align_get_bits(gb);
-    return ff_init_cabac_decoder(&s->HEVClc->cc,
+    return ff_init_cabac_decoder(&lc->cc,
                           gb->buffer + get_bits_count(gb) / 8,
                           (get_bits_left(gb) + 7) / 8);
 }
 
-static void cabac_init_state(HEVCContext *s)
+static void cabac_init_state(HEVCLocalContext *lc, const HEVCContext *s)
 {
     int init_type = 2 - s->sh.slice_type;
     int i;
@@ -501,31 +502,33 @@ static void cabac_init_state(HEVCContext *s)
         pre ^= pre >> 31;
         if (pre > 124)
             pre = 124 + (pre & 1);
-        s->HEVClc->cabac_state[i] = pre;
+        lc->cabac_state[i] = pre;
     }
 
     for (i = 0; i < 4; i++)
-        s->HEVClc->stat_coeff[i] = 0;
+        lc->stat_coeff[i] = 0;
 }
 
-int ff_hevc_cabac_init(HEVCContext *s, int ctb_addr_ts, int thread)
+int ff_hevc_cabac_init(HEVCLocalContext *lc, int ctb_addr_ts)
 {
+    const HEVCContext *const s = lc->parent;
+
     if (ctb_addr_ts == s->ps.pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs]) {
-        int ret = cabac_init_decoder(s);
+        int ret = cabac_init_decoder(lc);
         if (ret < 0)
             return ret;
         if (s->sh.dependent_slice_segment_flag == 0 ||
             (s->ps.pps->tiles_enabled_flag &&
              s->ps.pps->tile_id[ctb_addr_ts] != s->ps.pps->tile_id[ctb_addr_ts - 1]))
-            cabac_init_state(s);
+            cabac_init_state(lc, s);
 
         if (!s->sh.first_slice_in_pic_flag &&
             s->ps.pps->entropy_coding_sync_enabled_flag) {
             if (ctb_addr_ts % s->ps.sps->ctb_width == 0) {
                 if (s->ps.sps->ctb_width == 1)
-                    cabac_init_state(s);
+                    cabac_init_state(lc, s);
                 else if (s->sh.dependent_slice_segment_flag == 1)
-                    load_states(s, thread);
+                    load_states(lc, s);
             }
         }
     } else {
@@ -533,111 +536,112 @@ int ff_hevc_cabac_init(HEVCContext *s, int ctb_addr_ts, int thread)
             s->ps.pps->tile_id[ctb_addr_ts] != s->ps.pps->tile_id[ctb_addr_ts - 1]) {
             int ret;
             if (s->threads_number == 1)
-                ret = cabac_reinit(s->HEVClc);
+                ret = cabac_reinit(lc);
             else {
-                ret = cabac_init_decoder(s);
+                ret = cabac_init_decoder(lc);
             }
             if (ret < 0)
                 return ret;
-            cabac_init_state(s);
+            cabac_init_state(lc, s);
         }
         if (s->ps.pps->entropy_coding_sync_enabled_flag) {
             if (ctb_addr_ts % s->ps.sps->ctb_width == 0) {
                 int ret;
-                get_cabac_terminate(&s->HEVClc->cc);
+                get_cabac_terminate(&lc->cc);
                 if (s->threads_number == 1)
-                    ret = cabac_reinit(s->HEVClc);
+                    ret = cabac_reinit(lc);
                 else {
-                    ret = cabac_init_decoder(s);
+                    ret = cabac_init_decoder(lc);
                 }
                 if (ret < 0)
                     return ret;
 
                 if (s->ps.sps->ctb_width == 1)
-                    cabac_init_state(s);
+                    cabac_init_state(lc, s);
                 else
-                    load_states(s, thread);
+                    load_states(lc, s);
             }
         }
     }
     return 0;
 }
 
-#define GET_CABAC(ctx) get_cabac(&s->HEVClc->cc, &s->HEVClc->cabac_state[ctx])
+#define GET_CABAC(ctx)  get_cabac(&lc->cc, &lc->cabac_state[ctx])
 
-int ff_hevc_sao_merge_flag_decode(HEVCContext *s)
+int ff_hevc_sao_merge_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[SAO_MERGE_FLAG]);
 }
 
-int ff_hevc_sao_type_idx_decode(HEVCContext *s)
+int ff_hevc_sao_type_idx_decode(HEVCLocalContext *lc)
 {
     if (!GET_CABAC(elem_offset[SAO_TYPE_IDX]))
         return 0;
 
-    if (!get_cabac_bypass(&s->HEVClc->cc))
+    if (!get_cabac_bypass(&lc->cc))
         return SAO_BAND;
     return SAO_EDGE;
 }
 
-int ff_hevc_sao_band_position_decode(HEVCContext *s)
+int ff_hevc_sao_band_position_decode(HEVCLocalContext *lc)
 {
     int i;
-    int value = get_cabac_bypass(&s->HEVClc->cc);
+    int value = get_cabac_bypass(&lc->cc);
 
     for (i = 0; i < 4; i++)
-        value = (value << 1) | get_cabac_bypass(&s->HEVClc->cc);
+        value = (value << 1) | get_cabac_bypass(&lc->cc);
     return value;
 }
 
-int ff_hevc_sao_offset_abs_decode(HEVCContext *s)
+int ff_hevc_sao_offset_abs_decode(HEVCLocalContext *lc)
 {
     int i = 0;
-    int length = (1 << (FFMIN(s->ps.sps->bit_depth, 10) - 5)) - 1;
+    int length = (1 << (FFMIN(lc->parent->ps.sps->bit_depth, 10) - 5)) - 1;
 
-    while (i < length && get_cabac_bypass(&s->HEVClc->cc))
+    while (i < length && get_cabac_bypass(&lc->cc))
         i++;
     return i;
 }
 
-int ff_hevc_sao_offset_sign_decode(HEVCContext *s)
+int ff_hevc_sao_offset_sign_decode(HEVCLocalContext *lc)
 {
-    return get_cabac_bypass(&s->HEVClc->cc);
+    return get_cabac_bypass(&lc->cc);
 }
 
-int ff_hevc_sao_eo_class_decode(HEVCContext *s)
+int ff_hevc_sao_eo_class_decode(HEVCLocalContext *lc)
 {
-    int ret = get_cabac_bypass(&s->HEVClc->cc) << 1;
-    ret    |= get_cabac_bypass(&s->HEVClc->cc);
+    int ret = get_cabac_bypass(&lc->cc) << 1;
+    ret    |= get_cabac_bypass(&lc->cc);
     return ret;
 }
 
-int ff_hevc_end_of_slice_flag_decode(HEVCContext *s)
+int ff_hevc_end_of_slice_flag_decode(HEVCLocalContext *lc)
 {
-    return get_cabac_terminate(&s->HEVClc->cc);
+    return get_cabac_terminate(&lc->cc);
 }
 
-int ff_hevc_cu_transquant_bypass_flag_decode(HEVCContext *s)
+int ff_hevc_cu_transquant_bypass_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[CU_TRANSQUANT_BYPASS_FLAG]);
 }
 
-int ff_hevc_skip_flag_decode(HEVCContext *s, int x0, int y0, int x_cb, int y_cb)
+int ff_hevc_skip_flag_decode(HEVCLocalContext *lc, int x0, int y0, int x_cb, int y_cb)
 {
+    const HEVCContext *const s = lc->parent;
     int min_cb_width = s->ps.sps->min_cb_width;
     int inc = 0;
     int x0b = av_mod_uintp2(x0, s->ps.sps->log2_ctb_size);
     int y0b = av_mod_uintp2(y0, s->ps.sps->log2_ctb_size);
 
-    if (s->HEVClc->ctb_left_flag || x0b)
+    if (lc->ctb_left_flag || x0b)
         inc = !!SAMPLE_CTB(s->skip_flag, x_cb - 1, y_cb);
-    if (s->HEVClc->ctb_up_flag || y0b)
+    if (lc->ctb_up_flag || y0b)
         inc += !!SAMPLE_CTB(s->skip_flag, x_cb, y_cb - 1);
 
     return GET_CABAC(elem_offset[SKIP_FLAG] + inc);
 }
 
-int ff_hevc_cu_qp_delta_abs(HEVCContext *s)
+int ff_hevc_cu_qp_delta_abs(HEVCLocalContext *lc)
 {
     int prefix_val = 0;
     int suffix_val = 0;
@@ -649,34 +653,34 @@ int ff_hevc_cu_qp_delta_abs(HEVCContext *s)
     }
     if (prefix_val >= 5) {
         int k = 0;
-        while (k < 7 && get_cabac_bypass(&s->HEVClc->cc)) {
+        while (k < 7 && get_cabac_bypass(&lc->cc)) {
             suffix_val += 1 << k;
             k++;
         }
         if (k == 7) {
-            av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", k);
+            av_log(lc->logctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", k);
             return AVERROR_INVALIDDATA;
         }
 
         while (k--)
-            suffix_val += get_cabac_bypass(&s->HEVClc->cc) << k;
+            suffix_val += get_cabac_bypass(&lc->cc) << k;
     }
     return prefix_val + suffix_val;
 }
 
-int ff_hevc_cu_qp_delta_sign_flag(HEVCContext *s)
+int ff_hevc_cu_qp_delta_sign_flag(HEVCLocalContext *lc)
 {
-    return get_cabac_bypass(&s->HEVClc->cc);
+    return get_cabac_bypass(&lc->cc);
 }
 
-int ff_hevc_cu_chroma_qp_offset_flag(HEVCContext *s)
+int ff_hevc_cu_chroma_qp_offset_flag(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[CU_CHROMA_QP_OFFSET_FLAG]);
 }
 
-int ff_hevc_cu_chroma_qp_offset_idx(HEVCContext *s)
+int ff_hevc_cu_chroma_qp_offset_idx(HEVCLocalContext *lc)
 {
-    int c_max= FFMAX(5, s->ps.pps->chroma_qp_offset_list_len_minus1);
+    int c_max= FFMAX(5, lc->parent->ps.pps->chroma_qp_offset_list_len_minus1);
     int i = 0;
 
     while (i < c_max && GET_CABAC(elem_offset[CU_CHROMA_QP_OFFSET_IDX]))
@@ -685,23 +689,25 @@ int ff_hevc_cu_chroma_qp_offset_idx(HEVCContext *s)
     return i;
 }
 
-int ff_hevc_pred_mode_decode(HEVCContext *s)
+int ff_hevc_pred_mode_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[PRED_MODE_FLAG]);
 }
 
-int ff_hevc_split_coding_unit_flag_decode(HEVCContext *s, int ct_depth, int x0, int y0)
+int ff_hevc_split_coding_unit_flag_decode(HEVCLocalContext *lc, int ct_depth, int x0, int y0)
 {
+    const HEVCContext *const s = lc->parent;
+    const HEVCSPS *const sps = s->ps.sps;
     int inc = 0, depth_left = 0, depth_top = 0;
-    int x0b  = av_mod_uintp2(x0, s->ps.sps->log2_ctb_size);
-    int y0b  = av_mod_uintp2(y0, s->ps.sps->log2_ctb_size);
-    int x_cb = x0 >> s->ps.sps->log2_min_cb_size;
-    int y_cb = y0 >> s->ps.sps->log2_min_cb_size;
+    int x0b  = av_mod_uintp2(x0, sps->log2_ctb_size);
+    int y0b  = av_mod_uintp2(y0, sps->log2_ctb_size);
+    int x_cb = x0 >> sps->log2_min_cb_size;
+    int y_cb = y0 >> sps->log2_min_cb_size;
 
-    if (s->HEVClc->ctb_left_flag || x0b)
-        depth_left = s->tab_ct_depth[(y_cb) * s->ps.sps->min_cb_width + x_cb - 1];
-    if (s->HEVClc->ctb_up_flag || y0b)
-        depth_top = s->tab_ct_depth[(y_cb - 1) * s->ps.sps->min_cb_width + x_cb];
+    if (lc->ctb_left_flag || x0b)
+        depth_left = s->tab_ct_depth[(y_cb)     * sps->min_cb_width + x_cb - 1];
+    if (lc->ctb_up_flag || y0b)
+        depth_top  = s->tab_ct_depth[(y_cb - 1) * sps->min_cb_width + x_cb];
 
     inc += (depth_left > ct_depth);
     inc += (depth_top  > ct_depth);
@@ -709,12 +715,12 @@ int ff_hevc_split_coding_unit_flag_decode(HEVCContext *s, int ct_depth, int x0,
     return GET_CABAC(elem_offset[SPLIT_CODING_UNIT_FLAG] + inc);
 }
 
-int ff_hevc_part_mode_decode(HEVCContext *s, int log2_cb_size)
+int ff_hevc_part_mode_decode(HEVCLocalContext *lc, int log2_cb_size)
 {
     if (GET_CABAC(elem_offset[PART_MODE])) // 1
         return PART_2Nx2N;
-    if (log2_cb_size == s->ps.sps->log2_min_cb_size) {
-        if (s->HEVClc->cu.pred_mode == MODE_INTRA) // 0
+    if (log2_cb_size == lc->parent->ps.sps->log2_min_cb_size) {
+        if (lc->cu.pred_mode == MODE_INTRA) // 0
             return PART_NxN;
         if (GET_CABAC(elem_offset[PART_MODE] + 1)) // 01
             return PART_2NxN;
@@ -725,7 +731,7 @@ int ff_hevc_part_mode_decode(HEVCContext *s, int log2_cb_size)
         return PART_NxN; // 000
     }
 
-    if (!s->ps.sps->amp_enabled_flag) {
+    if (!lc->parent->ps.sps->amp_enabled_flag) {
         if (GET_CABAC(elem_offset[PART_MODE] + 1)) // 01
             return PART_2NxN;
         return PART_Nx2N;
@@ -734,84 +740,84 @@ int ff_hevc_part_mode_decode(HEVCContext *s, int log2_cb_size)
     if (GET_CABAC(elem_offset[PART_MODE] + 1)) { // 01X, 01XX
         if (GET_CABAC(elem_offset[PART_MODE] + 3)) // 011
             return PART_2NxN;
-        if (get_cabac_bypass(&s->HEVClc->cc)) // 0101
+        if (get_cabac_bypass(&lc->cc)) // 0101
             return PART_2NxnD;
         return PART_2NxnU; // 0100
     }
 
     if (GET_CABAC(elem_offset[PART_MODE] + 3)) // 001
         return PART_Nx2N;
-    if (get_cabac_bypass(&s->HEVClc->cc)) // 0001
+    if (get_cabac_bypass(&lc->cc)) // 0001
         return PART_nRx2N;
     return PART_nLx2N;  // 0000
 }
 
-int ff_hevc_pcm_flag_decode(HEVCContext *s)
+int ff_hevc_pcm_flag_decode(HEVCLocalContext *lc)
 {
-    return get_cabac_terminate(&s->HEVClc->cc);
+    return get_cabac_terminate(&lc->cc);
 }
 
-int ff_hevc_prev_intra_luma_pred_flag_decode(HEVCContext *s)
+int ff_hevc_prev_intra_luma_pred_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[PREV_INTRA_LUMA_PRED_FLAG]);
 }
 
-int ff_hevc_mpm_idx_decode(HEVCContext *s)
+int ff_hevc_mpm_idx_decode(HEVCLocalContext *lc)
 {
     int i = 0;
-    while (i < 2 && get_cabac_bypass(&s->HEVClc->cc))
+    while (i < 2 && get_cabac_bypass(&lc->cc))
         i++;
     return i;
 }
 
-int ff_hevc_rem_intra_luma_pred_mode_decode(HEVCContext *s)
+int ff_hevc_rem_intra_luma_pred_mode_decode(HEVCLocalContext *lc)
 {
     int i;
-    int value = get_cabac_bypass(&s->HEVClc->cc);
+    int value = get_cabac_bypass(&lc->cc);
 
     for (i = 0; i < 4; i++)
-        value = (value << 1) | get_cabac_bypass(&s->HEVClc->cc);
+        value = (value << 1) | get_cabac_bypass(&lc->cc);
     return value;
 }
 
-int ff_hevc_intra_chroma_pred_mode_decode(HEVCContext *s)
+int ff_hevc_intra_chroma_pred_mode_decode(HEVCLocalContext *lc)
 {
     int ret;
     if (!GET_CABAC(elem_offset[INTRA_CHROMA_PRED_MODE]))
         return 4;
 
-    ret  = get_cabac_bypass(&s->HEVClc->cc) << 1;
-    ret |= get_cabac_bypass(&s->HEVClc->cc);
+    ret  = get_cabac_bypass(&lc->cc) << 1;
+    ret |= get_cabac_bypass(&lc->cc);
     return ret;
 }
 
-int ff_hevc_merge_idx_decode(HEVCContext *s)
+int ff_hevc_merge_idx_decode(HEVCLocalContext *lc)
 {
     int i = GET_CABAC(elem_offset[MERGE_IDX]);
 
     if (i != 0) {
-        while (i < s->sh.max_num_merge_cand-1 && get_cabac_bypass(&s->HEVClc->cc))
+        while (i < lc->parent->sh.max_num_merge_cand-1 && get_cabac_bypass(&lc->cc))
             i++;
     }
     return i;
 }
 
-int ff_hevc_merge_flag_decode(HEVCContext *s)
+int ff_hevc_merge_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[MERGE_FLAG]);
 }
 
-int ff_hevc_inter_pred_idc_decode(HEVCContext *s, int nPbW, int nPbH)
+int ff_hevc_inter_pred_idc_decode(HEVCLocalContext *lc, int nPbW, int nPbH)
 {
     if (nPbW + nPbH == 12)
         return GET_CABAC(elem_offset[INTER_PRED_IDC] + 4);
-    if (GET_CABAC(elem_offset[INTER_PRED_IDC] + s->HEVClc->ct_depth))
+    if (GET_CABAC(elem_offset[INTER_PRED_IDC] + lc->ct_depth))
         return PRED_BI;
 
     return GET_CABAC(elem_offset[INTER_PRED_IDC] + 4);
 }
 
-int ff_hevc_ref_idx_lx_decode(HEVCContext *s, int num_ref_idx_lx)
+int ff_hevc_ref_idx_lx_decode(HEVCLocalContext *lc, int num_ref_idx_lx)
 {
     int i = 0;
     int max = num_ref_idx_lx - 1;
@@ -820,87 +826,88 @@ int ff_hevc_ref_idx_lx_decode(HEVCContext *s, int num_ref_idx_lx)
     while (i < max_ctx && GET_CABAC(elem_offset[REF_IDX_L0] + i))
         i++;
     if (i == 2) {
-        while (i < max && get_cabac_bypass(&s->HEVClc->cc))
+        while (i < max && get_cabac_bypass(&lc->cc))
             i++;
     }
 
     return i;
 }
 
-int ff_hevc_mvp_lx_flag_decode(HEVCContext *s)
+int ff_hevc_mvp_lx_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[MVP_LX_FLAG]);
 }
 
-int ff_hevc_no_residual_syntax_flag_decode(HEVCContext *s)
+int ff_hevc_no_residual_syntax_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[NO_RESIDUAL_DATA_FLAG]);
 }
 
-static av_always_inline int abs_mvd_greater0_flag_decode(HEVCContext *s)
+static av_always_inline int abs_mvd_greater0_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[ABS_MVD_GREATER0_FLAG]);
 }
 
-static av_always_inline int abs_mvd_greater1_flag_decode(HEVCContext *s)
+static av_always_inline int abs_mvd_greater1_flag_decode(HEVCLocalContext *lc)
 {
     return GET_CABAC(elem_offset[ABS_MVD_GREATER1_FLAG] + 1);
 }
 
-static av_always_inline int mvd_decode(HEVCContext *s)
+static av_always_inline int mvd_decode(HEVCLocalContext *lc)
 {
     int ret = 2;
     int k = 1;
 
-    while (k < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc)) {
+    while (k < CABAC_MAX_BIN && get_cabac_bypass(&lc->cc)) {
         ret += 1U << k;
         k++;
     }
     if (k == CABAC_MAX_BIN) {
-        av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", k);
+        av_log(lc->logctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", k);
         return 0;
     }
     while (k--)
-        ret += get_cabac_bypass(&s->HEVClc->cc) << k;
-    return get_cabac_bypass_sign(&s->HEVClc->cc, -ret);
+        ret += get_cabac_bypass(&lc->cc) << k;
+    return get_cabac_bypass_sign(&lc->cc, -ret);
 }
 
-static av_always_inline int mvd_sign_flag_decode(HEVCContext *s)
+static av_always_inline int mvd_sign_flag_decode(HEVCLocalContext *lc)
 {
-    return get_cabac_bypass_sign(&s->HEVClc->cc, -1);
+    return get_cabac_bypass_sign(&lc->cc, -1);
 }
 
-int ff_hevc_split_transform_flag_decode(HEVCContext *s, int log2_trafo_size)
+int ff_hevc_split_transform_flag_decode(HEVCLocalContext *lc, int log2_trafo_size)
 {
     return GET_CABAC(elem_offset[SPLIT_TRANSFORM_FLAG] + 5 - log2_trafo_size);
 }
 
-int ff_hevc_cbf_cb_cr_decode(HEVCContext *s, int trafo_depth)
+int ff_hevc_cbf_cb_cr_decode(HEVCLocalContext *lc, int trafo_depth)
 {
     return GET_CABAC(elem_offset[CBF_CB_CR] + trafo_depth);
 }
 
-int ff_hevc_cbf_luma_decode(HEVCContext *s, int trafo_depth)
+int ff_hevc_cbf_luma_decode(HEVCLocalContext *lc, int trafo_depth)
 {
     return GET_CABAC(elem_offset[CBF_LUMA] + !trafo_depth);
 }
 
-static int hevc_transform_skip_flag_decode(HEVCContext *s, int c_idx)
+static int hevc_transform_skip_flag_decode(HEVCLocalContext *lc, int c_idx)
 {
     return GET_CABAC(elem_offset[TRANSFORM_SKIP_FLAG] + !!c_idx);
 }
 
-static int explicit_rdpcm_flag_decode(HEVCContext *s, int c_idx)
+static int explicit_rdpcm_flag_decode(HEVCLocalContext *lc, int c_idx)
 {
     return GET_CABAC(elem_offset[EXPLICIT_RDPCM_FLAG] + !!c_idx);
 }
 
-static int explicit_rdpcm_dir_flag_decode(HEVCContext *s, int c_idx)
+static int explicit_rdpcm_dir_flag_decode(HEVCLocalContext *lc, int c_idx)
 {
     return GET_CABAC(elem_offset[EXPLICIT_RDPCM_DIR_FLAG] + !!c_idx);
 }
 
-int ff_hevc_log2_res_scale_abs(HEVCContext *s, int idx) {
+int ff_hevc_log2_res_scale_abs(HEVCLocalContext *lc, int idx)
+{
     int i =0;
 
     while (i < 4 && GET_CABAC(elem_offset[LOG2_RES_SCALE_ABS] + 4 * idx + i))
@@ -909,11 +916,12 @@ int ff_hevc_log2_res_scale_abs(HEVCContext *s, int idx) {
     return i;
 }
 
-int ff_hevc_res_scale_sign_flag(HEVCContext *s, int idx) {
+int ff_hevc_res_scale_sign_flag(HEVCLocalContext *lc, int idx)
+{
     return GET_CABAC(elem_offset[RES_SCALE_SIGN_FLAG] + idx);
 }
 
-static av_always_inline void last_significant_coeff_xy_prefix_decode(HEVCContext *s, int c_idx,
+static av_always_inline void last_significant_coeff_xy_prefix_decode(HEVCLocalContext *lc, int c_idx,
                                                    int log2_size, int *last_scx_prefix, int *last_scy_prefix)
 {
     int i = 0;
@@ -939,19 +947,19 @@ static av_always_inline void last_significant_coeff_xy_prefix_decode(HEVCContext
     *last_scy_prefix = i;
 }
 
-static av_always_inline int last_significant_coeff_suffix_decode(HEVCContext *s,
+static av_always_inline int last_significant_coeff_suffix_decode(HEVCLocalContext *lc,
                                                  int last_significant_coeff_prefix)
 {
     int i;
     int length = (last_significant_coeff_prefix >> 1) - 1;
-    int value = get_cabac_bypass(&s->HEVClc->cc);
+    int value = get_cabac_bypass(&lc->cc);
 
     for (i = 1; i < length; i++)
-        value = (value << 1) | get_cabac_bypass(&s->HEVClc->cc);
+        value = (value << 1) | get_cabac_bypass(&lc->cc);
     return value;
 }
 
-static av_always_inline int significant_coeff_group_flag_decode(HEVCContext *s, int c_idx, int ctx_cg)
+static av_always_inline int significant_coeff_group_flag_decode(HEVCLocalContext *lc, int c_idx, int ctx_cg)
 {
     int inc;
 
@@ -959,19 +967,19 @@ static av_always_inline int significant_coeff_group_flag_decode(HEVCContext *s,
 
     return GET_CABAC(elem_offset[SIGNIFICANT_COEFF_GROUP_FLAG] + inc);
 }
-static av_always_inline int significant_coeff_flag_decode(HEVCContext *s, int x_c, int y_c,
+static av_always_inline int significant_coeff_flag_decode(HEVCLocalContext *lc, int x_c, int y_c,
                                            int offset, const uint8_t *ctx_idx_map)
 {
     int inc = ctx_idx_map[(y_c << 2) + x_c] + offset;
     return GET_CABAC(elem_offset[SIGNIFICANT_COEFF_FLAG] + inc);
 }
 
-static av_always_inline int significant_coeff_flag_decode_0(HEVCContext *s, int c_idx, int offset)
+static av_always_inline int significant_coeff_flag_decode_0(HEVCLocalContext *lc, int c_idx, int offset)
 {
     return GET_CABAC(elem_offset[SIGNIFICANT_COEFF_FLAG] + offset);
 }
 
-static av_always_inline int coeff_abs_level_greater1_flag_decode(HEVCContext *s, int c_idx, int inc)
+static av_always_inline int coeff_abs_level_greater1_flag_decode(HEVCLocalContext *lc, int c_idx, int inc)
 {
 
     if (c_idx > 0)
@@ -980,7 +988,7 @@ static av_always_inline int coeff_abs_level_greater1_flag_decode(HEVCContext *s,
     return GET_CABAC(elem_offset[COEFF_ABS_LEVEL_GREATER1_FLAG] + inc);
 }
 
-static av_always_inline int coeff_abs_level_greater2_flag_decode(HEVCContext *s, int c_idx, int inc)
+static av_always_inline int coeff_abs_level_greater2_flag_decode(HEVCLocalContext *lc, int c_idx, int inc)
 {
     if (c_idx > 0)
         inc += 4;
@@ -988,47 +996,47 @@ static av_always_inline int coeff_abs_level_greater2_flag_decode(HEVCContext *s,
     return GET_CABAC(elem_offset[COEFF_ABS_LEVEL_GREATER2_FLAG] + inc);
 }
 
-static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)
+static av_always_inline int coeff_abs_level_remaining_decode(HEVCLocalContext *lc, int rc_rice_param)
 {
     int prefix = 0;
     int suffix = 0;
     int last_coeff_abs_level_remaining;
     int i;
 
-    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))
+    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&lc->cc))
         prefix++;
 
     if (prefix < 3) {
         for (i = 0; i < rc_rice_param; i++)
-            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);
+            suffix = (suffix << 1) | get_cabac_bypass(&lc->cc);
         last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;
     } else {
         int prefix_minus3 = prefix - 3;
 
         if (prefix == CABAC_MAX_BIN || prefix_minus3 + rc_rice_param > 16 + 6) {
-            av_log(s->avctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix);
+            av_log(lc->logctx, AV_LOG_ERROR, "CABAC_MAX_BIN : %d\n", prefix);
             return 0;
         }
 
         for (i = 0; i < prefix_minus3 + rc_rice_param; i++)
-            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);
+            suffix = (suffix << 1) | get_cabac_bypass(&lc->cc);
         last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)
                                               << rc_rice_param) + suffix;
     }
     return last_coeff_abs_level_remaining;
 }
 
-static av_always_inline int coeff_sign_flag_decode(HEVCContext *s, uint8_t nb)
+static av_always_inline int coeff_sign_flag_decode(HEVCLocalContext *lc, uint8_t nb)
 {
     int i;
     int ret = 0;
 
     for (i = 0; i < nb; i++)
-        ret = (ret << 1) | get_cabac_bypass(&s->HEVClc->cc);
+        ret = (ret << 1) | get_cabac_bypass(&lc->cc);
     return ret;
 }
 
-void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+void ff_hevc_hls_residual_coding(HEVCLocalContext *lc, int x0, int y0,
                                 int log2_trafo_size, enum ScanType scan_idx,
                                 int c_idx)
 {
@@ -1037,7 +1045,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
         x_c = (x_cg << 2) + scan_x_off[n];                      \
         y_c = (y_cg << 2) + scan_y_off[n];                      \
     } while (0)
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int transform_skip_flag = 0;
 
     int last_significant_coeff_x, last_significant_coeff_y;
@@ -1092,7 +1100,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
 
         if (s->ps.pps->transform_skip_enabled_flag &&
             log2_trafo_size <= s->ps.pps->log2_max_transform_skip_block_size) {
-            transform_skip_flag = hevc_transform_skip_flag_decode(s, c_idx);
+            transform_skip_flag = hevc_transform_skip_flag_decode(lc, c_idx);
         }
 
         if (c_idx == 0) {
@@ -1151,24 +1159,24 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
 
     if (lc->cu.pred_mode == MODE_INTER && s->ps.sps->explicit_rdpcm_enabled_flag &&
         (transform_skip_flag || lc->cu.cu_transquant_bypass_flag)) {
-        explicit_rdpcm_flag = explicit_rdpcm_flag_decode(s, c_idx);
+        explicit_rdpcm_flag = explicit_rdpcm_flag_decode(lc, c_idx);
         if (explicit_rdpcm_flag) {
-            explicit_rdpcm_dir_flag = explicit_rdpcm_dir_flag_decode(s, c_idx);
+            explicit_rdpcm_dir_flag = explicit_rdpcm_dir_flag_decode(lc, c_idx);
         }
     }
 
-    last_significant_coeff_xy_prefix_decode(s, c_idx, log2_trafo_size,
+    last_significant_coeff_xy_prefix_decode(lc, c_idx, log2_trafo_size,
                                            &last_significant_coeff_x, &last_significant_coeff_y);
 
     if (last_significant_coeff_x > 3) {
-        int suffix = last_significant_coeff_suffix_decode(s, last_significant_coeff_x);
+        int suffix = last_significant_coeff_suffix_decode(lc, last_significant_coeff_x);
         last_significant_coeff_x = (1 << ((last_significant_coeff_x >> 1) - 1)) *
         (2 + (last_significant_coeff_x & 1)) +
         suffix;
     }
 
     if (last_significant_coeff_y > 3) {
-        int suffix = last_significant_coeff_suffix_decode(s, last_significant_coeff_y);
+        int suffix = last_significant_coeff_suffix_decode(lc, last_significant_coeff_y);
         last_significant_coeff_y = (1 << ((last_significant_coeff_y >> 1) - 1)) *
         (2 + (last_significant_coeff_y & 1)) +
         suffix;
@@ -1247,7 +1255,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                 ctx_cg += significant_coeff_group_flag[x_cg][y_cg + 1];
 
             significant_coeff_group_flag[x_cg][y_cg] =
-                significant_coeff_group_flag_decode(s, c_idx, ctx_cg);
+                significant_coeff_group_flag_decode(lc, c_idx, ctx_cg);
             implicit_non_zero_coeff = 1;
         } else {
             significant_coeff_group_flag[x_cg][y_cg] =
@@ -1314,7 +1322,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
             for (n = n_end; n > 0; n--) {
                 x_c = scan_x_off[n];
                 y_c = scan_y_off[n];
-                if (significant_coeff_flag_decode(s, x_c, y_c, scf_offset, ctx_idx_map_p)) {
+                if (significant_coeff_flag_decode(lc, x_c, y_c, scf_offset, ctx_idx_map_p)) {
                     significant_coeff_flag_idx[nb_significant_coeff_flag] = n;
                     nb_significant_coeff_flag++;
                     implicit_non_zero_coeff = 0;
@@ -1338,7 +1346,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                         scf_offset = 2 + scf_offset;
                     }
                 }
-                if (significant_coeff_flag_decode_0(s, c_idx, scf_offset) == 1) {
+                if (significant_coeff_flag_decode_0(lc, c_idx, scf_offset) == 1) {
                     significant_coeff_flag_idx[nb_significant_coeff_flag] = 0;
                     nb_significant_coeff_flag++;
                 }
@@ -1382,7 +1390,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
             for (m = 0; m < (n_end > 8 ? 8 : n_end); m++) {
                 int inc = (ctx_set << 2) + greater1_ctx;
                 coeff_abs_level_greater1_flag[m] =
-                    coeff_abs_level_greater1_flag_decode(s, c_idx, inc);
+                    coeff_abs_level_greater1_flag_decode(lc, c_idx, inc);
                 if (coeff_abs_level_greater1_flag[m]) {
                     greater1_ctx = 0;
                     if (first_greater1_coeff_idx == -1)
@@ -1403,12 +1411,12 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                 sign_hidden = (last_nz_pos_in_cg - first_nz_pos_in_cg >= 4);
 
             if (first_greater1_coeff_idx != -1) {
-                coeff_abs_level_greater1_flag[first_greater1_coeff_idx] += coeff_abs_level_greater2_flag_decode(s, c_idx, ctx_set);
+                coeff_abs_level_greater1_flag[first_greater1_coeff_idx] += coeff_abs_level_greater2_flag_decode(lc, c_idx, ctx_set);
             }
             if (!s->ps.pps->sign_data_hiding_flag || !sign_hidden ) {
-                coeff_sign_flag = coeff_sign_flag_decode(s, nb_significant_coeff_flag) << (16 - nb_significant_coeff_flag);
+                coeff_sign_flag = coeff_sign_flag_decode(lc, nb_significant_coeff_flag) << (16 - nb_significant_coeff_flag);
             } else {
-                coeff_sign_flag = coeff_sign_flag_decode(s, nb_significant_coeff_flag - 1) << (16 - (nb_significant_coeff_flag - 1));
+                coeff_sign_flag = coeff_sign_flag_decode(lc, nb_significant_coeff_flag - 1) << (16 - (nb_significant_coeff_flag - 1));
             }
 
             for (m = 0; m < n_end; m++) {
@@ -1417,7 +1425,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                 if (m < 8) {
                     trans_coeff_level = 1 + coeff_abs_level_greater1_flag[m];
                     if (trans_coeff_level == ((m == first_greater1_coeff_idx) ? 3 : 2)) {
-                        int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(s, c_rice_param);
+                        int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(lc, c_rice_param);
 
                         trans_coeff_level += last_coeff_abs_level_remaining;
                         if (trans_coeff_level > (3 << c_rice_param))
@@ -1433,7 +1441,7 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
                         }
                     }
                 } else {
-                    int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(s, c_rice_param);
+                    int last_coeff_abs_level_remaining = coeff_abs_level_remaining_decode(lc, c_rice_param);
 
                     trans_coeff_level = 1 + last_coeff_abs_level_remaining;
                     if (trans_coeff_level > (3 << c_rice_param))
@@ -1538,26 +1546,25 @@ void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
     s->hevcdsp.add_residual[log2_trafo_size-2](dst, coeffs, stride);
 }
 
-void ff_hevc_hls_mvd_coding(HEVCContext *s, int x0, int y0, int log2_cb_size)
+void ff_hevc_hls_mvd_coding(HEVCLocalContext *lc, int x0, int y0, int log2_cb_size)
 {
-    HEVCLocalContext *lc = s->HEVClc;
-    int x = abs_mvd_greater0_flag_decode(s);
-    int y = abs_mvd_greater0_flag_decode(s);
+    int x = abs_mvd_greater0_flag_decode(lc);
+    int y = abs_mvd_greater0_flag_decode(lc);
 
     if (x)
-        x += abs_mvd_greater1_flag_decode(s);
+        x += abs_mvd_greater1_flag_decode(lc);
     if (y)
-        y += abs_mvd_greater1_flag_decode(s);
+        y += abs_mvd_greater1_flag_decode(lc);
 
     switch (x) {
-    case 2: lc->pu.mvd.x = mvd_decode(s);           break;
-    case 1: lc->pu.mvd.x = mvd_sign_flag_decode(s); break;
+    case 2: lc->pu.mvd.x = mvd_decode(lc);           break;
+    case 1: lc->pu.mvd.x = mvd_sign_flag_decode(lc); break;
     case 0: lc->pu.mvd.x = 0;                       break;
     }
 
     switch (y) {
-    case 2: lc->pu.mvd.y = mvd_decode(s);           break;
-    case 1: lc->pu.mvd.y = mvd_sign_flag_decode(s); break;
+    case 2: lc->pu.mvd.y = mvd_decode(lc);           break;
+    case 1: lc->pu.mvd.y = mvd_sign_flag_decode(lc); break;
     case 0: lc->pu.mvd.y = 0;                       break;
     }
 }
diff --git a/libavcodec/hevc_filter.c b/libavcodec/hevc_filter.c
index 1ae561d..0c45310 100644
--- a/libavcodec/hevc_filter.c
+++ b/libavcodec/hevc_filter.c
@@ -44,7 +44,7 @@ static const uint8_t betatable[52] = {
     38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64                      // QP 38...51
 };
 
-static int chroma_tc(HEVCContext *s, int qp_y, int c_idx, int tc_offset)
+static int chroma_tc(const HEVCContext *s, int qp_y, int c_idx, int tc_offset)
 {
     static const int qp_c[] = {
         29, 30, 31, 32, 33, 33, 34, 34, 35, 35, 36, 36, 37, 37
@@ -73,9 +73,9 @@ static int chroma_tc(HEVCContext *s, int qp_y, int c_idx, int tc_offset)
     return tctable[idxt];
 }
 
-static int get_qPy_pred(HEVCContext *s, int xBase, int yBase, int log2_cb_size)
+static int get_qPy_pred(HEVCLocalContext *lc, const HEVCContext *s,
+                        int xBase, int yBase, int log2_cb_size)
 {
-    HEVCLocalContext *lc     = s->HEVClc;
     int ctb_size_mask        = (1 << s->ps.sps->log2_ctb_size) - 1;
     int MinCuQpDeltaSizeMask = (1 << (s->ps.sps->log2_ctb_size -
                                       s->ps.pps->diff_cu_qp_delta_depth)) - 1;
@@ -116,19 +116,20 @@ static int get_qPy_pred(HEVCContext *s, int xBase, int yBase, int log2_cb_size)
     return (qPy_a + qPy_b + 1) >> 1;
 }
 
-void ff_hevc_set_qPy(HEVCContext *s, int xBase, int yBase, int log2_cb_size)
+void ff_hevc_set_qPy(HEVCLocalContext *lc, int xBase, int yBase, int log2_cb_size)
 {
-    int qp_y = get_qPy_pred(s, xBase, yBase, log2_cb_size);
+    const HEVCContext *const s = lc->parent;
+    int qp_y = get_qPy_pred(lc, s, xBase, yBase, log2_cb_size);
 
-    if (s->HEVClc->tu.cu_qp_delta != 0) {
+    if (lc->tu.cu_qp_delta != 0) {
         int off = s->ps.sps->qp_bd_offset;
-        s->HEVClc->qp_y = FFUMOD(qp_y + s->HEVClc->tu.cu_qp_delta + 52 + 2 * off,
+        lc->qp_y = FFUMOD(qp_y + lc->tu.cu_qp_delta + 52 + 2 * off,
                                  52 + off) - off;
     } else
-        s->HEVClc->qp_y = qp_y;
+        lc->qp_y = qp_y;
 }
 
-static int get_qPy(HEVCContext *s, int xC, int yC)
+static int get_qPy(const HEVCContext *s, int xC, int yC)
 {
     int log2_min_cb_size  = s->ps.sps->log2_min_cb_size;
     int x                 = xC >> log2_min_cb_size;
@@ -197,7 +198,7 @@ static void copy_vert(uint8_t *dst, const uint8_t *src,
     }
 }
 
-static void copy_CTB_to_hv(HEVCContext *s, const uint8_t *src,
+static void copy_CTB_to_hv(const HEVCContext *s, const uint8_t *src,
                            ptrdiff_t stride_src, int x, int y, int width, int height,
                            int c_idx, int x_ctb, int y_ctb)
 {
@@ -217,7 +218,7 @@ static void copy_CTB_to_hv(HEVCContext *s, const uint8_t *src,
     copy_vert(s->sao_pixel_buffer_v[c_idx] + (((2 * x_ctb + 1) * h + y) << sh), src + ((width - 1) << sh), sh, height, 1 << sh, stride_src);
 }
 
-static void restore_tqb_pixels(HEVCContext *s,
+static void restore_tqb_pixels(const HEVCContext *s,
                                uint8_t *src1, const uint8_t *dst1,
                                ptrdiff_t stride_src, ptrdiff_t stride_dst,
                                int x0, int y0, int width, int height, int c_idx)
@@ -252,10 +253,9 @@ static void restore_tqb_pixels(HEVCContext *s,
 
 #define CTB(tab, x, y) ((tab)[(y) * s->ps.sps->ctb_width + (x)])
 
-static void sao_filter_CTB(HEVCContext *s, int x, int y)
+static void sao_filter_CTB(HEVCLocalContext *lc, const HEVCContext *s, int x, int y)
 {
     static const uint8_t sao_tab[8] = { 0, 1, 2, 2, 3, 3, 4, 4 };
-    HEVCLocalContext *lc = s->HEVClc;
     int c_idx;
     int edges[4];  // 0 left 1 top 2 right 3 bottom
     int x_ctb                = x >> s->ps.sps->log2_ctb_size;
@@ -461,7 +461,7 @@ static void sao_filter_CTB(HEVCContext *s, int x, int y)
     }
 }
 
-static int get_pcm(HEVCContext *s, int x, int y)
+static int get_pcm(const HEVCContext *s, int x, int y)
 {
     int log2_min_pu_size = s->ps.sps->log2_min_pu_size;
     int x_pu, y_pu;
@@ -482,7 +482,7 @@ static int get_pcm(HEVCContext *s, int x, int y)
                     (tc_offset & -2),                                   \
                     0, MAX_QP + DEFAULT_INTRA_TC_OFFSET)]
 
-static void deblocking_filter_CTB(HEVCContext *s, int x0, int y0)
+static void deblocking_filter_CTB(const HEVCContext *s, int x0, int y0)
 {
     uint8_t *src;
     int x, y;
@@ -720,11 +720,11 @@ static int boundary_strength(const HEVCContext *s, const MvField *curr, const Mv
     return 1;
 }
 
-void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+void ff_hevc_deblocking_boundary_strengths(HEVCLocalContext *lc, int x0, int y0,
                                            int log2_trafo_size)
 {
-    HEVCLocalContext *lc = s->HEVClc;
-    MvField *tab_mvf     = s->ref->tab_mvf;
+    const HEVCContext *s = lc->parent;
+    const MvField *tab_mvf = s->ref->tab_mvf;
     int log2_min_pu_size = s->ps.sps->log2_min_pu_size;
     int log2_min_tu_size = s->ps.sps->log2_min_tb_size;
     int min_pu_width     = s->ps.sps->min_pu_width;
@@ -756,8 +756,8 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
             for (i = 0; i < (1 << log2_trafo_size); i += 4) {
                 int x_pu = (x0 + i) >> log2_min_pu_size;
                 int x_tu = (x0 + i) >> log2_min_tu_size;
-                MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];
-                MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];
+                const MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];
+                const MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];
                 uint8_t top_cbf_luma  = s->cbf_luma[yp_tu * min_tu_width + x_tu];
                 uint8_t curr_cbf_luma = s->cbf_luma[yq_tu * min_tu_width + x_tu];
 
@@ -794,8 +794,8 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
             for (i = 0; i < (1 << log2_trafo_size); i += 4) {
                 int y_pu      = (y0 + i) >> log2_min_pu_size;
                 int y_tu      = (y0 + i) >> log2_min_tu_size;
-                MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];
-                MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];
+                const MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];
+                const MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];
                 uint8_t left_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xp_tu];
                 uint8_t curr_cbf_luma = s->cbf_luma[y_tu * min_tu_width + xq_tu];
 
@@ -810,7 +810,7 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
     }
 
     if (log2_trafo_size > log2_min_pu_size && !is_intra) {
-        RefPicList *rpl = s->ref->refPicList;
+        const RefPicList *rpl = s->ref->refPicList;
 
         // bs for TU internal horizontal PU boundaries
         for (j = 8; j < (1 << log2_trafo_size); j += 8) {
@@ -819,8 +819,8 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
 
             for (i = 0; i < (1 << log2_trafo_size); i += 4) {
                 int x_pu = (x0 + i) >> log2_min_pu_size;
-                MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];
-                MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];
+                const MvField *top  = &tab_mvf[yp_pu * min_pu_width + x_pu];
+                const MvField *curr = &tab_mvf[yq_pu * min_pu_width + x_pu];
 
                 bs = boundary_strength(s, curr, top, rpl);
                 s->horizontal_bs[((x0 + i) + (y0 + j) * s->bs_width) >> 2] = bs;
@@ -834,8 +834,8 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
             for (i = 8; i < (1 << log2_trafo_size); i += 8) {
                 int xp_pu = (x0 + i - 1) >> log2_min_pu_size;
                 int xq_pu = (x0 + i)     >> log2_min_pu_size;
-                MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];
-                MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];
+                const MvField *left = &tab_mvf[y_pu * min_pu_width + xp_pu];
+                const MvField *curr = &tab_mvf[y_pu * min_pu_width + xq_pu];
 
                 bs = boundary_strength(s, curr, left, rpl);
                 s->vertical_bs[((x0 + i) + (y0 + j) * s->bs_width) >> 2] = bs;
@@ -848,8 +848,9 @@ void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
 #undef CB
 #undef CR
 
-void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
+void ff_hevc_hls_filter(HEVCLocalContext *lc, int x, int y, int ctb_size)
 {
+    const HEVCContext *const s = lc->parent;
     int x_end = x >= s->ps.sps->width  - ctb_size;
     int skip = 0;
     if (s->avctx->skip_loop_filter >= AVDISCARD_ALL ||
@@ -867,16 +868,16 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
     if (s->ps.sps->sao_enabled && !skip) {
         int y_end = y >= s->ps.sps->height - ctb_size;
         if (y && x)
-            sao_filter_CTB(s, x - ctb_size, y - ctb_size);
+            sao_filter_CTB(lc, s, x - ctb_size, y - ctb_size);
         if (x && y_end)
-            sao_filter_CTB(s, x - ctb_size, y);
+            sao_filter_CTB(lc, s, x - ctb_size, y);
         if (y && x_end) {
-            sao_filter_CTB(s, x, y - ctb_size);
+            sao_filter_CTB(lc, s, x, y - ctb_size);
             if (s->threads_type & FF_THREAD_FRAME )
                 ff_thread_report_progress(&s->ref->tf, y, 0);
         }
         if (x_end && y_end) {
-            sao_filter_CTB(s, x , y);
+            sao_filter_CTB(lc, s, x , y);
             if (s->threads_type & FF_THREAD_FRAME )
                 ff_thread_report_progress(&s->ref->tf, y + ctb_size, 0);
         }
@@ -884,14 +885,14 @@ void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size)
         ff_thread_report_progress(&s->ref->tf, y + ctb_size - 4, 0);
 }
 
-void ff_hevc_hls_filters(HEVCContext *s, int x_ctb, int y_ctb, int ctb_size)
+void ff_hevc_hls_filters(HEVCLocalContext *lc, int x_ctb, int y_ctb, int ctb_size)
 {
-    int x_end = x_ctb >= s->ps.sps->width  - ctb_size;
-    int y_end = y_ctb >= s->ps.sps->height - ctb_size;
+    int x_end = x_ctb >= lc->parent->ps.sps->width  - ctb_size;
+    int y_end = y_ctb >= lc->parent->ps.sps->height - ctb_size;
     if (y_ctb && x_ctb)
-        ff_hevc_hls_filter(s, x_ctb - ctb_size, y_ctb - ctb_size, ctb_size);
+        ff_hevc_hls_filter(lc, x_ctb - ctb_size, y_ctb - ctb_size, ctb_size);
     if (y_ctb && x_end)
-        ff_hevc_hls_filter(s, x_ctb, y_ctb - ctb_size, ctb_size);
+        ff_hevc_hls_filter(lc, x_ctb, y_ctb - ctb_size, ctb_size);
     if (x_ctb && y_end)
-        ff_hevc_hls_filter(s, x_ctb - ctb_size, y_ctb, ctb_size);
+        ff_hevc_hls_filter(lc, x_ctb - ctb_size, y_ctb, ctb_size);
 }
diff --git a/libavcodec/hevc_mvs.c b/libavcodec/hevc_mvs.c
index 516e4a6..c231797 100644
--- a/libavcodec/hevc_mvs.c
+++ b/libavcodec/hevc_mvs.c
@@ -40,10 +40,10 @@ static const uint8_t l0_l1_cand_idx[12][2] = {
     { 3, 2, },
 };
 
-void ff_hevc_set_neighbour_available(HEVCContext *s, int x0, int y0,
+void ff_hevc_set_neighbour_available(HEVCLocalContext *lc, int x0, int y0,
                                      int nPbW, int nPbH)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int x0b = av_mod_uintp2(x0, s->ps.sps->log2_ctb_size);
     int y0b = av_mod_uintp2(y0, s->ps.sps->log2_ctb_size);
 
@@ -62,7 +62,7 @@ void ff_hevc_set_neighbour_available(HEVCContext *s, int x0, int y0,
 /*
  * 6.4.1 Derivation process for z-scan order block availability
  */
-static av_always_inline int z_scan_block_avail(HEVCContext *s, int xCurr, int yCurr,
+static av_always_inline int z_scan_block_avail(const HEVCContext *s, int xCurr, int yCurr,
                               int xN, int yN)
 {
 #define MIN_TB_ADDR_ZS(x, y)                                            \
@@ -84,7 +84,7 @@ static av_always_inline int z_scan_block_avail(HEVCContext *s, int xCurr, int yC
 }
 
 //check if the two luma locations belong to the same motion estimation region
-static av_always_inline int is_diff_mer(HEVCContext *s, int xN, int yN, int xP, int yP)
+static av_always_inline int is_diff_mer(const HEVCContext *s, int xN, int yN, int xP, int yP)
 {
     uint8_t plevel = s->ps.pps->log2_parallel_merge_level;
 
@@ -161,11 +161,11 @@ static int check_mvset(Mv *mvLXCol, const Mv *mvCol,
                 refPicList_col, L ## l, temp_col.ref_idx[l])
 
 // derive the motion vectors section 8.5.3.1.8
-static int derive_temporal_colocated_mvs(HEVCContext *s, MvField temp_col,
+static int derive_temporal_colocated_mvs(const HEVCContext *s, MvField temp_col,
                                          int refIdxLx, Mv *mvLXCol, int X,
                                          int colPic, const RefPicList *refPicList_col)
 {
-    RefPicList *refPicList = s->ref->refPicList;
+    const RefPicList *refPicList = s->ref->refPicList;
 
     if (temp_col.pred_flag == PF_INTRA)
         return 0;
@@ -216,18 +216,18 @@ static int derive_temporal_colocated_mvs(HEVCContext *s, MvField temp_col,
 /*
  * 8.5.3.1.7  temporal luma motion vector prediction
  */
-static int temporal_luma_motion_vector(HEVCContext *s, int x0, int y0,
+static int temporal_luma_motion_vector(const HEVCContext *s, int x0, int y0,
                                        int nPbW, int nPbH, int refIdxLx,
                                        Mv *mvLXCol, int X)
 {
-    MvField *tab_mvf;
+    const MvField *tab_mvf;
     MvField temp_col;
     int x, y, x_pu, y_pu;
     int min_pu_width = s->ps.sps->min_pu_width;
     int availableFlagLXCol = 0;
     int colPic;
 
-    HEVCFrame *ref = s->ref->collocated_ref;
+    const HEVCFrame *ref = s->ref->collocated_ref;
 
     if (!ref) {
         memset(mvLXCol, 0, sizeof(*mvLXCol));
@@ -283,16 +283,16 @@ static int temporal_luma_motion_vector(HEVCContext *s, int x0, int y0,
 /*
  * 8.5.3.1.2  Derivation process for spatial merging candidates
  */
-static void derive_spatial_merge_candidates(HEVCContext *s, int x0, int y0,
+static void derive_spatial_merge_candidates(HEVCLocalContext *lc, const HEVCContext *s,
+                                            int x0, int y0,
                                             int nPbW, int nPbH,
                                             int log2_cb_size,
                                             int singleMCLFlag, int part_idx,
                                             int merge_idx,
                                             struct MvField mergecandlist[])
 {
-    HEVCLocalContext *lc   = s->HEVClc;
-    RefPicList *refPicList = s->ref->refPicList;
-    MvField *tab_mvf       = s->ref->tab_mvf;
+    const RefPicList *refPicList = s->ref->refPicList;
+    const MvField *tab_mvf       = s->ref->tab_mvf;
 
     const int min_pu_width = s->ps.sps->min_pu_width;
 
@@ -477,16 +477,16 @@ static void derive_spatial_merge_candidates(HEVCContext *s, int x0, int y0,
 /*
  * 8.5.3.1.1 Derivation process of luma Mvs for merge mode
  */
-void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,
+void ff_hevc_luma_mv_merge_mode(HEVCLocalContext *lc, int x0, int y0, int nPbW,
                                 int nPbH, int log2_cb_size, int part_idx,
                                 int merge_idx, MvField *mv)
 {
+    const HEVCContext *const s = lc->parent;
     int singleMCLFlag = 0;
     int nCS = 1 << log2_cb_size;
     MvField mergecand_list[MRG_MAX_NUM_CANDS];
     int nPbW2 = nPbW;
     int nPbH2 = nPbH;
-    HEVCLocalContext *lc = s->HEVClc;
 
     if (s->ps.pps->log2_parallel_merge_level > 2 && nCS == 8) {
         singleMCLFlag = 1;
@@ -497,8 +497,8 @@ void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,
         part_idx      = 0;
     }
 
-    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);
-    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,
+    ff_hevc_set_neighbour_available(lc, x0, y0, nPbW, nPbH);
+    derive_spatial_merge_candidates(lc, s, x0, y0, nPbW, nPbH, log2_cb_size,
                                     singleMCLFlag, part_idx,
                                     merge_idx, mergecand_list);
 
@@ -510,12 +510,12 @@ void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,
     *mv = mergecand_list[merge_idx];
 }
 
-static av_always_inline void dist_scale(HEVCContext *s, Mv *mv,
+static av_always_inline void dist_scale(const HEVCContext *s, Mv *mv,
                                         int min_pu_width, int x, int y,
                                         int elist, int ref_idx_curr, int ref_idx)
 {
-    RefPicList *refPicList = s->ref->refPicList;
-    MvField *tab_mvf       = s->ref->tab_mvf;
+    const RefPicList *refPicList = s->ref->refPicList;
+    const MvField *tab_mvf       = s->ref->tab_mvf;
     int ref_pic_elist      = refPicList[elist].list[TAB_MVF(x, y).ref_idx[elist]];
     int ref_pic_curr       = refPicList[ref_idx_curr].list[ref_idx];
 
@@ -527,13 +527,13 @@ static av_always_inline void dist_scale(HEVCContext *s, Mv *mv,
     }
 }
 
-static int mv_mp_mode_mx(HEVCContext *s, int x, int y, int pred_flag_index,
+static int mv_mp_mode_mx(const HEVCContext *s, int x, int y, int pred_flag_index,
                          Mv *mv, int ref_idx_curr, int ref_idx)
 {
-    MvField *tab_mvf = s->ref->tab_mvf;
+    const MvField *tab_mvf = s->ref->tab_mvf;
     int min_pu_width = s->ps.sps->min_pu_width;
 
-    RefPicList *refPicList = s->ref->refPicList;
+    const RefPicList *refPicList = s->ref->refPicList;
 
     if (((TAB_MVF(x, y).pred_flag) & (1 << pred_flag_index)) &&
         refPicList[pred_flag_index].list[TAB_MVF(x, y).ref_idx[pred_flag_index]] == refPicList[ref_idx_curr].list[ref_idx]) {
@@ -543,13 +543,13 @@ static int mv_mp_mode_mx(HEVCContext *s, int x, int y, int pred_flag_index,
     return 0;
 }
 
-static int mv_mp_mode_mx_lt(HEVCContext *s, int x, int y, int pred_flag_index,
+static int mv_mp_mode_mx_lt(const HEVCContext *s, int x, int y, int pred_flag_index,
                             Mv *mv, int ref_idx_curr, int ref_idx)
 {
-    MvField *tab_mvf = s->ref->tab_mvf;
+    const MvField *tab_mvf = s->ref->tab_mvf;
     int min_pu_width = s->ps.sps->min_pu_width;
 
-    RefPicList *refPicList = s->ref->refPicList;
+    const RefPicList *refPicList = s->ref->refPicList;
 
     if ((TAB_MVF(x, y).pred_flag) & (1 << pred_flag_index)) {
         int currIsLongTerm     = refPicList[ref_idx_curr].isLongTerm[ref_idx];
@@ -580,13 +580,13 @@ static int mv_mp_mode_mx_lt(HEVCContext *s, int x, int y, int pred_flag_index,
                      (y ## v) >> s->ps.sps->log2_min_pu_size,      \
                      pred, &mx, ref_idx_curr, ref_idx)
 
-void ff_hevc_luma_mv_mvp_mode(HEVCContext *s, int x0, int y0, int nPbW,
+void ff_hevc_luma_mv_mvp_mode(HEVCLocalContext *lc, int x0, int y0, int nPbW,
                               int nPbH, int log2_cb_size, int part_idx,
                               int merge_idx, MvField *mv,
                               int mvp_lx_flag, int LX)
 {
-    HEVCLocalContext *lc = s->HEVClc;
-    MvField *tab_mvf = s->ref->tab_mvf;
+    const HEVCContext *const s = lc->parent;
+    const MvField *const tab_mvf = s->ref->tab_mvf;
     int isScaledFlag_L0 = 0;
     int availableFlagLXA0 = 1;
     int availableFlagLXB0 = 1;
diff --git a/libavcodec/hevc_refs.c b/libavcodec/hevc_refs.c
index 6a70c81..811e8fe 100644
--- a/libavcodec/hevc_refs.c
+++ b/libavcodec/hevc_refs.c
@@ -173,23 +173,36 @@ int ff_hevc_set_new_ref(HEVCContext *s, AVFrame **frame, int poc)
     return 0;
 }
 
+static void unref_missing_refs(HEVCContext *s)
+{
+    for (int i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
+         HEVCFrame *frame = &s->DPB[i];
+         if (frame->sequence == HEVC_SEQUENCE_COUNTER_INVALID) {
+             ff_hevc_unref_frame(s, frame, ~0);
+         }
+    }
+}
+
 int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)
 {
+    if (IS_IRAP(s) && s->no_rasl_output_flag == 1) {
+        const static int mask = HEVC_FRAME_FLAG_BUMPING | HEVC_FRAME_FLAG_OUTPUT;
+        for (int i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
+            HEVCFrame *frame = &s->DPB[i];
+            if ((frame->flags & mask) == HEVC_FRAME_FLAG_OUTPUT &&
+                frame->sequence != s->seq_decode) {
+                if (s->sh.no_output_of_prior_pics_flag == 1)
+                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);
+                else
+                    frame->flags |= HEVC_FRAME_FLAG_BUMPING;
+            }
+        }
+    }
     do {
         int nb_output = 0;
         int min_poc   = INT_MAX;
         int i, min_idx, ret;
 
-        if (s->sh.no_output_of_prior_pics_flag == 1 && s->no_rasl_output_flag == 1) {
-            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
-                HEVCFrame *frame = &s->DPB[i];
-                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&
-                        frame->sequence == s->seq_output) {
-                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);
-                }
-            }
-        }
-
         for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
             HEVCFrame *frame = &s->DPB[i];
             if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&
@@ -230,7 +243,7 @@ int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)
         }
 
         if (s->seq_output != s->seq_decode)
-            s->seq_output = (s->seq_output + 1) & 0xff;
+            s->seq_output = (s->seq_output + 1) & HEVC_SEQUENCE_COUNTER_MASK;
         else
             break;
     } while (1);
@@ -374,7 +387,7 @@ static HEVCFrame *find_ref_idx(HEVCContext *s, int poc, uint8_t use_msb)
     for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
         HEVCFrame *ref = &s->DPB[i];
         if (ref->frame->buf[0] && ref->sequence == s->seq_decode) {
-            if ((ref->poc & mask) == poc)
+            if ((ref->poc & mask) == poc && (use_msb || ref->poc != s->poc))
                 return ref;
         }
     }
@@ -416,7 +429,7 @@ static HEVCFrame *generate_missing_ref(HEVCContext *s, int poc)
     }
 
     frame->poc      = poc;
-    frame->sequence = s->seq_decode;
+    frame->sequence = HEVC_SEQUENCE_COUNTER_INVALID;
     frame->flags    = 0;
 
     if (s->threads_type == FF_THREAD_FRAME)
@@ -460,6 +473,8 @@ int ff_hevc_frame_rps(HEVCContext *s)
         return 0;
     }
 
+    unref_missing_refs(s);
+
     /* clear the reference flags on all frames except the current one */
     for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
         HEVCFrame *frame = &s->DPB[i];
diff --git a/libavcodec/hevcdec.c b/libavcodec/hevcdec.c
index f8f981e..f1be8af 100644
--- a/libavcodec/hevcdec.c
+++ b/libavcodec/hevcdec.c
@@ -26,6 +26,7 @@
 #include "config_components.h"
 
 #include "libavutil/attributes.h"
+#include "libavutil/avstring.h"
 #include "libavutil/common.h"
 #include "libavutil/display.h"
 #include "libavutil/film_grain_params.h"
@@ -452,6 +453,9 @@ static enum AVPixelFormat get_format(HEVCContext *s, const HEVCSPS *sps)
 #endif
         break;
     case AV_PIX_FMT_YUV444P:
+#if CONFIG_HEVC_VAAPI_HWACCEL
+        *fmt++ = AV_PIX_FMT_VAAPI;
+#endif
 #if CONFIG_HEVC_VDPAU_HWACCEL
         *fmt++ = AV_PIX_FMT_VDPAU;
 #endif
@@ -569,7 +573,7 @@ static int hls_slice_header(HEVCContext *s)
     }
 
     if ((IS_IDR(s) || IS_BLA(s)) && sh->first_slice_in_pic_flag) {
-        s->seq_decode = (s->seq_decode + 1) & 0xff;
+        s->seq_decode = (s->seq_decode + 1) & HEVC_SEQUENCE_COUNTER_MASK;
         s->max_ra     = INT_MAX;
         if (IS_IDR(s))
             ff_hevc_clear_refs(s);
@@ -594,15 +598,8 @@ static int hls_slice_header(HEVCContext *s)
 
     if (s->ps.sps != (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data) {
         const HEVCSPS *sps = (HEVCSPS*)s->ps.sps_list[s->ps.pps->sps_id]->data;
-        const HEVCSPS *last_sps = s->ps.sps;
         enum AVPixelFormat pix_fmt;
 
-        if (last_sps && IS_IRAP(s) && s->nal_unit_type != HEVC_NAL_CRA_NUT) {
-            if (sps->width != last_sps->width || sps->height != last_sps->height ||
-                sps->temporal_layer[sps->max_sub_layers - 1].max_dec_pic_buffering !=
-                last_sps->temporal_layer[last_sps->max_sub_layers - 1].max_dec_pic_buffering)
-                sh->no_output_of_prior_pics_flag = 0;
-        }
         ff_hevc_clear_refs(s);
 
         ret = set_sps(s, sps, sps->pix_fmt);
@@ -614,7 +611,7 @@ static int hls_slice_header(HEVCContext *s)
             return pix_fmt;
         s->avctx->pix_fmt = pix_fmt;
 
-        s->seq_decode = (s->seq_decode + 1) & 0xff;
+        s->seq_decode = (s->seq_decode + 1) & HEVC_SEQUENCE_COUNTER_MASK;
         s->max_ra     = INT_MAX;
     }
 
@@ -1005,9 +1002,9 @@ do {                                                    \
         sao->elem = 0;                                  \
 } while (0)
 
-static void hls_sao_param(HEVCContext *s, int rx, int ry)
+static void hls_sao_param(HEVCLocalContext *lc, int rx, int ry)
 {
-    HEVCLocalContext *lc    = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int sao_merge_left_flag = 0;
     int sao_merge_up_flag   = 0;
     SAOParams *sao          = &CTB(s->sao, rx, ry);
@@ -1017,11 +1014,11 @@ static void hls_sao_param(HEVCContext *s, int rx, int ry)
         s->sh.slice_sample_adaptive_offset_flag[1]) {
         if (rx > 0) {
             if (lc->ctb_left_flag)
-                sao_merge_left_flag = ff_hevc_sao_merge_flag_decode(s);
+                sao_merge_left_flag = ff_hevc_sao_merge_flag_decode(lc);
         }
         if (ry > 0 && !sao_merge_left_flag) {
             if (lc->ctb_up_flag)
-                sao_merge_up_flag = ff_hevc_sao_merge_flag_decode(s);
+                sao_merge_up_flag = ff_hevc_sao_merge_flag_decode(lc);
         }
     }
 
@@ -1038,27 +1035,27 @@ static void hls_sao_param(HEVCContext *s, int rx, int ry)
             sao->type_idx[2] = sao->type_idx[1];
             sao->eo_class[2] = sao->eo_class[1];
         } else {
-            SET_SAO(type_idx[c_idx], ff_hevc_sao_type_idx_decode(s));
+            SET_SAO(type_idx[c_idx], ff_hevc_sao_type_idx_decode(lc));
         }
 
         if (sao->type_idx[c_idx] == SAO_NOT_APPLIED)
             continue;
 
         for (i = 0; i < 4; i++)
-            SET_SAO(offset_abs[c_idx][i], ff_hevc_sao_offset_abs_decode(s));
+            SET_SAO(offset_abs[c_idx][i], ff_hevc_sao_offset_abs_decode(lc));
 
         if (sao->type_idx[c_idx] == SAO_BAND) {
             for (i = 0; i < 4; i++) {
                 if (sao->offset_abs[c_idx][i]) {
                     SET_SAO(offset_sign[c_idx][i],
-                            ff_hevc_sao_offset_sign_decode(s));
+                            ff_hevc_sao_offset_sign_decode(lc));
                 } else {
                     sao->offset_sign[c_idx][i] = 0;
                 }
             }
-            SET_SAO(band_position[c_idx], ff_hevc_sao_band_position_decode(s));
+            SET_SAO(band_position[c_idx], ff_hevc_sao_band_position_decode(lc));
         } else if (c_idx != 2) {
-            SET_SAO(eo_class[c_idx], ff_hevc_sao_eo_class_decode(s));
+            SET_SAO(eo_class[c_idx], ff_hevc_sao_eo_class_decode(lc));
         }
 
         // Inferred parameters
@@ -1079,12 +1076,12 @@ static void hls_sao_param(HEVCContext *s, int rx, int ry)
 #undef SET_SAO
 #undef CTB
 
-static int hls_cross_component_pred(HEVCContext *s, int idx) {
-    HEVCLocalContext *lc    = s->HEVClc;
-    int log2_res_scale_abs_plus1 = ff_hevc_log2_res_scale_abs(s, idx);
+static int hls_cross_component_pred(HEVCLocalContext *lc, int idx)
+{
+    int log2_res_scale_abs_plus1 = ff_hevc_log2_res_scale_abs(lc, idx);
 
     if (log2_res_scale_abs_plus1 !=  0) {
-        int res_scale_sign_flag = ff_hevc_res_scale_sign_flag(s, idx);
+        int res_scale_sign_flag = ff_hevc_res_scale_sign_flag(lc, idx);
         lc->tu.res_scale_val = (1 << (log2_res_scale_abs_plus1 - 1)) *
                                (1 - 2 * res_scale_sign_flag);
     } else {
@@ -1095,20 +1092,20 @@ static int hls_cross_component_pred(HEVCContext *s, int idx) {
     return 0;
 }
 
-static int hls_transform_unit(HEVCContext *s, int x0, int y0,
+static int hls_transform_unit(HEVCLocalContext *lc, int x0, int y0,
                               int xBase, int yBase, int cb_xBase, int cb_yBase,
                               int log2_cb_size, int log2_trafo_size,
                               int blk_idx, int cbf_luma, int *cbf_cb, int *cbf_cr)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     const int log2_trafo_size_c = log2_trafo_size - s->ps.sps->hshift[1];
     int i;
 
     if (lc->cu.pred_mode == MODE_INTRA) {
         int trafo_size = 1 << log2_trafo_size;
-        ff_hevc_set_neighbour_available(s, x0, y0, trafo_size, trafo_size);
+        ff_hevc_set_neighbour_available(lc, x0, y0, trafo_size, trafo_size);
 
-        s->hpc.intra_pred[log2_trafo_size - 2](s, x0, y0, 0);
+        s->hpc.intra_pred[log2_trafo_size - 2](lc, x0, y0, 0);
     }
 
     if (cbf_luma || cbf_cb[0] || cbf_cr[0] ||
@@ -1120,9 +1117,9 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                          (cbf_cb[1] || cbf_cr[1]));
 
         if (s->ps.pps->cu_qp_delta_enabled_flag && !lc->tu.is_cu_qp_delta_coded) {
-            lc->tu.cu_qp_delta = ff_hevc_cu_qp_delta_abs(s);
+            lc->tu.cu_qp_delta = ff_hevc_cu_qp_delta_abs(lc);
             if (lc->tu.cu_qp_delta != 0)
-                if (ff_hevc_cu_qp_delta_sign_flag(s) == 1)
+                if (ff_hevc_cu_qp_delta_sign_flag(lc) == 1)
                     lc->tu.cu_qp_delta = -lc->tu.cu_qp_delta;
             lc->tu.is_cu_qp_delta_coded = 1;
 
@@ -1137,16 +1134,16 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                 return AVERROR_INVALIDDATA;
             }
 
-            ff_hevc_set_qPy(s, cb_xBase, cb_yBase, log2_cb_size);
+            ff_hevc_set_qPy(lc, cb_xBase, cb_yBase, log2_cb_size);
         }
 
         if (s->sh.cu_chroma_qp_offset_enabled_flag && cbf_chroma &&
             !lc->cu.cu_transquant_bypass_flag  &&  !lc->tu.is_cu_chroma_qp_offset_coded) {
-            int cu_chroma_qp_offset_flag = ff_hevc_cu_chroma_qp_offset_flag(s);
+            int cu_chroma_qp_offset_flag = ff_hevc_cu_chroma_qp_offset_flag(lc);
             if (cu_chroma_qp_offset_flag) {
                 int cu_chroma_qp_offset_idx  = 0;
                 if (s->ps.pps->chroma_qp_offset_list_len_minus1 > 0) {
-                    cu_chroma_qp_offset_idx = ff_hevc_cu_chroma_qp_offset_idx(s);
+                    cu_chroma_qp_offset_idx = ff_hevc_cu_chroma_qp_offset_idx(lc);
                     av_log(s->avctx, AV_LOG_ERROR,
                         "cu_chroma_qp_offset_idx not yet tested.\n");
                 }
@@ -1180,7 +1177,7 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
         lc->tu.cross_pf = 0;
 
         if (cbf_luma)
-            ff_hevc_hls_residual_coding(s, x0, y0, log2_trafo_size, scan_idx, 0);
+            ff_hevc_hls_residual_coding(lc, x0, y0, log2_trafo_size, scan_idx, 0);
         if (s->ps.sps->chroma_format_idc && (log2_trafo_size > 2 || s->ps.sps->chroma_format_idc == 3)) {
             int trafo_size_h = 1 << (log2_trafo_size_c + s->ps.sps->hshift[1]);
             int trafo_size_v = 1 << (log2_trafo_size_c + s->ps.sps->vshift[1]);
@@ -1189,22 +1186,22 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
                                  (lc->tu.chroma_mode_c ==  4)));
 
             if (lc->tu.cross_pf) {
-                hls_cross_component_pred(s, 0);
+                hls_cross_component_pred(lc, 0);
             }
             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
                 if (lc->cu.pred_mode == MODE_INTRA) {
-                    ff_hevc_set_neighbour_available(s, x0, y0 + (i << log2_trafo_size_c), trafo_size_h, trafo_size_v);
-                    s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i << log2_trafo_size_c), 1);
+                    ff_hevc_set_neighbour_available(lc, x0, y0 + (i << log2_trafo_size_c), trafo_size_h, trafo_size_v);
+                    s->hpc.intra_pred[log2_trafo_size_c - 2](lc, x0, y0 + (i << log2_trafo_size_c), 1);
                 }
                 if (cbf_cb[i])
-                    ff_hevc_hls_residual_coding(s, x0, y0 + (i << log2_trafo_size_c),
+                    ff_hevc_hls_residual_coding(lc, x0, y0 + (i << log2_trafo_size_c),
                                                 log2_trafo_size_c, scan_idx_c, 1);
                 else
                     if (lc->tu.cross_pf) {
                         ptrdiff_t stride = s->frame->linesize[1];
                         int hshift = s->ps.sps->hshift[1];
                         int vshift = s->ps.sps->vshift[1];
-                        int16_t *coeffs_y = (int16_t*)lc->edge_emu_buffer;
+                        const int16_t *coeffs_y = (int16_t*)lc->edge_emu_buffer;
                         int16_t *coeffs   = (int16_t*)lc->edge_emu_buffer2;
                         int size = 1 << log2_trafo_size_c;
 
@@ -1218,22 +1215,23 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
             }
 
             if (lc->tu.cross_pf) {
-                hls_cross_component_pred(s, 1);
+                hls_cross_component_pred(lc, 1);
             }
             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
                 if (lc->cu.pred_mode == MODE_INTRA) {
-                    ff_hevc_set_neighbour_available(s, x0, y0 + (i << log2_trafo_size_c), trafo_size_h, trafo_size_v);
-                    s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (i << log2_trafo_size_c), 2);
+                    ff_hevc_set_neighbour_available(lc, x0, y0 + (i << log2_trafo_size_c),
+                                                    trafo_size_h, trafo_size_v);
+                    s->hpc.intra_pred[log2_trafo_size_c - 2](lc, x0, y0 + (i << log2_trafo_size_c), 2);
                 }
                 if (cbf_cr[i])
-                    ff_hevc_hls_residual_coding(s, x0, y0 + (i << log2_trafo_size_c),
+                    ff_hevc_hls_residual_coding(lc, x0, y0 + (i << log2_trafo_size_c),
                                                 log2_trafo_size_c, scan_idx_c, 2);
                 else
                     if (lc->tu.cross_pf) {
                         ptrdiff_t stride = s->frame->linesize[2];
                         int hshift = s->ps.sps->hshift[2];
                         int vshift = s->ps.sps->vshift[2];
-                        int16_t *coeffs_y = (int16_t*)lc->edge_emu_buffer;
+                        const int16_t *coeffs_y = (int16_t*)lc->edge_emu_buffer;
                         int16_t *coeffs   = (int16_t*)lc->edge_emu_buffer2;
                         int size = 1 << log2_trafo_size_c;
 
@@ -1250,22 +1248,22 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
             int trafo_size_v = 1 << (log2_trafo_size + s->ps.sps->vshift[1]);
             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
                 if (lc->cu.pred_mode == MODE_INTRA) {
-                    ff_hevc_set_neighbour_available(s, xBase, yBase + (i << log2_trafo_size),
+                    ff_hevc_set_neighbour_available(lc, xBase, yBase + (i << log2_trafo_size),
                                                     trafo_size_h, trafo_size_v);
-                    s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i << log2_trafo_size), 1);
+                    s->hpc.intra_pred[log2_trafo_size - 2](lc, xBase, yBase + (i << log2_trafo_size), 1);
                 }
                 if (cbf_cb[i])
-                    ff_hevc_hls_residual_coding(s, xBase, yBase + (i << log2_trafo_size),
+                    ff_hevc_hls_residual_coding(lc, xBase, yBase + (i << log2_trafo_size),
                                                 log2_trafo_size, scan_idx_c, 1);
             }
             for (i = 0; i < (s->ps.sps->chroma_format_idc == 2 ? 2 : 1); i++) {
                 if (lc->cu.pred_mode == MODE_INTRA) {
-                    ff_hevc_set_neighbour_available(s, xBase, yBase + (i << log2_trafo_size),
+                    ff_hevc_set_neighbour_available(lc, xBase, yBase + (i << log2_trafo_size),
                                                 trafo_size_h, trafo_size_v);
-                    s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (i << log2_trafo_size), 2);
+                    s->hpc.intra_pred[log2_trafo_size - 2](lc, xBase, yBase + (i << log2_trafo_size), 2);
                 }
                 if (cbf_cr[i])
-                    ff_hevc_hls_residual_coding(s, xBase, yBase + (i << log2_trafo_size),
+                    ff_hevc_hls_residual_coding(lc, xBase, yBase + (i << log2_trafo_size),
                                                 log2_trafo_size, scan_idx_c, 2);
             }
         }
@@ -1273,27 +1271,27 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
         if (log2_trafo_size > 2 || s->ps.sps->chroma_format_idc == 3) {
             int trafo_size_h = 1 << (log2_trafo_size_c + s->ps.sps->hshift[1]);
             int trafo_size_v = 1 << (log2_trafo_size_c + s->ps.sps->vshift[1]);
-            ff_hevc_set_neighbour_available(s, x0, y0, trafo_size_h, trafo_size_v);
-            s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 1);
-            s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0, 2);
+            ff_hevc_set_neighbour_available(lc, x0, y0, trafo_size_h, trafo_size_v);
+            s->hpc.intra_pred[log2_trafo_size_c - 2](lc, x0, y0, 1);
+            s->hpc.intra_pred[log2_trafo_size_c - 2](lc, x0, y0, 2);
             if (s->ps.sps->chroma_format_idc == 2) {
-                ff_hevc_set_neighbour_available(s, x0, y0 + (1 << log2_trafo_size_c),
+                ff_hevc_set_neighbour_available(lc, x0, y0 + (1 << log2_trafo_size_c),
                                                 trafo_size_h, trafo_size_v);
-                s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 << log2_trafo_size_c), 1);
-                s->hpc.intra_pred[log2_trafo_size_c - 2](s, x0, y0 + (1 << log2_trafo_size_c), 2);
+                s->hpc.intra_pred[log2_trafo_size_c - 2](lc, x0, y0 + (1 << log2_trafo_size_c), 1);
+                s->hpc.intra_pred[log2_trafo_size_c - 2](lc, x0, y0 + (1 << log2_trafo_size_c), 2);
             }
         } else if (blk_idx == 3) {
             int trafo_size_h = 1 << (log2_trafo_size + 1);
             int trafo_size_v = 1 << (log2_trafo_size + s->ps.sps->vshift[1]);
-            ff_hevc_set_neighbour_available(s, xBase, yBase,
+            ff_hevc_set_neighbour_available(lc, xBase, yBase,
                                             trafo_size_h, trafo_size_v);
-            s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 1);
-            s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase, 2);
+            s->hpc.intra_pred[log2_trafo_size - 2](lc, xBase, yBase, 1);
+            s->hpc.intra_pred[log2_trafo_size - 2](lc, xBase, yBase, 2);
             if (s->ps.sps->chroma_format_idc == 2) {
-                ff_hevc_set_neighbour_available(s, xBase, yBase + (1 << (log2_trafo_size)),
+                ff_hevc_set_neighbour_available(lc, xBase, yBase + (1 << log2_trafo_size),
                                                 trafo_size_h, trafo_size_v);
-                s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 << (log2_trafo_size)), 1);
-                s->hpc.intra_pred[log2_trafo_size - 2](s, xBase, yBase + (1 << (log2_trafo_size)), 2);
+                s->hpc.intra_pred[log2_trafo_size - 2](lc, xBase, yBase + (1 << log2_trafo_size), 1);
+                s->hpc.intra_pred[log2_trafo_size - 2](lc, xBase, yBase + (1 << log2_trafo_size), 2);
             }
         }
     }
@@ -1301,7 +1299,7 @@ static int hls_transform_unit(HEVCContext *s, int x0, int y0,
     return 0;
 }
 
-static void set_deblocking_bypass(HEVCContext *s, int x0, int y0, int log2_cb_size)
+static void set_deblocking_bypass(const HEVCContext *s, int x0, int y0, int log2_cb_size)
 {
     int cb_size          = 1 << log2_cb_size;
     int log2_min_pu_size = s->ps.sps->log2_min_pu_size;
@@ -1316,13 +1314,13 @@ static void set_deblocking_bypass(HEVCContext *s, int x0, int y0, int log2_cb_si
             s->is_pcm[i + j * min_pu_width] = 2;
 }
 
-static int hls_transform_tree(HEVCContext *s, int x0, int y0,
+static int hls_transform_tree(HEVCLocalContext *lc, int x0, int y0,
                               int xBase, int yBase, int cb_xBase, int cb_yBase,
                               int log2_cb_size, int log2_trafo_size,
                               int trafo_depth, int blk_idx,
                               const int *base_cbf_cb, const int *base_cbf_cr)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     uint8_t split_transform_flag;
     int cbf_cb[2];
     int cbf_cr[2];
@@ -1354,7 +1352,7 @@ static int hls_transform_tree(HEVCContext *s, int x0, int y0,
         log2_trafo_size >  s->ps.sps->log2_min_tb_size    &&
         trafo_depth     < lc->cu.max_trafo_depth       &&
         !(lc->cu.intra_split_flag && trafo_depth == 0)) {
-        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);
+        split_transform_flag = ff_hevc_split_transform_flag_decode(lc, log2_trafo_size);
     } else {
         int inter_split = s->ps.sps->max_transform_hierarchy_depth_inter == 0 &&
                           lc->cu.pred_mode == MODE_INTER &&
@@ -1368,16 +1366,16 @@ static int hls_transform_tree(HEVCContext *s, int x0, int y0,
 
     if (s->ps.sps->chroma_format_idc && (log2_trafo_size > 2 || s->ps.sps->chroma_format_idc == 3)) {
         if (trafo_depth == 0 || cbf_cb[0]) {
-            cbf_cb[0] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
+            cbf_cb[0] = ff_hevc_cbf_cb_cr_decode(lc, trafo_depth);
             if (s->ps.sps->chroma_format_idc == 2 && (!split_transform_flag || log2_trafo_size == 3)) {
-                cbf_cb[1] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
+                cbf_cb[1] = ff_hevc_cbf_cb_cr_decode(lc, trafo_depth);
             }
         }
 
         if (trafo_depth == 0 || cbf_cr[0]) {
-            cbf_cr[0] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
+            cbf_cr[0] = ff_hevc_cbf_cb_cr_decode(lc, trafo_depth);
             if (s->ps.sps->chroma_format_idc == 2 && (!split_transform_flag || log2_trafo_size == 3)) {
-                cbf_cr[1] = ff_hevc_cbf_cb_cr_decode(s, trafo_depth);
+                cbf_cr[1] = ff_hevc_cbf_cb_cr_decode(lc, trafo_depth);
             }
         }
     }
@@ -1389,7 +1387,7 @@ static int hls_transform_tree(HEVCContext *s, int x0, int y0,
 
 #define SUBDIVIDE(x, y, idx)                                                    \
 do {                                                                            \
-    ret = hls_transform_tree(s, x, y, x0, y0, cb_xBase, cb_yBase, log2_cb_size, \
+    ret = hls_transform_tree(lc, x, y, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\
                              log2_trafo_size - 1, trafo_depth + 1, idx,         \
                              cbf_cb, cbf_cr);                                   \
     if (ret < 0)                                                                \
@@ -1411,10 +1409,10 @@ do {
         if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||
             cbf_cb[0] || cbf_cr[0] ||
             (s->ps.sps->chroma_format_idc == 2 && (cbf_cb[1] || cbf_cr[1]))) {
-            cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);
+            cbf_luma = ff_hevc_cbf_luma_decode(lc, trafo_depth);
         }
 
-        ret = hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,
+        ret = hls_transform_unit(lc, x0, y0, xBase, yBase, cb_xBase, cb_yBase,
                                  log2_cb_size, log2_trafo_size,
                                  blk_idx, cbf_luma, cbf_cb, cbf_cr);
         if (ret < 0)
@@ -1430,7 +1428,7 @@ do {
                 }
         }
         if (!s->sh.disable_deblocking_filter_flag) {
-            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size);
+            ff_hevc_deblocking_boundary_strengths(lc, x0, y0, log2_trafo_size);
             if (s->ps.pps->transquant_bypass_enable_flag &&
                 lc->cu.cu_transquant_bypass_flag)
                 set_deblocking_bypass(s, x0, y0, log2_trafo_size);
@@ -1439,9 +1437,9 @@ do {
     return 0;
 }
 
-static int hls_pcm_sample(HEVCContext *s, int x0, int y0, int log2_cb_size)
+static int hls_pcm_sample(HEVCLocalContext *lc, int x0, int y0, int log2_cb_size)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     GetBitContext gb;
     int cb_size   = 1 << log2_cb_size;
     ptrdiff_t stride0 = s->frame->linesize[0];
@@ -1459,7 +1457,7 @@ static int hls_pcm_sample(HEVCContext *s, int x0, int y0, int log2_cb_size)
     int ret;
 
     if (!s->sh.disable_deblocking_filter_flag)
-        ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_cb_size);
+        ff_hevc_deblocking_boundary_strengths(lc, x0, y0, log2_cb_size);
 
     ret = init_get_bits(&gb, pcm, length);
     if (ret < 0)
@@ -1496,12 +1494,12 @@ static int hls_pcm_sample(HEVCContext *s, int x0, int y0, int log2_cb_size)
  * @param luma_offset additive offset applied to the luma prediction value
  */
 
-static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
-                        AVFrame *ref, const Mv *mv, int x_off, int y_off,
+static void luma_mc_uni(HEVCLocalContext *lc, uint8_t *dst, ptrdiff_t dststride,
+                        const AVFrame *ref, const Mv *mv, int x_off, int y_off,
                         int block_w, int block_h, int luma_weight, int luma_offset)
 {
-    HEVCLocalContext *lc = s->HEVClc;
-    uint8_t *src         = ref->data[0];
+    const HEVCContext *const s = lc->parent;
+    const uint8_t *src   = ref->data[0];
     ptrdiff_t srcstride  = ref->linesize[0];
     int pic_width        = s->ps.sps->width;
     int pic_height       = s->ps.sps->height;
@@ -1557,11 +1555,12 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
  * @param mv1 motion vector1 (relative to block position) to get pixel data from
  * @param current_mv current motion vector structure
  */
- static void luma_mc_bi(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
-                       AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
-                       int block_w, int block_h, AVFrame *ref1, const Mv *mv1, struct MvField *current_mv)
+ static void luma_mc_bi(HEVCLocalContext *lc, uint8_t *dst, ptrdiff_t dststride,
+                        const AVFrame *ref0, const Mv *mv0, int x_off, int y_off,
+                        int block_w, int block_h, const AVFrame *ref1,
+                        const Mv *mv1, struct MvField *current_mv)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     ptrdiff_t src0stride  = ref0->linesize[0];
     ptrdiff_t src1stride  = ref1->linesize[0];
     int pic_width        = s->ps.sps->width;
@@ -1578,8 +1577,8 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
     int y_off1           = y_off + (mv1->y >> 2);
     int idx              = hevc_pel_weight[block_w];
 
-    uint8_t *src0  = ref0->data[0] + y_off0 * src0stride + (int)((unsigned)x_off0 << s->ps.sps->pixel_shift);
-    uint8_t *src1  = ref1->data[0] + y_off1 * src1stride + (int)((unsigned)x_off1 << s->ps.sps->pixel_shift);
+    const uint8_t *src0  = ref0->data[0] + y_off0 * src0stride + (int)((unsigned)x_off0 << s->ps.sps->pixel_shift);
+    const uint8_t *src1  = ref1->data[0] + y_off1 * src1stride + (int)((unsigned)x_off1 << s->ps.sps->pixel_shift);
 
     if (x_off0 < QPEL_EXTRA_BEFORE || y_off0 < QPEL_EXTRA_AFTER ||
         x_off0 >= pic_width - block_w - QPEL_EXTRA_AFTER ||
@@ -1648,11 +1647,12 @@ static void luma_mc_uni(HEVCContext *s, uint8_t *dst, ptrdiff_t dststride,
  * @param chroma_offset additive offset applied to the chroma prediction value
  */
 
-static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
-                          ptrdiff_t dststride, uint8_t *src0, ptrdiff_t srcstride, int reflist,
-                          int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int chroma_weight, int chroma_offset)
+static void chroma_mc_uni(HEVCLocalContext *lc, uint8_t *dst0,
+                          ptrdiff_t dststride, const uint8_t *src0, ptrdiff_t srcstride, int reflist,
+                          int x_off, int y_off, int block_w, int block_h,
+                          const struct MvField *current_mv, int chroma_weight, int chroma_offset)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[1];
     int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[1];
     const Mv *mv         = &current_mv->mv[reflist];
@@ -1713,20 +1713,21 @@ static void chroma_mc_uni(HEVCContext *s, uint8_t *dst0,
  * @param current_mv current motion vector structure
  * @param cidx chroma component(cb, cr)
  */
-static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVFrame *ref0, AVFrame *ref1,
-                         int x_off, int y_off, int block_w, int block_h, struct MvField *current_mv, int cidx)
+static void chroma_mc_bi(HEVCLocalContext *lc, uint8_t *dst0, ptrdiff_t dststride,
+                         const AVFrame *ref0, const AVFrame *ref1,
+                         int x_off, int y_off, int block_w, int block_h, const MvField *current_mv, int cidx)
 {
-    HEVCLocalContext *lc = s->HEVClc;
-    uint8_t *src1        = ref0->data[cidx+1];
-    uint8_t *src2        = ref1->data[cidx+1];
+    const HEVCContext *const s = lc->parent;
+    const uint8_t *src1  = ref0->data[cidx+1];
+    const uint8_t *src2  = ref1->data[cidx+1];
     ptrdiff_t src1stride = ref0->linesize[cidx+1];
     ptrdiff_t src2stride = ref1->linesize[cidx+1];
     int weight_flag      = (s->sh.slice_type == HEVC_SLICE_P && s->ps.pps->weighted_pred_flag) ||
                            (s->sh.slice_type == HEVC_SLICE_B && s->ps.pps->weighted_bipred_flag);
     int pic_width        = s->ps.sps->width >> s->ps.sps->hshift[1];
     int pic_height       = s->ps.sps->height >> s->ps.sps->vshift[1];
-    Mv *mv0              = &current_mv->mv[0];
-    Mv *mv1              = &current_mv->mv[1];
+    const Mv *const mv0  = &current_mv->mv[0];
+    const Mv *const mv1  = &current_mv->mv[1];
     int hshift = s->ps.sps->hshift[1];
     int vshift = s->ps.sps->vshift[1];
 
@@ -1803,7 +1804,7 @@ static void chroma_mc_bi(HEVCContext *s, uint8_t *dst0, ptrdiff_t dststride, AVF
                                                          _mx1, _my1, block_w);
 }
 
-static void hevc_await_progress(HEVCContext *s, HEVCFrame *ref,
+static void hevc_await_progress(const HEVCContext *s, const HEVCFrame *ref,
                                 const Mv *mv, int y0, int height)
 {
     if (s->threads_type == FF_THREAD_FRAME ) {
@@ -1813,27 +1814,27 @@ static void hevc_await_progress(HEVCContext *s, HEVCFrame *ref,
     }
 }
 
-static void hevc_luma_mv_mvp_mode(HEVCContext *s, int x0, int y0, int nPbW,
+static void hevc_luma_mv_mvp_mode(HEVCLocalContext *lc, int x0, int y0, int nPbW,
                                   int nPbH, int log2_cb_size, int part_idx,
                                   int merge_idx, MvField *mv)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     enum InterPredIdc inter_pred_idc = PRED_L0;
     int mvp_flag;
 
-    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);
+    ff_hevc_set_neighbour_available(lc, x0, y0, nPbW, nPbH);
     mv->pred_flag = 0;
     if (s->sh.slice_type == HEVC_SLICE_B)
-        inter_pred_idc = ff_hevc_inter_pred_idc_decode(s, nPbW, nPbH);
+        inter_pred_idc = ff_hevc_inter_pred_idc_decode(lc, nPbW, nPbH);
 
     if (inter_pred_idc != PRED_L1) {
         if (s->sh.nb_refs[L0])
-            mv->ref_idx[0]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L0]);
+            mv->ref_idx[0]= ff_hevc_ref_idx_lx_decode(lc, s->sh.nb_refs[L0]);
 
         mv->pred_flag = PF_L0;
-        ff_hevc_hls_mvd_coding(s, x0, y0, 0);
-        mvp_flag = ff_hevc_mvp_lx_flag_decode(s);
-        ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,
+        ff_hevc_hls_mvd_coding(lc, x0, y0, 0);
+        mvp_flag = ff_hevc_mvp_lx_flag_decode(lc);
+        ff_hevc_luma_mv_mvp_mode(lc, x0, y0, nPbW, nPbH, log2_cb_size,
                                  part_idx, merge_idx, mv, mvp_flag, 0);
         mv->mv[0].x += lc->pu.mvd.x;
         mv->mv[0].y += lc->pu.mvd.y;
@@ -1841,39 +1842,39 @@ static void hevc_luma_mv_mvp_mode(HEVCContext *s, int x0, int y0, int nPbW,
 
     if (inter_pred_idc != PRED_L0) {
         if (s->sh.nb_refs[L1])
-            mv->ref_idx[1]= ff_hevc_ref_idx_lx_decode(s, s->sh.nb_refs[L1]);
+            mv->ref_idx[1]= ff_hevc_ref_idx_lx_decode(lc, s->sh.nb_refs[L1]);
 
         if (s->sh.mvd_l1_zero_flag == 1 && inter_pred_idc == PRED_BI) {
             AV_ZERO32(&lc->pu.mvd);
         } else {
-            ff_hevc_hls_mvd_coding(s, x0, y0, 1);
+            ff_hevc_hls_mvd_coding(lc, x0, y0, 1);
         }
 
         mv->pred_flag += PF_L1;
-        mvp_flag = ff_hevc_mvp_lx_flag_decode(s);
-        ff_hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,
+        mvp_flag = ff_hevc_mvp_lx_flag_decode(lc);
+        ff_hevc_luma_mv_mvp_mode(lc, x0, y0, nPbW, nPbH, log2_cb_size,
                                  part_idx, merge_idx, mv, mvp_flag, 1);
         mv->mv[1].x += lc->pu.mvd.x;
         mv->mv[1].y += lc->pu.mvd.y;
     }
 }
 
-static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
+static void hls_prediction_unit(HEVCLocalContext *lc, int x0, int y0,
                                 int nPbW, int nPbH,
                                 int log2_cb_size, int partIdx, int idx)
 {
 #define POS(c_idx, x, y)                                                              \
     &s->frame->data[c_idx][((y) >> s->ps.sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \
                            (((x) >> s->ps.sps->hshift[c_idx]) << s->ps.sps->pixel_shift)]
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int merge_idx = 0;
     struct MvField current_mv = {{{ 0 }}};
 
     int min_pu_width = s->ps.sps->min_pu_width;
 
     MvField *tab_mvf = s->ref->tab_mvf;
-    RefPicList  *refPicList = s->ref->refPicList;
-    HEVCFrame *ref0 = NULL, *ref1 = NULL;
+    const RefPicList *refPicList = s->ref->refPicList;
+    const HEVCFrame *ref0 = NULL, *ref1 = NULL;
     uint8_t *dst0 = POS(0, x0, y0);
     uint8_t *dst1 = POS(1, x0, y0);
     uint8_t *dst2 = POS(2, x0, y0);
@@ -1887,18 +1888,18 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
     int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);
 
     if (!skip_flag)
-        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);
+        lc->pu.merge_flag = ff_hevc_merge_flag_decode(lc);
 
     if (skip_flag || lc->pu.merge_flag) {
         if (s->sh.max_num_merge_cand > 1)
-            merge_idx = ff_hevc_merge_idx_decode(s);
+            merge_idx = ff_hevc_merge_idx_decode(lc);
         else
             merge_idx = 0;
 
-        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,
+        ff_hevc_luma_mv_merge_mode(lc, x0, y0, nPbW, nPbH, log2_cb_size,
                                    partIdx, merge_idx, &current_mv);
     } else {
-        hevc_luma_mv_mvp_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,
+        hevc_luma_mv_mvp_mode(lc, x0, y0, nPbW, nPbH, log2_cb_size,
                               partIdx, merge_idx, &current_mv);
     }
 
@@ -1928,16 +1929,16 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
 
-        luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame,
+        luma_mc_uni(lc, dst0, s->frame->linesize[0], ref0->frame,
                     &current_mv.mv[0], x0, y0, nPbW, nPbH,
                     s->sh.luma_weight_l0[current_mv.ref_idx[0]],
                     s->sh.luma_offset_l0[current_mv.ref_idx[0]]);
 
         if (s->ps.sps->chroma_format_idc) {
-            chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
+            chroma_mc_uni(lc, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],
                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);
-            chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],
+            chroma_mc_uni(lc, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],
                           0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]);
         }
@@ -1947,17 +1948,17 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
 
-        luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame,
+        luma_mc_uni(lc, dst0, s->frame->linesize[0], ref1->frame,
                     &current_mv.mv[1], x0, y0, nPbW, nPbH,
                     s->sh.luma_weight_l1[current_mv.ref_idx[1]],
                     s->sh.luma_offset_l1[current_mv.ref_idx[1]]);
 
         if (s->ps.sps->chroma_format_idc) {
-            chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
+            chroma_mc_uni(lc, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],
                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);
 
-            chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],
+            chroma_mc_uni(lc, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],
                           1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,
                           s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);
         }
@@ -1967,15 +1968,15 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
         int nPbW_c = nPbW >> s->ps.sps->hshift[1];
         int nPbH_c = nPbH >> s->ps.sps->vshift[1];
 
-        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,
+        luma_mc_bi(lc, dst0, s->frame->linesize[0], ref0->frame,
                    &current_mv.mv[0], x0, y0, nPbW, nPbH,
                    ref1->frame, &current_mv.mv[1], &current_mv);
 
         if (s->ps.sps->chroma_format_idc) {
-            chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
+            chroma_mc_bi(lc, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,
                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);
 
-            chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,
+            chroma_mc_bi(lc, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,
                          x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);
         }
     }
@@ -1984,10 +1985,10 @@ static void hls_prediction_unit(HEVCContext *s, int x0, int y0,
 /**
  * 8.4.1
  */
-static int luma_intra_pred_mode(HEVCContext *s, int x0, int y0, int pu_size,
+static int luma_intra_pred_mode(HEVCLocalContext *lc, int x0, int y0, int pu_size,
                                 int prev_intra_luma_pred_flag)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int x_pu             = x0 >> s->ps.sps->log2_min_pu_size;
     int y_pu             = y0 >> s->ps.sps->log2_min_pu_size;
     int min_pu_width     = s->ps.sps->min_pu_width;
@@ -2064,7 +2065,7 @@ static int luma_intra_pred_mode(HEVCContext *s, int x0, int y0, int pu_size,
     return intra_pred_mode;
 }
 
-static av_always_inline void set_ct_depth(HEVCContext *s, int x0, int y0,
+static av_always_inline void set_ct_depth(const HEVCContext *s, int x0, int y0,
                                           int log2_cb_size, int ct_depth)
 {
     int length = (1 << log2_cb_size) >> s->ps.sps->log2_min_cb_size;
@@ -2081,10 +2082,10 @@ static const uint8_t tab_mode_idx[] = {
      0,  1,  2,  2,  2,  2,  3,  5,  7,  8, 10, 12, 13, 15, 17, 18, 19, 20,
     21, 22, 23, 23, 24, 24, 25, 25, 26, 27, 27, 28, 28, 29, 29, 30, 31};
 
-static void intra_prediction_unit(HEVCContext *s, int x0, int y0,
+static void intra_prediction_unit(HEVCLocalContext *lc, int x0, int y0,
                                   int log2_cb_size)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     static const uint8_t intra_chroma_table[4] = { 0, 26, 10, 1 };
     uint8_t prev_intra_luma_pred_flag[4];
     int split   = lc->cu.part_mode == PART_NxN;
@@ -2095,17 +2096,17 @@ static void intra_prediction_unit(HEVCContext *s, int x0, int y0,
 
     for (i = 0; i < side; i++)
         for (j = 0; j < side; j++)
-            prev_intra_luma_pred_flag[2 * i + j] = ff_hevc_prev_intra_luma_pred_flag_decode(s);
+            prev_intra_luma_pred_flag[2 * i + j] = ff_hevc_prev_intra_luma_pred_flag_decode(lc);
 
     for (i = 0; i < side; i++) {
         for (j = 0; j < side; j++) {
             if (prev_intra_luma_pred_flag[2 * i + j])
-                lc->pu.mpm_idx = ff_hevc_mpm_idx_decode(s);
+                lc->pu.mpm_idx = ff_hevc_mpm_idx_decode(lc);
             else
-                lc->pu.rem_intra_luma_pred_mode = ff_hevc_rem_intra_luma_pred_mode_decode(s);
+                lc->pu.rem_intra_luma_pred_mode = ff_hevc_rem_intra_luma_pred_mode_decode(lc);
 
             lc->pu.intra_pred_mode[2 * i + j] =
-                luma_intra_pred_mode(s, x0 + pb_size * j, y0 + pb_size * i, pb_size,
+                luma_intra_pred_mode(lc, x0 + pb_size * j, y0 + pb_size * i, pb_size,
                                      prev_intra_luma_pred_flag[2 * i + j]);
         }
     }
@@ -2113,7 +2114,7 @@ static void intra_prediction_unit(HEVCContext *s, int x0, int y0,
     if (s->ps.sps->chroma_format_idc == 3) {
         for (i = 0; i < side; i++) {
             for (j = 0; j < side; j++) {
-                lc->pu.chroma_mode_c[2 * i + j] = chroma_mode = ff_hevc_intra_chroma_pred_mode_decode(s);
+                lc->pu.chroma_mode_c[2 * i + j] = chroma_mode = ff_hevc_intra_chroma_pred_mode_decode(lc);
                 if (chroma_mode != 4) {
                     if (lc->pu.intra_pred_mode[2 * i + j] == intra_chroma_table[chroma_mode])
                         lc->pu.intra_pred_mode_c[2 * i + j] = 34;
@@ -2126,7 +2127,7 @@ static void intra_prediction_unit(HEVCContext *s, int x0, int y0,
         }
     } else if (s->ps.sps->chroma_format_idc == 2) {
         int mode_idx;
-        lc->pu.chroma_mode_c[0] = chroma_mode = ff_hevc_intra_chroma_pred_mode_decode(s);
+        lc->pu.chroma_mode_c[0] = chroma_mode = ff_hevc_intra_chroma_pred_mode_decode(lc);
         if (chroma_mode != 4) {
             if (lc->pu.intra_pred_mode[0] == intra_chroma_table[chroma_mode])
                 mode_idx = 34;
@@ -2137,7 +2138,7 @@ static void intra_prediction_unit(HEVCContext *s, int x0, int y0,
         }
         lc->pu.intra_pred_mode_c[0] = tab_mode_idx[mode_idx];
     } else if (s->ps.sps->chroma_format_idc != 0) {
-        chroma_mode = ff_hevc_intra_chroma_pred_mode_decode(s);
+        chroma_mode = ff_hevc_intra_chroma_pred_mode_decode(lc);
         if (chroma_mode != 4) {
             if (lc->pu.intra_pred_mode[0] == intra_chroma_table[chroma_mode])
                 lc->pu.intra_pred_mode_c[0] = 34;
@@ -2149,11 +2150,11 @@ static void intra_prediction_unit(HEVCContext *s, int x0, int y0,
     }
 }
 
-static void intra_prediction_unit_default_value(HEVCContext *s,
+static void intra_prediction_unit_default_value(HEVCLocalContext *lc,
                                                 int x0, int y0,
                                                 int log2_cb_size)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int pb_size          = 1 << log2_cb_size;
     int size_in_pus      = pb_size >> s->ps.sps->log2_min_pu_size;
     int min_pu_width     = s->ps.sps->min_pu_width;
@@ -2172,10 +2173,9 @@ static void intra_prediction_unit_default_value(HEVCContext *s,
                 tab_mvf[(y_pu + j) * min_pu_width + x_pu + k].pred_flag = PF_INTRA;
 }
 
-static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)
+static int hls_coding_unit(HEVCLocalContext *lc, const HEVCContext *s, int x0, int y0, int log2_cb_size)
 {
     int cb_size          = 1 << log2_cb_size;
-    HEVCLocalContext *lc = s->HEVClc;
     int log2_min_cb_size = s->ps.sps->log2_min_cb_size;
     int length           = cb_size >> log2_min_cb_size;
     int min_cb_width     = s->ps.sps->min_cb_width;
@@ -2195,14 +2195,14 @@ static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)
     for (x = 0; x < 4; x++)
         lc->pu.intra_pred_mode[x] = 1;
     if (s->ps.pps->transquant_bypass_enable_flag) {
-        lc->cu.cu_transquant_bypass_flag = ff_hevc_cu_transquant_bypass_flag_decode(s);
+        lc->cu.cu_transquant_bypass_flag = ff_hevc_cu_transquant_bypass_flag_decode(lc);
         if (lc->cu.cu_transquant_bypass_flag)
             set_deblocking_bypass(s, x0, y0, log2_cb_size);
     } else
         lc->cu.cu_transquant_bypass_flag = 0;
 
     if (s->sh.slice_type != HEVC_SLICE_I) {
-        uint8_t skip_flag = ff_hevc_skip_flag_decode(s, x0, y0, x_cb, y_cb);
+        uint8_t skip_flag = ff_hevc_skip_flag_decode(lc, x0, y0, x_cb, y_cb);
 
         x = y_cb * min_cb_width + x_cb;
         for (y = 0; y < length; y++) {
@@ -2219,19 +2219,19 @@ static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)
     }
 
     if (SAMPLE_CTB(s->skip_flag, x_cb, y_cb)) {
-        hls_prediction_unit(s, x0, y0, cb_size, cb_size, log2_cb_size, 0, idx);
-        intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);
+        hls_prediction_unit(lc, x0, y0, cb_size, cb_size, log2_cb_size, 0, idx);
+        intra_prediction_unit_default_value(lc, x0, y0, log2_cb_size);
 
         if (!s->sh.disable_deblocking_filter_flag)
-            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_cb_size);
+            ff_hevc_deblocking_boundary_strengths(lc, x0, y0, log2_cb_size);
     } else {
         int pcm_flag = 0;
 
         if (s->sh.slice_type != HEVC_SLICE_I)
-            lc->cu.pred_mode = ff_hevc_pred_mode_decode(s);
+            lc->cu.pred_mode = ff_hevc_pred_mode_decode(lc);
         if (lc->cu.pred_mode != MODE_INTRA ||
             log2_cb_size == s->ps.sps->log2_min_cb_size) {
-            lc->cu.part_mode        = ff_hevc_part_mode_decode(s, log2_cb_size);
+            lc->cu.part_mode        = ff_hevc_part_mode_decode(lc, log2_cb_size);
             lc->cu.intra_split_flag = lc->cu.part_mode == PART_NxN &&
                                       lc->cu.pred_mode == MODE_INTRA;
         }
@@ -2240,54 +2240,54 @@ static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)
             if (lc->cu.part_mode == PART_2Nx2N && s->ps.sps->pcm_enabled_flag &&
                 log2_cb_size >= s->ps.sps->pcm.log2_min_pcm_cb_size &&
                 log2_cb_size <= s->ps.sps->pcm.log2_max_pcm_cb_size) {
-                pcm_flag = ff_hevc_pcm_flag_decode(s);
+                pcm_flag = ff_hevc_pcm_flag_decode(lc);
             }
             if (pcm_flag) {
-                intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);
-                ret = hls_pcm_sample(s, x0, y0, log2_cb_size);
+                intra_prediction_unit_default_value(lc, x0, y0, log2_cb_size);
+                ret = hls_pcm_sample(lc, x0, y0, log2_cb_size);
                 if (s->ps.sps->pcm.loop_filter_disable_flag)
                     set_deblocking_bypass(s, x0, y0, log2_cb_size);
 
                 if (ret < 0)
                     return ret;
             } else {
-                intra_prediction_unit(s, x0, y0, log2_cb_size);
+                intra_prediction_unit(lc, x0, y0, log2_cb_size);
             }
         } else {
-            intra_prediction_unit_default_value(s, x0, y0, log2_cb_size);
+            intra_prediction_unit_default_value(lc, x0, y0, log2_cb_size);
             switch (lc->cu.part_mode) {
             case PART_2Nx2N:
-                hls_prediction_unit(s, x0, y0, cb_size, cb_size, log2_cb_size, 0, idx);
+                hls_prediction_unit(lc, x0, y0, cb_size, cb_size, log2_cb_size, 0, idx);
                 break;
             case PART_2NxN:
-                hls_prediction_unit(s, x0, y0,               cb_size, cb_size / 2, log2_cb_size, 0, idx);
-                hls_prediction_unit(s, x0, y0 + cb_size / 2, cb_size, cb_size / 2, log2_cb_size, 1, idx);
+                hls_prediction_unit(lc, x0, y0,               cb_size, cb_size / 2, log2_cb_size, 0, idx);
+                hls_prediction_unit(lc, x0, y0 + cb_size / 2, cb_size, cb_size / 2, log2_cb_size, 1, idx);
                 break;
             case PART_Nx2N:
-                hls_prediction_unit(s, x0,               y0, cb_size / 2, cb_size, log2_cb_size, 0, idx - 1);
-                hls_prediction_unit(s, x0 + cb_size / 2, y0, cb_size / 2, cb_size, log2_cb_size, 1, idx - 1);
+                hls_prediction_unit(lc, x0,               y0, cb_size / 2, cb_size, log2_cb_size, 0, idx - 1);
+                hls_prediction_unit(lc, x0 + cb_size / 2, y0, cb_size / 2, cb_size, log2_cb_size, 1, idx - 1);
                 break;
             case PART_2NxnU:
-                hls_prediction_unit(s, x0, y0,               cb_size, cb_size     / 4, log2_cb_size, 0, idx);
-                hls_prediction_unit(s, x0, y0 + cb_size / 4, cb_size, cb_size * 3 / 4, log2_cb_size, 1, idx);
+                hls_prediction_unit(lc, x0, y0,               cb_size, cb_size     / 4, log2_cb_size, 0, idx);
+                hls_prediction_unit(lc, x0, y0 + cb_size / 4, cb_size, cb_size * 3 / 4, log2_cb_size, 1, idx);
                 break;
             case PART_2NxnD:
-                hls_prediction_unit(s, x0, y0,                   cb_size, cb_size * 3 / 4, log2_cb_size, 0, idx);
-                hls_prediction_unit(s, x0, y0 + cb_size * 3 / 4, cb_size, cb_size     / 4, log2_cb_size, 1, idx);
+                hls_prediction_unit(lc, x0, y0,                   cb_size, cb_size * 3 / 4, log2_cb_size, 0, idx);
+                hls_prediction_unit(lc, x0, y0 + cb_size * 3 / 4, cb_size, cb_size     / 4, log2_cb_size, 1, idx);
                 break;
             case PART_nLx2N:
-                hls_prediction_unit(s, x0,               y0, cb_size     / 4, cb_size, log2_cb_size, 0, idx - 2);
-                hls_prediction_unit(s, x0 + cb_size / 4, y0, cb_size * 3 / 4, cb_size, log2_cb_size, 1, idx - 2);
+                hls_prediction_unit(lc, x0,               y0, cb_size     / 4, cb_size, log2_cb_size, 0, idx - 2);
+                hls_prediction_unit(lc, x0 + cb_size / 4, y0, cb_size * 3 / 4, cb_size, log2_cb_size, 1, idx - 2);
                 break;
             case PART_nRx2N:
-                hls_prediction_unit(s, x0,                   y0, cb_size * 3 / 4, cb_size, log2_cb_size, 0, idx - 2);
-                hls_prediction_unit(s, x0 + cb_size * 3 / 4, y0, cb_size     / 4, cb_size, log2_cb_size, 1, idx - 2);
+                hls_prediction_unit(lc, x0,                   y0, cb_size * 3 / 4, cb_size, log2_cb_size, 0, idx - 2);
+                hls_prediction_unit(lc, x0 + cb_size * 3 / 4, y0, cb_size     / 4, cb_size, log2_cb_size, 1, idx - 2);
                 break;
             case PART_NxN:
-                hls_prediction_unit(s, x0,               y0,               cb_size / 2, cb_size / 2, log2_cb_size, 0, idx - 1);
-                hls_prediction_unit(s, x0 + cb_size / 2, y0,               cb_size / 2, cb_size / 2, log2_cb_size, 1, idx - 1);
-                hls_prediction_unit(s, x0,               y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 2, idx - 1);
-                hls_prediction_unit(s, x0 + cb_size / 2, y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 3, idx - 1);
+                hls_prediction_unit(lc, x0,               y0,               cb_size / 2, cb_size / 2, log2_cb_size, 0, idx - 1);
+                hls_prediction_unit(lc, x0 + cb_size / 2, y0,               cb_size / 2, cb_size / 2, log2_cb_size, 1, idx - 1);
+                hls_prediction_unit(lc, x0,               y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 2, idx - 1);
+                hls_prediction_unit(lc, x0 + cb_size / 2, y0 + cb_size / 2, cb_size / 2, cb_size / 2, log2_cb_size, 3, idx - 1);
                 break;
             }
         }
@@ -2297,27 +2297,27 @@ static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)
 
             if (lc->cu.pred_mode != MODE_INTRA &&
                 !(lc->cu.part_mode == PART_2Nx2N && lc->pu.merge_flag)) {
-                rqt_root_cbf = ff_hevc_no_residual_syntax_flag_decode(s);
+                rqt_root_cbf = ff_hevc_no_residual_syntax_flag_decode(lc);
             }
             if (rqt_root_cbf) {
                 const static int cbf[2] = { 0 };
                 lc->cu.max_trafo_depth = lc->cu.pred_mode == MODE_INTRA ?
                                          s->ps.sps->max_transform_hierarchy_depth_intra + lc->cu.intra_split_flag :
                                          s->ps.sps->max_transform_hierarchy_depth_inter;
-                ret = hls_transform_tree(s, x0, y0, x0, y0, x0, y0,
+                ret = hls_transform_tree(lc, x0, y0, x0, y0, x0, y0,
                                          log2_cb_size,
                                          log2_cb_size, 0, 0, cbf, cbf);
                 if (ret < 0)
                     return ret;
             } else {
                 if (!s->sh.disable_deblocking_filter_flag)
-                    ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_cb_size);
+                    ff_hevc_deblocking_boundary_strengths(lc, x0, y0, log2_cb_size);
             }
         }
     }
 
     if (s->ps.pps->cu_qp_delta_enabled_flag && lc->tu.is_cu_qp_delta_coded == 0)
-        ff_hevc_set_qPy(s, x0, y0, log2_cb_size);
+        ff_hevc_set_qPy(lc, x0, y0, log2_cb_size);
 
     x = y_cb * min_cb_width + x_cb;
     for (y = 0; y < length; y++) {
@@ -2335,10 +2335,10 @@ static int hls_coding_unit(HEVCContext *s, int x0, int y0, int log2_cb_size)
     return 0;
 }
 
-static int hls_coding_quadtree(HEVCContext *s, int x0, int y0,
+static int hls_coding_quadtree(HEVCLocalContext *lc, int x0, int y0,
                                int log2_cb_size, int cb_depth)
 {
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     const int cb_size    = 1 << log2_cb_size;
     int ret;
     int split_cu;
@@ -2347,7 +2347,7 @@ static int hls_coding_quadtree(HEVCContext *s, int x0, int y0,
     if (x0 + cb_size <= s->ps.sps->width  &&
         y0 + cb_size <= s->ps.sps->height &&
         log2_cb_size > s->ps.sps->log2_min_cb_size) {
-        split_cu = ff_hevc_split_coding_unit_flag_decode(s, cb_depth, x0, y0);
+        split_cu = ff_hevc_split_coding_unit_flag_decode(lc, cb_depth, x0, y0);
     } else {
         split_cu = (log2_cb_size > s->ps.sps->log2_min_cb_size);
     }
@@ -2370,23 +2370,23 @@ static int hls_coding_quadtree(HEVCContext *s, int x0, int y0,
 
         int more_data = 0;
 
-        more_data = hls_coding_quadtree(s, x0, y0, log2_cb_size - 1, cb_depth + 1);
+        more_data = hls_coding_quadtree(lc, x0, y0, log2_cb_size - 1, cb_depth + 1);
         if (more_data < 0)
             return more_data;
 
         if (more_data && x1 < s->ps.sps->width) {
-            more_data = hls_coding_quadtree(s, x1, y0, log2_cb_size - 1, cb_depth + 1);
+            more_data = hls_coding_quadtree(lc, x1, y0, log2_cb_size - 1, cb_depth + 1);
             if (more_data < 0)
                 return more_data;
         }
         if (more_data && y1 < s->ps.sps->height) {
-            more_data = hls_coding_quadtree(s, x0, y1, log2_cb_size - 1, cb_depth + 1);
+            more_data = hls_coding_quadtree(lc, x0, y1, log2_cb_size - 1, cb_depth + 1);
             if (more_data < 0)
                 return more_data;
         }
         if (more_data && x1 < s->ps.sps->width &&
             y1 < s->ps.sps->height) {
-            more_data = hls_coding_quadtree(s, x1, y1, log2_cb_size - 1, cb_depth + 1);
+            more_data = hls_coding_quadtree(lc, x1, y1, log2_cb_size - 1, cb_depth + 1);
             if (more_data < 0)
                 return more_data;
         }
@@ -2401,7 +2401,7 @@ static int hls_coding_quadtree(HEVCContext *s, int x0, int y0,
         else
             return 0;
     } else {
-        ret = hls_coding_unit(s, x0, y0, log2_cb_size);
+        ret = hls_coding_unit(lc, s, x0, y0, log2_cb_size);
         if (ret < 0)
             return ret;
         if ((!((x0 + cb_size) %
@@ -2410,7 +2410,7 @@ static int hls_coding_quadtree(HEVCContext *s, int x0, int y0,
             (!((y0 + cb_size) %
                (1 << (s->ps.sps->log2_ctb_size))) ||
              (y0 + cb_size >= s->ps.sps->height))) {
-            int end_of_slice_flag = ff_hevc_end_of_slice_flag_decode(s);
+            int end_of_slice_flag = ff_hevc_end_of_slice_flag_decode(lc);
             return !end_of_slice_flag;
         } else {
             return 1;
@@ -2420,10 +2420,10 @@ static int hls_coding_quadtree(HEVCContext *s, int x0, int y0,
     return 0;
 }
 
-static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
+static void hls_decode_neighbour(HEVCLocalContext *lc, int x_ctb, int y_ctb,
                                  int ctb_addr_ts)
 {
-    HEVCLocalContext *lc  = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int ctb_size          = 1 << s->ps.sps->log2_ctb_size;
     int ctb_addr_rs       = s->ps.pps->ctb_addr_ts_to_rs[ctb_addr_ts];
     int ctb_addr_in_slice = ctb_addr_rs - s->sh.slice_addr;
@@ -2472,6 +2472,7 @@ static void hls_decode_neighbour(HEVCContext *s, int x_ctb, int y_ctb,
 static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 {
     HEVCContext *s  = avctxt->priv_data;
+    HEVCLocalContext *const lc = s->HEVClc;
     int ctb_size    = 1 << s->ps.sps->log2_ctb_size;
     int more_data   = 1;
     int x_ctb       = 0;
@@ -2497,21 +2498,21 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
         x_ctb = (ctb_addr_rs % ((s->ps.sps->width + ctb_size - 1) >> s->ps.sps->log2_ctb_size)) << s->ps.sps->log2_ctb_size;
         y_ctb = (ctb_addr_rs / ((s->ps.sps->width + ctb_size - 1) >> s->ps.sps->log2_ctb_size)) << s->ps.sps->log2_ctb_size;
-        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);
+        hls_decode_neighbour(lc, x_ctb, y_ctb, ctb_addr_ts);
 
-        ret = ff_hevc_cabac_init(s, ctb_addr_ts, 0);
+        ret = ff_hevc_cabac_init(lc, ctb_addr_ts);
         if (ret < 0) {
             s->tab_slice_address[ctb_addr_rs] = -1;
             return ret;
         }
 
-        hls_sao_param(s, x_ctb >> s->ps.sps->log2_ctb_size, y_ctb >> s->ps.sps->log2_ctb_size);
+        hls_sao_param(lc, x_ctb >> s->ps.sps->log2_ctb_size, y_ctb >> s->ps.sps->log2_ctb_size);
 
         s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;
         s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;
         s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;
 
-        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+        more_data = hls_coding_quadtree(lc, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
         if (more_data < 0) {
             s->tab_slice_address[ctb_addr_rs] = -1;
             return more_data;
@@ -2519,13 +2520,13 @@ static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)
 
 
         ctb_addr_ts++;
-        ff_hevc_save_states(s, ctb_addr_ts);
-        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
+        ff_hevc_save_states(lc, ctb_addr_ts);
+        ff_hevc_hls_filters(lc, x_ctb, y_ctb, ctb_size);
     }
 
     if (x_ctb + ctb_size >= s->ps.sps->width &&
         y_ctb + ctb_size >= s->ps.sps->height)
-        ff_hevc_hls_filter(s, x_ctb, y_ctb, ctb_size);
+        ff_hevc_hls_filter(lc, x_ctb, y_ctb, ctb_size);
 
     return ctb_addr_ts;
 }
@@ -2541,22 +2542,19 @@ static int hls_slice_data(HEVCContext *s)
     s->avctx->execute(s->avctx, hls_decode_entry, arg, ret , 1, sizeof(int));
     return ret[0];
 }
-static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int job, int self_id)
+static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *hevc_lclist,
+                                int job, int self_id)
 {
-    HEVCContext *s1  = avctxt->priv_data, *s;
-    HEVCLocalContext *lc;
-    int ctb_size    = 1<< s1->ps.sps->log2_ctb_size;
+    HEVCLocalContext *lc = ((HEVCLocalContext**)hevc_lclist)[self_id];
+    const HEVCContext *const s = lc->parent;
+    int ctb_size    = 1 << s->ps.sps->log2_ctb_size;
     int more_data   = 1;
-    int *ctb_row_p    = input_ctb_row;
-    int ctb_row = ctb_row_p[job];
-    int ctb_addr_rs = s1->sh.slice_ctb_addr_rs + ctb_row * ((s1->ps.sps->width + ctb_size - 1) >> s1->ps.sps->log2_ctb_size);
-    int ctb_addr_ts = s1->ps.pps->ctb_addr_rs_to_ts[ctb_addr_rs];
-    int thread = ctb_row % s1->threads_number;
+    int ctb_row = job;
+    int ctb_addr_rs = s->sh.slice_ctb_addr_rs + ctb_row * ((s->ps.sps->width + ctb_size - 1) >> s->ps.sps->log2_ctb_size);
+    int ctb_addr_ts = s->ps.pps->ctb_addr_rs_to_ts[ctb_addr_rs];
+    int thread = ctb_row % s->threads_number;
     int ret;
 
-    s = s1->sList[self_id];
-    lc = s->HEVClc;
-
     if(ctb_row) {
         ret = init_get_bits8(&lc->gb, s->data + s->sh.offset[ctb_row - 1], s->sh.size[ctb_row - 1]);
         if (ret < 0)
@@ -2568,20 +2566,23 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
         int x_ctb = (ctb_addr_rs % s->ps.sps->ctb_width) << s->ps.sps->log2_ctb_size;
         int y_ctb = (ctb_addr_rs / s->ps.sps->ctb_width) << s->ps.sps->log2_ctb_size;
 
-        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);
+        hls_decode_neighbour(lc, x_ctb, y_ctb, ctb_addr_ts);
 
         ff_thread_await_progress2(s->avctx, ctb_row, thread, SHIFT_CTB_WPP);
 
-        if (atomic_load(&s1->wpp_err)) {
+        /* atomic_load's prototype requires a pointer to non-const atomic variable
+         * (due to implementations via mutexes, where reads involve writes).
+         * Of course, casting const away here is nevertheless safe. */
+        if (atomic_load((atomic_int*)&s->wpp_err)) {
             ff_thread_report_progress2(s->avctx, ctb_row , thread, SHIFT_CTB_WPP);
             return 0;
         }
 
-        ret = ff_hevc_cabac_init(s, ctb_addr_ts, thread);
+        ret = ff_hevc_cabac_init(lc, ctb_addr_ts);
         if (ret < 0)
             goto error;
-        hls_sao_param(s, x_ctb >> s->ps.sps->log2_ctb_size, y_ctb >> s->ps.sps->log2_ctb_size);
-        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
+        hls_sao_param(lc, x_ctb >> s->ps.sps->log2_ctb_size, y_ctb >> s->ps.sps->log2_ctb_size);
+        more_data = hls_coding_quadtree(lc, x_ctb, y_ctb, s->ps.sps->log2_ctb_size, 0);
 
         if (more_data < 0) {
             ret = more_data;
@@ -2590,18 +2591,19 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
 
         ctb_addr_ts++;
 
-        ff_hevc_save_states(s, ctb_addr_ts);
+        ff_hevc_save_states(lc, ctb_addr_ts);
         ff_thread_report_progress2(s->avctx, ctb_row, thread, 1);
-        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);
+        ff_hevc_hls_filters(lc, x_ctb, y_ctb, ctb_size);
 
         if (!more_data && (x_ctb+ctb_size) < s->ps.sps->width && ctb_row != s->sh.num_entry_point_offsets) {
-            atomic_store(&s1->wpp_err, 1);
+            /* Casting const away here is safe, because it is an atomic operation. */
+            atomic_store((atomic_int*)&s->wpp_err, 1);
             ff_thread_report_progress2(s->avctx, ctb_row ,thread, SHIFT_CTB_WPP);
             return 0;
         }
 
         if ((x_ctb+ctb_size) >= s->ps.sps->width && (y_ctb+ctb_size) >= s->ps.sps->height ) {
-            ff_hevc_hls_filter(s, x_ctb, y_ctb, ctb_size);
+            ff_hevc_hls_filter(lc, x_ctb, y_ctb, ctb_size);
             ff_thread_report_progress2(s->avctx, ctb_row , thread, SHIFT_CTB_WPP);
             return ctb_addr_ts;
         }
@@ -2617,7 +2619,8 @@ static int hls_decode_entry_wpp(AVCodecContext *avctxt, void *input_ctb_row, int
     return 0;
 error:
     s->tab_slice_address[ctb_addr_rs] = -1;
-    atomic_store(&s1->wpp_err, 1);
+    /* Casting const away here is safe, because it is an atomic operation. */
+    atomic_store((atomic_int*)&s->wpp_err, 1);
     ff_thread_report_progress2(s->avctx, ctb_row ,thread, SHIFT_CTB_WPP);
     return ret;
 }
@@ -2627,42 +2630,28 @@ static int hls_slice_data_wpp(HEVCContext *s, const H2645NAL *nal)
     const uint8_t *data = nal->data;
     int length          = nal->size;
     HEVCLocalContext *lc = s->HEVClc;
-    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));
-    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));
+    int *ret;
     int64_t offset;
     int64_t startheader, cmpt = 0;
     int i, j, res = 0;
 
-    if (!ret || !arg) {
-        av_free(ret);
-        av_free(arg);
-        return AVERROR(ENOMEM);
-    }
-
     if (s->sh.slice_ctb_addr_rs + s->sh.num_entry_point_offsets * s->ps.sps->ctb_width >= s->ps.sps->ctb_width * s->ps.sps->ctb_height) {
         av_log(s->avctx, AV_LOG_ERROR, "WPP ctb addresses are wrong (%d %d %d %d)\n",
             s->sh.slice_ctb_addr_rs, s->sh.num_entry_point_offsets,
             s->ps.sps->ctb_width, s->ps.sps->ctb_height
         );
-        res = AVERROR_INVALIDDATA;
-        goto error;
+        return AVERROR_INVALIDDATA;
     }
 
-    ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);
-
     for (i = 1; i < s->threads_number; i++) {
-        if (s->sList[i] && s->HEVClcList[i])
+        if (s->HEVClcList[i])
             continue;
-        av_freep(&s->sList[i]);
-        av_freep(&s->HEVClcList[i]);
-        s->sList[i] = av_malloc(sizeof(HEVCContext));
         s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext));
-        if (!s->sList[i] || !s->HEVClcList[i]) {
-            res = AVERROR(ENOMEM);
-            goto error;
-        }
-        memcpy(s->sList[i], s, sizeof(HEVCContext));
-        s->sList[i]->HEVClc = s->HEVClcList[i];
+        if (!s->HEVClcList[i])
+            return AVERROR(ENOMEM);
+        s->HEVClcList[i]->logctx = s->avctx;
+        s->HEVClcList[i]->parent = s;
+        s->HEVClcList[i]->common_cabac_state = &s->cabac;
     }
 
     offset = (lc->gb.index >> 3);
@@ -2691,8 +2680,7 @@ static int hls_slice_data_wpp(HEVCContext *s, const H2645NAL *nal)
         offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt;
         if (length < offset) {
             av_log(s->avctx, AV_LOG_ERROR, "entry_point_offset table is corrupted\n");
-            res = AVERROR_INVALIDDATA;
-            goto error;
+            return AVERROR_INVALIDDATA;
         }
         s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset;
         s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset;
@@ -2701,28 +2689,26 @@ static int hls_slice_data_wpp(HEVCContext *s, const H2645NAL *nal)
     s->data = data;
 
     for (i = 1; i < s->threads_number; i++) {
-        s->sList[i]->HEVClc->first_qp_group = 1;
-        s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y;
-        memcpy(s->sList[i], s, sizeof(HEVCContext));
-        s->sList[i]->HEVClc = s->HEVClcList[i];
+        s->HEVClcList[i]->first_qp_group = 1;
+        s->HEVClcList[i]->qp_y = s->HEVClc->qp_y;
     }
 
     atomic_store(&s->wpp_err, 0);
-    ff_reset_entries(s->avctx);
+    res = ff_slice_thread_allocz_entries(s->avctx, s->sh.num_entry_point_offsets + 1);
+    if (res < 0)
+        return res;
 
-    for (i = 0; i <= s->sh.num_entry_point_offsets; i++) {
-        arg[i] = i;
-        ret[i] = 0;
-    }
+    ret = av_calloc(s->sh.num_entry_point_offsets + 1, sizeof(*ret));
+    if (!ret)
+        return AVERROR(ENOMEM);
 
     if (s->ps.pps->entropy_coding_sync_enabled_flag)
-        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);
+        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, s->HEVClcList, ret, s->sh.num_entry_point_offsets + 1);
 
     for (i = 0; i <= s->sh.num_entry_point_offsets; i++)
         res += ret[i];
-error:
+
     av_free(ret);
-    av_free(arg);
     return res;
 }
 
@@ -3266,7 +3252,7 @@ static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
         break;
     case HEVC_NAL_EOS_NUT:
     case HEVC_NAL_EOB_NUT:
-        s->seq_decode = (s->seq_decode + 1) & 0xff;
+        s->seq_decode = (s->seq_decode + 1) & HEVC_SEQUENCE_COUNTER_MASK;
         s->max_ra     = INT_MAX;
         break;
     case HEVC_NAL_AUD:
@@ -3374,17 +3360,12 @@ fail:
     return ret;
 }
 
-static void print_md5(void *log_ctx, int level, uint8_t md5[16])
-{
-    int i;
-    for (i = 0; i < 16; i++)
-        av_log(log_ctx, level, "%02"PRIx8, md5[i]);
-}
-
 static int verify_md5(HEVCContext *s, AVFrame *frame)
 {
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);
+    char msg_buf[4 * (50 + 2 * 2 * 16 /* MD5-size */)];
     int pixel_shift;
+    int err = 0;
     int i, j;
 
     if (!desc)
@@ -3392,9 +3373,6 @@ static int verify_md5(HEVCContext *s, AVFrame *frame)
 
     pixel_shift = desc->comp[0].depth > 8;
 
-    av_log(s->avctx, AV_LOG_DEBUG, "Verifying checksum for frame with POC %d: ",
-           s->poc);
-
     /* the checksums are LE, so we have to byteswap for >8bpp formats
      * on BE arches */
 #if HAVE_BIGENDIAN
@@ -3407,6 +3385,7 @@ static int verify_md5(HEVCContext *s, AVFrame *frame)
     }
 #endif
 
+    msg_buf[0] = '\0';
     for (i = 0; frame->data[i]; i++) {
         int width  = s->avctx->coded_width;
         int height = s->avctx->coded_height;
@@ -3428,23 +3407,26 @@ static int verify_md5(HEVCContext *s, AVFrame *frame)
         }
         av_md5_final(s->md5_ctx, md5);
 
+#define MD5_PRI "%016" PRIx64 "%016" PRIx64
+#define MD5_PRI_ARG(buf) AV_RB64(buf), AV_RB64((const uint8_t*)(buf) + 8)
+
         if (!memcmp(md5, s->sei.picture_hash.md5[i], 16)) {
-            av_log   (s->avctx, AV_LOG_DEBUG, "plane %d - correct ", i);
-            print_md5(s->avctx, AV_LOG_DEBUG, md5);
-            av_log   (s->avctx, AV_LOG_DEBUG, "; ");
+            av_strlcatf(msg_buf, sizeof(msg_buf),
+                        "plane %d - correct " MD5_PRI "; ",
+                        i, MD5_PRI_ARG(md5));
         } else {
-            av_log   (s->avctx, AV_LOG_ERROR, "mismatching checksum of plane %d - ", i);
-            print_md5(s->avctx, AV_LOG_ERROR, md5);
-            av_log   (s->avctx, AV_LOG_ERROR, " != ");
-            print_md5(s->avctx, AV_LOG_ERROR, s->sei.picture_hash.md5[i]);
-            av_log   (s->avctx, AV_LOG_ERROR, "\n");
-            return AVERROR_INVALIDDATA;
+            av_strlcatf(msg_buf, sizeof(msg_buf),
+                       "mismatching checksum of plane %d - " MD5_PRI " != " MD5_PRI "; ",
+                        i, MD5_PRI_ARG(md5), MD5_PRI_ARG(s->sei.picture_hash.md5[i]));
+            err = AVERROR_INVALIDDATA;
         }
     }
 
-    av_log(s->avctx, AV_LOG_DEBUG, "\n");
+    av_log(s->avctx, err < 0 ? AV_LOG_ERROR : AV_LOG_DEBUG,
+           "Verifying checksum for frame with POC %d: %s\n",
+           s->poc, msg_buf);
 
-    return 0;
+    return err;
 }
 
 static int hevc_decode_extradata(HEVCContext *s, uint8_t *buf, int length, int first)
@@ -3516,7 +3498,7 @@ static int hevc_decode_frame(AVCodecContext *avctx, AVFrame *rframe,
         }
     } else {
         /* verify the SEI checksum */
-        if (avctx->err_recognition & AV_EF_CRCCHECK && s->ref && s->is_decoded &&
+        if (avctx->err_recognition & AV_EF_CRCCHECK && s->is_decoded &&
             s->sei.picture_hash.is_md5) {
             ret = verify_md5(s, s->ref->frame);
             if (ret < 0 && avctx->err_recognition & AV_EF_EXPLODE) {
@@ -3599,8 +3581,6 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
 
     av_freep(&s->md5_ctx);
 
-    av_freep(&s->cabac_state);
-
     for (i = 0; i < 3; i++) {
         av_freep(&s->sao_pixel_buffer_h[i]);
         av_freep(&s->sao_pixel_buffer_v[i]);
@@ -3619,15 +3599,13 @@ static av_cold int hevc_decode_free(AVCodecContext *avctx)
     av_freep(&s->sh.offset);
     av_freep(&s->sh.size);
 
-    if (s->HEVClcList && s->sList) {
+    if (s->HEVClcList) {
         for (i = 1; i < s->threads_number; i++) {
             av_freep(&s->HEVClcList[i]);
-            av_freep(&s->sList[i]);
         }
     }
     av_freep(&s->HEVClc);
     av_freep(&s->HEVClcList);
-    av_freep(&s->sList);
 
     ff_h2645_packet_uninit(&s->pkt);
 
@@ -3645,15 +3623,12 @@ static av_cold int hevc_init_context(AVCodecContext *avctx)
 
     s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
     s->HEVClcList = av_mallocz(sizeof(HEVCLocalContext*) * s->threads_number);
-    s->sList = av_mallocz(sizeof(HEVCContext*) * s->threads_number);
-    if (!s->HEVClc || !s->HEVClcList || !s->sList)
+    if (!s->HEVClc || !s->HEVClcList)
         return AVERROR(ENOMEM);
+    s->HEVClc->parent = s;
+    s->HEVClc->logctx = avctx;
+    s->HEVClc->common_cabac_state = &s->cabac;
     s->HEVClcList[0] = s->HEVClc;
-    s->sList[0] = s;
-
-    s->cabac_state = av_malloc(HEVC_CONTEXTS);
-    if (!s->cabac_state)
-        return AVERROR(ENOMEM);
 
     s->output_frame = av_frame_alloc();
     if (!s->output_frame)
@@ -3741,7 +3716,7 @@ static int hevc_update_thread_context(AVCodecContext *dst,
     s->threads_type        = s0->threads_type;
 
     if (s0->eos) {
-        s->seq_decode = (s->seq_decode + 1) & 0xff;
+        s->seq_decode = (s->seq_decode + 1) & HEVC_SEQUENCE_COUNTER_MASK;
         s->max_ra = INT_MAX;
     }
 
@@ -3881,7 +3856,7 @@ const FFCodec ff_hevc_decoder = {
     .update_thread_context = ONLY_IF_THREADS_ENABLED(hevc_update_thread_context),
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY |
                              AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_EXPORTS_CROPPING |
+    .caps_internal         = FF_CODEC_CAP_EXPORTS_CROPPING |
                              FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP,
     .p.profiles            = NULL_IF_CONFIG_SMALL(ff_hevc_profiles),
     .hw_configs            = (const AVCodecHWConfigInternal *const []) {
diff --git a/libavcodec/hevcdec.h b/libavcodec/hevcdec.h
index f6acf84..9d3f4ad 100644
--- a/libavcodec/hevcdec.h
+++ b/libavcodec/hevcdec.h
@@ -226,6 +226,11 @@ enum ScanType {
     SCAN_VERT,
 };
 
+typedef struct HEVCCABACState {
+    uint8_t state[HEVC_CONTEXTS];
+    uint8_t stat_coeff[HEVC_STAT_COEFFS];
+} HEVCCABACState;
+
 typedef struct LongTermRPS {
     int     poc[32];
     uint8_t poc_msb_present[32];
@@ -390,6 +395,9 @@ typedef struct DBParams {
 #define HEVC_FRAME_FLAG_LONG_REF  (1 << 2)
 #define HEVC_FRAME_FLAG_BUMPING   (1 << 3)
 
+#define HEVC_SEQUENCE_COUNTER_MASK 0xff
+#define HEVC_SEQUENCE_COUNTER_INVALID (HEVC_SEQUENCE_COUNTER_MASK + 1)
+
 typedef struct HEVCFrame {
     AVFrame *frame;
     AVFrame *frame_grain;
@@ -428,9 +436,24 @@ typedef struct HEVCLocalContext {
 
     uint8_t first_qp_group;
 
+    void *logctx;
+    const struct HEVCContext *parent;
+
     GetBitContext gb;
     CABACContext cc;
 
+    /**
+     * This is a pointer to the common CABAC state.
+     * In case entropy_coding_sync_enabled_flag is set,
+     * the CABAC state after decoding the second CTU in a row is
+     * stored here and used to initialize the CABAC state before
+     * decoding the first CTU in the next row.
+     * This is the basis for WPP and in case slice-threading is used,
+     * the next row is decoded by another thread making this state
+     * shared between threads.
+     */
+    HEVCCABACState *common_cabac_state;
+
     int8_t qp_y;
     int8_t curr_qp_y;
 
@@ -468,8 +491,6 @@ typedef struct HEVCContext {
     const AVClass *c;  // needed by private avoptions
     AVCodecContext *avctx;
 
-    struct HEVCContext  **sList;
-
     HEVCLocalContext    **HEVClcList;
     HEVCLocalContext    *HEVClc;
 
@@ -479,9 +500,6 @@ typedef struct HEVCContext {
     int                 width;
     int                 height;
 
-    uint8_t *cabac_state;
-    uint8_t stat_coeff[HEVC_STAT_COEFFS];
-
     /** 1 if the independent slice segment header was successfully parsed */
     uint8_t slice_initialized;
 
@@ -554,6 +572,9 @@ typedef struct HEVCContext {
     uint16_t seq_decode;
     uint16_t seq_output;
 
+    /** The target for the common_cabac_state of the local contexts. */
+    HEVCCABACState cabac;
+
     int enable_parallel_tiles;
     atomic_int wpp_err;
 
@@ -597,38 +618,38 @@ int ff_hevc_frame_rps(HEVCContext *s);
  */
 int ff_hevc_slice_rpl(HEVCContext *s);
 
-void ff_hevc_save_states(HEVCContext *s, int ctb_addr_ts);
-int ff_hevc_cabac_init(HEVCContext *s, int ctb_addr_ts, int thread);
-int ff_hevc_sao_merge_flag_decode(HEVCContext *s);
-int ff_hevc_sao_type_idx_decode(HEVCContext *s);
-int ff_hevc_sao_band_position_decode(HEVCContext *s);
-int ff_hevc_sao_offset_abs_decode(HEVCContext *s);
-int ff_hevc_sao_offset_sign_decode(HEVCContext *s);
-int ff_hevc_sao_eo_class_decode(HEVCContext *s);
-int ff_hevc_end_of_slice_flag_decode(HEVCContext *s);
-int ff_hevc_cu_transquant_bypass_flag_decode(HEVCContext *s);
-int ff_hevc_skip_flag_decode(HEVCContext *s, int x0, int y0,
+void ff_hevc_save_states(HEVCLocalContext *lc, int ctb_addr_ts);
+int ff_hevc_cabac_init(HEVCLocalContext *lc, int ctb_addr_ts);
+int ff_hevc_sao_merge_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_sao_type_idx_decode(HEVCLocalContext *lc);
+int ff_hevc_sao_band_position_decode(HEVCLocalContext *lc);
+int ff_hevc_sao_offset_abs_decode(HEVCLocalContext *lc);
+int ff_hevc_sao_offset_sign_decode(HEVCLocalContext *lc);
+int ff_hevc_sao_eo_class_decode(HEVCLocalContext *lc);
+int ff_hevc_end_of_slice_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_cu_transquant_bypass_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_skip_flag_decode(HEVCLocalContext *lc, int x0, int y0,
                              int x_cb, int y_cb);
-int ff_hevc_pred_mode_decode(HEVCContext *s);
-int ff_hevc_split_coding_unit_flag_decode(HEVCContext *s, int ct_depth,
+int ff_hevc_pred_mode_decode(HEVCLocalContext *lc);
+int ff_hevc_split_coding_unit_flag_decode(HEVCLocalContext *lc, int ct_depth,
                                           int x0, int y0);
-int ff_hevc_part_mode_decode(HEVCContext *s, int log2_cb_size);
-int ff_hevc_pcm_flag_decode(HEVCContext *s);
-int ff_hevc_prev_intra_luma_pred_flag_decode(HEVCContext *s);
-int ff_hevc_mpm_idx_decode(HEVCContext *s);
-int ff_hevc_rem_intra_luma_pred_mode_decode(HEVCContext *s);
-int ff_hevc_intra_chroma_pred_mode_decode(HEVCContext *s);
-int ff_hevc_merge_idx_decode(HEVCContext *s);
-int ff_hevc_merge_flag_decode(HEVCContext *s);
-int ff_hevc_inter_pred_idc_decode(HEVCContext *s, int nPbW, int nPbH);
-int ff_hevc_ref_idx_lx_decode(HEVCContext *s, int num_ref_idx_lx);
-int ff_hevc_mvp_lx_flag_decode(HEVCContext *s);
-int ff_hevc_no_residual_syntax_flag_decode(HEVCContext *s);
-int ff_hevc_split_transform_flag_decode(HEVCContext *s, int log2_trafo_size);
-int ff_hevc_cbf_cb_cr_decode(HEVCContext *s, int trafo_depth);
-int ff_hevc_cbf_luma_decode(HEVCContext *s, int trafo_depth);
-int ff_hevc_log2_res_scale_abs(HEVCContext *s, int idx);
-int ff_hevc_res_scale_sign_flag(HEVCContext *s, int idx);
+int ff_hevc_part_mode_decode(HEVCLocalContext *lc, int log2_cb_size);
+int ff_hevc_pcm_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_prev_intra_luma_pred_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_mpm_idx_decode(HEVCLocalContext *lc);
+int ff_hevc_rem_intra_luma_pred_mode_decode(HEVCLocalContext *lc);
+int ff_hevc_intra_chroma_pred_mode_decode(HEVCLocalContext *lc);
+int ff_hevc_merge_idx_decode(HEVCLocalContext *lc);
+int ff_hevc_merge_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_inter_pred_idc_decode(HEVCLocalContext *lc, int nPbW, int nPbH);
+int ff_hevc_ref_idx_lx_decode(HEVCLocalContext *lc, int num_ref_idx_lx);
+int ff_hevc_mvp_lx_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_no_residual_syntax_flag_decode(HEVCLocalContext *lc);
+int ff_hevc_split_transform_flag_decode(HEVCLocalContext *lc, int log2_trafo_size);
+int ff_hevc_cbf_cb_cr_decode(HEVCLocalContext *lc, int trafo_depth);
+int ff_hevc_cbf_luma_decode(HEVCLocalContext *lc, int trafo_depth);
+int ff_hevc_log2_res_scale_abs(HEVCLocalContext *lc, int idx);
+int ff_hevc_res_scale_sign_flag(HEVCLocalContext *lc, int idx);
 
 /**
  * Get the number of candidate references for the current frame.
@@ -664,30 +685,30 @@ void ff_hevc_bump_frame(HEVCContext *s);
 
 void ff_hevc_unref_frame(HEVCContext *s, HEVCFrame *frame, int flags);
 
-void ff_hevc_set_neighbour_available(HEVCContext *s, int x0, int y0,
+void ff_hevc_set_neighbour_available(HEVCLocalContext *lc, int x0, int y0,
                                      int nPbW, int nPbH);
-void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0,
+void ff_hevc_luma_mv_merge_mode(HEVCLocalContext *lc, int x0, int y0,
                                 int nPbW, int nPbH, int log2_cb_size,
                                 int part_idx, int merge_idx, MvField *mv);
-void ff_hevc_luma_mv_mvp_mode(HEVCContext *s, int x0, int y0,
+void ff_hevc_luma_mv_mvp_mode(HEVCLocalContext *lc, int x0, int y0,
                               int nPbW, int nPbH, int log2_cb_size,
                               int part_idx, int merge_idx,
                               MvField *mv, int mvp_lx_flag, int LX);
-void ff_hevc_set_qPy(HEVCContext *s, int xBase, int yBase,
+void ff_hevc_hls_filter(HEVCLocalContext *lc, int x, int y, int ctb_size);
+void ff_hevc_hls_filters(HEVCLocalContext *lc, int x_ctb, int y_ctb, int ctb_size);
+void ff_hevc_set_qPy(HEVCLocalContext *lc, int xBase, int yBase,
                      int log2_cb_size);
-void ff_hevc_deblocking_boundary_strengths(HEVCContext *s, int x0, int y0,
+void ff_hevc_deblocking_boundary_strengths(HEVCLocalContext *lc, int x0, int y0,
                                            int log2_trafo_size);
-int ff_hevc_cu_qp_delta_sign_flag(HEVCContext *s);
-int ff_hevc_cu_qp_delta_abs(HEVCContext *s);
-int ff_hevc_cu_chroma_qp_offset_flag(HEVCContext *s);
-int ff_hevc_cu_chroma_qp_offset_idx(HEVCContext *s);
-void ff_hevc_hls_filter(HEVCContext *s, int x, int y, int ctb_size);
-void ff_hevc_hls_filters(HEVCContext *s, int x_ctb, int y_ctb, int ctb_size);
-void ff_hevc_hls_residual_coding(HEVCContext *s, int x0, int y0,
+int ff_hevc_cu_qp_delta_sign_flag(HEVCLocalContext *lc);
+int ff_hevc_cu_qp_delta_abs(HEVCLocalContext *lc);
+int ff_hevc_cu_chroma_qp_offset_flag(HEVCLocalContext *lc);
+int ff_hevc_cu_chroma_qp_offset_idx(HEVCLocalContext *lc);
+void ff_hevc_hls_residual_coding(HEVCLocalContext *lc, int x0, int y0,
                                  int log2_trafo_size, enum ScanType scan_idx,
                                  int c_idx);
 
-void ff_hevc_hls_mvd_coding(HEVCContext *s, int x0, int y0, int log2_cb_size);
+void ff_hevc_hls_mvd_coding(HEVCLocalContext *lc, int x0, int y0, int log2_cb_size);
 
 extern const uint8_t ff_hevc_qpel_extra_before[4];
 extern const uint8_t ff_hevc_qpel_extra_after[4];
diff --git a/libavcodec/hevcdsp.h b/libavcodec/hevcdsp.h
index d642ecf..1b9c5bb 100644
--- a/libavcodec/hevcdsp.h
+++ b/libavcodec/hevcdsp.h
@@ -48,7 +48,7 @@ typedef struct HEVCDSPContext {
     void (*put_pcm)(uint8_t *_dst, ptrdiff_t _stride, int width, int height,
                     struct GetBitContext *gb, int pcm_bit_depth);
 
-    void (*add_residual[4])(uint8_t *dst, int16_t *res, ptrdiff_t stride);
+    void (*add_residual[4])(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
 
     void (*dequant)(int16_t *coeffs, int16_t log2_size);
 
@@ -60,68 +60,68 @@ typedef struct HEVCDSPContext {
 
     void (*idct_dc[4])(int16_t *coeffs);
 
-    void (*sao_band_filter[5])(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
-                               int16_t *sao_offset_val, int sao_left_class, int width, int height);
+    void (*sao_band_filter[5])(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
+                               const int16_t *sao_offset_val, int sao_left_class, int width, int height);
 
     /* implicit stride_src parameter has value of 2 * MAX_PB_SIZE + AV_INPUT_BUFFER_PADDING_SIZE */
-    void (*sao_edge_filter[5])(uint8_t *_dst /* align 16 */, uint8_t *_src /* align 32 */, ptrdiff_t stride_dst,
-                               int16_t *sao_offset_val, int sao_eo_class, int width, int height);
+    void (*sao_edge_filter[5])(uint8_t *_dst /* align 16 */, const uint8_t *_src /* align 32 */, ptrdiff_t stride_dst,
+                               const int16_t *sao_offset_val, int sao_eo_class, int width, int height);
 
-    void (*sao_edge_restore[2])(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
-                                struct SAOParams *sao, int *borders, int _width, int _height, int c_idx,
-                                uint8_t *vert_edge, uint8_t *horiz_edge, uint8_t *diag_edge);
+    void (*sao_edge_restore[2])(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
+                                const struct SAOParams *sao, const int *borders, int _width, int _height, int c_idx,
+                                const uint8_t *vert_edge, const uint8_t *horiz_edge, const uint8_t *diag_edge);
 
-    void (*put_hevc_qpel[10][2][2])(int16_t *dst, uint8_t *src, ptrdiff_t srcstride,
+    void (*put_hevc_qpel[10][2][2])(int16_t *dst, const uint8_t *src, ptrdiff_t srcstride,
                                     int height, intptr_t mx, intptr_t my, int width);
-    void (*put_hevc_qpel_uni[10][2][2])(uint8_t *dst, ptrdiff_t dststride, uint8_t *src, ptrdiff_t srcstride,
+    void (*put_hevc_qpel_uni[10][2][2])(uint8_t *dst, ptrdiff_t dststride, const uint8_t *src, ptrdiff_t srcstride,
                                         int height, intptr_t mx, intptr_t my, int width);
-    void (*put_hevc_qpel_uni_w[10][2][2])(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+    void (*put_hevc_qpel_uni_w[10][2][2])(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                           int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width);
 
-    void (*put_hevc_qpel_bi[10][2][2])(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                       int16_t *src2,
+    void (*put_hevc_qpel_bi[10][2][2])(uint8_t *dst, ptrdiff_t dststride,
+                                       const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                        int height, intptr_t mx, intptr_t my, int width);
-    void (*put_hevc_qpel_bi_w[10][2][2])(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                         int16_t *src2,
+    void (*put_hevc_qpel_bi_w[10][2][2])(uint8_t *dst, ptrdiff_t dststride,
+                                         const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                          int height, int denom, int wx0, int wx1,
                                          int ox0, int ox1, intptr_t mx, intptr_t my, int width);
-    void (*put_hevc_epel[10][2][2])(int16_t *dst, uint8_t *src, ptrdiff_t srcstride,
+    void (*put_hevc_epel[10][2][2])(int16_t *dst, const uint8_t *src, ptrdiff_t srcstride,
                                     int height, intptr_t mx, intptr_t my, int width);
 
-    void (*put_hevc_epel_uni[10][2][2])(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride,
+    void (*put_hevc_epel_uni[10][2][2])(uint8_t *dst, ptrdiff_t dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                         int height, intptr_t mx, intptr_t my, int width);
-    void (*put_hevc_epel_uni_w[10][2][2])(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+    void (*put_hevc_epel_uni_w[10][2][2])(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                           int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width);
-    void (*put_hevc_epel_bi[10][2][2])(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                       int16_t *src2,
+    void (*put_hevc_epel_bi[10][2][2])(uint8_t *dst, ptrdiff_t dststride, const uint8_t *_src, ptrdiff_t _srcstride,
+                                       const int16_t *src2,
                                        int height, intptr_t mx, intptr_t my, int width);
-    void (*put_hevc_epel_bi_w[10][2][2])(uint8_t *dst, ptrdiff_t dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                         int16_t *src2,
+    void (*put_hevc_epel_bi_w[10][2][2])(uint8_t *dst, ptrdiff_t dststride,
+                                         const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                          int height, int denom, int wx0, int ox0, int wx1,
                                          int ox1, intptr_t mx, intptr_t my, int width);
 
     void (*hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
-                                    int beta, int32_t *tc,
-                                    uint8_t *no_p, uint8_t *no_q);
+                                    int beta, const int32_t *tc,
+                                    const uint8_t *no_p, const uint8_t *no_q);
     void (*hevc_v_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
-                                    int beta, int32_t *tc,
-                                    uint8_t *no_p, uint8_t *no_q);
+                                    int beta, const int32_t *tc,
+                                    const uint8_t *no_p, const uint8_t *no_q);
     void (*hevc_h_loop_filter_chroma)(uint8_t *pix, ptrdiff_t stride,
-                                      int32_t *tc, uint8_t *no_p, uint8_t *no_q);
+                                      const int32_t *tc, const uint8_t *no_p, const uint8_t *no_q);
     void (*hevc_v_loop_filter_chroma)(uint8_t *pix, ptrdiff_t stride,
-                                      int32_t *tc, uint8_t *no_p, uint8_t *no_q);
+                                      const int32_t *tc, const uint8_t *no_p, const uint8_t *no_q);
     void (*hevc_h_loop_filter_luma_c)(uint8_t *pix, ptrdiff_t stride,
-                                      int beta, int32_t *tc,
-                                      uint8_t *no_p, uint8_t *no_q);
+                                      int beta, const int32_t *tc,
+                                      const uint8_t *no_p, const uint8_t *no_q);
     void (*hevc_v_loop_filter_luma_c)(uint8_t *pix, ptrdiff_t stride,
-                                      int beta, int32_t *tc,
-                                      uint8_t *no_p, uint8_t *no_q);
+                                      int beta, const int32_t *tc,
+                                      const uint8_t *no_p, const uint8_t *no_q);
     void (*hevc_h_loop_filter_chroma_c)(uint8_t *pix, ptrdiff_t stride,
-                                        int32_t *tc, uint8_t *no_p,
-                                        uint8_t *no_q);
+                                        const int32_t *tc, const uint8_t *no_p,
+                                        const uint8_t *no_q);
     void (*hevc_v_loop_filter_chroma_c)(uint8_t *pix, ptrdiff_t stride,
-                                        int32_t *tc, uint8_t *no_p,
-                                        uint8_t *no_q);
+                                        const int32_t *tc, const uint8_t *no_p,
+                                        const uint8_t *no_q);
 } HEVCDSPContext;
 
 void ff_hevc_dsp_init(HEVCDSPContext *hpc, int bit_depth);
diff --git a/libavcodec/hevcdsp_template.c b/libavcodec/hevcdsp_template.c
index 6142597..725fab9 100644
--- a/libavcodec/hevcdsp_template.c
+++ b/libavcodec/hevcdsp_template.c
@@ -41,7 +41,7 @@ static void FUNC(put_pcm)(uint8_t *_dst, ptrdiff_t stride, int width, int height
     }
 }
 
-static av_always_inline void FUNC(add_residual)(uint8_t *_dst, int16_t *res,
+static av_always_inline void FUNC(add_residual)(uint8_t *_dst, const int16_t *res,
                                                 ptrdiff_t stride, int size)
 {
     int x, y;
@@ -58,25 +58,25 @@ static av_always_inline void FUNC(add_residual)(uint8_t *_dst, int16_t *res,
     }
 }
 
-static void FUNC(add_residual4x4)(uint8_t *_dst, int16_t *res,
+static void FUNC(add_residual4x4)(uint8_t *_dst, const int16_t *res,
                                   ptrdiff_t stride)
 {
     FUNC(add_residual)(_dst, res, stride, 4);
 }
 
-static void FUNC(add_residual8x8)(uint8_t *_dst, int16_t *res,
+static void FUNC(add_residual8x8)(uint8_t *_dst, const int16_t *res,
                                   ptrdiff_t stride)
 {
     FUNC(add_residual)(_dst, res, stride, 8);
 }
 
-static void FUNC(add_residual16x16)(uint8_t *_dst, int16_t *res,
+static void FUNC(add_residual16x16)(uint8_t *_dst, const int16_t *res,
                                     ptrdiff_t stride)
 {
     FUNC(add_residual)(_dst, res, stride, 16);
 }
 
-static void FUNC(add_residual32x32)(uint8_t *_dst, int16_t *res,
+static void FUNC(add_residual32x32)(uint8_t *_dst, const int16_t *res,
                                     ptrdiff_t stride)
 {
     FUNC(add_residual)(_dst, res, stride, 32);
@@ -295,13 +295,13 @@ IDCT_DC(32)
 #undef SET
 #undef SCALE
 
-static void FUNC(sao_band_filter)(uint8_t *_dst, uint8_t *_src,
+static void FUNC(sao_band_filter)(uint8_t *_dst, const uint8_t *_src,
                                   ptrdiff_t stride_dst, ptrdiff_t stride_src,
-                                  int16_t *sao_offset_val, int sao_left_class,
+                                  const int16_t *sao_offset_val, int sao_left_class,
                                   int width, int height)
 {
     pixel *dst = (pixel *)_dst;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     int offset_table[32] = { 0 };
     int k, y, x;
     int shift  = BIT_DEPTH - 5;
@@ -321,7 +321,7 @@ static void FUNC(sao_band_filter)(uint8_t *_dst, uint8_t *_src,
 
 #define CMP(a, b) (((a) > (b)) - ((a) < (b)))
 
-static void FUNC(sao_edge_filter)(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val,
+static void FUNC(sao_edge_filter)(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst, const int16_t *sao_offset_val,
                                   int eo, int width, int height) {
 
     static const uint8_t edge_idx[] = { 1, 2, 0, 3, 4 };
@@ -332,7 +332,7 @@ static void FUNC(sao_edge_filter)(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride
         { {  1, -1 }, { -1, 1 } }, // 135 degree
     };
     pixel *dst = (pixel *)_dst;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     int a_stride, b_stride;
     int x, y;
     ptrdiff_t stride_src = (2*MAX_PB_SIZE + AV_INPUT_BUFFER_PADDING_SIZE) / sizeof(pixel);
@@ -352,16 +352,16 @@ static void FUNC(sao_edge_filter)(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride
     }
 }
 
-static void FUNC(sao_edge_restore_0)(uint8_t *_dst, uint8_t *_src,
-                                    ptrdiff_t stride_dst, ptrdiff_t stride_src, SAOParams *sao,
-                                    int *borders, int _width, int _height,
-                                    int c_idx, uint8_t *vert_edge,
-                                    uint8_t *horiz_edge, uint8_t *diag_edge)
+static void FUNC(sao_edge_restore_0)(uint8_t *_dst, const uint8_t *_src,
+                                    ptrdiff_t stride_dst, ptrdiff_t stride_src, const SAOParams *sao,
+                                    const int *borders, int _width, int _height,
+                                    int c_idx, const uint8_t *vert_edge,
+                                    const uint8_t *horiz_edge, const uint8_t *diag_edge)
 {
     int x, y;
     pixel *dst = (pixel *)_dst;
-    pixel *src = (pixel *)_src;
-    int16_t *sao_offset_val = sao->offset_val[c_idx];
+    const pixel *src = (const pixel *)_src;
+    const int16_t *sao_offset_val = sao->offset_val[c_idx];
     int sao_eo_class    = sao->eo_class[c_idx];
     int init_x = 0, width = _width, height = _height;
 
@@ -402,16 +402,16 @@ static void FUNC(sao_edge_restore_0)(uint8_t *_dst, uint8_t *_src,
     }
 }
 
-static void FUNC(sao_edge_restore_1)(uint8_t *_dst, uint8_t *_src,
-                                    ptrdiff_t stride_dst, ptrdiff_t stride_src, SAOParams *sao,
-                                    int *borders, int _width, int _height,
-                                    int c_idx, uint8_t *vert_edge,
-                                    uint8_t *horiz_edge, uint8_t *diag_edge)
+static void FUNC(sao_edge_restore_1)(uint8_t *_dst, const uint8_t *_src,
+                                    ptrdiff_t stride_dst, ptrdiff_t stride_src, const SAOParams *sao,
+                                    const int *borders, int _width, int _height,
+                                    int c_idx, const uint8_t *vert_edge,
+                                    const uint8_t *horiz_edge, const uint8_t *diag_edge)
 {
     int x, y;
     pixel *dst = (pixel *)_dst;
-    pixel *src = (pixel *)_src;
-    int16_t *sao_offset_val = sao->offset_val[c_idx];
+    const pixel *src = (const pixel *)_src;
+    const int16_t *sao_offset_val = sao->offset_val[c_idx];
     int sao_eo_class    = sao->eo_class[c_idx];
     int init_x = 0, init_y = 0, width = _width, height = _height;
 
@@ -494,11 +494,11 @@ static void FUNC(sao_edge_restore_1)(uint8_t *_dst, uint8_t *_src,
 //
 ////////////////////////////////////////////////////////////////////////////////
 static void FUNC(put_hevc_pel_pixels)(int16_t *dst,
-                                      uint8_t *_src, ptrdiff_t _srcstride,
+                                      const uint8_t *_src, ptrdiff_t _srcstride,
                                       int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src          = (pixel *)_src;
+    const pixel *src    = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
 
     for (y = 0; y < height; y++) {
@@ -509,11 +509,11 @@ static void FUNC(put_hevc_pel_pixels)(int16_t *dst,
     }
 }
 
-static void FUNC(put_hevc_pel_uni_pixels)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_pel_uni_pixels)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                           int height, intptr_t mx, intptr_t my, int width)
 {
     int y;
-    pixel *src          = (pixel *)_src;
+    const pixel *src    = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -525,12 +525,12 @@ static void FUNC(put_hevc_pel_uni_pixels)(uint8_t *_dst, ptrdiff_t _dststride, u
     }
 }
 
-static void FUNC(put_hevc_pel_bi_pixels)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                         int16_t *src2,
+static void FUNC(put_hevc_pel_bi_pixels)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
+                                         const int16_t *src2,
                                          int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src          = (pixel *)_src;
+    const pixel *src    = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -551,11 +551,11 @@ static void FUNC(put_hevc_pel_bi_pixels)(uint8_t *_dst, ptrdiff_t _dststride, ui
     }
 }
 
-static void FUNC(put_hevc_pel_uni_w_pixels)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_pel_uni_w_pixels)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                             int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src          = (pixel *)_src;
+    const pixel *src    = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -575,13 +575,13 @@ static void FUNC(put_hevc_pel_uni_w_pixels)(uint8_t *_dst, ptrdiff_t _dststride,
     }
 }
 
-static void FUNC(put_hevc_pel_bi_w_pixels)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                           int16_t *src2,
+static void FUNC(put_hevc_pel_bi_w_pixels)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
+                                           const int16_t *src2,
                                            int height, int denom, int wx0, int wx1,
                                            int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src          = (pixel *)_src;
+    const pixel *src    = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -615,11 +615,11 @@ static void FUNC(put_hevc_pel_bi_w_pixels)(uint8_t *_dst, ptrdiff_t _dststride,
      filter[7] * src[x + 4 * stride])
 
 static void FUNC(put_hevc_qpel_h)(int16_t *dst,
-                                  uint8_t *_src, ptrdiff_t _srcstride,
+                                  const uint8_t *_src, ptrdiff_t _srcstride,
                                   int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     const int8_t *filter    = ff_hevc_qpel_filters[mx - 1];
     for (y = 0; y < height; y++) {
@@ -631,11 +631,11 @@ static void FUNC(put_hevc_qpel_h)(int16_t *dst,
 }
 
 static void FUNC(put_hevc_qpel_v)(int16_t *dst,
-                                  uint8_t *_src, ptrdiff_t _srcstride,
+                                  const uint8_t *_src, ptrdiff_t _srcstride,
                                   int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     const int8_t *filter    = ff_hevc_qpel_filters[my - 1];
     for (y = 0; y < height; y++)  {
@@ -647,14 +647,14 @@ static void FUNC(put_hevc_qpel_v)(int16_t *dst,
 }
 
 static void FUNC(put_hevc_qpel_hv)(int16_t *dst,
-                                   uint8_t *_src,
+                                   const uint8_t *_src,
                                    ptrdiff_t _srcstride,
                                    int height, intptr_t mx,
                                    intptr_t my, int width)
 {
     int x, y;
     const int8_t *filter;
-    pixel *src = (pixel*)_src;
+    const pixel *src = (const pixel*)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     int16_t tmp_array[(MAX_PB_SIZE + QPEL_EXTRA) * MAX_PB_SIZE];
     int16_t *tmp = tmp_array;
@@ -679,11 +679,11 @@ static void FUNC(put_hevc_qpel_hv)(int16_t *dst,
 }
 
 static void FUNC(put_hevc_qpel_uni_h)(uint8_t *_dst,  ptrdiff_t _dststride,
-                                      uint8_t *_src, ptrdiff_t _srcstride,
+                                      const uint8_t *_src, ptrdiff_t _srcstride,
                                       int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -704,12 +704,12 @@ static void FUNC(put_hevc_qpel_uni_h)(uint8_t *_dst,  ptrdiff_t _dststride,
     }
 }
 
-static void FUNC(put_hevc_qpel_bi_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                     int16_t *src2,
+static void FUNC(put_hevc_qpel_bi_h)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
+                                     const int16_t *src2,
                                      int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -733,11 +733,11 @@ static void FUNC(put_hevc_qpel_bi_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_
 }
 
 static void FUNC(put_hevc_qpel_uni_v)(uint8_t *_dst,  ptrdiff_t _dststride,
-                                     uint8_t *_src, ptrdiff_t _srcstride,
+                                      const uint8_t *_src, ptrdiff_t _srcstride,
                                      int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -759,12 +759,12 @@ static void FUNC(put_hevc_qpel_uni_v)(uint8_t *_dst,  ptrdiff_t _dststride,
 }
 
 
-static void FUNC(put_hevc_qpel_bi_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                     int16_t *src2,
+static void FUNC(put_hevc_qpel_bi_v)(uint8_t *_dst, ptrdiff_t _dststride,
+                                     const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                      int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -788,12 +788,12 @@ static void FUNC(put_hevc_qpel_bi_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_
 }
 
 static void FUNC(put_hevc_qpel_uni_hv)(uint8_t *_dst,  ptrdiff_t _dststride,
-                                       uint8_t *_src, ptrdiff_t _srcstride,
+                                       const uint8_t *_src, ptrdiff_t _srcstride,
                                        int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
     const int8_t *filter;
-    pixel *src = (pixel*)_src;
+    const pixel *src = (const pixel*)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -827,13 +827,13 @@ static void FUNC(put_hevc_qpel_uni_hv)(uint8_t *_dst,  ptrdiff_t _dststride,
     }
 }
 
-static void FUNC(put_hevc_qpel_bi_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                      int16_t *src2,
+static void FUNC(put_hevc_qpel_bi_hv)(uint8_t *_dst, ptrdiff_t _dststride,
+                                      const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                       int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
     const int8_t *filter;
-    pixel *src = (pixel*)_src;
+    const pixel *src = (const pixel*)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -868,12 +868,12 @@ static void FUNC(put_hevc_qpel_bi_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8
 }
 
 static void FUNC(put_hevc_qpel_uni_w_h)(uint8_t *_dst,  ptrdiff_t _dststride,
-                                        uint8_t *_src, ptrdiff_t _srcstride,
+                                        const uint8_t *_src, ptrdiff_t _srcstride,
                                         int height, int denom, int wx, int ox,
                                         intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -894,13 +894,13 @@ static void FUNC(put_hevc_qpel_uni_w_h)(uint8_t *_dst,  ptrdiff_t _dststride,
     }
 }
 
-static void FUNC(put_hevc_qpel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                       int16_t *src2,
+static void FUNC(put_hevc_qpel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride,
+                                       const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                        int height, int denom, int wx0, int wx1,
                                        int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -923,12 +923,12 @@ static void FUNC(put_hevc_qpel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint
 }
 
 static void FUNC(put_hevc_qpel_uni_w_v)(uint8_t *_dst,  ptrdiff_t _dststride,
-                                        uint8_t *_src, ptrdiff_t _srcstride,
+                                        const uint8_t *_src, ptrdiff_t _srcstride,
                                         int height, int denom, int wx, int ox,
                                         intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -949,13 +949,13 @@ static void FUNC(put_hevc_qpel_uni_w_v)(uint8_t *_dst,  ptrdiff_t _dststride,
     }
 }
 
-static void FUNC(put_hevc_qpel_bi_w_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                       int16_t *src2,
+static void FUNC(put_hevc_qpel_bi_w_v)(uint8_t *_dst, ptrdiff_t _dststride,
+                                       const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                        int height, int denom, int wx0, int wx1,
                                        int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel        *src       = (pixel*)_src;
+    const pixel  *src       = (const pixel*)_src;
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -978,13 +978,13 @@ static void FUNC(put_hevc_qpel_bi_w_v)(uint8_t *_dst, ptrdiff_t _dststride, uint
 }
 
 static void FUNC(put_hevc_qpel_uni_w_hv)(uint8_t *_dst,  ptrdiff_t _dststride,
-                                         uint8_t *_src, ptrdiff_t _srcstride,
+                                         const uint8_t *_src, ptrdiff_t _srcstride,
                                          int height, int denom, int wx, int ox,
                                          intptr_t mx, intptr_t my, int width)
 {
     int x, y;
     const int8_t *filter;
-    pixel *src = (pixel*)_src;
+    const pixel *src = (const pixel*)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1018,14 +1018,14 @@ static void FUNC(put_hevc_qpel_uni_w_hv)(uint8_t *_dst,  ptrdiff_t _dststride,
     }
 }
 
-static void FUNC(put_hevc_qpel_bi_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                        int16_t *src2,
+static void FUNC(put_hevc_qpel_bi_w_hv)(uint8_t *_dst, ptrdiff_t _dststride,
+                                        const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                         int height, int denom, int wx0, int wx1,
                                         int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
     const int8_t *filter;
-    pixel *src = (pixel*)_src;
+    const pixel *src = (const pixel*)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1068,11 +1068,11 @@ static void FUNC(put_hevc_qpel_bi_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, uin
      filter[3] * src[x + 2 * stride])
 
 static void FUNC(put_hevc_epel_h)(int16_t *dst,
-                                  uint8_t *_src, ptrdiff_t _srcstride,
+                                  const uint8_t *_src, ptrdiff_t _srcstride,
                                   int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     const int8_t *filter = ff_hevc_epel_filters[mx - 1];
     for (y = 0; y < height; y++) {
@@ -1084,11 +1084,11 @@ static void FUNC(put_hevc_epel_h)(int16_t *dst,
 }
 
 static void FUNC(put_hevc_epel_v)(int16_t *dst,
-                                  uint8_t *_src, ptrdiff_t _srcstride,
+                                  const uint8_t *_src, ptrdiff_t _srcstride,
                                   int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     const int8_t *filter = ff_hevc_epel_filters[my - 1];
 
@@ -1101,11 +1101,11 @@ static void FUNC(put_hevc_epel_v)(int16_t *dst,
 }
 
 static void FUNC(put_hevc_epel_hv)(int16_t *dst,
-                                   uint8_t *_src, ptrdiff_t _srcstride,
+                                   const uint8_t *_src, ptrdiff_t _srcstride,
                                    int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     const int8_t *filter = ff_hevc_epel_filters[mx - 1];
     int16_t tmp_array[(MAX_PB_SIZE + EPEL_EXTRA) * MAX_PB_SIZE];
@@ -1131,11 +1131,11 @@ static void FUNC(put_hevc_epel_hv)(int16_t *dst,
     }
 }
 
-static void FUNC(put_hevc_epel_uni_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_epel_uni_h)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                       int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1155,12 +1155,12 @@ static void FUNC(put_hevc_epel_uni_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8
     }
 }
 
-static void FUNC(put_hevc_epel_bi_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                     int16_t *src2,
+static void FUNC(put_hevc_epel_bi_h)(uint8_t *_dst, ptrdiff_t _dststride,
+                                     const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                      int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1182,11 +1182,11 @@ static void FUNC(put_hevc_epel_bi_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_
     }
 }
 
-static void FUNC(put_hevc_epel_uni_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_epel_uni_v)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                       int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1206,12 +1206,12 @@ static void FUNC(put_hevc_epel_uni_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8
     }
 }
 
-static void FUNC(put_hevc_epel_bi_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                     int16_t *src2,
+static void FUNC(put_hevc_epel_bi_v)(uint8_t *_dst, ptrdiff_t _dststride,
+                                     const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                      int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     const int8_t *filter = ff_hevc_epel_filters[my - 1];
     pixel *dst          = (pixel *)_dst;
@@ -1232,11 +1232,11 @@ static void FUNC(put_hevc_epel_bi_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_
     }
 }
 
-static void FUNC(put_hevc_epel_uni_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_epel_uni_hv)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                        int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1270,12 +1270,12 @@ static void FUNC(put_hevc_epel_uni_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint
     }
 }
 
-static void FUNC(put_hevc_epel_bi_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                      int16_t *src2,
+static void FUNC(put_hevc_epel_bi_hv)(uint8_t *_dst, ptrdiff_t _dststride,
+                                      const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                       int height, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1310,11 +1310,11 @@ static void FUNC(put_hevc_epel_bi_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8
     }
 }
 
-static void FUNC(put_hevc_epel_uni_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_epel_uni_w_h)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                         int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1336,13 +1336,13 @@ static void FUNC(put_hevc_epel_uni_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uin
     }
 }
 
-static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                       int16_t *src2,
+static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride,
+                                       const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                        int height, int denom, int wx0, int wx1,
                                        int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1362,11 +1362,11 @@ static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint
     }
 }
 
-static void FUNC(put_hevc_epel_uni_w_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_epel_uni_w_v)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                         int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1388,13 +1388,13 @@ static void FUNC(put_hevc_epel_uni_w_v)(uint8_t *_dst, ptrdiff_t _dststride, uin
     }
 }
 
-static void FUNC(put_hevc_epel_bi_w_v)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                       int16_t *src2,
+static void FUNC(put_hevc_epel_bi_w_v)(uint8_t *_dst, ptrdiff_t _dststride,
+                                       const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                        int height, int denom, int wx0, int wx1,
                                        int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride  = _srcstride / sizeof(pixel);
     const int8_t *filter = ff_hevc_epel_filters[my - 1];
     pixel *dst          = (pixel *)_dst;
@@ -1414,11 +1414,11 @@ static void FUNC(put_hevc_epel_bi_w_v)(uint8_t *_dst, ptrdiff_t _dststride, uint
     }
 }
 
-static void FUNC(put_hevc_epel_uni_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
+static void FUNC(put_hevc_epel_uni_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride,
                                          int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1453,13 +1453,13 @@ static void FUNC(put_hevc_epel_uni_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, ui
     }
 }
 
-static void FUNC(put_hevc_epel_bi_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,
-                                        int16_t *src2,
+static void FUNC(put_hevc_epel_bi_w_hv)(uint8_t *_dst, ptrdiff_t _dststride,
+                                        const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2,
                                         int height, int denom, int wx0, int wx1,
                                         int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 {
     int x, y;
-    pixel *src = (pixel *)_src;
+    const pixel *src = (const pixel *)_src;
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);
     pixel *dst          = (pixel *)_dst;
     ptrdiff_t dststride = _dststride / sizeof(pixel);
@@ -1515,8 +1515,8 @@ static void FUNC(put_hevc_epel_bi_w_hv)(uint8_t *_dst, ptrdiff_t _dststride, uin
 
 static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix,
                                         ptrdiff_t _xstride, ptrdiff_t _ystride,
-                                        int beta, int *_tc,
-                                        uint8_t *_no_p, uint8_t *_no_q)
+                                        int beta, const int *_tc,
+                                        const uint8_t *_no_p, const uint8_t *_no_q)
 {
     int d, j;
     pixel *pix        = (pixel *)_pix;
@@ -1610,8 +1610,8 @@ static void FUNC(hevc_loop_filter_luma)(uint8_t *_pix,
 }
 
 static void FUNC(hevc_loop_filter_chroma)(uint8_t *_pix, ptrdiff_t _xstride,
-                                          ptrdiff_t _ystride, int *_tc,
-                                          uint8_t *_no_p, uint8_t *_no_q)
+                                          ptrdiff_t _ystride, const int *_tc,
+                                          const uint8_t *_no_p, const uint8_t *_no_q)
 {
     int d, j, no_p, no_q;
     pixel *pix        = (pixel *)_pix;
@@ -1644,30 +1644,30 @@ static void FUNC(hevc_loop_filter_chroma)(uint8_t *_pix, ptrdiff_t _xstride,
 }
 
 static void FUNC(hevc_h_loop_filter_chroma)(uint8_t *pix, ptrdiff_t stride,
-                                            int32_t *tc, uint8_t *no_p,
-                                            uint8_t *no_q)
+                                            const int32_t *tc, const uint8_t *no_p,
+                                            const uint8_t *no_q)
 {
     FUNC(hevc_loop_filter_chroma)(pix, stride, sizeof(pixel), tc, no_p, no_q);
 }
 
 static void FUNC(hevc_v_loop_filter_chroma)(uint8_t *pix, ptrdiff_t stride,
-                                            int32_t *tc, uint8_t *no_p,
-                                            uint8_t *no_q)
+                                            const int32_t *tc, const uint8_t *no_p,
+                                            const uint8_t *no_q)
 {
     FUNC(hevc_loop_filter_chroma)(pix, sizeof(pixel), stride, tc, no_p, no_q);
 }
 
 static void FUNC(hevc_h_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
-                                          int beta, int32_t *tc, uint8_t *no_p,
-                                          uint8_t *no_q)
+                                          int beta, const int32_t *tc, const uint8_t *no_p,
+                                          const uint8_t *no_q)
 {
     FUNC(hevc_loop_filter_luma)(pix, stride, sizeof(pixel),
                                 beta, tc, no_p, no_q);
 }
 
 static void FUNC(hevc_v_loop_filter_luma)(uint8_t *pix, ptrdiff_t stride,
-                                          int beta, int32_t *tc, uint8_t *no_p,
-                                          uint8_t *no_q)
+                                          int beta, const int32_t *tc, const uint8_t *no_p,
+                                          const uint8_t *no_q)
 {
     FUNC(hevc_loop_filter_luma)(pix, sizeof(pixel), stride,
                                 beta, tc, no_p, no_q);
diff --git a/libavcodec/hevcpred.h b/libavcodec/hevcpred.h
index eb17663..b1b1dc4 100644
--- a/libavcodec/hevcpred.h
+++ b/libavcodec/hevcpred.h
@@ -26,10 +26,10 @@
 #include <stddef.h>
 #include <stdint.h>
 
-struct HEVCContext;
+struct HEVCLocalContext;
 
 typedef struct HEVCPredContext {
-    void (*intra_pred[4])(struct HEVCContext *s, int x0, int y0, int c_idx);
+    void (*intra_pred[4])(struct HEVCLocalContext *lc, int x0, int y0, int c_idx);
 
     void (*pred_planar[4])(uint8_t *src, const uint8_t *top,
                            const uint8_t *left, ptrdiff_t stride);
diff --git a/libavcodec/hevcpred_template.c b/libavcodec/hevcpred_template.c
index ca75ec1..16d1c7f 100644
--- a/libavcodec/hevcpred_template.c
+++ b/libavcodec/hevcpred_template.c
@@ -27,7 +27,7 @@
 
 #define POS(x, y) src[(x) + stride * (y)]
 
-static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,
+static av_always_inline void FUNC(intra_pred)(HEVCLocalContext *lc, int x0, int y0,
                                               int log2_size, int c_idx)
 {
 #define PU(x) \
@@ -70,7 +70,7 @@ do {                                  \
             else                                                               \
                 a = PIXEL_SPLAT_X4(ptr[i + 3])
 
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int i;
     int hshift = s->ps.sps->hshift[c_idx];
     int vshift = s->ps.sps->vshift[c_idx];
@@ -346,9 +346,9 @@ do {                                  \
 }
 
 #define INTRA_PRED(size)                                                            \
-static void FUNC(intra_pred_ ## size)(HEVCContext *s, int x0, int y0, int c_idx)    \
+static void FUNC(intra_pred_ ## size)(HEVCLocalContext *lc, int x0, int y0, int c_idx) \
 {                                                                                   \
-    FUNC(intra_pred)(s, x0, y0, size, c_idx);                                       \
+    FUNC(intra_pred)(lc, x0, y0, size, c_idx);                                      \
 }
 
 INTRA_PRED(2)
diff --git a/libavcodec/hnm4video.c b/libavcodec/hnm4video.c
index 1326d5f..db4c877 100644
--- a/libavcodec/hnm4video.c
+++ b/libavcodec/hnm4video.c
@@ -507,5 +507,5 @@ const FFCodec ff_hnm4_video_decoder = {
     .close          = hnm_decode_end,
     FF_CODEC_DECODE_CB(hnm_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/hq_hqa.c b/libavcodec/hq_hqa.c
index cea2475..a17fa18 100644
--- a/libavcodec/hq_hqa.c
+++ b/libavcodec/hq_hqa.c
@@ -24,6 +24,7 @@
 #include "libavutil/intreadwrite.h"
 
 #include "avcodec.h"
+#include "bytestream.h"
 #include "canopus.h"
 #include "codec_internal.h"
 #include "get_bits.h"
@@ -114,12 +115,12 @@ static int hq_decode_mb(HQContext *c, AVFrame *pic,
     return 0;
 }
 
-static int hq_decode_frame(HQContext *ctx, AVFrame *pic,
+static int hq_decode_frame(HQContext *ctx, AVFrame *pic, GetByteContext *gbc,
                            int prof_num, size_t data_size)
 {
     const HQProfile *profile;
     GetBitContext gb;
-    const uint8_t *perm, *src = ctx->gbc.buffer;
+    const uint8_t *perm, *src = gbc->buffer;
     uint32_t slice_off[21];
     int slice, start_off, next_off, i, ret;
 
@@ -144,7 +145,7 @@ static int hq_decode_frame(HQContext *ctx, AVFrame *pic,
 
     /* Offsets are stored from CUV position, so adjust them accordingly. */
     for (i = 0; i < profile->num_slices + 1; i++)
-        slice_off[i] = bytestream2_get_be24(&ctx->gbc) - 4;
+        slice_off[i] = bytestream2_get_be24(gbc) - 4;
 
     next_off = 0;
     for (slice = 0; slice < profile->num_slices; slice++) {
@@ -240,20 +241,20 @@ static int hqa_decode_slice(HQContext *ctx, AVFrame *pic, GetBitContext *gb,
     return 0;
 }
 
-static int hqa_decode_frame(HQContext *ctx, AVFrame *pic, size_t data_size)
+static int hqa_decode_frame(HQContext *ctx, AVFrame *pic, GetByteContext *gbc, size_t data_size)
 {
     GetBitContext gb;
     const int num_slices = 8;
     uint32_t slice_off[9];
     int i, slice, ret;
     int width, height, quant;
-    const uint8_t *src = ctx->gbc.buffer;
+    const uint8_t *src = gbc->buffer;
 
-    if (bytestream2_get_bytes_left(&ctx->gbc) < 8 + 4*(num_slices + 1))
+    if (bytestream2_get_bytes_left(gbc) < 8 + 4*(num_slices + 1))
         return AVERROR_INVALIDDATA;
 
-    width  = bytestream2_get_be16(&ctx->gbc);
-    height = bytestream2_get_be16(&ctx->gbc);
+    width  = bytestream2_get_be16(gbc);
+    height = bytestream2_get_be16(gbc);
 
     ret = ff_set_dimensions(ctx->avctx, width, height);
     if (ret < 0)
@@ -266,8 +267,8 @@ static int hqa_decode_frame(HQContext *ctx, AVFrame *pic, size_t data_size)
 
     av_log(ctx->avctx, AV_LOG_VERBOSE, "HQA Profile\n");
 
-    quant = bytestream2_get_byte(&ctx->gbc);
-    bytestream2_skip(&ctx->gbc, 3);
+    quant = bytestream2_get_byte(gbc);
+    bytestream2_skip(gbc, 3);
     if (quant >= NUM_HQ_QUANTS) {
         av_log(ctx->avctx, AV_LOG_ERROR,
                "Invalid quantization matrix %d.\n", quant);
@@ -280,7 +281,7 @@ static int hqa_decode_frame(HQContext *ctx, AVFrame *pic, size_t data_size)
 
     /* Offsets are stored from HQA1 position, so adjust them accordingly. */
     for (i = 0; i < num_slices + 1; i++)
-        slice_off[i] = bytestream2_get_be32(&ctx->gbc) - 4;
+        slice_off[i] = bytestream2_get_be32(gbc) - 4;
 
     for (slice = 0; slice < num_slices; slice++) {
         if (slice_off[slice] < (num_slices + 1) * 3 ||
@@ -305,32 +306,33 @@ static int hq_hqa_decode_frame(AVCodecContext *avctx, AVFrame *pic,
                                int *got_frame, AVPacket *avpkt)
 {
     HQContext *ctx = avctx->priv_data;
+    GetByteContext gbc0, *const gbc = &gbc0;
     uint32_t info_tag;
     unsigned int data_size;
     int ret;
     unsigned tag;
 
-    bytestream2_init(&ctx->gbc, avpkt->data, avpkt->size);
-    if (bytestream2_get_bytes_left(&ctx->gbc) < 4 + 4) {
+    bytestream2_init(gbc, avpkt->data, avpkt->size);
+    if (bytestream2_get_bytes_left(gbc) < 4 + 4) {
         av_log(avctx, AV_LOG_ERROR, "Frame is too small (%d).\n", avpkt->size);
         return AVERROR_INVALIDDATA;
     }
 
-    info_tag = bytestream2_peek_le32(&ctx->gbc);
+    info_tag = bytestream2_peek_le32(gbc);
     if (info_tag == MKTAG('I', 'N', 'F', 'O')) {
         int info_size;
-        bytestream2_skip(&ctx->gbc, 4);
-        info_size = bytestream2_get_le32(&ctx->gbc);
-        if (info_size < 0 || bytestream2_get_bytes_left(&ctx->gbc) < info_size) {
+        bytestream2_skip(gbc, 4);
+        info_size = bytestream2_get_le32(gbc);
+        if (info_size < 0 || bytestream2_get_bytes_left(gbc) < info_size) {
             av_log(avctx, AV_LOG_ERROR, "Invalid INFO size (%d).\n", info_size);
             return AVERROR_INVALIDDATA;
         }
-        ff_canopus_parse_info_tag(avctx, ctx->gbc.buffer, info_size);
+        ff_canopus_parse_info_tag(avctx, gbc->buffer, info_size);
 
-        bytestream2_skip(&ctx->gbc, info_size);
+        bytestream2_skip(gbc, info_size);
     }
 
-    data_size = bytestream2_get_bytes_left(&ctx->gbc);
+    data_size = bytestream2_get_bytes_left(gbc);
     if (data_size < 4) {
         av_log(avctx, AV_LOG_ERROR, "Frame is too small (%d).\n", data_size);
         return AVERROR_INVALIDDATA;
@@ -339,11 +341,11 @@ static int hq_hqa_decode_frame(AVCodecContext *avctx, AVFrame *pic,
     /* HQ defines dimensions and number of slices, and thus slice traversal
      * order. HQA has no size constraint and a fixed number of slices, so it
      * needs a separate scheme for it. */
-    tag = bytestream2_get_le32(&ctx->gbc);
+    tag = bytestream2_get_le32(gbc);
     if ((tag & 0x00FFFFFF) == (MKTAG('U', 'V', 'C', ' ') & 0x00FFFFFF)) {
-        ret = hq_decode_frame(ctx, pic, tag >> 24, data_size);
+        ret = hq_decode_frame(ctx, pic, gbc, tag >> 24, data_size);
     } else if (tag == MKTAG('H', 'Q', 'A', '1')) {
-        ret = hqa_decode_frame(ctx, pic, data_size);
+        ret = hqa_decode_frame(ctx, pic, gbc, data_size);
     } else {
         av_log(avctx, AV_LOG_ERROR, "Not a HQ/HQA frame.\n");
         return AVERROR_INVALIDDATA;
@@ -391,6 +393,5 @@ const FFCodec ff_hq_hqa_decoder = {
     FF_CODEC_DECODE_CB(hq_hqa_decode_frame),
     .close          = hq_hqa_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/hq_hqa.h b/libavcodec/hq_hqa.h
index 08d79e7..71aa367 100644
--- a/libavcodec/hq_hqa.h
+++ b/libavcodec/hq_hqa.h
@@ -26,7 +26,6 @@
 #include "libavutil/mem_internal.h"
 
 #include "avcodec.h"
-#include "bytestream.h"
 #include "hq_hqadsp.h"
 #include "vlc.h"
 
@@ -37,7 +36,6 @@
 typedef struct HQContext {
     AVCodecContext *avctx;
     HQDSPContext hqhqadsp;
-    GetByteContext gbc;
 
     VLC hq_ac_vlc;
     VLC hqa_cbp_vlc;
diff --git a/libavcodec/hqx.c b/libavcodec/hqx.c
index 596b8a7..c7ba6af 100644
--- a/libavcodec/hqx.c
+++ b/libavcodec/hqx.c
@@ -545,6 +545,5 @@ const FFCodec ff_hqx_decoder = {
     .close          = hqx_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS |
                       AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/huffyuvdec.c b/libavcodec/huffyuvdec.c
index acc4aaf..a9d63ac 100644
--- a/libavcodec/huffyuvdec.c
+++ b/libavcodec/huffyuvdec.c
@@ -1273,7 +1273,7 @@ const FFCodec ff_huffyuv_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DRAW_HORIZ_BAND |
                         AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 #if CONFIG_FFVHUFF_DECODER
@@ -1288,7 +1288,7 @@ const FFCodec ff_ffvhuff_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DRAW_HORIZ_BAND |
                         AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif /* CONFIG_FFVHUFF_DECODER */
 
@@ -1304,6 +1304,6 @@ const FFCodec ff_hymt_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DRAW_HORIZ_BAND |
                         AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif /* CONFIG_HYMT_DECODER */
diff --git a/libavcodec/huffyuvenc.c b/libavcodec/huffyuvenc.c
index 195d45c..c585d00 100644
--- a/libavcodec/huffyuvenc.c
+++ b/libavcodec/huffyuvenc.c
@@ -119,7 +119,7 @@ static inline void sub_left_prediction_bgr32(HYuvContext *s, uint8_t *dst,
 }
 
 static inline void sub_left_prediction_rgb24(HYuvContext *s, uint8_t *dst,
-                                             uint8_t *src, int w,
+                                             const uint8_t *src, int w,
                                              int *red, int *green, int *blue)
 {
     int i;
@@ -789,7 +789,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             y++; cy++;
 
             for (; y < height; y++,cy++) {
-                uint8_t *ydst, *udst, *vdst;
+                const uint8_t *ydst, *udst, *vdst;
 
                 if (s->bitstream_bpp == 12) {
                     while (2 * cy > y) {
@@ -812,7 +812,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             }
         } else {
             for (cy = y = 1; y < height; y++, cy++) {
-                uint8_t *ydst, *udst, *vdst;
+                const uint8_t *ydst, *udst, *vdst;
 
                 /* encode a luma only line & y++ */
                 if (s->bitstream_bpp == 12) {
@@ -852,7 +852,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             }
         }
     } else if(avctx->pix_fmt == AV_PIX_FMT_RGB32) {
-        uint8_t *data = p->data[0] + (height - 1) * p->linesize[0];
+        const uint8_t *data = p->data[0] + (height - 1) * p->linesize[0];
         const int stride = -p->linesize[0];
         const int fake_stride = -fake_ystride;
         int y;
@@ -868,7 +868,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         encode_bgra_bitstream(s, width - 1, 4);
 
         for (y = 1; y < s->height; y++) {
-            uint8_t *dst = data + y*stride;
+            const uint8_t *dst = data + y*stride;
             if (s->predictor == PLANE && s->interlaced < y) {
                 s->llvidencdsp.diff_bytes(s->temp[1], dst, dst - fake_stride, width * 4);
                 sub_left_prediction_bgr32(s, s->temp[0], s->temp[1], width,
@@ -880,7 +880,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             encode_bgra_bitstream(s, width, 4);
         }
     } else if (avctx->pix_fmt == AV_PIX_FMT_RGB24) {
-        uint8_t *data = p->data[0] + (height - 1) * p->linesize[0];
+        const uint8_t *data = p->data[0] + (height - 1) * p->linesize[0];
         const int stride = -p->linesize[0];
         const int fake_stride = -fake_ystride;
         int y;
@@ -896,7 +896,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         encode_bgra_bitstream(s, width-1, 3);
 
         for (y = 1; y < s->height; y++) {
-            uint8_t *dst = data + y * stride;
+            const uint8_t *dst = data + y * stride;
             if (s->predictor == PLANE && s->interlaced < y) {
                 s->llvidencdsp.diff_bytes(s->temp[1], dst, dst - fake_stride,
                                       width * 3);
@@ -939,7 +939,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                 lefttop = p->data[plane][0];
 
                 for (; y < h; y++) {
-                    uint8_t *dst = p->data[plane] + p->linesize[plane] * y;
+                    const uint8_t *dst = p->data[plane] + p->linesize[plane] * y;
 
                     sub_median_prediction(s, s->temp[0], dst - fake_stride, dst, w , &left, &lefttop);
 
@@ -947,7 +947,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                 }
             } else {
                 for (y = 1; y < h; y++) {
-                    uint8_t *dst = p->data[plane] + p->linesize[plane] * y;
+                    const uint8_t *dst = p->data[plane] + p->linesize[plane] * y;
 
                     if (s->predictor == PLANE && s->interlaced < y) {
                         diff_bytes(s, s->temp[1], dst, dst - fake_stride, w);
@@ -1064,8 +1064,7 @@ const FFCodec ff_huffyuv_encoder = {
         AV_PIX_FMT_YUV422P, AV_PIX_FMT_RGB24,
         AV_PIX_FMT_RGB32, AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 #if CONFIG_FFVHUFF_ENCODER
@@ -1097,7 +1096,6 @@ const FFCodec ff_ffvhuff_encoder = {
         AV_PIX_FMT_RGB24,
         AV_PIX_FMT_RGB32, AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/idcinvideo.c b/libavcodec/idcinvideo.c
index ecd4ab2..1535e6a 100644
--- a/libavcodec/idcinvideo.c
+++ b/libavcodec/idcinvideo.c
@@ -251,5 +251,4 @@ const FFCodec ff_idcin_decoder = {
     FF_CODEC_DECODE_CB(idcin_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .defaults       = idcin_defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/iff.c b/libavcodec/iff.c
index 74ebddc..cd78352 100644
--- a/libavcodec/iff.c
+++ b/libavcodec/iff.c
@@ -1916,5 +1916,5 @@ const FFCodec ff_iff_ilbm_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/ilbcdec.c b/libavcodec/ilbcdec.c
index 62a9ad1..2bc559a 100644
--- a/libavcodec/ilbcdec.c
+++ b/libavcodec/ilbcdec.c
@@ -91,7 +91,6 @@ typedef struct ILBCContext {
     int              enhancer;
 
     int              mode;
-    GetBitContext    gb;
     ILBCFrame        frame;
 
     int              prev_enh_pl;
@@ -127,11 +126,14 @@ typedef struct ILBCContext {
     int16_t          hpimemy[4];
 } ILBCContext;
 
-static int unpack_frame(ILBCContext *s)
+static int unpack_frame(ILBCContext *s, const uint8_t *buf, int size)
 {
     ILBCFrame *frame = &s->frame;
-    GetBitContext *gb = &s->gb;
-    int j;
+    GetBitContext gb0, *const gb = &gb0;
+    int j, ret;
+
+    if ((ret = init_get_bits8(gb, buf, size)) < 0)
+        return ret;
 
     frame->lsf[0] = get_bits(gb, 6);
     frame->lsf[1] = get_bits(gb, 7);
@@ -331,8 +333,8 @@ static void lsf_check_stability(int16_t *lsf, int dim, int nb_vectors)
     }
 }
 
-static void lsf_interpolate(int16_t *out, int16_t *in1,
-                            int16_t *in2, int16_t coef,
+static void lsf_interpolate(int16_t *out, const int16_t *in1,
+                            const int16_t *in2, int16_t coef,
                             int size)
 {
     int invcoef = 16384 - coef, i;
@@ -341,7 +343,7 @@ static void lsf_interpolate(int16_t *out, int16_t *in1,
         out[i] = (coef * in1[i] + invcoef * in2[i] + 8192) >> 14;
 }
 
-static void lsf2lsp(int16_t *lsf, int16_t *lsp, int order)
+static void lsf2lsp(const int16_t *lsf, int16_t *lsp, int order)
 {
     int16_t diff, freq;
     int32_t tmp;
@@ -364,7 +366,7 @@ static void lsf2lsp(int16_t *lsf, int16_t *lsp, int order)
     }
 }
 
-static void get_lsp_poly(int16_t *lsp, int32_t *f)
+static void get_lsp_poly(const int16_t *lsp, int32_t *f)
 {
     int16_t high, low;
     int i, j, k, l;
@@ -391,7 +393,7 @@ static void get_lsp_poly(int16_t *lsp, int32_t *f)
     }
 }
 
-static void lsf2poly(int16_t *a, int16_t *lsf)
+static void lsf2poly(int16_t *a, const int16_t *lsf)
 {
     int32_t f[2][6];
     int16_t lsp[10];
@@ -418,8 +420,8 @@ static void lsf2poly(int16_t *a, int16_t *lsf)
     }
 }
 
-static void lsp_interpolate2polydec(int16_t *a, int16_t *lsf1,
-                                   int16_t *lsf2, int coef, int length)
+static void lsp_interpolate2polydec(int16_t *a, const int16_t *lsf1,
+                                    const int16_t *lsf2, int coef, int length)
 {
     int16_t lsftmp[LPC_FILTERORDER];
 
@@ -437,13 +439,13 @@ static void bw_expand(int16_t *out, const int16_t *in, const int16_t *coef, int
 }
 
 static void lsp_interpolate(int16_t *syntdenum, int16_t *weightdenum,
-                            int16_t *lsfdeq, int16_t length,
+                            const int16_t *lsfdeq, int16_t length,
                             ILBCContext *s)
 {
-    int16_t lp[LPC_FILTERORDER + 1], *lsfdeq2;
+    int16_t lp[LPC_FILTERORDER + 1];
+    const int16_t *const lsfdeq2 = lsfdeq + length;
     int i, pos, lp_length;
 
-    lsfdeq2 = lsfdeq + length;
     lp_length = length + 1;
 
     if (s->mode == 30) {
@@ -478,8 +480,8 @@ static void lsp_interpolate(int16_t *syntdenum, int16_t *weightdenum,
     }
 }
 
-static void filter_mafq12(int16_t *in_ptr, int16_t *out_ptr,
-                          int16_t *B, int16_t B_length,
+static void filter_mafq12(const int16_t *in_ptr, int16_t *out_ptr,
+                          const int16_t *B, int16_t B_length,
                           int16_t length)
 {
     int o, i, j;
@@ -520,13 +522,14 @@ static void filter_arfq12(const int16_t *data_in,
     }
 }
 
-static void state_construct(int16_t ifm, int16_t *idx,
-                           int16_t *synt_denum, int16_t *Out_fix,
+static void state_construct(int16_t ifm, const int16_t *idx,
+                            const int16_t *synt_denum, int16_t *Out_fix,
                            int16_t len)
 {
     int k;
     int16_t maxVal;
-    int16_t *tmp1, *tmp2, *tmp3;
+    int16_t *tmp1, *tmp3;
+    const int16_t *tmp2;
     /* Stack based */
     int16_t numerator[1 + LPC_FILTERORDER];
     int16_t sampleValVec[2 * STATE_SHORT_LEN_30MS + LPC_FILTERORDER];
@@ -630,7 +633,7 @@ static void add_vector_and_shift(int16_t *out, const int16_t *in1,
         out[i] = (in1[i] + in2[i]) >> shift;
 }
 
-static void create_augmented_vector(int index, int16_t *buffer, int16_t *cbVec)
+static void create_augmented_vector(int index, const int16_t *buffer, int16_t *cbVec)
 {
     int16_t cbVecTmp[4];
     int interpolation_length = FFMIN(4, index);
@@ -696,7 +699,7 @@ static void get_codebook(int16_t * cbvec,   /* (o) Constructed codebook vector *
 
             /* do filtering to get the codebook vector */
 
-            filter_mafq12(&mem[memIndTest + 4], cbvec, (int16_t *) kCbFiltersRev, CB_FILTERLEN, cbveclen);
+            filter_mafq12(&mem[memIndTest + 4], cbvec, kCbFiltersRev, CB_FILTERLEN, cbveclen);
         } else {
             /* interpolated vectors */
             /* Stuff zeros outside memory buffer  */
@@ -704,7 +707,7 @@ static void get_codebook(int16_t * cbvec,   /* (o) Constructed codebook vector *
             memset(mem + lMem, 0, CB_HALFFILTERLEN * 2);
 
             /* do filtering */
-            filter_mafq12(&mem[memIndTest + 7], tempbuff2, (int16_t *) kCbFiltersRev, CB_FILTERLEN, (int16_t) (cbveclen + 5));
+            filter_mafq12(&mem[memIndTest + 7], tempbuff2, kCbFiltersRev, CB_FILTERLEN, (int16_t) (cbveclen + 5));
 
             /* Calculate lag index */
             lag = (cbveclen << 1) - 20 + index - base_size - lMem - 1;
@@ -716,8 +719,8 @@ static void get_codebook(int16_t * cbvec,   /* (o) Constructed codebook vector *
 
 static void construct_vector (
     int16_t *decvector,   /* (o) Decoded vector */
-    int16_t *index,       /* (i) Codebook indices */
-    int16_t *gain_index,  /* (i) Gain quantization indices */
+    const int16_t *index,       /* (i) Codebook indices */
+    const int16_t *gain_index,  /* (i) Gain quantization indices */
     int16_t *mem,         /* (i) Buffer for codevector construction */
     int16_t lMem,         /* (i) Length of buffer */
     int16_t veclen)
@@ -753,10 +756,10 @@ static void construct_vector (
     }
 }
 
-static void reverse_memcpy(int16_t *dest, int16_t *source, int length)
+static void reverse_memcpy(int16_t *dest, const int16_t *source, int length)
 {
     int16_t* destPtr = dest;
-    int16_t* sourcePtr = source;
+    const int16_t *sourcePtr = source;
     int j;
 
     for (j = 0; j < length; j++)
@@ -766,7 +769,7 @@ static void reverse_memcpy(int16_t *dest, int16_t *source, int length)
 static void decode_residual(ILBCContext *s,
                             ILBCFrame *encbits,
                             int16_t *decresidual,
-                            int16_t *syntdenum)
+                            const int16_t *syntdenum)
 {
     int16_t meml_gotten, Nfor, Nback, diff, start_pos;
     int16_t subcount, subframe;
@@ -911,12 +914,10 @@ static int32_t scale_dot_product(const int16_t *v1, const int16_t *v2, int lengt
     return av_clipl_int32(sum);
 }
 
-static void correlation(int32_t *corr, int32_t *ener, int16_t *buffer,
+static void correlation(int32_t *corr, int32_t *ener, const int16_t *buffer,
                         int16_t lag, int16_t blen, int16_t srange, int16_t scale)
 {
-    int16_t *w16ptr;
-
-    w16ptr = &buffer[blen - srange - lag];
+    const int16_t *w16ptr = &buffer[blen - srange - lag];
 
     *corr = scale_dot_product(&buffer[blen - srange], w16ptr, srange, scale);
     *ener = scale_dot_product(w16ptr, w16ptr, srange, scale);
@@ -952,8 +953,8 @@ static void do_plc(int16_t *plc_residual,      /* (o) concealed residual */
                    int16_t *plc_lpc,           /* (o) concealed LP parameters */
                    int16_t PLI,                /* (i) packet loss indicator
                                                       0 - no PL, 1 = PL */
-                   int16_t *decresidual,       /* (i) decoded residual */
-                   int16_t *lpc,               /* (i) decoded LPC (only used for no PL) */
+                   const int16_t *decresidual, /* (i) decoded residual */
+                   const int16_t *lpc,         /* (i) decoded LPC (only used for no PL) */
                    int16_t inlag,              /* (i) pitch lag */
                    ILBCContext *s)             /* (i/o) decoder instance */
 {
@@ -1202,7 +1203,7 @@ static void do_plc(int16_t *plc_residual,      /* (o) concealed residual */
     return;
 }
 
-static int xcorr_coeff(int16_t *target, int16_t *regressor,
+static int xcorr_coeff(const int16_t *target, const int16_t *regressor,
                        int16_t subl, int16_t searchLen,
                        int16_t offset, int16_t step)
 {
@@ -1213,8 +1214,8 @@ static int xcorr_coeff(int16_t *target, int16_t *regressor,
     int16_t cross_corr_sg_mod, cross_corr_sg_mod_max;
     int32_t cross_corr, energy;
     int16_t cross_corr_mod, energy_mod, enery_mod_max;
-    int16_t *tp, *rp;
-    int16_t *rp_beg, *rp_end;
+    const int16_t *rp;
+    const int16_t *rp_beg, *rp_end;
     int16_t totscale, totscale_max;
     int16_t scalediff;
     int32_t new_crit, max_crit;
@@ -1253,10 +1254,9 @@ static int xcorr_coeff(int16_t *target, int16_t *regressor,
     energy = scale_dot_product(regressor, regressor, subl, shifts);
 
     for (k = 0; k < searchLen; k++) {
-        tp = target;
         rp = &regressor[pos];
 
-        cross_corr = scale_dot_product(tp, rp, subl, shifts);
+        cross_corr = scale_dot_product(target, rp, subl, shifts);
 
         if ((energy > 0) && (cross_corr > 0)) {
             /* Put cross correlation and energy on 16 bit word */
@@ -1359,21 +1359,21 @@ static void hp_output(int16_t *signal, const int16_t *ba, int16_t *y,
 static int ilbc_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                              int *got_frame_ptr, AVPacket *avpkt)
 {
-    const uint8_t *buf = avpkt->data;
     ILBCContext *s     = avctx->priv_data;
     int mode = s->mode, ret;
     int16_t *plc_data = &s->plc_residual[LPC_FILTERORDER];
 
-    if ((ret = init_get_bits8(&s->gb, buf, avpkt->size)) < 0)
-        return ret;
     memset(&s->frame, 0, sizeof(ILBCFrame));
+    ret = unpack_frame(s, avpkt->data, avpkt->size);
+    if (ret < 0)
+        return ret;
+    if (ret)
+        mode = 0;
 
     frame->nb_samples = s->block_samples;
     if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)
         return ret;
 
-    if (unpack_frame(s))
-        mode = 0;
     if (s->frame.start < 1 || s->frame.start > 5)
         mode = 0;
 
@@ -1487,5 +1487,4 @@ const FFCodec ff_ilbc_decoder = {
     FF_CODEC_DECODE_CB(ilbc_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .priv_data_size = sizeof(ILBCContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/imc.c b/libavcodec/imc.c
index 978ea74..e9c51a1 100644
--- a/libavcodec/imc.c
+++ b/libavcodec/imc.c
@@ -1095,7 +1095,6 @@ const FFCodec ff_imc_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_IAC_DECODER
@@ -1112,6 +1111,5 @@ const FFCodec ff_iac_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/imm4.c b/libavcodec/imm4.c
index d826818..fe4e15f 100644
--- a/libavcodec/imm4.c
+++ b/libavcodec/imm4.c
@@ -543,6 +543,5 @@ const FFCodec ff_imm4_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .flush            = decode_flush,
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/imm5.c b/libavcodec/imm5.c
index 9b7ac17..2c85bcc 100644
--- a/libavcodec/imm5.c
+++ b/libavcodec/imm5.c
@@ -187,6 +187,5 @@ const FFCodec ff_imm5_decoder = {
     .close          = imm5_close,
     .flush          = imm5_flush,
     .priv_data_size = sizeof(IMM5Context),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/imx.c b/libavcodec/imx.c
index 4ee6006..4856de0 100644
--- a/libavcodec/imx.c
+++ b/libavcodec/imx.c
@@ -191,6 +191,5 @@ const FFCodec ff_simbiosis_imx_decoder = {
     .close          = imx_decode_close,
     .flush          = imx_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/indeo2.c b/libavcodec/indeo2.c
index 7902897..9bad9bf 100644
--- a/libavcodec/indeo2.c
+++ b/libavcodec/indeo2.c
@@ -269,5 +269,4 @@ const FFCodec ff_indeo2_decoder = {
     .close          = ir2_decode_end,
     FF_CODEC_DECODE_CB(ir2_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/indeo3.c b/libavcodec/indeo3.c
index 43669f4..e634cf3 100644
--- a/libavcodec/indeo3.c
+++ b/libavcodec/indeo3.c
@@ -1143,5 +1143,5 @@ const FFCodec ff_indeo3_decoder = {
     .close          = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/indeo4.c b/libavcodec/indeo4.c
index f0cdff0..b612c88 100644
--- a/libavcodec/indeo4.c
+++ b/libavcodec/indeo4.c
@@ -713,5 +713,4 @@ const FFCodec ff_indeo4_decoder = {
     .close          = ff_ivi_decode_close,
     FF_CODEC_DECODE_CB(ff_ivi_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/indeo5.c b/libavcodec/indeo5.c
index aff1102..1f799fd 100644
--- a/libavcodec/indeo5.c
+++ b/libavcodec/indeo5.c
@@ -693,5 +693,5 @@ const FFCodec ff_indeo5_decoder = {
     .close          = ff_ivi_decode_close,
     FF_CODEC_DECODE_CB(ff_ivi_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/intelh263dec.c b/libavcodec/intelh263dec.c
index ded0a7f..9fb1155 100644
--- a/libavcodec/intelh263dec.c
+++ b/libavcodec/intelh263dec.c
@@ -140,8 +140,7 @@ const FFCodec ff_h263i_decoder = {
     .close          = ff_h263_decode_end,
     FF_CODEC_DECODE_CB(ff_h263_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
         AV_PIX_FMT_NONE
diff --git a/libavcodec/internal.h b/libavcodec/internal.h
index 17e1de8..52e7f11 100644
--- a/libavcodec/internal.h
+++ b/libavcodec/internal.h
@@ -33,6 +33,10 @@
 #include "avcodec.h"
 #include "config.h"
 
+#if CONFIG_LCMS2
+# include "fflcms2.h"
+#endif
+
 #define FF_SANE_NB_CHANNELS 512U
 
 #if HAVE_SIMD_ALIGN_64
@@ -103,6 +107,14 @@ typedef struct AVCodecInternal {
      */
     AVFrame *in_frame;
 
+    /**
+     * When the AV_CODEC_FLAG_RECON_FRAME flag is used. the encoder should store
+     * here the reconstructed frame corresponding to the last returned packet.
+     *
+     * Not allocated in other cases.
+     */
+    AVFrame *recon_frame;
+
     /**
      * If this is set, then FFCodec->close (if existing) needs to be called
      * for the parent AVCodecContext.
@@ -133,8 +145,6 @@ typedef struct AVCodecInternal {
 
     int showed_multi_packet_warning;
 
-    int skip_samples_multiplier;
-
     /* to prevent infinite loop on errors when draining */
     int nb_draining_errors;
 
@@ -148,6 +158,10 @@ typedef struct AVCodecInternal {
     uint64_t initial_channel_layout;
 #endif
     AVChannelLayout initial_ch_layout;
+
+#if CONFIG_LCMS2
+    FFIccContext icc; /* used to read and write embedded ICC profiles */
+#endif
 } AVCodecInternal;
 
 /**
@@ -212,8 +226,6 @@ int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags);
  */
 int ff_reget_buffer(AVCodecContext *avctx, AVFrame *frame, int flags);
 
-int ff_thread_can_start_frame(AVCodecContext *avctx);
-
 int avpriv_h264_has_num_reorder_frames(AVCodecContext *avctx);
 
 int avpriv_codec_get_cap_skip_frame_fill_param(const AVCodec *codec);
diff --git a/libavcodec/interplayacm.c b/libavcodec/interplayacm.c
index 3c482e4..3b14919 100644
--- a/libavcodec/interplayacm.c
+++ b/libavcodec/interplayacm.c
@@ -641,6 +641,6 @@ const FFCodec ff_interplay_acm_decoder = {
     .close          = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(InterplayACMContext),
 };
diff --git a/libavcodec/interplayvideo.c b/libavcodec/interplayvideo.c
index fe2a9e1..75feb83 100644
--- a/libavcodec/interplayvideo.c
+++ b/libavcodec/interplayvideo.c
@@ -1366,5 +1366,5 @@ const FFCodec ff_interplay_video_decoder = {
     .close          = ipvideo_decode_end,
     FF_CODEC_DECODE_CB(ipvideo_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_PARAM_CHANGE,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/intrax8.c b/libavcodec/intrax8.c
index 73b8aee..e82cb86 100644
--- a/libavcodec/intrax8.c
+++ b/libavcodec/intrax8.c
@@ -25,7 +25,6 @@
 #include "libavutil/thread.h"
 #include "avcodec.h"
 #include "get_bits.h"
-#include "idctdsp.h"
 #include "msmpeg4data.h"
 #include "intrax8huf.h"
 #include "intrax8.h"
@@ -92,9 +91,9 @@ static av_cold void x8_vlc_init(void)
 
 static void x8_reset_vlc_tables(IntraX8Context *w)
 {
-    memset(w->j_dc_vlc, 0, sizeof(w->j_dc_vlc));
-    memset(w->j_ac_vlc, 0, sizeof(w->j_ac_vlc));
-    w->j_orient_vlc = NULL;
+    memset(w->j_dc_vlc_table, 0, sizeof(w->j_dc_vlc_table));
+    memset(w->j_ac_vlc_table, 0, sizeof(w->j_ac_vlc_table));
+    w->j_orient_vlc_table = NULL;
 }
 
 static inline void x8_select_ac_table(IntraX8Context *const w, int mode)
@@ -103,23 +102,23 @@ static inline void x8_select_ac_table(IntraX8Context *const w, int mode)
 
     av_assert2(mode < 4);
 
-    if (w->j_ac_vlc[mode])
+    if (w->j_ac_vlc_table[mode])
         return;
 
     table_index       = get_bits(w->gb, 3);
     // 2 modes use same tables
-    w->j_ac_vlc[mode] = &j_ac_vlc[w->quant < 13][mode >> 1][table_index];
+    w->j_ac_vlc_table[mode] = j_ac_vlc[w->quant < 13][mode >> 1][table_index].table;
     av_assert2(w->j_ac_vlc[mode]);
 }
 
 static inline int x8_get_orient_vlc(IntraX8Context *w)
 {
-    if (!w->j_orient_vlc) {
+    if (!w->j_orient_vlc_table) {
         int table_index = get_bits(w->gb, 1 + (w->quant < 13));
-        w->j_orient_vlc = &j_orient_vlc[w->quant < 13][table_index];
+        w->j_orient_vlc_table = j_orient_vlc[w->quant < 13][table_index].table;
     }
 
-    return get_vlc2(w->gb, w->j_orient_vlc->table, OR_VLC_BITS, OR_VLC_MTD);
+    return get_vlc2(w->gb, w->j_orient_vlc_table, OR_VLC_BITS, OR_VLC_MTD);
 }
 
 #define extra_bits(eb)  (eb)        // 3 bits
@@ -175,7 +174,7 @@ static void x8_get_ac_rlf(IntraX8Context *const w, const int mode,
     int i, e;
 
 //    x8_select_ac_table(w, mode);
-    i = get_vlc2(w->gb, w->j_ac_vlc[mode]->table, AC_VLC_BITS, AC_VLC_MTD);
+    i = get_vlc2(w->gb, w->j_ac_vlc_table[mode], AC_VLC_BITS, AC_VLC_MTD);
 
     if (i < 46) { // [0-45]
         int t, l;
@@ -255,13 +254,13 @@ static int x8_get_dc_rlf(IntraX8Context *const w, const int mode,
     int i, e, c;
 
     av_assert2(mode < 3);
-    if (!w->j_dc_vlc[mode]) {
+    if (!w->j_dc_vlc_table[mode]) {
         int table_index = get_bits(w->gb, 3);
         // 4 modes, same table
-        w->j_dc_vlc[mode] = &j_dc_vlc[w->quant < 13][table_index];
+        w->j_dc_vlc_table[mode] = j_dc_vlc[w->quant < 13][table_index].table;
     }
 
-    i = get_vlc2(w->gb, w->j_dc_vlc[mode]->table, DC_VLC_BITS, DC_VLC_MTD);
+    i = get_vlc2(w->gb, w->j_dc_vlc_table[mode], DC_VLC_BITS, DC_VLC_MTD);
 
     /* (i >= 17) { i -= 17; final =1; } */
     c      = i > 16;
@@ -692,7 +691,7 @@ static void x8_init_block_index(IntraX8Context *w, AVFrame *frame)
 }
 
 av_cold int ff_intrax8_common_init(AVCodecContext *avctx,
-                                   IntraX8Context *w, IDCTDSPContext *idsp,
+                                   IntraX8Context *w,
                                    int16_t (*block)[64],
                                    int block_last_index[12],
                                    int mb_width, int mb_height)
@@ -700,7 +699,6 @@ av_cold int ff_intrax8_common_init(AVCodecContext *avctx,
     static AVOnce init_static_once = AV_ONCE_INIT;
 
     w->avctx = avctx;
-    w->idsp = *idsp;
     w->mb_width  = mb_width;
     w->mb_height = mb_height;
     w->block = block;
diff --git a/libavcodec/intrax8.h b/libavcodec/intrax8.h
index 5b8946e..966f1b1 100644
--- a/libavcodec/intrax8.h
+++ b/libavcodec/intrax8.h
@@ -27,9 +27,9 @@
 #include "mpegpicture.h"
 
 typedef struct IntraX8Context {
-    VLC *j_ac_vlc[4]; // they point to the static j_mb_vlc
-    VLC *j_orient_vlc;
-    VLC *j_dc_vlc[3];
+    const VLCElem *j_ac_vlc_table[4]; // they point to the static j_mb_vlc.table
+    const VLCElem *j_orient_vlc_table;
+    const VLCElem *j_dc_vlc_table[3];
 
     int use_quant_matrix;
 
@@ -44,7 +44,6 @@ typedef struct IntraX8Context {
 
     // set by the caller codec
     IntraX8DSPContext dsp;
-    IDCTDSPContext idsp;
     BlockDSPContext bdsp;
     int quant;
     int dquant;
@@ -86,7 +85,7 @@ typedef struct IntraX8Context {
  * @return 0 on success, a negative AVERROR value on error
  */
 int ff_intrax8_common_init(AVCodecContext *avctx,
-                           IntraX8Context *w, IDCTDSPContext *idsp,
+                           IntraX8Context *w,
                            int16_t (*block)[64],
                            int block_last_index[12],
                            int mb_width, int mb_height);
diff --git a/libavcodec/ituh263enc.c b/libavcodec/ituh263enc.c
index 2fcd001..e43cb33 100644
--- a/libavcodec/ituh263enc.c
+++ b/libavcodec/ituh263enc.c
@@ -903,7 +903,7 @@ const FFCodec ff_h263_encoder = {
     .p.id           = AV_CODEC_ID_H263,
     .p.pix_fmts = (const enum AVPixelFormat[]){AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE},
     .p.priv_class   = &h263_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(MpegEncContext),
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
@@ -934,7 +934,7 @@ const FFCodec ff_h263p_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
     .p.priv_class   = &h263p_class,
     .p.capabilities = AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(MpegEncContext),
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
diff --git a/libavcodec/j2kenc.c b/libavcodec/j2kenc.c
index ce77a6d..5ef7f24 100644
--- a/libavcodec/j2kenc.c
+++ b/libavcodec/j2kenc.c
@@ -507,7 +507,7 @@ static int init_tiles(Jpeg2000EncoderContext *s)
     static void copy_frame_ ##D(Jpeg2000EncoderContext *s)                                                                  \
     {                                                                                                                       \
         int tileno, compno, i, y, x;                                                                                        \
-        PIXEL *line;                                                                                                        \
+        const PIXEL *line;                                                                                                  \
         for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){                                                   \
             Jpeg2000Tile *tile = s->tile + tileno;                                                                          \
             if (s->planar){                                                                                                 \
@@ -515,23 +515,23 @@ static int init_tiles(Jpeg2000EncoderContext *s)
                     Jpeg2000Component *comp = tile->comp + compno;                                                          \
                     int *dst = comp->i_data;                                                                                \
                     int cbps = s->cbps[compno];                                                                             \
-                    line = (PIXEL*)s->picture->data[compno]                                                                 \
+                    line = (const PIXEL*)s->picture->data[compno]                                                           \
                            + comp->coord[1][0] * (s->picture->linesize[compno] / sizeof(PIXEL))                             \
                            + comp->coord[0][0];                                                                             \
                     for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){                                                \
-                        PIXEL *ptr = line;                                                                                  \
+                        const PIXEL *ptr = line;                                                                            \
                         for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)                                             \
                             *dst++ = *ptr++ - (1 << (cbps - 1));                                                            \
                         line += s->picture->linesize[compno] / sizeof(PIXEL);                                               \
                     }                                                                                                       \
                 }                                                                                                           \
             } else{                                                                                                         \
-                line = (PIXEL*)s->picture->data[0] + tile->comp[0].coord[1][0] * (s->picture->linesize[0] / sizeof(PIXEL))  \
+                line = (const PIXEL*)(s->picture->data[0] + tile->comp[0].coord[1][0] * s->picture->linesize[0])            \
                        + tile->comp[0].coord[0][0] * s->ncomponents;                                                        \
                                                                                                                             \
                 i = 0;                                                                                                      \
                 for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){                                    \
-                    PIXEL *ptr = line;                                                                                      \
+                    const PIXEL *ptr = line;                                                                                \
                     for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){                           \
                         for (compno = 0; compno < s->ncomponents; compno++){                                                \
                             int cbps = s->cbps[compno];                                                                     \
@@ -1597,7 +1597,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         update_size(chunkstart, s->buf);
         if (avctx->pix_fmt == AV_PIX_FMT_PAL8) {
             int i;
-            uint8_t *palette = pict->data[1];
+            const uint8_t *palette = pict->data[1];
             chunkstart = s->buf;
             bytestream_put_be32(&s->buf, 0);
             bytestream_put_buffer(&s->buf, "pclr", 4);
@@ -1848,5 +1848,5 @@ const FFCodec ff_jpeg2000_encoder = {
         AV_PIX_FMT_NONE
     },
     .p.priv_class   = &j2k_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/jacosubdec.c b/libavcodec/jacosubdec.c
index e3bf9f4..8dcc38e 100644
--- a/libavcodec/jacosubdec.c
+++ b/libavcodec/jacosubdec.c
@@ -202,5 +202,4 @@ const FFCodec ff_jacosub_decoder = {
     FF_CODEC_DECODE_SUB_CB(jacosub_decode_frame),
     .flush          = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/jpeg2000.h b/libavcodec/jpeg2000.h
index d063134..e5ecb4c 100644
--- a/libavcodec/jpeg2000.h
+++ b/libavcodec/jpeg2000.h
@@ -110,6 +110,8 @@ enum Jpeg2000Quantsty { // quantization style
 #define JPEG2000_CSTY_PREC      0x01 // Precincts defined in coding style
 #define JPEG2000_CSTY_SOP       0x02 // SOP marker present
 #define JPEG2000_CSTY_EPH       0x04 // EPH marker present
+#define JPEG2000_CTSY_HTJ2K_F   0x40 // Only HT code-blocks (Rec. ITU-T T.814 | ISO/IEC 15444-15) are present
+#define JPEG2000_CTSY_HTJ2K_M   0xC0 // HT code blocks (Rec. ITU-T T.814 | ISO/IEC 15444-15) can be present
 
 // Progression orders
 #define JPEG2000_PGOD_LRCP      0x00  // Layer-resolution level-component-position progression
diff --git a/libavcodec/jpeg2000dec.c b/libavcodec/jpeg2000dec.c
index 92966b1..5e177ce 100644
--- a/libavcodec/jpeg2000dec.c
+++ b/libavcodec/jpeg2000dec.c
@@ -521,6 +521,10 @@ static int get_cox(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *c)
 
     c->cblk_style = bytestream2_get_byteu(&s->g);
     if (c->cblk_style != 0) { // cblk style
+        if (c->cblk_style & JPEG2000_CTSY_HTJ2K_M || c->cblk_style & JPEG2000_CTSY_HTJ2K_F) {
+            av_log(s->avctx, AV_LOG_ERROR, "Support for High throughput JPEG 2000 is not yet available\n");
+            return AVERROR_PATCHWELCOME;
+        }
         av_log(s->avctx, AV_LOG_WARNING, "extra cblk styles %X\n", c->cblk_style);
         if (c->cblk_style & JPEG2000_CBLK_BYPASS)
             av_log(s->avctx, AV_LOG_WARNING, "Selective arithmetic coding bypass\n");
@@ -1679,7 +1683,7 @@ static void decode_refpass(Jpeg2000T1Context *t1, int width, int height,
                 }
 }
 
-static void decode_clnpass(Jpeg2000DecoderContext *s, Jpeg2000T1Context *t1,
+static void decode_clnpass(const Jpeg2000DecoderContext *s, Jpeg2000T1Context *t1,
                            int width, int height, int bpno, int bandno,
                            int seg_symbols, int vert_causal_ctx_csty_symbol)
 {
@@ -1745,7 +1749,7 @@ static void decode_clnpass(Jpeg2000DecoderContext *s, Jpeg2000T1Context *t1,
     }
 }
 
-static int decode_cblk(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,
+static int decode_cblk(const Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *codsty,
                        Jpeg2000T1Context *t1, Jpeg2000Cblk *cblk,
                        int width, int height, int bandpos, uint8_t roi_shift)
 {
@@ -1896,7 +1900,7 @@ static void dequantization_int_97(int x, int y, Jpeg2000Cblk *cblk,
     }
 }
 
-static inline void mct_decode(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)
+static inline void mct_decode(const Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)
 {
     int i, csize = 1;
     void *src[3];
@@ -1937,7 +1941,7 @@ static inline void roi_scale_cblk(Jpeg2000Cblk *cblk,
     }
 }
 
-static inline void tile_codeblocks(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)
+static inline void tile_codeblocks(const Jpeg2000DecoderContext *s, Jpeg2000Tile *tile)
 {
     Jpeg2000T1Context t1;
 
@@ -2009,7 +2013,7 @@ static inline void tile_codeblocks(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile
 }
 
 #define WRITE_FRAME(D, PIXEL)                                                                     \
-    static inline void write_frame_ ## D(Jpeg2000DecoderContext * s, Jpeg2000Tile * tile,         \
+    static inline void write_frame_ ## D(const Jpeg2000DecoderContext * s, Jpeg2000Tile * tile,   \
                                          AVFrame * picture, int precision)                        \
     {                                                                                             \
         const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(s->avctx->pix_fmt);               \
@@ -2078,7 +2082,7 @@ WRITE_FRAME(16, uint16_t)
 static int jpeg2000_decode_tile(AVCodecContext *avctx, void *td,
                                 int jobnr, int threadnr)
 {
-    Jpeg2000DecoderContext *s = avctx->priv_data;
+    const Jpeg2000DecoderContext *s = avctx->priv_data;
     AVFrame *picture = td;
     Jpeg2000Tile *tile = s->tile + jobnr;
 
@@ -2582,5 +2586,4 @@ const FFCodec ff_jpeg2000_decoder = {
     .p.priv_class     = &jpeg2000_class,
     .p.max_lowres     = 5,
     .p.profiles       = NULL_IF_CONFIG_SMALL(ff_jpeg2000_profiles),
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/jpeglsdec.c b/libavcodec/jpeglsdec.c
index ab663dc..984cc3b 100644
--- a/libavcodec/jpeglsdec.c
+++ b/libavcodec/jpeglsdec.c
@@ -560,6 +560,6 @@ const FFCodec ff_jpegls_decoder = {
     .close          = ff_mjpeg_decode_end,
     FF_CODEC_RECEIVE_FRAME_CB(ff_mjpeg_receive_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_SETS_PKT_DTS,
 };
diff --git a/libavcodec/jpeglsenc.c b/libavcodec/jpeglsenc.c
index 577e8a1..ba93552 100644
--- a/libavcodec/jpeglsenc.c
+++ b/libavcodec/jpeglsenc.c
@@ -489,6 +489,5 @@ const FFCodec ff_jpegls_encoder = {
         AV_PIX_FMT_GRAY8, AV_PIX_FMT_GRAY16,
         AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/jvdec.c b/libavcodec/jvdec.c
index 06015ba..bca2603 100644
--- a/libavcodec/jvdec.c
+++ b/libavcodec/jvdec.c
@@ -244,5 +244,4 @@ const FFCodec ff_jv_decoder = {
     .close          = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/kgv1dec.c b/libavcodec/kgv1dec.c
index 08e92c7..47c2a31 100644
--- a/libavcodec/kgv1dec.c
+++ b/libavcodec/kgv1dec.c
@@ -187,5 +187,4 @@ const FFCodec ff_kgv1_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .flush          = decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/kmvc.c b/libavcodec/kmvc.c
index a009ba0..d5da541 100644
--- a/libavcodec/kmvc.c
+++ b/libavcodec/kmvc.c
@@ -413,5 +413,4 @@ const FFCodec ff_kmvc_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/lagarith.c b/libavcodec/lagarith.c
index 00e8005..68ffbc9 100644
--- a/libavcodec/lagarith.c
+++ b/libavcodec/lagarith.c
@@ -737,5 +737,4 @@ const FFCodec ff_lagarith_decoder = {
     .init           = lag_decode_init,
     FF_CODEC_DECODE_CB(lag_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/lcldec.c b/libavcodec/lcldec.c
index ffa2fe5..6de5545 100644
--- a/libavcodec/lcldec.c
+++ b/libavcodec/lcldec.c
@@ -640,7 +640,7 @@ const FFCodec ff_mszh_decoder = {
     .init           = decode_init,
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
 
@@ -655,6 +655,6 @@ const FFCodec ff_zlib_decoder = {
     .init           = decode_init,
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/lclenc.c b/libavcodec/lclenc.c
index bd42c15..f08cec1 100644
--- a/libavcodec/lclenc.c
+++ b/libavcodec/lclenc.c
@@ -162,6 +162,5 @@ const FFCodec ff_zlib_encoder = {
     .close          = encode_end,
     .p.capabilities = AV_CODEC_CAP_FRAME_THREADS,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_BGR24, AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/libaom.c b/libavcodec/libaom.c
new file mode 100644
index 0000000..0befaaa
--- /dev/null
+++ b/libavcodec/libaom.c
@@ -0,0 +1,49 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * AOM common functions
+ */
+
+#include "libavutil/pixdesc.h"
+#include "libaom.h"
+
+void ff_aom_image_copy_16_to_8(AVFrame *pic, struct aom_image *img)
+{
+    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pic->format);
+    int i;
+
+    for (i = 0; i < desc->nb_components; i++) {
+        int w = img->d_w;
+        int h = img->d_h;
+        int x, y;
+
+        if (i) {
+            w = (w + img->x_chroma_shift) >> img->x_chroma_shift;
+            h = (h + img->y_chroma_shift) >> img->y_chroma_shift;
+        }
+
+        for (y = 0; y < h; y++) {
+            uint16_t *src = (uint16_t *)(img->planes[i] + y * img->stride[i]);
+            uint8_t *dst = pic->data[i] + y * pic->linesize[i];
+            for (x = 0; x < w; x++)
+                *dst++ = *src++;
+        }
+    }
+}
diff --git a/libavcodec/libaom.h b/libavcodec/libaom.h
new file mode 100644
index 0000000..bb495af
--- /dev/null
+++ b/libavcodec/libaom.h
@@ -0,0 +1,33 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * AOM common functions
+ */
+
+#ifndef AVCODEC_LIBAOM_H
+#define AVCODEC_LIBAOM_H
+
+#include <aom/aom_image.h>
+
+#include "libavutil/frame.h"
+
+void ff_aom_image_copy_16_to_8(AVFrame *pic, struct aom_image *img);
+
+#endif /* AVCODEC_LIBAOM_H */
diff --git a/libavcodec/libaomdec.c b/libavcodec/libaomdec.c
index 52a8bf1..cb672b0 100644
--- a/libavcodec/libaomdec.c
+++ b/libavcodec/libaomdec.c
@@ -33,6 +33,7 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "internal.h"
+#include "libaom.h"
 #include "profiles.h"
 
 typedef struct AV1DecodeContext {
@@ -60,30 +61,6 @@ static av_cold int aom_init(AVCodecContext *avctx,
     return 0;
 }
 
-static void image_copy_16_to_8(AVFrame *pic, struct aom_image *img)
-{
-    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pic->format);
-    int i;
-
-    for (i = 0; i < desc->nb_components; i++) {
-        int w = img->d_w;
-        int h = img->d_h;
-        int x, y;
-
-        if (i) {
-            w = (w + img->x_chroma_shift) >> img->x_chroma_shift;
-            h = (h + img->y_chroma_shift) >> img->y_chroma_shift;
-        }
-
-        for (y = 0; y < h; y++) {
-            uint16_t *src = (uint16_t *)(img->planes[i] + y * img->stride[i]);
-            uint8_t *dst = pic->data[i] + y * pic->linesize[i];
-            for (x = 0; x < w; x++)
-                *dst++ = *src++;
-        }
-    }
-}
-
 // returns 0 on success, AVERROR_INVALIDDATA otherwise
 static int set_pix_fmt(AVCodecContext *avctx, struct aom_image *img)
 {
@@ -223,7 +200,7 @@ static int aom_decode(AVCodecContext *avctx, AVFrame *picture,
         ff_set_sar(avctx, picture->sample_aspect_ratio);
 
         if ((img->fmt & AOM_IMG_FMT_HIGHBITDEPTH) && img->bit_depth == 8)
-            image_copy_16_to_8(picture, img);
+            ff_aom_image_copy_16_to_8(picture, img);
         else {
             const uint8_t *planes[4] = { img->planes[0], img->planes[1], img->planes[2] };
             const int      stride[4] = { img->stride[0], img->stride[1], img->stride[2] };
@@ -258,7 +235,8 @@ const FFCodec ff_libaom_av1_decoder = {
     .close          = aom_free,
     FF_CODEC_DECODE_CB(aom_decode),
     .p.capabilities = AV_CODEC_CAP_OTHER_THREADS | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_av1_profiles),
     .p.wrapper_name = "libaom",
 };
diff --git a/libavcodec/libaomenc.c b/libavcodec/libaomenc.c
index 6b7e426..1fd69d5 100644
--- a/libavcodec/libaomenc.c
+++ b/libavcodec/libaomenc.c
@@ -31,6 +31,7 @@
 #include "libavutil/base64.h"
 #include "libavutil/common.h"
 #include "libavutil/cpu.h"
+#include "libavutil/imgutils.h"
 #include "libavutil/mathematics.h"
 #include "libavutil/opt.h"
 #include "libavutil/pixdesc.h"
@@ -41,6 +42,7 @@
 #include "codec_internal.h"
 #include "encode.h"
 #include "internal.h"
+#include "libaom.h"
 #include "packet_internal.h"
 #include "profiles.h"
 
@@ -208,6 +210,7 @@ static const char *const ctlidstr[] = {
 #ifdef AOM_CTRL_AV1E_GET_TARGET_SEQ_LEVEL_IDX
     [AV1E_GET_TARGET_SEQ_LEVEL_IDX]     = "AV1E_GET_TARGET_SEQ_LEVEL_IDX",
 #endif
+    [AV1_GET_NEW_FRAME_IMAGE]           = "AV1_GET_NEW_FRAME_IMAGE",
 };
 
 static av_cold void log_encoder_error(AVCodecContext *avctx, const char *desc)
@@ -364,6 +367,31 @@ static av_cold int codecctl_intp(AVCodecContext *avctx,
 }
 #endif
 
+static av_cold int codecctl_imgp(AVCodecContext *avctx,
+#ifdef UENUM1BYTE
+                                 aome_enc_control_id id,
+#else
+                                 enum aome_enc_control_id id,
+#endif
+                                 struct aom_image *img)
+{
+    AOMContext *ctx = avctx->priv_data;
+    char buf[80];
+    int res;
+
+    snprintf(buf, sizeof(buf), "%s:", ctlidstr[id]);
+
+    res = aom_codec_control(&ctx->encoder, id, img);
+    if (res != AOM_CODEC_OK) {
+        snprintf(buf, sizeof(buf), "Failed to get %s codec control",
+                 ctlidstr[id]);
+        log_encoder_error(avctx, buf);
+        return AVERROR(EINVAL);
+    }
+
+    return 0;
+}
+
 static av_cold int aom_free(AVCodecContext *avctx)
 {
     AOMContext *ctx = avctx->priv_data;
@@ -1206,6 +1234,37 @@ static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
     return size;
 }
 
+static enum AVPixelFormat aomfmt_to_pixfmt(struct aom_image *img)
+{
+    switch (img->fmt) {
+    case AOM_IMG_FMT_I420:
+    case AOM_IMG_FMT_I42016:
+        if (img->bit_depth == 8)
+            return img->monochrome ? AV_PIX_FMT_GRAY8 : AV_PIX_FMT_YUV420P;
+        else if (img->bit_depth == 10)
+            return img->monochrome ? AV_PIX_FMT_GRAY10 : AV_PIX_FMT_YUV420P10;
+        else
+            return img->monochrome ? AV_PIX_FMT_GRAY12 : AV_PIX_FMT_YUV420P12;
+    case AOM_IMG_FMT_I422:
+    case AOM_IMG_FMT_I42216:
+        if (img->bit_depth == 8)
+            return AV_PIX_FMT_YUV422P;
+        else if (img->bit_depth == 10)
+            return AV_PIX_FMT_YUV422P10;
+        else
+            return AV_PIX_FMT_YUV422P12;
+    case AOM_IMG_FMT_I444:
+    case AOM_IMG_FMT_I44416:
+        if (img->bit_depth == 8)
+            return AV_PIX_FMT_YUV444P;
+        else if (img->bit_depth == 10)
+            return AV_PIX_FMT_YUV444P10;
+        else
+            return AV_PIX_FMT_YUV444P12;
+    };
+    return AV_PIX_FMT_NONE;
+}
+
 static int aom_encode(AVCodecContext *avctx, AVPacket *pkt,
                       const AVFrame *frame, int *got_packet)
 {
@@ -1259,6 +1318,43 @@ static int aom_encode(AVCodecContext *avctx, AVPacket *pkt,
     }
 
     *got_packet = !!coded_size;
+
+    if (*got_packet && avctx->flags & AV_CODEC_FLAG_RECON_FRAME) {
+        AVCodecInternal *avci = avctx->internal;
+        struct aom_image img;
+
+        av_frame_unref(avci->recon_frame);
+
+        res = codecctl_imgp(avctx, AV1_GET_NEW_FRAME_IMAGE, &img);
+        if (res < 0)
+            return res;
+
+        avci->recon_frame->format = aomfmt_to_pixfmt(&img);
+        if (avci->recon_frame->format == AV_PIX_FMT_NONE) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "Unhandled reconstructed frame colorspace: %d\n",
+                   img.fmt);
+            return AVERROR(ENOSYS);
+        }
+
+        avci->recon_frame->width  = img.d_w;
+        avci->recon_frame->height = img.d_h;
+
+        res = av_frame_get_buffer(avci->recon_frame, 0);
+        if (res < 0)
+            return res;
+
+        if ((img.fmt & AOM_IMG_FMT_HIGHBITDEPTH) && img.bit_depth == 8)
+            ff_aom_image_copy_16_to_8(avci->recon_frame, &img);
+        else {
+            const uint8_t *planes[4] = { img.planes[0], img.planes[1], img.planes[2] };
+            const int      stride[4] = { img.stride[0], img.stride[1], img.stride[2] };
+
+            av_image_copy(avci->recon_frame->data, avci->recon_frame->linesize, planes,
+                          stride, avci->recon_frame->format, img.d_w, img.d_h);
+        }
+    }
+
     return 0;
 }
 
@@ -1434,6 +1530,7 @@ FFCodec ff_libaom_av1_encoder = {
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_AV1,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY |
+                      AV_CODEC_CAP_ENCODER_RECON_FRAME |
                       AV_CODEC_CAP_OTHER_THREADS,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_av1_profiles),
     .p.priv_class   = &class_aom,
@@ -1442,7 +1539,8 @@ FFCodec ff_libaom_av1_encoder = {
     .init           = av1_init,
     FF_CODEC_ENCODE_CB(aom_encode),
     .close          = aom_free,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .defaults       = defaults,
     .init_static_data = av1_init_static,
 };
diff --git a/libavcodec/libaribb24.c b/libavcodec/libaribb24.c
index 9658e1d..e89e49a 100644
--- a/libavcodec/libaribb24.c
+++ b/libavcodec/libaribb24.c
@@ -388,6 +388,7 @@ const FFCodec ff_libaribb24_decoder = {
     .p.id           = AV_CODEC_ID_ARIB_CAPTION,
     .p.priv_class   = &aribb24_class,
     .p.wrapper_name = "libaribb24",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(Libaribb24Context),
     .init      = libaribb24_init,
     .close     = libaribb24_close,
diff --git a/libavcodec/libcelt_dec.c b/libavcodec/libcelt_dec.c
index d659d80..a9c9962 100644
--- a/libavcodec/libcelt_dec.c
+++ b/libavcodec/libcelt_dec.c
@@ -134,6 +134,7 @@ const FFCodec ff_libcelt_decoder = {
     .p.id           = AV_CODEC_ID_CELT,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.wrapper_name = "libcelt",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(struct libcelt_context),
     .init           = libcelt_dec_init,
     .close          = libcelt_dec_close,
diff --git a/libavcodec/libcodec2.c b/libavcodec/libcodec2.c
index abb1130..0f2e671 100644
--- a/libavcodec/libcodec2.c
+++ b/libavcodec/libcodec2.c
@@ -185,6 +185,7 @@ const FFCodec ff_libcodec2_decoder = {
     .p.supported_samplerates = (const int[]){ 8000, 0 },
     .p.sample_fmts          = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },
     .p.ch_layouts           = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO, { 0 } },
+    .caps_internal          = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size         = sizeof(LibCodec2Context),
     .init                   = libcodec2_init_decoder,
     .close                  = libcodec2_close,
@@ -204,6 +205,7 @@ const FFCodec ff_libcodec2_encoder = {
     .p.sample_fmts          = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },
     .p.ch_layouts           = (const AVChannelLayout[]) { AV_CHANNEL_LAYOUT_MONO, { 0 } },
     .p.priv_class           = &libcodec2_enc_class,
+    .caps_internal          = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size         = sizeof(LibCodec2Context),
     .init                   = libcodec2_init_encoder,
     .close                  = libcodec2_close,
diff --git a/libavcodec/libdav1d.c b/libavcodec/libdav1d.c
index 0a46cf2..b120d55 100644
--- a/libavcodec/libdav1d.c
+++ b/libavcodec/libdav1d.c
@@ -415,7 +415,7 @@ static int libdav1d_receive_frame(AVCodecContext *c, AVFrame *frame)
     frame->pkt_dts = p->m.timestamp;
     frame->pkt_pos = p->m.offset;
     frame->pkt_size = p->m.size;
-    frame->pkt_duration = p->m.duration;
+    frame->duration = p->m.duration;
     frame->key_frame = p->frame_hdr->frame_type == DAV1D_FRAME_TYPE_KEY;
 
     switch (p->frame_hdr->frame_type) {
@@ -585,7 +585,7 @@ const FFCodec ff_libdav1d_decoder = {
     .flush          = libdav1d_flush,
     FF_CODEC_RECEIVE_FRAME_CB(libdav1d_receive_frame),
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_SETS_PKT_DTS |
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS |
                       FF_CODEC_CAP_AUTO_THREADS,
     .p.priv_class   = &libdav1d_class,
     .p.wrapper_name = "libdav1d",
diff --git a/libavcodec/libdavs2.c b/libavcodec/libdavs2.c
index 918e485..ce4c6a3 100644
--- a/libavcodec/libdavs2.c
+++ b/libavcodec/libdavs2.c
@@ -232,7 +232,8 @@ const FFCodec ff_libdavs2_decoder = {
     FF_CODEC_DECODE_CB(davs2_decode_frame),
     .flush          = davs2_flush,
     .p.capabilities =  AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
     .p.wrapper_name = "libdavs2",
diff --git a/libavcodec/libfdk-aacdec.c b/libavcodec/libfdk-aacdec.c
index 11eee51..87e412f 100644
--- a/libavcodec/libfdk-aacdec.c
+++ b/libavcodec/libfdk-aacdec.c
@@ -492,7 +492,6 @@ const FFCodec ff_libfdk_aac_decoder = {
 #endif
     ,
     .p.priv_class   = &fdk_aac_dec_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name = "libfdk",
 };
diff --git a/libavcodec/libfdk-aacenc.c b/libavcodec/libfdk-aacenc.c
index a5697bd..2ffbc18 100644
--- a/libavcodec/libfdk-aacenc.c
+++ b/libavcodec/libfdk-aacenc.c
@@ -480,6 +480,7 @@ const FFCodec ff_libfdk_aac_encoder = {
     .p.long_name           = NULL_IF_CONFIG_SMALL("Fraunhofer FDK AAC"),
     .p.type                = AVMEDIA_TYPE_AUDIO,
     .p.id                  = AV_CODEC_ID_AAC,
+    .caps_internal         = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size        = sizeof(AACContext),
     .init                  = aac_encode_init,
     FF_CODEC_ENCODE_CB(aac_encode_frame),
diff --git a/libavcodec/libgsmdec.c b/libavcodec/libgsmdec.c
index 9c2304f..6e37122 100644
--- a/libavcodec/libgsmdec.c
+++ b/libavcodec/libgsmdec.c
@@ -132,6 +132,7 @@ const FFCodec ff_libgsm_decoder = {
     .p.id           = AV_CODEC_ID_GSM,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.wrapper_name = "libgsm",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibGSMDecodeContext),
     .init           = libgsm_decode_init,
     .close          = libgsm_decode_close,
@@ -147,6 +148,7 @@ const FFCodec ff_libgsm_ms_decoder = {
     .p.id           = AV_CODEC_ID_GSM_MS,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.wrapper_name = "libgsm",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibGSMDecodeContext),
     .init           = libgsm_decode_init,
     .close          = libgsm_decode_close,
diff --git a/libavcodec/libgsmenc.c b/libavcodec/libgsmenc.c
index a45b77b..f83389d 100644
--- a/libavcodec/libgsmenc.c
+++ b/libavcodec/libgsmenc.c
@@ -134,6 +134,7 @@ const FFCodec ff_libgsm_encoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
     .p.wrapper_name = "libgsm",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_LIBGSM_MS_ENCODER
@@ -154,5 +155,6 @@ const FFCodec ff_libgsm_ms_encoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
     .p.wrapper_name = "libgsm",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/libilbc.c b/libavcodec/libilbc.c
index a7b1eaf..0b6b1fb 100644
--- a/libavcodec/libilbc.c
+++ b/libavcodec/libilbc.c
@@ -122,6 +122,7 @@ const FFCodec ff_libilbc_decoder = {
     .p.long_name    = NULL_IF_CONFIG_SMALL("iLBC (Internet Low Bitrate Codec)"),
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_ILBC,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(ILBCDecContext),
     .init           = ilbc_decode_init,
     FF_CODEC_DECODE_CB(ilbc_decode_frame),
@@ -204,6 +205,7 @@ const FFCodec ff_libilbc_encoder = {
     .p.long_name    = NULL_IF_CONFIG_SMALL("iLBC (Internet Low Bitrate Codec)"),
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_ILBC,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(ILBCEncContext),
     .init           = ilbc_encode_init,
     FF_CODEC_ENCODE_CB(ilbc_encode_frame),
diff --git a/libavcodec/libjxldec.c b/libavcodec/libjxldec.c
index 829478b..f547015 100644
--- a/libavcodec/libjxldec.c
+++ b/libavcodec/libjxldec.c
@@ -455,6 +455,8 @@ const FFCodec ff_libjxl_decoder = {
     FF_CODEC_DECODE_CB(libjxl_decode_frame),
     .close            = libjxl_decode_close,
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_OTHER_THREADS,
-    .caps_internal    = FF_CODEC_CAP_AUTO_THREADS | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                        FF_CODEC_CAP_AUTO_THREADS | FF_CODEC_CAP_INIT_CLEANUP |
+                        FF_CODEC_CAP_ICC_PROFILES,
     .p.wrapper_name   = "libjxl",
 };
diff --git a/libavcodec/libjxlenc.c b/libavcodec/libjxlenc.c
index 6a948cc..7e97237 100644
--- a/libavcodec/libjxlenc.c
+++ b/libavcodec/libjxlenc.c
@@ -190,7 +190,7 @@ static av_cold int libjxl_encode_init(AVCodecContext *avctx)
  * Populate a JxlColorEncoding with the given enum AVColorPrimaries.
  * @return < 0 upon failure, >= 0 upon success
  */
-static int libjxl_populate_primaries(JxlColorEncoding *jxl_color, enum AVColorPrimaries prm)
+static int libjxl_populate_primaries(void *avctx, JxlColorEncoding *jxl_color, enum AVColorPrimaries prm)
 {
     const AVColorPrimariesDesc *desc;
 
@@ -211,6 +211,11 @@ static int libjxl_populate_primaries(JxlColorEncoding *jxl_color, enum AVColorPr
         jxl_color->primaries = JXL_PRIMARIES_P3;
         jxl_color->white_point = JXL_WHITE_POINT_D65;
         return 0;
+    case AVCOL_PRI_UNSPECIFIED:
+        av_log(avctx, AV_LOG_WARNING, "Unknown primaries, assuming BT.709/sRGB. Colors may be wrong.\n");
+        jxl_color->primaries = JXL_PRIMARIES_SRGB;
+        jxl_color->white_point = JXL_WHITE_POINT_D65;
+        return 0;
     }
 
     desc = av_csp_primaries_desc_from_id(prm);
@@ -340,7 +345,7 @@ static int libjxl_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFra
     else
         jxl_color.color_space = JXL_COLOR_SPACE_RGB;
 
-    ret = libjxl_populate_primaries(&jxl_color,
+    ret = libjxl_populate_primaries(avctx, &jxl_color,
             frame->color_primaries && frame->color_primaries != AVCOL_PRI_UNSPECIFIED
             ? frame->color_primaries : avctx->color_primaries);
     if (ret < 0)
@@ -463,7 +468,9 @@ const FFCodec ff_libjxl_encoder = {
     FF_CODEC_ENCODE_CB(libjxl_encode_frame),
     .close            = libjxl_encode_close,
     .p.capabilities   = AV_CODEC_CAP_OTHER_THREADS,
-    .caps_internal    = FF_CODEC_CAP_AUTO_THREADS | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                        FF_CODEC_CAP_AUTO_THREADS | FF_CODEC_CAP_INIT_CLEANUP |
+                        FF_CODEC_CAP_ICC_PROFILES,
     .p.pix_fmts       = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_RGB24, AV_PIX_FMT_RGBA,
         AV_PIX_FMT_RGB48, AV_PIX_FMT_RGBA64,
diff --git a/libavcodec/libkvazaar.c b/libavcodec/libkvazaar.c
index 7fd0e95..3a3648f 100644
--- a/libavcodec/libkvazaar.c
+++ b/libavcodec/libkvazaar.c
@@ -335,7 +335,7 @@ const FFCodec ff_libkvazaar_encoder = {
     FF_CODEC_ENCODE_CB(libkvazaar_encode),
     .close            = libkvazaar_close,
 
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP |
                         FF_CODEC_CAP_AUTO_THREADS,
 
     .p.wrapper_name   = "libkvazaar",
diff --git a/libavcodec/libmp3lame.c b/libavcodec/libmp3lame.c
index 02a256c..2cd5169 100644
--- a/libavcodec/libmp3lame.c
+++ b/libavcodec/libmp3lame.c
@@ -335,6 +335,7 @@ const FFCodec ff_libmp3lame_encoder = {
     .p.id                  = AV_CODEC_ID_MP3,
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY |
                              AV_CODEC_CAP_SMALL_LAST_FRAME,
+    .caps_internal         = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size        = sizeof(LAMEContext),
     .init                  = mp3lame_encode_init,
     FF_CODEC_ENCODE_CB(mp3lame_encode_frame),
diff --git a/libavcodec/libopencore-amr.c b/libavcodec/libopencore-amr.c
index 539f0de..014dd53 100644
--- a/libavcodec/libopencore-amr.c
+++ b/libavcodec/libopencore-amr.c
@@ -138,6 +138,7 @@ const FFCodec ff_libopencore_amrnb_decoder = {
     .p.long_name    = NULL_IF_CONFIG_SMALL("OpenCORE AMR-NB (Adaptive Multi-Rate Narrow-Band)"),
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_AMR_NB,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(AMRContext),
     .init           = amr_nb_decode_init,
     .close          = amr_nb_decode_close,
@@ -293,6 +294,7 @@ const FFCodec ff_libopencore_amrnb_encoder = {
     .p.long_name    = NULL_IF_CONFIG_SMALL("OpenCORE AMR-NB (Adaptive Multi-Rate Narrow-Band)"),
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_AMR_NB,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(AMRContext),
     .init           = amr_nb_encode_init,
     FF_CODEC_ENCODE_CB(amr_nb_encode_frame),
@@ -379,6 +381,7 @@ const FFCodec ff_libopencore_amrwb_decoder = {
     .p.id           = AV_CODEC_ID_AMR_WB,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.wrapper_name = "libopencore_amrwb",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(AMRWBContext),
     .init           = amr_wb_decode_init,
     .close          = amr_wb_decode_close,
diff --git a/libavcodec/libopenh264dec.c b/libavcodec/libopenh264dec.c
index 007f86b..04157d8 100644
--- a/libavcodec/libopenh264dec.c
+++ b/libavcodec/libopenh264dec.c
@@ -166,7 +166,7 @@ const FFCodec ff_libopenh264_decoder = {
     FF_CODEC_DECODE_CB(svc_decode_frame),
     .close          = svc_decode_close,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_INIT_THREADSAFE |
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS |
                       FF_CODEC_CAP_INIT_CLEANUP,
     .bsfs           = "h264_mp4toannexb",
     .p.wrapper_name = "libopenh264",
diff --git a/libavcodec/libopenh264enc.c b/libavcodec/libopenh264enc.c
index db252aa..54dff68 100644
--- a/libavcodec/libopenh264enc.c
+++ b/libavcodec/libopenh264enc.c
@@ -461,7 +461,7 @@ const FFCodec ff_libopenh264_encoder = {
     .init           = svc_encode_init,
     FF_CODEC_ENCODE_CB(svc_encode_frame),
     .close          = svc_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_AUTO_THREADS,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P,
                                                     AV_PIX_FMT_NONE },
diff --git a/libavcodec/libopenjpegdec.c b/libavcodec/libopenjpegdec.c
index 58ac6c4..fa420f1 100644
--- a/libavcodec/libopenjpegdec.c
+++ b/libavcodec/libopenjpegdec.c
@@ -509,6 +509,7 @@ const FFCodec ff_libopenjpeg_decoder = {
     .p.max_lowres   = 31,
     .p.priv_class   = &openjpeg_class,
     .p.wrapper_name = "libopenjpeg",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibOpenJPEGContext),
     .init           = libopenjpeg_decode_init,
     FF_CODEC_DECODE_CB(libopenjpeg_decode_frame),
diff --git a/libavcodec/libopenjpegenc.c b/libavcodec/libopenjpegenc.c
index 06338e8..750fce3 100644
--- a/libavcodec/libopenjpegenc.c
+++ b/libavcodec/libopenjpegenc.c
@@ -759,6 +759,7 @@ const FFCodec ff_libopenjpeg_encoder = {
     .p.long_name    = NULL_IF_CONFIG_SMALL("OpenJPEG JPEG 2000"),
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_JPEG2000,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibOpenJPEGContext),
     .init           = libopenjpeg_encode_init,
     FF_CODEC_ENCODE_CB(libopenjpeg_encode_frame),
diff --git a/libavcodec/libopusdec.c b/libavcodec/libopusdec.c
index 316ab0f..7b7d9c8 100644
--- a/libavcodec/libopusdec.c
+++ b/libavcodec/libopusdec.c
@@ -241,7 +241,8 @@ const FFCodec ff_libopus_decoder = {
     FF_CODEC_DECODE_CB(libopus_decode),
     .flush          = libopus_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLT,
                                                      AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
diff --git a/libavcodec/libopusenc.c b/libavcodec/libopusenc.c
index c884075..b8ab184 100644
--- a/libavcodec/libopusenc.c
+++ b/libavcodec/libopusenc.c
@@ -459,7 +459,7 @@ static int libopus_encode(AVCodecContext *avctx, AVPacket *avpkt,
     const int bytes_per_sample = av_get_bytes_per_sample(avctx->sample_fmt);
     const int channels         = avctx->ch_layout.nb_channels;
     const int sample_size      = channels * bytes_per_sample;
-    uint8_t *audio;
+    const uint8_t *audio;
     int ret;
     int discard_padding;
 
@@ -470,18 +470,18 @@ static int libopus_encode(AVCodecContext *avctx, AVPacket *avpkt,
         if (opus->encoder_channel_map != NULL) {
             audio = opus->samples;
             libopus_copy_samples_with_channel_map(
-                audio, frame->data[0], opus->encoder_channel_map,
+                opus->samples, frame->data[0], opus->encoder_channel_map,
                 channels, frame->nb_samples, bytes_per_sample);
         } else if (frame->nb_samples < opus->opts.packet_size) {
             audio = opus->samples;
-            memcpy(audio, frame->data[0], frame->nb_samples * sample_size);
+            memcpy(opus->samples, frame->data[0], frame->nb_samples * sample_size);
         } else
             audio = frame->data[0];
     } else {
         if (!opus->afq.remaining_samples || (!opus->afq.frame_alloc && !opus->afq.frame_count))
             return 0;
         audio = opus->samples;
-        memset(audio, 0, opus->opts.packet_size * sample_size);
+        memset(opus->samples, 0, opus->opts.packet_size * sample_size);
     }
 
     /* Maximum packet size taken from opusenc in opus-tools. 120ms packets
@@ -491,11 +491,11 @@ static int libopus_encode(AVCodecContext *avctx, AVPacket *avpkt,
         return ret;
 
     if (avctx->sample_fmt == AV_SAMPLE_FMT_FLT)
-        ret = opus_multistream_encode_float(opus->enc, (float *)audio,
+        ret = opus_multistream_encode_float(opus->enc, (const float *)audio,
                                             opus->opts.packet_size,
                                             avpkt->data, avpkt->size);
     else
-        ret = opus_multistream_encode(opus->enc, (opus_int16 *)audio,
+        ret = opus_multistream_encode(opus->enc, (const opus_int16 *)audio,
                                       opus->opts.packet_size,
                                       avpkt->data, avpkt->size);
 
@@ -588,6 +588,7 @@ const FFCodec ff_libopus_encoder = {
     .p.long_name     = NULL_IF_CONFIG_SMALL("libopus Opus"),
     .p.type          = AVMEDIA_TYPE_AUDIO,
     .p.id            = AV_CODEC_ID_OPUS,
+    .caps_internal   = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size  = sizeof(LibopusEncContext),
     .init            = libopus_encode_init,
     FF_CODEC_ENCODE_CB(libopus_encode),
diff --git a/libavcodec/librav1e.c b/libavcodec/librav1e.c
index 9d811ba..67b301b 100644
--- a/libavcodec/librav1e.c
+++ b/libavcodec/librav1e.c
@@ -628,6 +628,7 @@ const FFCodec ff_librav1e_encoder = {
     .p.pix_fmts     = librav1e_pix_fmts,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_AUTO_THREADS,
     .p.wrapper_name = "librav1e",
 };
diff --git a/libavcodec/libshine.c b/libavcodec/libshine.c
index 9bc5456..123b1a0 100644
--- a/libavcodec/libshine.c
+++ b/libavcodec/libshine.c
@@ -137,6 +137,7 @@ const FFCodec ff_libshine_encoder = {
     .p.type                = AVMEDIA_TYPE_AUDIO,
     .p.id                  = AV_CODEC_ID_MP3,
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
+    .caps_internal         = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size        = sizeof(SHINEContext),
     .init                  = libshine_encode_init,
     FF_CODEC_ENCODE_CB(libshine_encode_frame),
diff --git a/libavcodec/libspeexdec.c b/libavcodec/libspeexdec.c
index bb8e1a7..af0f224 100644
--- a/libavcodec/libspeexdec.c
+++ b/libavcodec/libspeexdec.c
@@ -197,6 +197,7 @@ const FFCodec ff_libspeex_decoder = {
     .p.id           = AV_CODEC_ID_SPEEX,
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DELAY | AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.wrapper_name = "libspeex",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibSpeexContext),
     .init           = libspeex_decode_init,
     .close          = libspeex_decode_close,
diff --git a/libavcodec/libspeexenc.c b/libavcodec/libspeexenc.c
index ec4b3c6..9eab8f8 100644
--- a/libavcodec/libspeexenc.c
+++ b/libavcodec/libspeexenc.c
@@ -353,6 +353,7 @@ const FFCodec ff_libspeex_encoder = {
     .p.long_name    = NULL_IF_CONFIG_SMALL("libspeex Speex"),
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_SPEEX,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibSpeexEncContext),
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
diff --git a/libavcodec/libsvtav1.c b/libavcodec/libsvtav1.c
index 4001cf7..234c24c 100644
--- a/libavcodec/libsvtav1.c
+++ b/libavcodec/libsvtav1.c
@@ -424,8 +424,11 @@ static int eb_send_frame(AVCodecContext *avctx, const AVFrame *frame)
         if (svt_enc->eos_flag == EOS_SENT)
             return 0;
 
-        memset(&headerPtrLast, 0, sizeof(headerPtrLast));
-        headerPtrLast.pic_type      = EB_AV1_INVALID_PICTURE;
+        headerPtrLast.n_alloc_len   = 0;
+        headerPtrLast.n_filled_len  = 0;
+        headerPtrLast.n_tick_count  = 0;
+        headerPtrLast.p_app_private = NULL;
+        headerPtrLast.p_buffer      = NULL;
         headerPtrLast.flags         = EB_BUFFERFLAG_EOS;
 
         svt_av1_enc_send_picture(svt_enc->svt_handle, &headerPtrLast);
@@ -663,7 +666,8 @@ const FFCodec ff_libsvtav1_encoder = {
     FF_CODEC_RECEIVE_PACKET_CB(eb_receive_packet),
     .close          = eb_enc_close,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS | FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P,
                                                     AV_PIX_FMT_YUV420P10,
                                                     AV_PIX_FMT_NONE },
diff --git a/libavcodec/libtheoraenc.c b/libavcodec/libtheoraenc.c
index 162d170..2283555 100644
--- a/libavcodec/libtheoraenc.c
+++ b/libavcodec/libtheoraenc.c
@@ -374,6 +374,7 @@ const FFCodec ff_libtheora_encoder = {
     .p.id           = AV_CODEC_ID_THEORA,
     .p.capabilities = AV_CODEC_CAP_DR1 |
                       AV_CODEC_CAP_DELAY /* for statsfile summary */,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(TheoraContext),
     .init           = encode_init,
     .close          = encode_close,
diff --git a/libavcodec/libtwolame.c b/libavcodec/libtwolame.c
index 1e53cf2..98df38d 100644
--- a/libavcodec/libtwolame.c
+++ b/libavcodec/libtwolame.c
@@ -214,6 +214,7 @@ const FFCodec ff_libtwolame_encoder = {
     .p.long_name    = NULL_IF_CONFIG_SMALL("libtwolame MP2 (MPEG audio layer 2)"),
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_MP2,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(TWOLAMEContext),
     .init           = twolame_encode_init,
     FF_CODEC_ENCODE_CB(twolame_encode_frame),
diff --git a/libavcodec/libuavs3d.c b/libavcodec/libuavs3d.c
index 7c6c3f0..5ccd989 100644
--- a/libavcodec/libuavs3d.c
+++ b/libavcodec/libuavs3d.c
@@ -256,7 +256,8 @@ const FFCodec ff_libuavs3d_decoder = {
     .close          = libuavs3d_end,
     FF_CODEC_DECODE_CB(libuavs3d_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY | AV_CODEC_CAP_OTHER_THREADS,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .flush          = libuavs3d_flush,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_YUV420P10LE,
diff --git a/libavcodec/libvo-amrwbenc.c b/libavcodec/libvo-amrwbenc.c
index 12ef6d7..e58c980 100644
--- a/libavcodec/libvo-amrwbenc.c
+++ b/libavcodec/libvo-amrwbenc.c
@@ -148,6 +148,7 @@ const FFCodec ff_libvo_amrwbenc_encoder = {
     .p.id           = AV_CODEC_ID_AMR_WB,
     .p.priv_class   = &amrwb_class,
     .p.wrapper_name = "libvo_amrwbenc",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(AMRWBContext),
     .init           = amr_wb_encode_init,
     FF_CODEC_ENCODE_CB(amr_wb_encode_frame),
diff --git a/libavcodec/libvorbisdec.c b/libavcodec/libvorbisdec.c
index 81c4ac1..38a8314 100644
--- a/libavcodec/libvorbisdec.c
+++ b/libavcodec/libvorbisdec.c
@@ -216,6 +216,7 @@ const FFCodec ff_libvorbis_decoder = {
     .p.type         = AVMEDIA_TYPE_AUDIO,
     .p.id           = AV_CODEC_ID_VORBIS,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_CHANNEL_CONF,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(OggVorbisDecContext),
     .init           = oggvorbis_decode_init,
     FF_CODEC_DECODE_CB(oggvorbis_decode_frame),
diff --git a/libavcodec/libvorbisenc.c b/libavcodec/libvorbisenc.c
index 9460d32..3353776 100644
--- a/libavcodec/libvorbisenc.c
+++ b/libavcodec/libvorbisenc.c
@@ -382,6 +382,7 @@ const FFCodec ff_libvorbis_encoder = {
     .p.id           = AV_CODEC_ID_VORBIS,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY |
                       AV_CODEC_CAP_SMALL_LAST_FRAME,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibvorbisEncContext),
     .init           = libvorbis_encode_init,
     FF_CODEC_ENCODE_CB(libvorbis_encode_frame),
diff --git a/libavcodec/libvpxdec.c b/libavcodec/libvpxdec.c
index 0b279e7..c5b9533 100644
--- a/libavcodec/libvpxdec.c
+++ b/libavcodec/libvpxdec.c
@@ -366,7 +366,8 @@ const FFCodec ff_libvpx_vp8_decoder = {
     .init           = vp8_init,
     .close          = vpx_free,
     FF_CODEC_DECODE_CB(vpx_decode),
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
 };
 #endif /* CONFIG_LIBVPX_VP8_DECODER */
 
@@ -389,7 +390,8 @@ FFCodec ff_libvpx_vp9_decoder = {
     .init           = vp9_init,
     .close          = vpx_free,
     FF_CODEC_DECODE_CB(vpx_decode),
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .init_static_data = ff_vp9_init_static,
 };
 #endif /* CONFIG_LIBVPX_VP9_DECODER */
diff --git a/libavcodec/libvpxenc.c b/libavcodec/libvpxenc.c
index 5e5247a..5b7c773 100644
--- a/libavcodec/libvpxenc.c
+++ b/libavcodec/libvpxenc.c
@@ -56,6 +56,8 @@
 struct FrameListData {
     void *buf;                       /**< compressed data buffer */
     size_t sz;                       /**< length of compressed data */
+    void *buf_alpha;
+    size_t sz_alpha;
     int64_t pts;                     /**< time stamp to show frame
                                           (in timebase units) */
     unsigned long duration;          /**< duration to show frame
@@ -85,7 +87,6 @@ typedef struct VPxEncoderContext {
     int have_sse; /**< true if we have pending sse[] */
     uint64_t frame_number;
     struct FrameListData *coded_frame_list;
-    struct FrameListData *alpha_coded_frame_list;
 
     int cpu_used;
     int sharpness;
@@ -310,6 +311,8 @@ static void coded_frame_add(void *list, struct FrameListData *cx_frame)
 static av_cold void free_coded_frame(struct FrameListData *cx_frame)
 {
     av_freep(&cx_frame->buf);
+    if (cx_frame->buf_alpha)
+        av_freep(&cx_frame->buf_alpha);
     av_freep(&cx_frame);
 }
 
@@ -443,7 +446,6 @@ static av_cold int vpx_free(AVCodecContext *avctx)
     av_freep(&ctx->twopass_stats.buf);
     av_freep(&avctx->stats_out);
     free_frame_list(ctx->coded_frame_list);
-    free_frame_list(ctx->alpha_coded_frame_list);
     if (ctx->hdr10_plus_fifo)
         free_hdr10_plus_fifo(&ctx->hdr10_plus_fifo);
     return 0;
@@ -1203,6 +1205,7 @@ static av_cold int vpx_init(AVCodecContext *avctx,
 
 static inline void cx_pktcpy(struct FrameListData *dst,
                              const struct vpx_codec_cx_pkt *src,
+                             const struct vpx_codec_cx_pkt *src_alpha,
                              VPxContext *ctx)
 {
     dst->pts      = src->data.frame.pts;
@@ -1226,6 +1229,13 @@ static inline void cx_pktcpy(struct FrameListData *dst,
     } else {
         dst->frame_number = -1;   /* sanity marker */
     }
+    if (src_alpha) {
+        dst->buf_alpha = src_alpha->data.frame.buf;
+        dst->sz_alpha = src_alpha->data.frame.sz;
+    } else {
+        dst->buf_alpha = NULL;
+        dst->sz_alpha = 0;
+    }
 }
 
 /**
@@ -1236,7 +1246,7 @@ static inline void cx_pktcpy(struct FrameListData *dst,
  * @return a negative AVERROR on error
  */
 static int storeframe(AVCodecContext *avctx, struct FrameListData *cx_frame,
-                      struct FrameListData *alpha_cx_frame, AVPacket *pkt)
+                      AVPacket *pkt)
 {
     VPxContext *ctx = avctx->priv_data;
     int ret = ff_get_encode_buffer(avctx, pkt, cx_frame->sz, 0);
@@ -1269,16 +1279,16 @@ static int storeframe(AVCodecContext *avctx, struct FrameListData *cx_frame,
             avctx->error[i] += cx_frame->sse[i + 1];
         cx_frame->have_sse = 0;
     }
-    if (alpha_cx_frame) {
+    if (cx_frame->sz_alpha > 0) {
         side_data = av_packet_new_side_data(pkt,
                                             AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL,
-                                            alpha_cx_frame->sz + 8);
+                                            cx_frame->sz_alpha + 8);
         if (!side_data) {
             av_packet_unref(pkt);
             return AVERROR(ENOMEM);
         }
         AV_WB64(side_data, 1);
-        memcpy(side_data + 8, alpha_cx_frame->buf, alpha_cx_frame->sz);
+        memcpy(side_data + 8, cx_frame->buf_alpha, cx_frame->sz_alpha);
     }
     if (cx_frame->frame_number != -1) {
         if (ctx->hdr10_plus_fifo) {
@@ -1299,37 +1309,40 @@ static int storeframe(AVCodecContext *avctx, struct FrameListData *cx_frame,
  * @return AVERROR(EINVAL) on output size error
  * @return AVERROR(ENOMEM) on coded frame queue data allocation error
  */
-static int queue_frames(AVCodecContext *avctx, struct vpx_codec_ctx *encoder,
-                        struct FrameListData **frame_list, AVPacket *pkt_out)
+static int queue_frames(AVCodecContext *avctx, AVPacket *pkt_out)
 {
     VPxContext *ctx = avctx->priv_data;
     const struct vpx_codec_cx_pkt *pkt;
+    const struct vpx_codec_cx_pkt *pkt_alpha = NULL;
     const void *iter = NULL;
+    const void *iter_alpha = NULL;
     int size = 0;
 
-    if (!ctx->is_alpha && *frame_list) {
-        struct FrameListData *cx_frame = *frame_list;
+    if (ctx->coded_frame_list) {
+        struct FrameListData *cx_frame = ctx->coded_frame_list;
         /* return the leading frame if we've already begun queueing */
-        size = storeframe(avctx, cx_frame, NULL, pkt_out);
+        size = storeframe(avctx, cx_frame, pkt_out);
         if (size < 0)
             return size;
-        *frame_list = cx_frame->next;
+        ctx->coded_frame_list = cx_frame->next;
         free_coded_frame(cx_frame);
     }
 
     /* consume all available output from the encoder before returning. buffers
        are only good through the next vpx_codec call */
-    while (pkt = vpx_codec_get_cx_data(encoder, &iter)) {
+    while ((pkt = vpx_codec_get_cx_data(&ctx->encoder, &iter)) &&
+           (!ctx->is_alpha ||
+            (pkt_alpha = vpx_codec_get_cx_data(&ctx->encoder_alpha, &iter_alpha)))) {
         switch (pkt->kind) {
         case VPX_CODEC_CX_FRAME_PKT:
-            if (!ctx->is_alpha && !size) {
+            if (!size) {
                 struct FrameListData cx_frame;
 
                 /* avoid storing the frame when the list is empty and we haven't yet
                    provided a frame for output */
                 av_assert0(!ctx->coded_frame_list);
-                cx_pktcpy(&cx_frame, pkt, ctx);
-                size = storeframe(avctx, &cx_frame, NULL, pkt_out);
+                cx_pktcpy(&cx_frame, pkt, pkt_alpha, ctx);
+                size = storeframe(avctx, &cx_frame, pkt_out);
                 if (size < 0)
                     return size;
             } else {
@@ -1340,7 +1353,7 @@ static int queue_frames(AVCodecContext *avctx, struct vpx_codec_ctx *encoder,
                            "Frame queue element alloc failed\n");
                     return AVERROR(ENOMEM);
                 }
-                cx_pktcpy(cx_frame, pkt, ctx);
+                cx_pktcpy(cx_frame, pkt, pkt_alpha, ctx);
                 cx_frame->buf = av_malloc(cx_frame->sz);
 
                 if (!cx_frame->buf) {
@@ -1351,14 +1364,23 @@ static int queue_frames(AVCodecContext *avctx, struct vpx_codec_ctx *encoder,
                     return AVERROR(ENOMEM);
                 }
                 memcpy(cx_frame->buf, pkt->data.frame.buf, pkt->data.frame.sz);
-                coded_frame_add(frame_list, cx_frame);
+                if (ctx->is_alpha) {
+                    cx_frame->buf_alpha = av_malloc(cx_frame->sz_alpha);
+                    if (!cx_frame->buf_alpha) {
+                        av_log(avctx, AV_LOG_ERROR,
+                               "Data buffer alloc (%"SIZE_SPECIFIER" bytes) failed\n",
+                               cx_frame->sz_alpha);
+                        av_free(cx_frame);
+                        return AVERROR(ENOMEM);
+                    }
+                    memcpy(cx_frame->buf_alpha, pkt_alpha->data.frame.buf, pkt_alpha->data.frame.sz);
+                }
+                coded_frame_add(&ctx->coded_frame_list, cx_frame);
             }
             break;
         case VPX_CODEC_STATS_PKT: {
             struct vpx_fixed_buf *stats = &ctx->twopass_stats;
             int err;
-            if (!pkt_out)
-                break;
             if ((err = av_reallocp(&stats->buf,
                                    stats->sz +
                                    pkt->data.twopass_stats.sz)) < 0) {
@@ -1372,8 +1394,6 @@ static int queue_frames(AVCodecContext *avctx, struct vpx_codec_ctx *encoder,
             break;
         }
         case VPX_CODEC_PSNR_PKT:
-            if (!pkt_out)
-                break;
             av_assert0(!ctx->have_sse);
             ctx->sse[0] = pkt->data.psnr.sse[0];
             ctx->sse[1] = pkt->data.psnr.sse[1];
@@ -1768,24 +1788,7 @@ static int vpx_encode(AVCodecContext *avctx, AVPacket *pkt,
         }
     }
 
-    coded_size = queue_frames(avctx, &ctx->encoder, &ctx->coded_frame_list, pkt);
-    if (ctx->is_alpha) {
-        queue_frames(avctx, &ctx->encoder_alpha, &ctx->alpha_coded_frame_list, NULL);
-
-        if (ctx->coded_frame_list && ctx->alpha_coded_frame_list) {
-            struct FrameListData *cx_frame = ctx->coded_frame_list;
-            struct FrameListData *alpha_cx_frame = ctx->alpha_coded_frame_list;
-            av_assert0(!coded_size);
-            /* return the leading frame if we've already begun queueing */
-            coded_size = storeframe(avctx, cx_frame, alpha_cx_frame, pkt);
-            if (coded_size < 0)
-                return coded_size;
-            ctx->coded_frame_list = cx_frame->next;
-            ctx->alpha_coded_frame_list = alpha_cx_frame->next;
-            free_coded_frame(cx_frame);
-            free_coded_frame(alpha_cx_frame);
-        }
-    }
+    coded_size = queue_frames(avctx, pkt);
 
     if (!frame && avctx->flags & AV_CODEC_FLAG_PASS1) {
         unsigned int b64_size = AV_BASE64_SIZE(ctx->twopass_stats.sz);
@@ -1948,7 +1951,8 @@ const FFCodec ff_libvpx_vp8_encoder = {
     .init           = vp8_init,
     FF_CODEC_ENCODE_CB(vpx_encode),
     .close          = vpx_free,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUVA420P, AV_PIX_FMT_NONE },
     .p.priv_class   = &class_vp8,
     .defaults       = defaults,
@@ -1983,7 +1987,8 @@ FFCodec ff_libvpx_vp9_encoder = {
     .init           = vp9_init,
     FF_CODEC_ENCODE_CB(vpx_encode),
     .close          = vpx_free,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .defaults       = defaults,
     .init_static_data = ff_vp9_init_static,
 };
diff --git a/libavcodec/libwebpenc.c b/libavcodec/libwebpenc.c
index c5dc1b1..be7bfa3 100644
--- a/libavcodec/libwebpenc.c
+++ b/libavcodec/libwebpenc.c
@@ -96,6 +96,7 @@ const FFCodec ff_libwebp_encoder = {
     .p.pix_fmts     = ff_libwebpenc_pix_fmts,
     .p.priv_class   = &ff_libwebpenc_class,
     .p.wrapper_name = "libwebp",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibWebPContext),
     .defaults       = ff_libwebp_defaults,
     .init           = libwebp_encode_init,
diff --git a/libavcodec/libwebpenc_animencoder.c b/libavcodec/libwebpenc_animencoder.c
index 765fcf7..43116c6 100644
--- a/libavcodec/libwebpenc_animencoder.c
+++ b/libavcodec/libwebpenc_animencoder.c
@@ -138,6 +138,7 @@ const FFCodec ff_libwebp_anim_encoder = {
     .p.pix_fmts     = ff_libwebpenc_pix_fmts,
     .p.priv_class   = &ff_libwebpenc_class,
     .p.wrapper_name = "libwebp",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(LibWebPAnimContext),
     .defaults       = ff_libwebp_defaults,
     .init           = libwebp_anim_encode_init,
diff --git a/libavcodec/libx264.c b/libavcodec/libx264.c
index 98ec030..6afa3cd 100644
--- a/libavcodec/libx264.c
+++ b/libavcodec/libx264.c
@@ -311,6 +311,28 @@ static void free_picture(AVCodecContext *ctx)
     pic->extra_sei.num_payloads = 0;
 }
 
+static enum AVPixelFormat csp_to_pixfmt(int csp)
+{
+    switch (csp) {
+#ifdef X264_CSP_I400
+    case X264_CSP_I400:                         return AV_PIX_FMT_GRAY8;
+    case X264_CSP_I400 | X264_CSP_HIGH_DEPTH:   return AV_PIX_FMT_GRAY10;
+#endif
+    case X264_CSP_I420:                         return AV_PIX_FMT_YUV420P;
+    case X264_CSP_I420 | X264_CSP_HIGH_DEPTH:   return AV_PIX_FMT_YUV420P10;
+    case X264_CSP_I422:                         return AV_PIX_FMT_YUV422P;
+    case X264_CSP_I422 | X264_CSP_HIGH_DEPTH:   return AV_PIX_FMT_YUV422P10;
+    case X264_CSP_I444:                         return AV_PIX_FMT_YUV444P;
+    case X264_CSP_I444 | X264_CSP_HIGH_DEPTH:   return AV_PIX_FMT_YUV444P10;
+    case X264_CSP_NV12:                         return AV_PIX_FMT_NV12;
+#ifdef X264_CSP_NV21
+    case X264_CSP_NV21:                         return AV_PIX_FMT_NV21;
+#endif
+    case X264_CSP_NV16:                         return AV_PIX_FMT_NV16;
+    };
+    return AV_PIX_FMT_NONE;
+}
+
 static int X264_frame(AVCodecContext *ctx, AVPacket *pkt, const AVFrame *frame,
                       int *got_packet)
 {
@@ -496,6 +518,33 @@ static int X264_frame(AVCodecContext *ctx, AVPacket *pkt, const AVFrame *frame,
         if (x264_encoder_encode(x4->enc, &nal, &nnal, frame? &x4->pic: NULL, &pic_out) < 0)
             return AVERROR_EXTERNAL;
 
+        if (nnal && (ctx->flags & AV_CODEC_FLAG_RECON_FRAME)) {
+            AVCodecInternal *avci = ctx->internal;
+
+            av_frame_unref(avci->recon_frame);
+
+            avci->recon_frame->format = csp_to_pixfmt(pic_out.img.i_csp);
+            if (avci->recon_frame->format == AV_PIX_FMT_NONE) {
+                av_log(ctx, AV_LOG_ERROR,
+                       "Unhandled reconstructed frame colorspace: %d\n",
+                       pic_out.img.i_csp);
+                return AVERROR(ENOSYS);
+            }
+
+            avci->recon_frame->width  = ctx->width;
+            avci->recon_frame->height = ctx->height;
+            for (int i = 0; i < pic_out.img.i_plane; i++) {
+                avci->recon_frame->data[i]     = pic_out.img.plane[i];
+                avci->recon_frame->linesize[i] = pic_out.img.i_stride[i];
+            }
+
+            ret = av_frame_make_writable(avci->recon_frame);
+            if (ret < 0) {
+                av_frame_unref(avci->recon_frame);
+                return ret;
+            }
+        }
+
         ret = encode_nals(ctx, pkt, nal, nnal);
         if (ret < 0)
             return ret;
@@ -928,6 +977,9 @@ static av_cold int X264_init(AVCodecContext *avctx)
     if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER)
         x4->params.b_repeat_headers = 0;
 
+    if (avctx->flags & AV_CODEC_FLAG_RECON_FRAME)
+        x4->params.b_full_recon = 1;
+
     if(x4->x264opts){
         const char *p= x4->x264opts;
         while(p){
@@ -1223,7 +1275,8 @@ FFCodec ff_libx264_encoder = {
     .p.id             = AV_CODEC_ID_H264,
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY |
                         AV_CODEC_CAP_OTHER_THREADS |
-                        AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE,
+                        AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE |
+                        AV_CODEC_CAP_ENCODER_RECON_FRAME,
     .p.priv_class     = &x264_class,
     .p.wrapper_name   = "libx264",
     .priv_data_size   = sizeof(X264Context),
@@ -1237,8 +1290,8 @@ FFCodec ff_libx264_encoder = {
     .p.pix_fmts       = pix_fmts_all,
 #endif
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_AUTO_THREADS
-#if X264_BUILD >= 158
-                      | FF_CODEC_CAP_INIT_THREADSAFE
+#if X264_BUILD < 158
+                      | FF_CODEC_CAP_NOT_INIT_THREADSAFE
 #endif
                       ,
 };
@@ -1269,8 +1322,8 @@ const FFCodec ff_libx264rgb_encoder = {
     .close          = X264_close,
     .defaults       = x264_defaults,
     .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_AUTO_THREADS
-#if X264_BUILD >= 158
-                      | FF_CODEC_CAP_INIT_THREADSAFE
+#if X264_BUILD < 158
+                      | FF_CODEC_CAP_NOT_INIT_THREADSAFE
 #endif
                       ,
 };
@@ -1300,6 +1353,7 @@ const FFCodec ff_libx262_encoder = {
     FF_CODEC_ENCODE_CB(X264_frame),
     .close            = X264_close,
     .defaults         = x264_defaults,
-    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal    = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                        FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_AUTO_THREADS,
 };
 #endif
diff --git a/libavcodec/libx265.c b/libavcodec/libx265.c
index f68ecb3..6d2590d 100644
--- a/libavcodec/libx265.c
+++ b/libavcodec/libx265.c
@@ -757,5 +757,6 @@ FFCodec ff_libx265_encoder = {
     .close            = libx265_encode_close,
     .priv_data_size   = sizeof(libx265Context),
     .defaults         = x265_defaults,
-    .caps_internal    = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal    = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                        FF_CODEC_CAP_AUTO_THREADS,
 };
diff --git a/libavcodec/libxavs.c b/libavcodec/libxavs.c
index a3efbcb..2c75775 100644
--- a/libavcodec/libxavs.c
+++ b/libavcodec/libxavs.c
@@ -432,7 +432,8 @@ const FFCodec ff_libxavs_encoder = {
     .init           = XAVS_init,
     FF_CODEC_ENCODE_CB(XAVS_frame),
     .close          = XAVS_close,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
     .p.priv_class   = &xavs_class,
     .defaults       = xavs_defaults,
diff --git a/libavcodec/libxavs2.c b/libavcodec/libxavs2.c
index bf34b7a..d4a1bf5 100644
--- a/libavcodec/libxavs2.c
+++ b/libavcodec/libxavs2.c
@@ -297,7 +297,8 @@ const FFCodec ff_libxavs2_encoder = {
     .init           = xavs2_init,
     FF_CODEC_ENCODE_CB(xavs2_encode_frame),
     .close          = xavs2_close,
-    .caps_internal  = FF_CODEC_CAP_AUTO_THREADS,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_AUTO_THREADS,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
     .p.priv_class   = &libxavs2,
diff --git a/libavcodec/libxvid.c b/libavcodec/libxvid.c
index 4b3dd71..fb08d09 100644
--- a/libavcodec/libxvid.c
+++ b/libavcodec/libxvid.c
@@ -908,7 +908,6 @@ const FFCodec ff_libxvid_encoder = {
     .close          = xvid_encode_close,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
     .p.priv_class   = &xvid_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name = "libxvid",
 };
diff --git a/libavcodec/libzvbi-teletextdec.c b/libavcodec/libzvbi-teletextdec.c
index 514e76f..c88ede0 100644
--- a/libavcodec/libzvbi-teletextdec.c
+++ b/libavcodec/libzvbi-teletextdec.c
@@ -819,6 +819,7 @@ const FFCodec ff_libzvbi_teletext_decoder = {
     .p.capabilities = AV_CODEC_CAP_DELAY,
     .p.priv_class   = &teletext_class,
     .p.wrapper_name = "libzvbi",
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
     .priv_data_size = sizeof(TeletextContext),
     .init      = teletext_init_decoder,
     .close     = teletext_close_decoder,
diff --git a/libavcodec/ljpegenc.c b/libavcodec/ljpegenc.c
index fc7a462..26f42a2 100644
--- a/libavcodec/ljpegenc.c
+++ b/libavcodec/ljpegenc.c
@@ -78,7 +78,7 @@ static int ljpeg_encode_bgr(AVCodecContext *avctx, PutBitContext *pb,
 
     for (y = 0; y < height; y++) {
         const int modified_predictor = y ? s->pred : 1;
-        uint8_t *ptr = frame->data[0] + (linesize * y);
+        const uint8_t *ptr = frame->data[0] + (linesize * y);
 
         if (put_bytes_left(pb, 0) < width * 4 * 4) {
             av_log(avctx, AV_LOG_ERROR, "encoded frame too large\n");
@@ -132,7 +132,7 @@ static inline void ljpeg_encode_yuv_mb(LJpegEncContext *s, PutBitContext *pb,
 
     if (mb_x == 0 || mb_y == 0) {
         for (i = 0; i < 3; i++) {
-            uint8_t *ptr;
+            const uint8_t *ptr;
             int x, y, h, v, linesize;
             h = s->hsample[i];
             v = s->vsample[i];
@@ -166,7 +166,7 @@ static inline void ljpeg_encode_yuv_mb(LJpegEncContext *s, PutBitContext *pb,
         }
     } else {
         for (i = 0; i < 3; i++) {
-            uint8_t *ptr;
+            const uint8_t *ptr;
             int x, y, h, v, linesize;
             h = s->hsample[i];
             v = s->vsample[i];
@@ -339,5 +339,4 @@ const FFCodec ff_ljpeg_encoder = {
         AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ444P, AV_PIX_FMT_YUVJ422P,
         AV_PIX_FMT_YUV420P , AV_PIX_FMT_YUV444P , AV_PIX_FMT_YUV422P,
         AV_PIX_FMT_NONE},
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/loco.c b/libavcodec/loco.c
index 9cadc9d..4a37cd6 100644
--- a/libavcodec/loco.c
+++ b/libavcodec/loco.c
@@ -345,5 +345,4 @@ const FFCodec ff_loco_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/loongarch/h264chroma_lasx.c b/libavcodec/loongarch/h264chroma_lasx.c
index 824a78d..5e61199 100644
--- a/libavcodec/loongarch/h264chroma_lasx.c
+++ b/libavcodec/loongarch/h264chroma_lasx.c
@@ -33,7 +33,7 @@ static const uint8_t chroma_mask_arr[64] = {
     0, 1, 1, 2, 2, 3, 3, 4, 16, 17, 17, 18, 18, 19, 19, 20
 };
 
-static av_always_inline void avc_chroma_hv_8x4_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avc_chroma_hv_8x4_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride, uint32_t coef_hor0,
                              uint32_t coef_hor1, uint32_t coef_ver0,
                              uint32_t coef_ver1)
@@ -51,7 +51,7 @@ static av_always_inline void avc_chroma_hv_8x4_lasx(uint8_t *src, uint8_t *dst,
     __m256i coeff_vt_vec1 = __lasx_xvreplgr2vr_h(coef_ver1);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 0, src, 0, mask, src0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
               src1, src2, src3, src4);
     DUP2_ARG3(__lasx_xvpermi_q, src2, src1, 0x20, src4, src3, 0x20, src1, src3);
     src0 = __lasx_xvshuf_b(src0, src0, mask);
@@ -71,7 +71,7 @@ static av_always_inline void avc_chroma_hv_8x4_lasx(uint8_t *src, uint8_t *dst,
     __lasx_xvstelm_d(out, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_hv_8x8_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avc_chroma_hv_8x8_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride, uint32_t coef_hor0,
                              uint32_t coef_hor1, uint32_t coef_ver0,
                              uint32_t coef_ver1)
@@ -91,10 +91,10 @@ static av_always_inline void avc_chroma_hv_8x8_lasx(uint8_t *src, uint8_t *dst,
     __m256i coeff_vt_vec1 = __lasx_xvreplgr2vr_h(coef_ver1);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 0, src, 0, mask, src0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
               src1, src2, src3, src4);
     src += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
               src5, src6, src7, src8);
     DUP4_ARG3(__lasx_xvpermi_q, src2, src1, 0x20, src4, src3, 0x20, src6, src5, 0x20,
               src8, src7, 0x20, src1, src3, src5, src7);
@@ -127,7 +127,7 @@ static av_always_inline void avc_chroma_hv_8x8_lasx(uint8_t *src, uint8_t *dst,
     __lasx_xvstelm_d(out1, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_hz_8x4_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avc_chroma_hz_8x4_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride, uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2x = stride << 1;
@@ -141,8 +141,8 @@ static av_always_inline void avc_chroma_hz_8x4_lasx(uint8_t *src, uint8_t *dst,
 
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 0, src, 0, mask, src0);
-    DUP2_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src1, src2);
-    src3 = __lasx_xvldx(src, stride_3x);
+    DUP2_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src1, src2);
+    src3 = LASX_XVLDX(src, stride_3x);
     DUP2_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src3, src2, 0x20, src0, src2);
     DUP2_ARG3(__lasx_xvshuf_b, src0, src0, mask, src2, src2, mask, src0, src2);
     DUP2_ARG2(__lasx_xvdp2_h_bu, src0, coeff_vec, src2, coeff_vec, res0, res1);
@@ -154,7 +154,7 @@ static av_always_inline void avc_chroma_hz_8x4_lasx(uint8_t *src, uint8_t *dst,
 
 }
 
-static av_always_inline void avc_chroma_hz_8x8_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avc_chroma_hz_8x8_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride, uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2x = stride << 1;
@@ -170,11 +170,11 @@ static av_always_inline void avc_chroma_hz_8x8_lasx(uint8_t *src, uint8_t *dst,
 
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 0, src, 0, mask, src0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
               src1, src2, src3, src4);
     src += stride_4x;
-    DUP2_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src5, src6);
-    src7 = __lasx_xvldx(src, stride_3x);
+    DUP2_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src5, src6);
+    src7 = LASX_XVLDX(src, stride_3x);
     DUP4_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src3, src2, 0x20, src5, src4, 0x20,
               src7, src6, 0x20, src0, src2, src4, src6);
     DUP4_ARG3(__lasx_xvshuf_b, src0, src0, mask, src2, src2, mask, src4, src4, mask,
@@ -193,7 +193,7 @@ static av_always_inline void avc_chroma_hz_8x8_lasx(uint8_t *src, uint8_t *dst,
     __lasx_xvstelm_d(out1, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_hz_nonmult_lasx(uint8_t *src,
+static av_always_inline void avc_chroma_hz_nonmult_lasx(const uint8_t *src,
                              uint8_t *dst, ptrdiff_t stride, uint32_t coeff0,
                              uint32_t coeff1, int32_t height)
 {
@@ -212,7 +212,7 @@ static av_always_inline void avc_chroma_hz_nonmult_lasx(uint8_t *src,
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
 
     for (row = height >> 2; row--;) {
-        DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+        DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
                   src0, src1, src2, src3);
         src += stride_4x;
         DUP2_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src3, src2, 0x20, src0, src2);
@@ -228,7 +228,7 @@ static av_always_inline void avc_chroma_hz_nonmult_lasx(uint8_t *src,
 
     if ((height & 3)) {
         src0 = __lasx_xvld(src, 0);
-        src1 = __lasx_xvldx(src, stride);
+        src1 = LASX_XVLDX(src, stride);
         src1 = __lasx_xvpermi_q(src1, src0, 0x20);
         src0 = __lasx_xvshuf_b(src1, src1, mask);
         res0 = __lasx_xvdp2_h_bu(src0, coeff_vec);
@@ -239,7 +239,7 @@ static av_always_inline void avc_chroma_hz_nonmult_lasx(uint8_t *src,
     }
 }
 
-static av_always_inline void avc_chroma_vt_8x4_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avc_chroma_vt_8x4_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride, uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2x = stride << 1;
@@ -253,7 +253,7 @@ static av_always_inline void avc_chroma_vt_8x4_lasx(uint8_t *src, uint8_t *dst,
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     src0 = __lasx_xvld(src, 0);
     src += stride;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src1, src2, src3, src4);
     DUP4_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src2, src1, 0x20, src3, src2, 0x20,
               src4, src3, 0x20, src0, src1, src2, src3);
@@ -266,7 +266,7 @@ static av_always_inline void avc_chroma_vt_8x4_lasx(uint8_t *src, uint8_t *dst,
     __lasx_xvstelm_d(out, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_vt_8x8_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avc_chroma_vt_8x8_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride, uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2x = stride << 1;
@@ -282,10 +282,10 @@ static av_always_inline void avc_chroma_vt_8x8_lasx(uint8_t *src, uint8_t *dst,
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     src0 = __lasx_xvld(src, 0);
     src += stride;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src1, src2, src3, src4);
     src += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src5, src6, src7, src8);
     DUP4_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src2, src1, 0x20, src3, src2, 0x20,
               src4, src3, 0x20, src0, src1, src2, src3);
@@ -307,7 +307,7 @@ static av_always_inline void avc_chroma_vt_8x8_lasx(uint8_t *src, uint8_t *dst,
     __lasx_xvstelm_d(out1, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void copy_width8x8_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void copy_width8x8_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride)
 {
     uint64_t tmp[8];
@@ -347,7 +347,7 @@ static av_always_inline void copy_width8x8_lasx(uint8_t *src, uint8_t *dst,
     );
 }
 
-static av_always_inline void copy_width8x4_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void copy_width8x4_lasx(const uint8_t *src, uint8_t *dst,
                              ptrdiff_t stride)
 {
     uint64_t tmp[4];
@@ -372,7 +372,7 @@ static av_always_inline void copy_width8x4_lasx(uint8_t *src, uint8_t *dst,
     );
 }
 
-static void avc_chroma_hv_8w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hv_8w_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1,
                                   int32_t height)
@@ -386,7 +386,7 @@ static void avc_chroma_hv_8w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-static void avc_chroma_hv_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hv_4x2_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coef_hor0, uint32_t coef_hor1,
                                    uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -402,7 +402,7 @@ static void avc_chroma_hv_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __m256i coeff_vt_vec  = __lasx_xvpermi_q(coeff_vt_vec1, coeff_vt_vec0, 0x02);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 32, src, 0, mask, src0);
-    DUP2_ARG2(__lasx_xvldx, src, stride, src, stride_2, src1, src2);
+    DUP2_ARG2(LASX_XVLDX, src, stride, src, stride_2, src1, src2);
     DUP2_ARG3(__lasx_xvshuf_b, src1, src0, mask, src2, src1, mask, src0, src1);
     src0 = __lasx_xvpermi_q(src0, src1, 0x02);
     res_hz = __lasx_xvdp2_h_bu(src0, coeff_hz_vec);
@@ -414,7 +414,7 @@ static void avc_chroma_hv_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res_vt, dst + stride, 0, 1);
 }
 
-static void avc_chroma_hv_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hv_4x4_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coef_hor0, uint32_t coef_hor1,
                                    uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -431,7 +431,7 @@ static void avc_chroma_hv_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __m256i coeff_vt_vec1 = __lasx_xvreplgr2vr_h(coef_ver1);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 32, src, 0, mask, src0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2, src, stride_3,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2, src, stride_3,
               src, stride_4, src1, src2, src3, src4);
     DUP4_ARG3(__lasx_xvshuf_b, src1, src0, mask, src2, src1, mask, src3, src2, mask,
               src4, src3, mask, src0, src1, src2, src3);
@@ -446,7 +446,7 @@ static void avc_chroma_hv_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res_hz0, dst + stride_3, 0, 5);
 }
 
-static void avc_chroma_hv_4x8_lasx(uint8_t *src, uint8_t * dst, ptrdiff_t stride,
+static void avc_chroma_hv_4x8_lasx(const uint8_t *src, uint8_t * dst, ptrdiff_t stride,
                                    uint32_t coef_hor0, uint32_t coef_hor1,
                                    uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -464,10 +464,10 @@ static void avc_chroma_hv_4x8_lasx(uint8_t *src, uint8_t * dst, ptrdiff_t stride
     __m256i coeff_vt_vec1 = __lasx_xvreplgr2vr_h(coef_ver1);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 32, src, 0, mask, src0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2, src, stride_3,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2, src, stride_3,
               src, stride_4, src1, src2, src3, src4);
     src += stride_4;
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2, src, stride_3,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2, src, stride_3,
               src, stride_4, src5, src6, src7, src8);
     DUP4_ARG3(__lasx_xvshuf_b, src1, src0, mask, src2, src1, mask, src3, src2, mask,
               src4, src3, mask, src0, src1, src2, src3);
@@ -492,7 +492,7 @@ static void avc_chroma_hv_4x8_lasx(uint8_t *src, uint8_t * dst, ptrdiff_t stride
     __lasx_xvstelm_w(res_hz0, dst + stride_3, 0, 7);
 }
 
-static void avc_chroma_hv_4w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hv_4w_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1,
                                   int32_t height)
@@ -509,7 +509,7 @@ static void avc_chroma_hv_4w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-static void avc_chroma_hz_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hz_4x2_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coeff0, uint32_t coeff1)
 {
     __m256i src0, src1;
@@ -519,7 +519,7 @@ static void avc_chroma_hz_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __m256i coeff_vec  = __lasx_xvilvl_b(coeff_vec0, coeff_vec1);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 32, src, 0, mask, src0);
-    src1 = __lasx_xvldx(src, stride);
+    src1 = LASX_XVLDX(src, stride);
     src0 = __lasx_xvshuf_b(src1, src0, mask);
     res = __lasx_xvdp2_h_bu(src0, coeff_vec);
     res = __lasx_xvslli_h(res, 3);
@@ -528,7 +528,7 @@ static void avc_chroma_hz_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res, dst + stride, 0, 1);
 }
 
-static void avc_chroma_hz_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hz_4x4_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2 = stride << 1;
@@ -540,8 +540,8 @@ static void avc_chroma_hz_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __m256i coeff_vec  = __lasx_xvilvl_b(coeff_vec0, coeff_vec1);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 32, src, 0, mask, src0);
-    DUP2_ARG2(__lasx_xvldx, src, stride, src, stride_2, src1, src2);
-    src3 = __lasx_xvldx(src, stride_3);
+    DUP2_ARG2(LASX_XVLDX, src, stride, src, stride_2, src1, src2);
+    src3 = LASX_XVLDX(src, stride_3);
     DUP2_ARG3(__lasx_xvshuf_b, src1, src0, mask, src3, src2, mask, src0, src2);
     src0 = __lasx_xvpermi_q(src0, src2, 0x02);
     res = __lasx_xvdp2_h_bu(src0, coeff_vec);
@@ -553,7 +553,7 @@ static void avc_chroma_hz_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res, dst + stride_3, 0, 5);
 }
 
-static void avc_chroma_hz_4x8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hz_4x8_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2 = stride << 1;
@@ -567,11 +567,11 @@ static void avc_chroma_hz_4x8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
 
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 32, src, 0, mask, src0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2, src, stride_3,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2, src, stride_3,
               src, stride_4, src1, src2, src3, src4);
     src += stride_4;
-    DUP2_ARG2(__lasx_xvldx, src, stride, src, stride_2, src5, src6);
-    src7 = __lasx_xvldx(src, stride_3);
+    DUP2_ARG2(LASX_XVLDX, src, stride, src, stride_2, src5, src6);
+    src7 = LASX_XVLDX(src, stride_3);
     DUP4_ARG3(__lasx_xvshuf_b, src1, src0, mask, src3, src2, mask, src5, src4, mask,
               src7, src6, mask, src0, src2, src4, src6);
     DUP2_ARG3(__lasx_xvpermi_q, src0, src2, 0x02, src4, src6, 0x02, src0, src4);
@@ -588,7 +588,7 @@ static void avc_chroma_hz_4x8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res0, dst + stride_3, 0, 7);
 }
 
-static void avc_chroma_hz_4w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hz_4w_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                   uint32_t coeff0, uint32_t coeff1,
                                   int32_t height)
 {
@@ -601,7 +601,7 @@ static void avc_chroma_hz_4w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-static void avc_chroma_hz_8w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_hz_8w_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                   uint32_t coeff0, uint32_t coeff1,
                                   int32_t height)
 {
@@ -614,7 +614,7 @@ static void avc_chroma_hz_8w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-static void avc_chroma_vt_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_vt_4x2_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coeff0, uint32_t coeff1)
 {
     __m256i src0, src1, src2;
@@ -625,7 +625,7 @@ static void avc_chroma_vt_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __m256i coeff_vec  = __lasx_xvilvl_b(coeff_vec0, coeff_vec1);
 
     src0 = __lasx_xvld(src, 0);
-    DUP2_ARG2(__lasx_xvldx, src, stride, src, stride << 1, src1, src2);
+    DUP2_ARG2(LASX_XVLDX, src, stride, src, stride << 1, src1, src2);
     DUP2_ARG2(__lasx_xvilvl_b, src1, src0, src2, src1, tmp0, tmp1);
     tmp0 = __lasx_xvilvl_d(tmp1, tmp0);
     res  = __lasx_xvdp2_h_bu(tmp0, coeff_vec);
@@ -635,7 +635,7 @@ static void avc_chroma_vt_4x2_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res, dst + stride, 0, 1);
 }
 
-static void avc_chroma_vt_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_vt_4x4_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2 = stride << 1;
@@ -649,7 +649,7 @@ static void avc_chroma_vt_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __m256i coeff_vec  = __lasx_xvilvl_b(coeff_vec0, coeff_vec1);
 
     src0 = __lasx_xvld(src, 0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2, src, stride_3,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2, src, stride_3,
               src, stride_4, src1, src2, src3, src4);
     DUP4_ARG2(__lasx_xvilvl_b, src1, src0, src2, src1, src3, src2, src4, src3,
               tmp0, tmp1, tmp2, tmp3);
@@ -664,7 +664,7 @@ static void avc_chroma_vt_4x4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res, dst + stride_3, 0, 5);
 }
 
-static void avc_chroma_vt_4x8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_vt_4x8_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                    uint32_t coeff0, uint32_t coeff1)
 {
     ptrdiff_t stride_2 = stride << 1;
@@ -679,10 +679,10 @@ static void avc_chroma_vt_4x8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
 
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     src0 = __lasx_xvld(src, 0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2, src, stride_3,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2, src, stride_3,
               src, stride_4, src1, src2, src3, src4);
     src += stride_4;
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2, src, stride_3,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2, src, stride_3,
               src, stride_4, src5, src6, src7, src8);
     DUP4_ARG2(__lasx_xvilvl_b, src1, src0, src2, src1, src3, src2, src4, src3,
               tmp0, tmp1, tmp2, tmp3);
@@ -705,7 +705,7 @@ static void avc_chroma_vt_4x8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     __lasx_xvstelm_w(res0, dst + stride_3, 0, 7);
 }
 
-static void avc_chroma_vt_4w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_vt_4w_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                   uint32_t coeff0, uint32_t coeff1,
                                   int32_t height)
 {
@@ -718,7 +718,7 @@ static void avc_chroma_vt_4w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-static void avc_chroma_vt_8w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avc_chroma_vt_8w_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                                   uint32_t coeff0, uint32_t coeff1,
                                   int32_t height)
 {
@@ -729,7 +729,7 @@ static void avc_chroma_vt_8w_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-static void copy_width4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void copy_width4_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                              int32_t height)
 {
     uint32_t tp0, tp1, tp2, tp3, tp4, tp5, tp6, tp7;
@@ -799,7 +799,7 @@ static void copy_width4_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-static void copy_width8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void copy_width8_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                              int32_t height)
 {
     if (8 == height) {
@@ -809,7 +809,7 @@ static void copy_width8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-void ff_put_h264_chroma_mc4_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_lasx(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int height, int x, int y)
 {
     av_assert2(x < 8 && y < 8 && x >= 0 && y >= 0);
@@ -825,7 +825,7 @@ void ff_put_h264_chroma_mc4_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
     }
 }
 
-void ff_put_h264_chroma_mc8_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_lasx(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int height, int x, int y)
 {
     av_assert2(x < 8 && y < 8 && x >= 0 && y >= 0);
@@ -841,7 +841,7 @@ void ff_put_h264_chroma_mc8_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
     }
 }
 
-static av_always_inline void avc_chroma_hv_and_aver_dst_8x4_lasx(uint8_t *src,
+static av_always_inline void avc_chroma_hv_and_aver_dst_8x4_lasx(const uint8_t *src,
                              uint8_t *dst, ptrdiff_t stride, uint32_t coef_hor0,
                              uint32_t coef_hor1, uint32_t coef_ver0,
                              uint32_t coef_ver1)
@@ -860,7 +860,7 @@ static av_always_inline void avc_chroma_hv_and_aver_dst_8x4_lasx(uint8_t *src,
     __m256i coeff_vt_vec1 = __lasx_xvreplgr2vr_h(coef_ver1);
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 0, src, 0, mask, src0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
               src1, src2, src3, src4);
     DUP2_ARG3(__lasx_xvpermi_q, src2, src1, 0x20, src4, src3, 0x20, src1, src3);
     src0 = __lasx_xvshuf_b(src0, src0, mask);
@@ -874,7 +874,7 @@ static av_always_inline void avc_chroma_hv_and_aver_dst_8x4_lasx(uint8_t *src,
     res_vt0 = __lasx_xvmadd_h(res_vt0, res_hz0, coeff_vt_vec1);
     res_vt1 = __lasx_xvmadd_h(res_vt1, res_hz1, coeff_vt_vec1);
     out = __lasx_xvssrarni_bu_h(res_vt1, res_vt0, 6);
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
     tp0 = __lasx_xvpermi_q(tp2, tp0, 0x20);
@@ -885,7 +885,7 @@ static av_always_inline void avc_chroma_hv_and_aver_dst_8x4_lasx(uint8_t *src,
     __lasx_xvstelm_d(out, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_hv_and_aver_dst_8x8_lasx(uint8_t *src,
+static av_always_inline void avc_chroma_hv_and_aver_dst_8x8_lasx(const uint8_t *src,
                              uint8_t *dst, ptrdiff_t stride, uint32_t coef_hor0,
                              uint32_t coef_hor1, uint32_t coef_ver0,
                              uint32_t coef_ver1)
@@ -907,10 +907,10 @@ static av_always_inline void avc_chroma_hv_and_aver_dst_8x8_lasx(uint8_t *src,
 
     DUP2_ARG2(__lasx_xvld, chroma_mask_arr, 0, src, 0, mask, src0);
     src += stride;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src1, src2, src3, src4);
     src += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src5, src6, src7, src8);
     DUP4_ARG3(__lasx_xvpermi_q, src2, src1, 0x20, src4, src3, 0x20, src6, src5, 0x20,
               src8, src7, 0x20, src1, src3, src5, src7);
@@ -934,12 +934,12 @@ static av_always_inline void avc_chroma_hv_and_aver_dst_8x8_lasx(uint8_t *src,
     res_vt3 = __lasx_xvmadd_h(res_vt3, res_hz3, coeff_vt_vec1);
     DUP2_ARG3(__lasx_xvssrarni_bu_h, res_vt1, res_vt0, 6, res_vt3, res_vt2, 6,
               out0, out1);
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
     dst0 = __lasx_xvpermi_q(tp2, tp0, 0x20);
     dst += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     dst -= stride_4x;
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
@@ -957,7 +957,7 @@ static av_always_inline void avc_chroma_hv_and_aver_dst_8x8_lasx(uint8_t *src,
     __lasx_xvstelm_d(out1, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_hz_and_aver_dst_8x4_lasx(uint8_t *src,
+static av_always_inline void avc_chroma_hz_and_aver_dst_8x4_lasx(const uint8_t *src,
                              uint8_t *dst, ptrdiff_t stride, uint32_t coeff0,
                              uint32_t coeff1)
 {
@@ -973,13 +973,13 @@ static av_always_inline void avc_chroma_hz_and_aver_dst_8x4_lasx(uint8_t *src,
 
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     mask = __lasx_xvld(chroma_mask_arr, 0);
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src0, src1, src2, src3);
     DUP2_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src3, src2, 0x20, src0, src2);
     DUP2_ARG3(__lasx_xvshuf_b, src0, src0, mask, src2, src2, mask, src0, src2);
     DUP2_ARG2(__lasx_xvdp2_h_bu, src0, coeff_vec, src2, coeff_vec, res0, res1);
     out = __lasx_xvssrarni_bu_h(res1, res0, 6);
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
     tp0 = __lasx_xvpermi_q(tp2, tp0, 0x20);
@@ -990,7 +990,7 @@ static av_always_inline void avc_chroma_hz_and_aver_dst_8x4_lasx(uint8_t *src,
     __lasx_xvstelm_d(out, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_hz_and_aver_dst_8x8_lasx(uint8_t *src,
+static av_always_inline void avc_chroma_hz_and_aver_dst_8x8_lasx(const uint8_t *src,
                              uint8_t *dst, ptrdiff_t stride, uint32_t coeff0,
                              uint32_t coeff1)
 {
@@ -1008,10 +1008,10 @@ static av_always_inline void avc_chroma_hz_and_aver_dst_8x8_lasx(uint8_t *src,
 
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     mask = __lasx_xvld(chroma_mask_arr, 0);
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src0, src1, src2, src3);
     src += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src4, src5, src6, src7);
     DUP4_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src3, src2, 0x20, src5, src4, 0x20,
               src7, src6, 0x20, src0, src2, src4, src6);
@@ -1020,12 +1020,12 @@ static av_always_inline void avc_chroma_hz_and_aver_dst_8x8_lasx(uint8_t *src,
     DUP4_ARG2(__lasx_xvdp2_h_bu, src0, coeff_vec, src2, coeff_vec, src4, coeff_vec, src6,
               coeff_vec, res0, res1, res2, res3);
     DUP2_ARG3(__lasx_xvssrarni_bu_h, res1, res0, 6, res3, res2, 6, out0, out1);
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
     dst0 = __lasx_xvpermi_q(tp2, tp0, 0x20);
     dst += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     dst -= stride_4x;
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
@@ -1043,7 +1043,7 @@ static av_always_inline void avc_chroma_hz_and_aver_dst_8x8_lasx(uint8_t *src,
     __lasx_xvstelm_d(out1, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_vt_and_aver_dst_8x4_lasx(uint8_t *src,
+static av_always_inline void avc_chroma_vt_and_aver_dst_8x4_lasx(const uint8_t *src,
                              uint8_t *dst, ptrdiff_t stride, uint32_t coeff0,
                              uint32_t coeff1)
 {
@@ -1059,14 +1059,14 @@ static av_always_inline void avc_chroma_vt_and_aver_dst_8x4_lasx(uint8_t *src,
 
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     src0 = __lasx_xvld(src, 0);
-    DUP4_ARG2(__lasx_xvldx, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
+    DUP4_ARG2(LASX_XVLDX, src, stride, src, stride_2x, src, stride_3x, src, stride_4x,
               src1, src2, src3, src4);
     DUP4_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src2, src1, 0x20, src3, src2, 0x20,
               src4, src3, 0x20, src0, src1, src2, src3);
     DUP2_ARG2(__lasx_xvilvl_b, src1, src0, src3, src2, src0, src2);
     DUP2_ARG2(__lasx_xvdp2_h_bu, src0, coeff_vec, src2, coeff_vec, res0, res1);
     out = __lasx_xvssrarni_bu_h(res1, res0, 6);
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
     tp0 = __lasx_xvpermi_q(tp2, tp0, 0x20);
@@ -1077,7 +1077,7 @@ static av_always_inline void avc_chroma_vt_and_aver_dst_8x4_lasx(uint8_t *src,
     __lasx_xvstelm_d(out, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avc_chroma_vt_and_aver_dst_8x8_lasx(uint8_t *src,
+static av_always_inline void avc_chroma_vt_and_aver_dst_8x8_lasx(const uint8_t *src,
                              uint8_t *dst, ptrdiff_t stride, uint32_t coeff0,
                              uint32_t coeff1)
 {
@@ -1095,10 +1095,10 @@ static av_always_inline void avc_chroma_vt_and_aver_dst_8x8_lasx(uint8_t *src,
     coeff_vec = __lasx_xvslli_b(coeff_vec, 3);
     src0 = __lasx_xvld(src, 0);
     src += stride;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src1, src2, src3, src4);
     src += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, src, 0, src, stride, src, stride_2x, src, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, src, 0, src, stride, src, stride_2x, src, stride_3x,
               src5, src6, src7, src8);
     DUP4_ARG3(__lasx_xvpermi_q, src1, src0, 0x20, src2, src1, 0x20, src3, src2, 0x20,
               src4, src3, 0x20, src0, src1, src2, src3);
@@ -1109,12 +1109,12 @@ static av_always_inline void avc_chroma_vt_and_aver_dst_8x8_lasx(uint8_t *src,
     DUP4_ARG2(__lasx_xvdp2_h_bu, src0, coeff_vec, src2, coeff_vec, src4, coeff_vec, src6,
               coeff_vec, res0, res1, res2, res3);
     DUP2_ARG3(__lasx_xvssrarni_bu_h, res1, res0, 6, res3, res2, 6, out0, out1);
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
     dst0 = __lasx_xvpermi_q(tp2, tp0, 0x20);
     dst += stride_4x;
-    DUP4_ARG2(__lasx_xvldx, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
+    DUP4_ARG2(LASX_XVLDX, dst, 0, dst, stride, dst, stride_2x, dst, stride_3x,
               tp0, tp1, tp2, tp3);
     dst -= stride_4x;
     DUP2_ARG2(__lasx_xvilvl_d, tp2, tp0, tp3, tp1, tp0, tp2);
@@ -1132,7 +1132,7 @@ static av_always_inline void avc_chroma_vt_and_aver_dst_8x8_lasx(uint8_t *src,
     __lasx_xvstelm_d(out1, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avg_width8x8_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avg_width8x8_lasx(const uint8_t *src, uint8_t *dst,
                                                ptrdiff_t stride)
 {
     __m256i src0, src1, src2, src3;
@@ -1184,7 +1184,7 @@ static av_always_inline void avg_width8x8_lasx(uint8_t *src, uint8_t *dst,
     __lasx_xvstelm_d(dst0, dst + stride_3x, 0, 3);
 }
 
-static av_always_inline void avg_width8x4_lasx(uint8_t *src, uint8_t *dst,
+static av_always_inline void avg_width8x4_lasx(const uint8_t *src, uint8_t *dst,
                                                ptrdiff_t stride)
 {
     __m256i src0, src1, src2, src3;
@@ -1213,7 +1213,7 @@ static av_always_inline void avg_width8x4_lasx(uint8_t *src, uint8_t *dst,
     __lasx_xvstelm_d(dst0, dst + stride_3x, 0, 3);
 }
 
-static void avc_chroma_hv_and_aver_dst_8w_lasx(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_8w_lasx(const uint8_t *src, uint8_t *dst,
                                                ptrdiff_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1230,7 +1230,7 @@ static void avc_chroma_hv_and_aver_dst_8w_lasx(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_hz_and_aver_dst_8w_lasx(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_8w_lasx(const uint8_t *src, uint8_t *dst,
                                                ptrdiff_t stride, uint32_t coeff0,
                                                uint32_t coeff1, int32_t height)
 {
@@ -1241,7 +1241,7 @@ static void avc_chroma_hz_and_aver_dst_8w_lasx(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_vt_and_aver_dst_8w_lasx(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_8w_lasx(const uint8_t *src, uint8_t *dst,
                                                ptrdiff_t stride, uint32_t coeff0,
                                                uint32_t coeff1, int32_t height)
 {
@@ -1252,7 +1252,7 @@ static void avc_chroma_vt_and_aver_dst_8w_lasx(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avg_width8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
+static void avg_width8_lasx(const uint8_t *src, uint8_t *dst, ptrdiff_t stride,
                             int32_t height)
 {
     if (8 == height) {
@@ -1262,7 +1262,7 @@ static void avg_width8_lasx(uint8_t *src, uint8_t *dst, ptrdiff_t stride,
     }
 }
 
-void ff_avg_h264_chroma_mc8_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_lasx(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                  int height, int x, int y)
 {
     av_assert2(x < 8 && y < 8 && x >= 0 && y >= 0);
diff --git a/libavcodec/loongarch/h264chroma_lasx.h b/libavcodec/loongarch/h264chroma_lasx.h
index 4aac8db..6337520 100644
--- a/libavcodec/loongarch/h264chroma_lasx.h
+++ b/libavcodec/loongarch/h264chroma_lasx.h
@@ -26,11 +26,11 @@
 #include <stddef.h>
 #include "libavcodec/h264.h"
 
-void ff_put_h264_chroma_mc4_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_lasx(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y);
-void ff_put_h264_chroma_mc8_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_lasx(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y);
-void ff_avg_h264_chroma_mc8_lasx(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_lasx(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y);
 
 #endif /* AVCODEC_LOONGARCH_H264CHROMA_LASX_H */
diff --git a/libavcodec/loongarch/hevc_lpf_sao_lsx.c b/libavcodec/loongarch/hevc_lpf_sao_lsx.c
index fc10e8e..1944336 100644
--- a/libavcodec/loongarch/hevc_lpf_sao_lsx.c
+++ b/libavcodec/loongarch/hevc_lpf_sao_lsx.c
@@ -24,8 +24,8 @@
 #include "hevcdsp_lsx.h"
 
 void ff_hevc_loop_filter_luma_h_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *p_is_pcm, uint8_t *q_is_pcm)
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *p_is_pcm, const uint8_t *q_is_pcm)
 {
     ptrdiff_t stride_2x = (stride << 1);
     ptrdiff_t stride_4x = (stride << 2);
@@ -436,8 +436,8 @@ void ff_hevc_loop_filter_luma_h_8_lsx(uint8_t *src, ptrdiff_t stride,
 }
 
 void ff_hevc_loop_filter_luma_v_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *p_is_pcm, uint8_t *q_is_pcm)
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *p_is_pcm, const uint8_t *q_is_pcm)
 {
     ptrdiff_t stride_2x = (stride << 1);
     ptrdiff_t stride_4x = (stride << 2);
@@ -861,8 +861,8 @@ void ff_hevc_loop_filter_luma_v_8_lsx(uint8_t *src, ptrdiff_t stride,
 }
 
 void ff_hevc_loop_filter_chroma_h_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                        int32_t *tc, uint8_t *p_is_pcm,
-                                        uint8_t *q_is_pcm)
+                                        const int32_t *tc, const uint8_t *p_is_pcm,
+                                        const uint8_t *q_is_pcm)
 {
     uint8_t *p1_ptr = src - (stride << 1);
     uint8_t *p0_ptr = src - stride;
@@ -915,8 +915,8 @@ void ff_hevc_loop_filter_chroma_h_8_lsx(uint8_t *src, ptrdiff_t stride,
 }
 
 void ff_hevc_loop_filter_chroma_v_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                        int32_t *tc, uint8_t *p_is_pcm,
-                                        uint8_t *q_is_pcm)
+                                        const int32_t *tc, const uint8_t *p_is_pcm,
+                                        const uint8_t *q_is_pcm)
 {
     ptrdiff_t stride_2x = (stride << 1);
     ptrdiff_t stride_4x = (stride << 2);
@@ -987,9 +987,9 @@ void ff_hevc_loop_filter_chroma_v_8_lsx(uint8_t *src, ptrdiff_t stride,
 
 static void hevc_sao_edge_filter_0degree_4width_lsx(uint8_t *dst,
                                                     int32_t dst_stride,
-                                                    uint8_t *src,
+                                                    const uint8_t *src,
                                                     int32_t src_stride,
-                                                    int16_t *sao_offset_val,
+                                                    const int16_t *sao_offset_val,
                                                     int32_t height)
 {
     const int32_t src_stride_2x = (src_stride << 1);
@@ -1072,9 +1072,9 @@ static void hevc_sao_edge_filter_0degree_4width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_0degree_8width_lsx(uint8_t *dst,
                                                     int32_t dst_stride,
-                                                    uint8_t *src,
+                                                    const uint8_t *src,
                                                     int32_t src_stride,
-                                                    int16_t *sao_offset_val,
+                                                    const int16_t *sao_offset_val,
                                                     int32_t height)
 {
     const int32_t src_stride_2x = (src_stride << 1);
@@ -1165,13 +1165,14 @@ static void hevc_sao_edge_filter_0degree_8width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_0degree_16multiple_lsx(uint8_t *dst,
                                                         int32_t dst_stride,
-                                                        uint8_t *src,
+                                                        const uint8_t *src,
                                                         int32_t src_stride,
-                                                        int16_t *sao_offset_val,
+                                                        const int16_t *sao_offset_val,
                                                         int32_t width,
                                                         int32_t height)
 {
-    uint8_t *dst_ptr, *src_minus1;
+    uint8_t *dst_ptr;
+    const uint8_t *src_minus1;
     int32_t v_cnt;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
@@ -1201,17 +1202,17 @@ static void hevc_sao_edge_filter_0degree_16multiple_lsx(uint8_t *dst,
     for (; height; height -= 4) {
         src_minus1 = src - 1;
         src_minus10 = __lsx_vld(src_minus1, 0);
-        DUP2_ARG2(__lsx_vldx, src_minus1, src_stride, src_minus1,
+        DUP2_ARG2(LSX_VLDX, src_minus1, src_stride, src_minus1,
                   src_stride_2x, src_minus11, src_minus12);
-        src_minus13 = __lsx_vldx(src_minus1, src_stride_3x);
+        src_minus13 = LSX_VLDX(src_minus1, src_stride_3x);
 
         for (v_cnt = 0; v_cnt < width; v_cnt += 16) {
             src_minus1 += 16;
             dst_ptr = dst + v_cnt;
             src10 = __lsx_vld(src_minus1, 0);
-            DUP2_ARG2(__lsx_vldx, src_minus1, src_stride, src_minus1,
+            DUP2_ARG2(LSX_VLDX, src_minus1, src_stride, src_minus1,
                       src_stride_2x, src11, src12);
-            src13 = __lsx_vldx(src_minus1, src_stride_3x);
+            src13 = LSX_VLDX(src_minus1, src_stride_3x);
             DUP4_ARG3(__lsx_vshuf_b, src10, src_minus10, shuf1, src11,
                       src_minus11, shuf1, src12, src_minus12, shuf1, src13,
                       src_minus13, shuf1, src_zero0, src_zero1,
@@ -1303,9 +1304,9 @@ static void hevc_sao_edge_filter_0degree_16multiple_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_90degree_4width_lsx(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
     const int32_t src_stride_2x = (src_stride << 1);
@@ -1358,7 +1359,7 @@ static void hevc_sao_edge_filter_90degree_4width_lsx(uint8_t *dst,
         src_minus11 = src11;
 
         /* load in advance */
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src10, src11);
 
         __lsx_vstelm_w(dst0, dst, 0, 0);
@@ -1398,9 +1399,9 @@ static void hevc_sao_edge_filter_90degree_4width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_90degree_8width_lsx(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
     const int32_t src_stride_2x = (src_stride << 1);
@@ -1417,7 +1418,7 @@ static void hevc_sao_edge_filter_90degree_8width_lsx(uint8_t *dst,
 
     /* load in advance */
     DUP2_ARG2(__lsx_vld, src - src_stride, 0, src, 0, src_minus10, src_minus11);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src10, src11);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src10, src11);
 
     for (height -= 2; height; height -= 2) {
         src += src_stride_2x;
@@ -1451,7 +1452,7 @@ static void hevc_sao_edge_filter_90degree_8width_lsx(uint8_t *dst,
         src_minus11 = src11;
 
         /* load in advance */
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src10, src11);
 
         __lsx_vstelm_d(dst0, dst, 0, 0);
@@ -1491,14 +1492,14 @@ static void hevc_sao_edge_filter_90degree_8width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_90degree_16multiple_lsx(uint8_t *dst,
                                                          int32_t dst_stride,
-                                                         uint8_t *src,
+                                                         const uint8_t *src,
                                                          int32_t src_stride,
-                                                         int16_t *
+                                                         const int16_t *
                                                          sao_offset_val,
                                                          int32_t width,
                                                          int32_t height)
 {
-    uint8_t *src_orig = src;
+    const uint8_t *src_orig = src;
     uint8_t *dst_orig = dst;
     int32_t h_cnt, v_cnt;
     const int32_t src_stride_2x = (src_stride << 1);
@@ -1528,7 +1529,7 @@ static void hevc_sao_edge_filter_90degree_16multiple_lsx(uint8_t *dst,
                   src_minus10, src_minus11);
 
         for (h_cnt = (height >> 2); h_cnt--;) {
-            DUP4_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+            DUP4_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                       src, src_stride_3x, src, src_stride_4x,
                       src10, src11, src12, src13);
             DUP4_ARG2(__lsx_vseq_b, src_minus11, src_minus10, src_minus11,
@@ -1610,12 +1611,12 @@ static void hevc_sao_edge_filter_90degree_16multiple_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_45degree_4width_lsx(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
     __m128i shuf1 = {0x807060504030201, 0x100F0E0D0C0B0A09};
@@ -1635,7 +1636,7 @@ static void hevc_sao_edge_filter_45degree_4width_lsx(uint8_t *dst,
     /* load in advance */
     DUP2_ARG2(__lsx_vld, src_orig - src_stride, 0, src_orig, 0,
               src_minus10, src_minus11);
-    DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
               src10, src11);
 
     for (height -= 2; height; height -= 2) {
@@ -1677,7 +1678,7 @@ static void hevc_sao_edge_filter_45degree_4width_lsx(uint8_t *dst,
         src_minus11 = src11;
 
         /* load in advance */
-        DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
                   src10, src11);
 
         __lsx_vstelm_w(dst0, dst, 0, 0);
@@ -1723,12 +1724,12 @@ static void hevc_sao_edge_filter_45degree_4width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_45degree_8width_lsx(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
     __m128i shuf1 = {0x807060504030201, 0x100F0E0D0C0B0A09};
@@ -1748,7 +1749,7 @@ static void hevc_sao_edge_filter_45degree_8width_lsx(uint8_t *dst,
     /* load in advance */
     DUP2_ARG2(__lsx_vld, src_orig - src_stride, 0, src_orig, 0, src_minus10,
               src_minus11);
-    DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
               src10, src11);
 
     for (height -= 2; height; height -= 2) {
@@ -1790,7 +1791,7 @@ static void hevc_sao_edge_filter_45degree_8width_lsx(uint8_t *dst,
         src_minus11 = src11;
 
         /* load in advance */
-        DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
                   src10, src11)
         __lsx_vstelm_d(dst0, dst, 0, 0);
         __lsx_vstelm_d(dst0, dst + dst_stride, 0, 1);
@@ -1833,7 +1834,7 @@ static void hevc_sao_edge_filter_45degree_8width_lsx(uint8_t *dst,
     src_minus11 = src11;
 
     /* load in advance */
-    DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
               src10, src11);
 
     __lsx_vstelm_d(dst0, dst, 0, 0);
@@ -1842,14 +1843,14 @@ static void hevc_sao_edge_filter_45degree_8width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_45degree_16multiple_lsx(uint8_t *dst,
                                                          int32_t dst_stride,
-                                                         uint8_t *src,
+                                                         const uint8_t *src,
                                                          int32_t src_stride,
-                                                         int16_t *
+                                                         const int16_t *
                                                          sao_offset_val,
                                                          int32_t width,
                                                          int32_t height)
 {
-    uint8_t *src_orig = src;
+    const uint8_t *src_orig = src;
     uint8_t *dst_orig = dst;
     int32_t v_cnt;
     const int32_t src_stride_2x = (src_stride << 1);
@@ -1880,17 +1881,17 @@ static void hevc_sao_edge_filter_45degree_16multiple_lsx(uint8_t *dst,
         src_orig = src - 1;
         dst_orig = dst;
         src_minus11 = __lsx_vld(src_orig, 0);
-        DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
                   src_minus12, src_minus13);
-        src_minus14 = __lsx_vldx(src_orig, src_stride_3x);
+        src_minus14 = LSX_VLDX(src_orig, src_stride_3x);
 
         for (v_cnt = 0; v_cnt < width; v_cnt += 16) {
             src_minus10 = __lsx_vld(src_orig - src_stride, 0);
             src_orig += 16;
             src10 = __lsx_vld(src_orig, 0);
-            DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig,
+            DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig,
                       src_stride_2x, src11, src12);
-            src13 = __lsx_vldx(src_orig, src_stride_3x);
+            src13 = LSX_VLDX(src_orig, src_stride_3x);
             src_plus13 = __lsx_vld(src + v_cnt + src_stride_4x, 1);
 
             DUP4_ARG3(__lsx_vshuf_b, src10, src_minus11, shuf1, src11,
@@ -1990,12 +1991,12 @@ static void hevc_sao_edge_filter_45degree_16multiple_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_135degree_4width_lsx(uint8_t *dst,
                                                       int32_t dst_stride,
-                                                      uint8_t *src,
+                                                      const uint8_t *src,
                                                       int32_t src_stride,
-                                                      int16_t *sao_offset_val,
+                                                      const int16_t *sao_offset_val,
                                                       int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
 
@@ -2016,7 +2017,7 @@ static void hevc_sao_edge_filter_135degree_4width_lsx(uint8_t *dst,
     /* load in advance */
     DUP2_ARG2(__lsx_vld, src_orig - src_stride, 0, src_orig, 0,
               src_minus10, src_minus11);
-    DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
               src10, src11);
 
     for (height -= 2; height; height -= 2) {
@@ -2058,7 +2059,7 @@ static void hevc_sao_edge_filter_135degree_4width_lsx(uint8_t *dst,
         src_minus11 = src11;
 
         /* load in advance */
-        DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
                   src10, src11);
 
         __lsx_vstelm_w(dst0, dst, 0, 0);
@@ -2105,12 +2106,12 @@ static void hevc_sao_edge_filter_135degree_4width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_135degree_8width_lsx(uint8_t *dst,
                                                       int32_t dst_stride,
-                                                      uint8_t *src,
+                                                      const uint8_t *src,
                                                       int32_t src_stride,
-                                                      int16_t *sao_offset_val,
+                                                      const int16_t *sao_offset_val,
                                                       int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
 
@@ -2131,7 +2132,7 @@ static void hevc_sao_edge_filter_135degree_8width_lsx(uint8_t *dst,
     /* load in advance */
     DUP2_ARG2(__lsx_vld, src_orig - src_stride, 0, src_orig, 0,
               src_minus10, src_minus11);
-    DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
               src10, src11);
 
     for (height -= 2; height; height -= 2) {
@@ -2173,7 +2174,7 @@ static void hevc_sao_edge_filter_135degree_8width_lsx(uint8_t *dst,
         src_minus11 = src11;
 
         /* load in advance */
-        DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
                   src10, src11);
 
         __lsx_vstelm_d(dst0, dst, 0, 0);
@@ -2219,13 +2220,14 @@ static void hevc_sao_edge_filter_135degree_8width_lsx(uint8_t *dst,
 
 static void hevc_sao_edge_filter_135degree_16multiple_lsx(uint8_t *dst,
                                                           int32_t dst_stride,
-                                                          uint8_t *src,
+                                                          const uint8_t *src,
                                                           int32_t src_stride,
-                                                          int16_t *sao_offset_val,
+                                                          const int16_t *sao_offset_val,
                                                           int32_t width,
                                                           int32_t height)
 {
-    uint8_t *src_orig, *dst_orig;
+    const uint8_t *src_orig;
+    uint8_t *dst_orig;
     int32_t v_cnt;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
@@ -2255,18 +2257,18 @@ static void hevc_sao_edge_filter_135degree_16multiple_lsx(uint8_t *dst,
         dst_orig = dst;
 
         src_minus11 = __lsx_vld(src_orig, 0);
-        DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
                   src_plus10, src_plus11);
-        src_plus12 = __lsx_vldx(src_orig, src_stride_3x);
+        src_plus12 = LSX_VLDX(src_orig, src_stride_3x);
 
         for (v_cnt = 0; v_cnt < width; v_cnt += 16) {
             src_minus10 = __lsx_vld(src_orig - src_stride, 2);
-            src_plus13 = __lsx_vldx(src_orig, src_stride_4x);
+            src_plus13 = LSX_VLDX(src_orig, src_stride_4x);
             src_orig += 16;
             src10 = __lsx_vld(src_orig, 0);
-            DUP2_ARG2(__lsx_vldx, src_orig, src_stride, src_orig, src_stride_2x,
+            DUP2_ARG2(LSX_VLDX, src_orig, src_stride, src_orig, src_stride_2x,
                       src11, src12);
-            src13 =__lsx_vldx(src_orig, src_stride_3x);
+            src13 =LSX_VLDX(src_orig, src_stride_3x);
 
             DUP4_ARG3(__lsx_vshuf_b, src10, src_minus11, shuf1, src11,
                       src_plus10,  shuf1, src12, src_plus11, shuf1, src13,
@@ -2362,9 +2364,9 @@ static void hevc_sao_edge_filter_135degree_16multiple_lsx(uint8_t *dst,
     }
 }
 
-void ff_hevc_sao_edge_filter_8_lsx(uint8_t *dst, uint8_t *src,
+void ff_hevc_sao_edge_filter_8_lsx(uint8_t *dst, const uint8_t *src,
                                    ptrdiff_t stride_dst,
-                                   int16_t *sao_offset_val,
+                                   const int16_t *sao_offset_val,
                                    int eo, int width, int height)
 {
     ptrdiff_t stride_src = (2 * MAX_PB_SIZE + AV_INPUT_BUFFER_PADDING_SIZE);
diff --git a/libavcodec/loongarch/hevc_mc_bi_lsx.c b/libavcodec/loongarch/hevc_mc_bi_lsx.c
index 9092fdc..4e10a8a 100644
--- a/libavcodec/loongarch/hevc_mc_bi_lsx.c
+++ b/libavcodec/loongarch/hevc_mc_bi_lsx.c
@@ -42,8 +42,8 @@ hevc_bi_rnd_clip(__m128i in0, __m128i vec0, __m128i in1, __m128i vec1)
 
 /* hevc_bi_copy: dst = av_clip_uint8((src0 << 6 + src1) >> 7) */
 static
-void hevc_bi_copy_4w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                         int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_4w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                         const int16_t *src1_ptr, int32_t src2_stride,
                          uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     int32_t loop_cnt = height >> 3;
@@ -127,8 +127,8 @@ void hevc_bi_copy_4w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                         int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_6w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                         const int16_t *src1_ptr, int32_t src2_stride,
                          uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     int32_t loop_cnt;
@@ -163,14 +163,14 @@ void hevc_bi_copy_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
         DUP2_ARG2(__lsx_vilvl_d, reg1, reg0, reg3, reg2, src2, src3);
         src0_ptr += src_stride_4x;
         in0 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in1, in2);
-        in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         in4 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in5, in6);
-        in7 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in7 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         DUP4_ARG2(__lsx_vsllwil_hu_bu, src0, 6, src1, 6, src2, 6, src3, 6,
                   dst0, dst2, dst4, dst6);
@@ -207,7 +207,7 @@ void hevc_bi_copy_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
         src0 = __lsx_vilvl_d(reg1, reg0);
         src0_ptr += src_stride_2x;
         in0 = __lsx_vld(src1_ptr, 0);
-        in1 = __lsx_vldx(src1_ptr, src2_stride_x);
+        in1 = LSX_VLDX(src1_ptr, src2_stride_x);
         src1_ptr += src2_stride_x;
         dst0 = __lsx_vsllwil_hu_bu(src0, 6);
         dst1 = __lsx_vilvh_b(zero, src0);
@@ -223,8 +223,8 @@ void hevc_bi_copy_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                         int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_8w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                         const int16_t *src1_ptr, int32_t src2_stride,
                          uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     int32_t loop_cnt = height >> 3;
@@ -265,14 +265,14 @@ void hevc_bi_copy_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
         DUP4_ARG2(__lsx_vslli_h, dst1, 6, dst3, 6, dst5, 6, dst7, 6, dst1,
                   dst3, dst5, dst7);
         in0 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in1, in2);
-        in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         in4 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in5, in6);
-        in7 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in7 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         out0 = hevc_bi_rnd_clip(in0, dst0, in1, dst1);
         out1 = hevc_bi_rnd_clip(in2, dst2, in3, dst3);
@@ -294,7 +294,7 @@ void hevc_bi_copy_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
         reg1 = __lsx_vldrepl_d(src0_ptr + src_stride, 0);
         src0 = __lsx_vilvl_d(reg1, reg0);
         in0  = __lsx_vld(src1_ptr, 0);
-        in1  = __lsx_vldx(src1_ptr, src2_stride_x);
+        in1  = LSX_VLDX(src1_ptr, src2_stride_x);
         dst0 = __lsx_vsllwil_hu_bu(src0, 6);
         dst1 = __lsx_vilvh_b(zero, src0);
         dst1 = __lsx_vslli_h(dst1, 6);
@@ -308,8 +308,8 @@ void hevc_bi_copy_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                          int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_12w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                          const int16_t *src1_ptr, int32_t src2_stride,
                           uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     uint32_t loop_cnt;
@@ -322,7 +322,7 @@ void hevc_bi_copy_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     int32_t src_stride_3x = src_stride_2x + src_stride;
     int32_t dst_stride_3x = dst_stride_2x + dst_stride;
     int32_t src2_stride_3x = src2_stride_2x + src2_stride_x;
-    int16_t* _src1 = src1_ptr + 8;
+    const int16_t *_src1 = src1_ptr + 8;
     __m128i out0, out1, out2;
     __m128i src0, src1, src2, src3;
     __m128i in0, in1, in2, in3, in4, in5, in6, in7;
@@ -330,19 +330,19 @@ void hevc_bi_copy_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 
     for (loop_cnt = 4; loop_cnt--;) {
         src0 = __lsx_vld(src0_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src0_ptr, src_stride_3x);
+        src3 = LSX_VLDX(src0_ptr, src_stride_3x);
         src0_ptr += src_stride_4x;
         in0 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in1, in2);
-        in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         in4 = __lsx_vld(_src1, 0);
-        DUP2_ARG2(__lsx_vldx, _src1, src2_stride_x, _src1, src2_stride_2x,
+        DUP2_ARG2(LSX_VLDX, _src1, src2_stride_x, _src1, src2_stride_2x,
                   in5, in6);
-        in7 = __lsx_vldx(_src1, src2_stride_3x);
+        in7 = LSX_VLDX(_src1, src2_stride_3x);
         _src1 += src2_stride_2x;
 
         DUP2_ARG2(__lsx_vilvl_d, in5, in4, in7, in6, in4, in5);
@@ -366,8 +366,8 @@ void hevc_bi_copy_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                          int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_16w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                          const int16_t *src1_ptr, int32_t src2_stride,
                           uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     uint32_t loop_cnt;
@@ -380,7 +380,7 @@ void hevc_bi_copy_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     int32_t src_stride_3x = src_stride_2x + src_stride;
     int32_t dst_stride_3x = dst_stride_2x + dst_stride;
     int32_t src2_stride_3x = src2_stride_2x + src2_stride_x;
-    int16_t *_src1 = src1_ptr + 8;
+    const int16_t *_src1 = src1_ptr + 8;
     __m128i out0, out1, out2, out3;
     __m128i src0, src1, src2, src3;
     __m128i in0, in1, in2, in3, in4, in5, in6, in7;
@@ -389,19 +389,19 @@ void hevc_bi_copy_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src0 = __lsx_vld(src0_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src0_ptr, src_stride_3x);
+        src3 = LSX_VLDX(src0_ptr, src_stride_3x);
         src0_ptr += src_stride_4x;
         in0 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in1, in2);
-        in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         in4 = __lsx_vld(_src1, 0);
-        DUP2_ARG2(__lsx_vldx, _src1, src2_stride_x, _src1, src2_stride_2x,
+        DUP2_ARG2(LSX_VLDX, _src1, src2_stride_x, _src1, src2_stride_2x,
                   in5, in6);
-        in7 = __lsx_vldx(_src1, src2_stride_3x);
+        in7 = LSX_VLDX(_src1, src2_stride_3x);
         _src1 += src2_stride_2x;
         DUP4_ARG2(__lsx_vsllwil_hu_bu, src0, 6, src1, 6, src2, 6, src3, 6,
                   dst0_r, dst1_r, dst2_r, dst3_r)
@@ -423,8 +423,8 @@ void hevc_bi_copy_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                          int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_24w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                          const int16_t *src1_ptr, int32_t src2_stride,
                           uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     hevc_bi_copy_16w_lsx(src0_ptr, src_stride, src1_ptr, src2_stride,
@@ -434,8 +434,8 @@ void hevc_bi_copy_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                          int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_32w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                          const int16_t *src1_ptr, int32_t src2_stride,
                           uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     hevc_bi_copy_16w_lsx(src0_ptr, src_stride, src1_ptr, src2_stride,
@@ -445,8 +445,8 @@ void hevc_bi_copy_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                          int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_48w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                          const int16_t *src1_ptr, int32_t src2_stride,
                           uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     hevc_bi_copy_16w_lsx(src0_ptr, src_stride, src1_ptr, src2_stride,
@@ -456,8 +456,8 @@ void hevc_bi_copy_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static
-void hevc_bi_copy_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                          int16_t *src1_ptr, int32_t src2_stride,
+void hevc_bi_copy_64w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                          const int16_t *src1_ptr, int32_t src2_stride,
                           uint8_t *dst, int32_t dst_stride, int32_t height)
 {
     hevc_bi_copy_32w_lsx(src0_ptr, src_stride, src1_ptr, src2_stride,
@@ -466,8 +466,8 @@ void hevc_bi_copy_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                          dst + 32, dst_stride, height);
 }
 
-static void hevc_hz_8t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr,  int32_t src2_stride,
+static void hevc_hz_8t_16w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr,  int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -531,8 +531,8 @@ static void hevc_hz_8t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hz_8t_24w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -585,8 +585,8 @@ static void hevc_hz_8t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hz_8t_32w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -596,8 +596,8 @@ static void hevc_hz_8t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                        dst + 16, dst_stride, filter, height);
 }
 
-static void hevc_hz_8t_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hz_8t_48w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -607,8 +607,8 @@ static void hevc_hz_8t_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                        dst + 16, dst_stride, filter, height);
 }
 
-static void hevc_hz_8t_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hz_8t_64w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -619,7 +619,7 @@ static void hevc_hz_8t_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static av_always_inline
-void hevc_vt_8t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr,
+void hevc_vt_8t_8w_lsx(const uint8_t *src0_ptr, int32_t src_stride, const int16_t *src1_ptr,
                        int32_t src2_stride, uint8_t *dst, int32_t dst_stride,\
                        const int8_t *filter, int32_t height)
 {
@@ -647,12 +647,12 @@ void hevc_vt_8t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr,
               filt0, filt1, filt2, filt3);
 
     src0 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src1, src2);
-    src3 = __lsx_vldx(src0_ptr, src_stride_3x);
+    src3 = LSX_VLDX(src0_ptr, src_stride_3x);
     src0_ptr += src_stride_4x;
     src4 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src5, src6);
     src0_ptr += src_stride_3x;
     DUP4_ARG2(__lsx_vilvl_b, src1, src0, src3, src2, src5, src4, src2, src1,
@@ -661,14 +661,14 @@ void hevc_vt_8t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src7 = __lsx_vld(src0_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
                   src8, src9);
-        src10 = __lsx_vldx(src0_ptr, src_stride_3x);
+        src10 = LSX_VLDX(src0_ptr, src_stride_3x);
         src0_ptr += src_stride_4x;
         in0 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr, src2_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr, src2_stride_2x,
                   in1, in2);
-        in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         DUP4_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src9, src8, src10, src9,
                   src76_r, src87_r, src98_r, src109_r);
@@ -705,14 +705,14 @@ void hevc_vt_8t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr,
 }
 
 static av_always_inline
-void hevc_vt_8t_16multx2mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                                 int16_t *src1_ptr, int32_t src2_stride,
+void hevc_vt_8t_16multx2mult_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                                 const int16_t *src1_ptr, int32_t src2_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height,
                                  int32_t width)
 {
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt;
     uint32_t cnt;
@@ -741,12 +741,12 @@ void hevc_vt_8t_16multx2mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
         dst_tmp = dst;
 
         src0 = __lsx_vld(src0_ptr_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr_tmp, src_stride, src0_ptr_tmp,
+        DUP2_ARG2(LSX_VLDX, src0_ptr_tmp, src_stride, src0_ptr_tmp,
                   src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src0_ptr_tmp, src_stride_3x);
+        src3 = LSX_VLDX(src0_ptr_tmp, src_stride_3x);
         src0_ptr_tmp += src_stride_4x;
         src4 = __lsx_vld(src0_ptr_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr_tmp, src_stride, src0_ptr_tmp,
+        DUP2_ARG2(LSX_VLDX, src0_ptr_tmp, src_stride, src0_ptr_tmp,
                   src_stride_2x, src5, src6);
         src0_ptr_tmp += src_stride_3x;
 
@@ -759,7 +759,7 @@ void hevc_vt_8t_16multx2mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
 
         for (loop_cnt = (height >> 1); loop_cnt--;) {
             src7 = __lsx_vld(src0_ptr_tmp, 0);
-            src8 = __lsx_vldx(src0_ptr_tmp, src_stride);
+            src8 = LSX_VLDX(src0_ptr_tmp, src_stride);
             src0_ptr_tmp += src_stride_2x;
             DUP2_ARG2(__lsx_vld, src1_ptr_tmp, 0, src1_ptr_tmp, 16, in0, in2);
             src1_ptr_tmp += src2_stride;
@@ -808,8 +808,8 @@ void hevc_vt_8t_16multx2mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_8t_16w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -817,8 +817,8 @@ static void hevc_vt_8t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                 dst, dst_stride, filter, height, 16);
 }
 
-static void hevc_vt_8t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_8t_24w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -828,8 +828,8 @@ static void hevc_vt_8t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                       dst + 16, dst_stride, filter, height);
 }
 
-static void hevc_vt_8t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_8t_32w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -837,8 +837,8 @@ static void hevc_vt_8t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                 dst, dst_stride, filter, height, 32);
 }
 
-static void hevc_vt_8t_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_8t_48w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -846,8 +846,8 @@ static void hevc_vt_8t_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                 dst, dst_stride, filter, height, 48);
 }
 
-static void hevc_vt_8t_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_8t_64w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -856,16 +856,16 @@ static void hevc_vt_8t_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static av_always_inline
-void hevc_hv_8t_8multx1mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                                int16_t *src1_ptr, int32_t src2_stride,
+void hevc_hv_8t_8multx1mult_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                                const int16_t *src1_ptr, int32_t src2_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter_x, const int8_t *filter_y,
                                 int32_t height, int32_t width)
 {
     uint32_t loop_cnt;
     uint32_t cnt;
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_4x = (src_stride << 2);
@@ -903,12 +903,12 @@ void hevc_hv_8t_8multx1mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
         src1_ptr_tmp = src1_ptr;
 
         src0 = __lsx_vld(src0_ptr_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr_tmp, src_stride, src0_ptr_tmp,
+        DUP2_ARG2(LSX_VLDX, src0_ptr_tmp, src_stride, src0_ptr_tmp,
                   src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src0_ptr_tmp, src_stride_3x);
+        src3 = LSX_VLDX(src0_ptr_tmp, src_stride_3x);
         src0_ptr_tmp += src_stride_4x;
         src4 = __lsx_vld(src0_ptr_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr_tmp, src_stride, src0_ptr_tmp,
+        DUP2_ARG2(LSX_VLDX, src0_ptr_tmp, src_stride, src0_ptr_tmp,
                   src_stride_2x, src5, src6);
         src0_ptr_tmp += src_stride_3x;
 
@@ -994,8 +994,8 @@ void hevc_hv_8t_8multx1mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_hv_8t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                              int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_8t_8w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                              const int16_t *src1_ptr, int32_t src2_stride,
                               uint8_t *dst, int32_t dst_stride,
                               const int8_t *filter_x, const int8_t *filter_y,
                               int32_t height)
@@ -1004,8 +1004,8 @@ static void hevc_hv_8t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                dst, dst_stride, filter_x, filter_y, height, 8);
 }
 
-static void hevc_hv_8t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_8t_16w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1014,8 +1014,8 @@ static void hevc_hv_8t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                dst, dst_stride, filter_x, filter_y, height, 16);
 }
 
-static void hevc_hv_8t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_8t_24w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1024,8 +1024,8 @@ static void hevc_hv_8t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                dst, dst_stride, filter_x, filter_y, height, 24);
 }
 
-static void hevc_hv_8t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_8t_32w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1034,8 +1034,8 @@ static void hevc_hv_8t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                dst, dst_stride, filter_x, filter_y, height, 32);
 }
 
-static void hevc_hv_8t_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_8t_48w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1044,8 +1044,8 @@ static void hevc_hv_8t_48w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                dst, dst_stride, filter_x, filter_y, height, 48);
 }
 
-static void hevc_hv_8t_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_8t_64w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1054,12 +1054,12 @@ static void hevc_hv_8t_64w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                                dst, dst_stride, filter_x, filter_y, height, 64);
 }
 
-static void hevc_hz_4t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hz_4t_24w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
-    int16_t *src1_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt;
     int32_t dst_stride_2x = (dst_stride << 1);
@@ -1134,9 +1134,9 @@ static void hevc_hz_4t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
         dst += dst_stride_4x;
 
         in0 = __lsx_vld(src1_ptr_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr_tmp, src2_stride_x, src1_ptr_tmp,
+        DUP2_ARG2(LSX_VLDX, src1_ptr_tmp, src2_stride_x, src1_ptr_tmp,
                   src2_stride_2x, in1, in2);
-        in3 = __lsx_vldx(src1_ptr_tmp, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr_tmp, src2_stride_3x);
         src1_ptr_tmp += src2_stride_2x;
 
         DUP4_ARG3(__lsx_vshuf_b, src1, src1, mask0, src3, src3, mask0, src5,
@@ -1157,8 +1157,8 @@ static void hevc_hz_4t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_hz_4t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hz_4t_32w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1201,8 +1201,8 @@ static void hevc_hz_4t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_vt_4t_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_4t_12w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1216,7 +1216,7 @@ static void hevc_vt_4t_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     int32_t src_stride_3x = src_stride_2x + src_stride;
     int32_t dst_stride_3x = dst_stride_2x + dst_stride;
     int32_t src2_stride_3x = src2_stride_2x + src2_stride_x;
-    int16_t *_src1 = src1_ptr + 8;
+    const int16_t *_src1 = src1_ptr + 8;
     __m128i src0, src1, src2, src3, src4, src5, src6;
     __m128i in0, in1, in2, in3, in4, in5, in6, in7;
     __m128i src10_r, src32_r, src21_r, src43_r, src54_r, src65_r;
@@ -1229,7 +1229,7 @@ static void hevc_vt_4t_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     DUP2_ARG2(__lsx_vldrepl_h, filter, 0, filter, 2, filt0, filt1);
 
     src0 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src1, src2);
     src0_ptr += src_stride_3x;
     DUP2_ARG2(__lsx_vilvl_b, src1, src0, src2, src1, src10_r, src21_r);
@@ -1238,19 +1238,19 @@ static void hevc_vt_4t_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src3 = __lsx_vld(src0_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
                   src4, src5);
-        src6 = __lsx_vldx(src0_ptr, src_stride_3x);
+        src6 = LSX_VLDX(src0_ptr, src_stride_3x);
         src0_ptr += src_stride_4x;
         in0 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in1, in2);
-        in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += src2_stride_2x;
         in4 = __lsx_vld(_src1, 0);
-        DUP2_ARG2(__lsx_vldx, _src1, src2_stride_x, _src1, src2_stride_2x,
+        DUP2_ARG2(LSX_VLDX, _src1, src2_stride_x, _src1, src2_stride_2x,
                   in5, in6);
-        in7 = __lsx_vldx(_src1, src2_stride_3x);
+        in7 = LSX_VLDX(_src1, src2_stride_3x);
         _src1 += src2_stride_2x;
         DUP2_ARG2(__lsx_vilvl_d, in5, in4, in7, in6, in4, in5);
 
@@ -1290,8 +1290,8 @@ static void hevc_vt_4t_12w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_vt_4t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_4t_16w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1310,7 +1310,7 @@ static void hevc_vt_4t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     DUP2_ARG2(__lsx_vldrepl_h, filter, 0, filter, 2, filt0, filt1);
 
     src0 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src1, src2);
     src0_ptr += src_stride_3x;
     DUP2_ARG2(__lsx_vilvl_b, src1, src0, src2, src1, src10_r, src21_r);
@@ -1318,7 +1318,7 @@ static void hevc_vt_4t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src3 = __lsx_vld(src0_ptr, 0);
-        src4 = __lsx_vldx(src0_ptr, src_stride);
+        src4 = LSX_VLDX(src0_ptr, src_stride);
         src0_ptr += src_stride_2x;
         DUP2_ARG2(__lsx_vld, src1_ptr, 0, src1_ptr, 16, in0, in2);
         src1_ptr += src2_stride;
@@ -1340,7 +1340,7 @@ static void hevc_vt_4t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
         dst += dst_stride_2x;
 
         src5 = __lsx_vld(src0_ptr, 0);
-        src2 = __lsx_vldx(src0_ptr, src_stride);
+        src2 = LSX_VLDX(src0_ptr, src_stride);
         src0_ptr += src_stride_2x;
         DUP2_ARG2(__lsx_vld, src1_ptr, 0, src1_ptr, 16, in0, in2);
         src1_ptr += src2_stride;
@@ -1362,8 +1362,8 @@ static void hevc_vt_4t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_vt_4t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_4t_24w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1469,8 +1469,8 @@ static void hevc_vt_4t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_vt_4t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_vt_4t_32w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1480,8 +1480,8 @@ static void hevc_vt_4t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                        dst + 16, dst_stride, filter, height);
 }
 
-static void hevc_hv_4t_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                              int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_4t_6w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                              const int16_t *src1_ptr, int32_t src2_stride,
                               uint8_t *dst, int32_t dst_stride,
                               const int8_t *filter_x, const int8_t *filter_y,
                               int32_t height)
@@ -1517,7 +1517,7 @@ static void hevc_hv_4t_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     mask1 = __lsx_vaddi_bu(mask0, 2);
 
     src0 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src1, src2);
     src0_ptr += src_stride_3x;
 
@@ -1535,9 +1535,9 @@ static void hevc_hv_4t_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     DUP2_ARG2(__lsx_vilvh_h, dsth1, dsth0, dsth2, dsth1, tmp1, tmp3);
 
     src3 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src4, src5);
-    src6 = __lsx_vldx(src0_ptr, src_stride_3x);
+    src6 = LSX_VLDX(src0_ptr, src_stride_3x);
     src0_ptr += src_stride_4x;
     DUP2_ARG3(__lsx_vshuf_b, src3, src3, mask0, src3, src3, mask1, vec0, vec1);
     DUP2_ARG3(__lsx_vshuf_b, src4, src4, mask0, src4, src4, mask1, vec2, vec3);
@@ -1550,9 +1550,9 @@ static void hevc_hv_4t_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
               vec5, filt1, dsth6, vec7, filt1, dsth3, dsth4, dsth5, dsth6);
 
     src3 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src4, src5);
-    src6 = __lsx_vldx(src0_ptr, src_stride_3x);
+    src6 = LSX_VLDX(src0_ptr, src_stride_3x);
 
     DUP2_ARG3(__lsx_vshuf_b, src3, src3, mask0, src3, src3, mask1, vec0, vec1);
     DUP2_ARG3(__lsx_vshuf_b, src4, src4, mask0, src4, src4, mask1, vec2, vec3);
@@ -1668,7 +1668,7 @@ static void hevc_hv_4t_6w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static av_always_inline
-void hevc_hv_4t_8x2_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr,
+void hevc_hv_4t_8x2_lsx(const uint8_t *src0_ptr, int32_t src_stride, const int16_t *src1_ptr,
                         int32_t src2_stride, uint8_t *dst, int32_t dst_stride,
                         const int8_t *filter_x, const int8_t *filter_y)
 {
@@ -1700,7 +1700,7 @@ void hevc_hv_4t_8x2_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr
     mask1 = __lsx_vaddi_bu(mask0, 2);
 
     src0 = __lsx_vld(src0_ptr, 0);
-    DUP4_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP4_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src0_ptr, src_stride_3x, src0_ptr, src_stride_4x,
               src1, src2, src3, src4);
 
@@ -1739,8 +1739,8 @@ void hevc_hv_4t_8x2_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr
 }
 
 static av_always_inline
-void hevc_hv_4t_8multx4_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                            int16_t *src1_ptr, int32_t src2_stride,
+void hevc_hv_4t_8multx4_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                            const int16_t *src1_ptr, int32_t src2_stride,
                             uint8_t *dst, int32_t dst_stride,
                             const int8_t *filter_x, const int8_t *filter_y,
                             int32_t width8mult)
@@ -1777,19 +1777,19 @@ void hevc_hv_4t_8multx4_lsx(uint8_t *src0_ptr, int32_t src_stride,
 
     for (cnt = width8mult; cnt--;) {
         src0 = __lsx_vld(src0_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src0_ptr, src_stride_3x);
+        src3 = LSX_VLDX(src0_ptr, src_stride_3x);
         src0_ptr += src_stride_4x;
         src4 = __lsx_vld(src0_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
                   src5, src6);
         src0_ptr += (8 - src_stride_4x);
 
         in0 = __lsx_vld(src1_ptr, 0);
-        DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr,
+        DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr,
                   src2_stride_2x, in1, in2);
-        in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+        in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
         src1_ptr += 8;
 
         DUP2_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1,
@@ -1858,7 +1858,7 @@ void hevc_hv_4t_8multx4_lsx(uint8_t *src0_ptr, int32_t src_stride,
 }
 
 static av_always_inline
-void hevc_hv_4t_8x6_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr,
+void hevc_hv_4t_8x6_lsx(const uint8_t *src0_ptr, int32_t src_stride, const int16_t *src1_ptr,
                         int32_t src2_stride, uint8_t *dst, int32_t dst_stride,
                         const int8_t *filter_x, const int8_t *filter_y)
 {
@@ -1900,22 +1900,22 @@ void hevc_hv_4t_8x6_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr
     mask1 = __lsx_vaddi_bu(mask0, 2);
 
     src0 = __lsx_vld(src0_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src1, src2);
-    src3 = __lsx_vldx(src0_ptr, src_stride_3x);
+    src3 = LSX_VLDX(src0_ptr, src_stride_3x);
     src0_ptr += src_stride_4x;
     src4 = __lsx_vld(src0_ptr, 0);
-    DUP4_ARG2(__lsx_vldx, src0_ptr, src_stride, src0_ptr, src_stride_2x,
+    DUP4_ARG2(LSX_VLDX, src0_ptr, src_stride, src0_ptr, src_stride_2x,
               src0_ptr, src_stride_3x, src0_ptr, src_stride_4x,
               src5, src6, src7, src8);
 
     in0 = __lsx_vld(src1_ptr, 0);
-    DUP2_ARG2(__lsx_vldx, src1_ptr, src2_stride_x, src1_ptr, src2_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src1_ptr, src2_stride_x, src1_ptr, src2_stride_2x,
               in1, in2);
-    in3 = __lsx_vldx(src1_ptr, src2_stride_3x);
+    in3 = LSX_VLDX(src1_ptr, src2_stride_3x);
     src1_ptr += src2_stride_2x;
     in4 = __lsx_vld(src1_ptr, 0);
-    in5 = __lsx_vldx(src1_ptr, src2_stride_x);
+    in5 = LSX_VLDX(src1_ptr, src2_stride_x);
 
     DUP2_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1, vec0, vec1);
     DUP2_ARG3(__lsx_vshuf_b, src1, src1, mask0, src1, src1, mask1, vec2, vec3);
@@ -1990,15 +1990,15 @@ void hevc_hv_4t_8x6_lsx(uint8_t *src0_ptr, int32_t src_stride, int16_t *src1_ptr
 }
 
 static av_always_inline
-void hevc_hv_4t_8multx4mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                                int16_t *src1_ptr, int32_t src2_stride,
+void hevc_hv_4t_8multx4mult_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                                const int16_t *src1_ptr, int32_t src2_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter_x, const int8_t *filter_y,
                                 int32_t height, int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
@@ -2041,7 +2041,7 @@ void hevc_hv_4t_8multx4mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
         src1_ptr_tmp = src1_ptr;
 
         src0 = __lsx_vld(src0_ptr_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src0_ptr_tmp, src_stride, src0_ptr_tmp,
+        DUP2_ARG2(LSX_VLDX, src0_ptr_tmp, src_stride, src0_ptr_tmp,
                   src_stride_2x, src1, src2);
         src0_ptr_tmp += src_stride_3x;
 
@@ -2063,14 +2063,14 @@ void hevc_hv_4t_8multx4mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
 
         for (loop_cnt = height >> 2; loop_cnt--;) {
             src3 = __lsx_vld(src0_ptr_tmp, 0);
-            DUP2_ARG2(__lsx_vldx, src0_ptr_tmp, src_stride, src0_ptr_tmp,
+            DUP2_ARG2(LSX_VLDX, src0_ptr_tmp, src_stride, src0_ptr_tmp,
                       src_stride_2x, src4, src5);
-            src6 = __lsx_vldx(src0_ptr_tmp, src_stride_3x);
+            src6 = LSX_VLDX(src0_ptr_tmp, src_stride_3x);
             src0_ptr_tmp += src_stride_4x;
             in0 = __lsx_vld(src1_ptr_tmp, 0);
-            DUP2_ARG2(__lsx_vldx, src1_ptr_tmp, src2_stride_x, src1_ptr_tmp,
+            DUP2_ARG2(LSX_VLDX, src1_ptr_tmp, src2_stride_x, src1_ptr_tmp,
                       src2_stride_2x, in1, in2);
-            in3 = __lsx_vldx(src1_ptr_tmp, src2_stride_3x);
+            in3 = LSX_VLDX(src1_ptr_tmp, src2_stride_3x);
             src1_ptr_tmp += src2_stride_2x;
 
             DUP4_ARG3(__lsx_vshuf_b, src3, src3, mask0, src3, src3, mask1, src4,
@@ -2130,8 +2130,8 @@ void hevc_hv_4t_8multx4mult_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_hv_4t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                              int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_4t_8w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                              const int16_t *src1_ptr, int32_t src2_stride,
                               uint8_t *dst, int32_t dst_stride,
                               const int8_t *filter_x, const int8_t *filter_y,
                               int32_t height)
@@ -2151,8 +2151,8 @@ static void hevc_hv_4t_8w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_hv_4t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_4t_16w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2166,8 +2166,8 @@ static void hevc_hv_4t_16w_lsx(uint8_t *src0_ptr, int32_t src_stride,
     }
 }
 
-static void hevc_hv_4t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_4t_24w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2176,8 +2176,8 @@ static void hevc_hv_4t_24w_lsx(uint8_t *src0_ptr, int32_t src_stride,
                             dst, dst_stride, filter_x, filter_y, height, 24);
 }
 
-static void hevc_hv_4t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
-                               int16_t *src1_ptr, int32_t src2_stride,
+static void hevc_hv_4t_32w_lsx(const uint8_t *src0_ptr, int32_t src_stride,
+                               const int16_t *src1_ptr, int32_t src2_stride,
                                uint8_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2189,9 +2189,9 @@ static void hevc_hv_4t_32w_lsx(uint8_t *src0_ptr, int32_t src_stride,
 #define BI_MC_COPY(WIDTH)                                                 \
 void ff_hevc_put_hevc_bi_pel_pixels##WIDTH##_8_lsx(uint8_t *dst,          \
                                                    ptrdiff_t dst_stride,  \
-                                                   uint8_t *src,          \
+                                                   const uint8_t *src,    \
                                                    ptrdiff_t src_stride,  \
-                                                   int16_t *src_16bit,    \
+                                                   const int16_t *src_16bit, \
                                                    int height,            \
                                                    intptr_t mx,           \
                                                    intptr_t my,           \
@@ -2216,9 +2216,9 @@ BI_MC_COPY(64);
 #define BI_MC(PEL, DIR, WIDTH, TAP, DIR1, FILT_DIR)                          \
 void ff_hevc_put_hevc_bi_##PEL##_##DIR##WIDTH##_8_lsx(uint8_t *dst,          \
                                                       ptrdiff_t dst_stride,  \
-                                                      uint8_t *src,          \
+                                                      const uint8_t *src,    \
                                                       ptrdiff_t src_stride,  \
-                                                      int16_t *src_16bit,    \
+                                                      const int16_t *src_16bit, \
                                                       int height,            \
                                                       intptr_t mx,           \
                                                       intptr_t my,           \
@@ -2257,9 +2257,9 @@ BI_MC(epel, v, 32, 4, vt, my);
 #define BI_MC_HV(PEL, WIDTH, TAP)                                         \
 void ff_hevc_put_hevc_bi_##PEL##_hv##WIDTH##_8_lsx(uint8_t *dst,          \
                                                    ptrdiff_t dst_stride,  \
-                                                   uint8_t *src,          \
+                                                   const uint8_t *src,    \
                                                    ptrdiff_t src_stride,  \
-                                                   int16_t *src_16bit,    \
+                                                   const int16_t *src_16bit, \
                                                    int height,            \
                                                    intptr_t mx,           \
                                                    intptr_t my,           \
diff --git a/libavcodec/loongarch/hevc_mc_uni_lsx.c b/libavcodec/loongarch/hevc_mc_uni_lsx.c
index a15c862..de8e79f 100644
--- a/libavcodec/loongarch/hevc_mc_uni_lsx.c
+++ b/libavcodec/loongarch/hevc_mc_uni_lsx.c
@@ -33,7 +33,7 @@ static const uint8_t ff_hevc_mask_arr[16 * 3] __attribute__((aligned(0x40))) = {
 };
 
 static av_always_inline
-void common_hz_8t_64w_lsx(uint8_t *src, int32_t src_stride,
+void common_hz_8t_64w_lsx(const uint8_t *src, int32_t src_stride,
                           uint8_t *dst, int32_t dst_stride,
                           const int8_t *filter, int32_t height)
 {
@@ -125,7 +125,7 @@ void common_hz_8t_64w_lsx(uint8_t *src, int32_t src_stride,
 }
 
 static av_always_inline
-void common_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
+void common_vt_8t_8w_lsx(const uint8_t *src, int32_t src_stride,
                          uint8_t *dst, int32_t dst_stride,
                          const int8_t *filter, int32_t height)
 {
@@ -148,11 +148,11 @@ void common_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
               filt0, filt1, filt2, filt3);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-    src3 = __lsx_vldx(src, src_stride_3x);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+    src3 = LSX_VLDX(src, src_stride_3x);
     src += src_stride_4x;
     src4 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
     src += src_stride_3x;
     DUP4_ARG2(__lsx_vilvl_b, src1, src0, src3, src2, src5, src4, src2, src1,
               src10_r, src32_r, src54_r, src21_r);
@@ -160,8 +160,8 @@ void common_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src9, src8, src10,
@@ -197,11 +197,11 @@ void common_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
 }
 
 static av_always_inline
-void common_vt_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void common_vt_8t_16w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                           int32_t dst_stride, const int8_t *filter,
                           int32_t height, int32_t width)
 {
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt, cnt;
     const int32_t src_stride_2x = (src_stride << 1);
@@ -228,12 +228,12 @@ void common_vt_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
         dst_tmp = dst;
 
         src0 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src_tmp, src_stride_3x);
+        src3 = LSX_VLDX(src_tmp, src_stride_3x);
         src_tmp += src_stride_4x;
         src4 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src5, src6);
         src_tmp += src_stride_3x;
         DUP4_ARG2(__lsx_vilvl_b, src1, src0, src3, src2, src5, src4, src2, src1,
@@ -245,9 +245,9 @@ void common_vt_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
         for (loop_cnt = (height >> 2); loop_cnt--;) {
             src7 = __lsx_vld(src_tmp, 0);
-            DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+            DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                       src8, src9);
-            src10 = __lsx_vldx(src_tmp, src_stride_3x);
+            src10 = LSX_VLDX(src_tmp, src_stride_3x);
             src_tmp += src_stride_4x;
             DUP4_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src9, src8, src10,
                       src9, src76_r, src87_r, src98_r, src109_r);
@@ -304,7 +304,7 @@ void common_vt_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
     }
 }
 
-static void common_vt_8t_24w_lsx(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_24w_lsx(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -313,21 +313,21 @@ static void common_vt_8t_24w_lsx(uint8_t *src, int32_t src_stride,
                         height);
 }
 
-static void common_vt_8t_32w_lsx(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_32w_lsx(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
     common_vt_8t_16w_lsx(src, src_stride, dst, dst_stride, filter, height, 32);
 }
 
-static void common_vt_8t_48w_lsx(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_48w_lsx(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
     common_vt_8t_16w_lsx(src, src_stride, dst, dst_stride, filter, height, 48);
 }
 
-static void common_vt_8t_64w_lsx(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_64w_lsx(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -335,12 +335,12 @@ static void common_vt_8t_64w_lsx(uint8_t *src, int32_t src_stride,
 }
 
 static av_always_inline
-void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_8x2_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height, int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
@@ -380,12 +380,12 @@ void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
         dst_tmp = dst;
 
         src0 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src_tmp, src_stride_3x);
+        src3 = LSX_VLDX(src_tmp, src_stride_3x);
         src_tmp += src_stride_4x;
         src4 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src5, src6);
         src_tmp += src_stride_3x;
 
@@ -429,7 +429,7 @@ void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
         for (loop_cnt = height >> 1; loop_cnt--;) {
             src7 = __lsx_vld(src_tmp, 0);
-            src8 = __lsx_vldx(src_tmp, src_stride);
+            src8 = LSX_VLDX(src_tmp, src_stride);
             src_tmp += src_stride_2x;
 
             DUP4_ARG3(__lsx_vshuf_b, src7, src7, mask0, src7, src7, mask1, src7,
@@ -496,7 +496,7 @@ void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
     }
 }
 
-static void hevc_hv_8t_8w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_8t_8w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                               int32_t dst_stride, const int8_t *filter_x,
                               const int8_t *filter_y, int32_t height)
 {
@@ -504,7 +504,7 @@ static void hevc_hv_8t_8w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
                        filter_x, filter_y, height, 8);
 }
 
-static void hevc_hv_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_8t_16w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -512,7 +512,7 @@ static void hevc_hv_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
                       filter_x, filter_y, height, 16);
 }
 
-static void hevc_hv_8t_24w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_8t_24w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -520,7 +520,7 @@ static void hevc_hv_8t_24w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
                        filter_x, filter_y, height, 24);
 }
 
-static void hevc_hv_8t_32w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_8t_32w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -528,7 +528,7 @@ static void hevc_hv_8t_32w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
                        filter_x, filter_y, height, 32);
 }
 
-static void hevc_hv_8t_48w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_8t_48w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -536,7 +536,7 @@ static void hevc_hv_8t_48w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
                        filter_x, filter_y, height, 48);
 }
 
-static void hevc_hv_8t_64w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_8t_64w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -545,14 +545,14 @@ static void hevc_hv_8t_64w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static av_always_inline
-void common_vt_4t_24w_lsx(uint8_t *src, int32_t src_stride,
+void common_vt_4t_24w_lsx(const uint8_t *src, int32_t src_stride,
                           uint8_t *dst, int32_t dst_stride,
                           const int8_t *filter, int32_t height)
 {
     uint32_t loop_cnt;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_3x = src_stride_2x + src_stride;
-    uint8_t *_src;
+    const uint8_t *_src;
 
     __m128i src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     __m128i src11, filt0, filt1;
@@ -567,13 +567,13 @@ void common_vt_4t_24w_lsx(uint8_t *src, int32_t src_stride,
 
     /* 16 width */
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
     DUP2_ARG2(__lsx_vilvl_b, src1, src0, src2, src1, src10_r, src21_r);
     DUP2_ARG2(__lsx_vilvh_b, src1, src0, src2, src1, src10_l, src21_l);
 
     /* 8 width */
     src6 = __lsx_vld(_src, 0);
-    DUP2_ARG2(__lsx_vldx, _src, src_stride, _src, src_stride_2x, src7, src8);
+    DUP2_ARG2(LSX_VLDX, _src, src_stride, _src, src_stride_2x, src7, src8);
     src += src_stride_3x;
     _src += src_stride_3x;
     DUP2_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src76_r, src87_r);
@@ -581,7 +581,7 @@ void common_vt_4t_24w_lsx(uint8_t *src, int32_t src_stride,
     for (loop_cnt = 8; loop_cnt--;) {
         /* 16 width */
         DUP2_ARG2(__lsx_vld, src, 0, _src, 0, src3, src9);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, _src, src_stride, src4, src10);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, _src, src_stride, src4, src10);
         DUP2_ARG2(__lsx_vilvl_b, src3, src2, src4, src3, src32_r, src43_r);
         DUP2_ARG2(__lsx_vilvh_b, src3, src2, src4, src3, src32_l, src43_l);
 
@@ -615,7 +615,7 @@ void common_vt_4t_24w_lsx(uint8_t *src, int32_t src_stride,
 
         /* 16 width */
         DUP2_ARG2(__lsx_vld, src, 0, _src, 0, src5, src11);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, _src, src_stride, src2, src8);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, _src, src_stride, src2, src8);
         DUP2_ARG2(__lsx_vilvl_b, src5, src4, src2, src5, src10_r, src21_r);
         DUP2_ARG2(__lsx_vilvh_b, src5, src4, src2, src5, src10_l, src21_l);
 
@@ -651,7 +651,7 @@ void common_vt_4t_24w_lsx(uint8_t *src, int32_t src_stride,
 }
 
 static av_always_inline
-void common_vt_4t_32w_lsx(uint8_t *src, int32_t src_stride,
+void common_vt_4t_32w_lsx(const uint8_t *src, int32_t src_stride,
                           uint8_t *dst, int32_t dst_stride,
                           const int8_t *filter, int32_t height)
 {
@@ -659,7 +659,7 @@ void common_vt_4t_32w_lsx(uint8_t *src, int32_t src_stride,
     int32_t src_stride_2x = (src_stride << 1);
     int32_t dst_stride_2x = (dst_stride << 1);
     int32_t src_stride_3x = src_stride_2x + src_stride;
-    uint8_t *_src;
+    const uint8_t *_src;
 
     __m128i src0, src1, src2, src3, src4, src6, src7, src8, src9, src10;
     __m128i src10_r, src32_r, src76_r, src98_r;
@@ -676,14 +676,14 @@ void common_vt_4t_32w_lsx(uint8_t *src, int32_t src_stride,
 
     /* 16 width */
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
 
     DUP2_ARG2(__lsx_vilvl_b, src1, src0, src2, src1, src10_r, src21_r);
     DUP2_ARG2(__lsx_vilvh_b, src1, src0, src2, src1, src10_l, src21_l);
 
     /* next 16 width */
     src6 = __lsx_vld(_src, 0);
-    DUP2_ARG2(__lsx_vldx, _src, src_stride, _src, src_stride_2x, src7, src8);
+    DUP2_ARG2(LSX_VLDX, _src, src_stride, _src, src_stride_2x, src7, src8);
     src += src_stride_3x;
     _src += src_stride_3x;
 
@@ -693,7 +693,7 @@ void common_vt_4t_32w_lsx(uint8_t *src, int32_t src_stride,
     for (loop_cnt = (height >> 1); loop_cnt--;) {
         /* 16 width */
         DUP2_ARG2(__lsx_vld, src, 0, _src, 0, src3, src9);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, _src, src_stride, src4, src10);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, _src, src_stride, src4, src10);
         DUP2_ARG2(__lsx_vilvl_b, src3, src2, src4, src3, src32_r, src43_r);
         DUP2_ARG2(__lsx_vilvh_b, src3, src2, src4, src3, src32_l, src43_l);
 
@@ -745,7 +745,7 @@ void common_vt_4t_32w_lsx(uint8_t *src, int32_t src_stride,
 }
 
 static av_always_inline
-void hevc_hv_4t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_4t_8x2_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y)
 {
@@ -774,7 +774,7 @@ void hevc_hv_4t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
     mask1 = __lsx_vaddi_bu(mask0, 2);
     src0 = __lsx_vld(src, 0);
-    DUP4_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src,
+    DUP4_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src,
               src_stride_3x, src, src_stride_4x, src1, src2, src3, src4);
 
     DUP4_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1, src1, src1,
@@ -806,7 +806,7 @@ void hevc_hv_4t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static av_always_inline
-void hevc_hv_4t_8multx4_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_4t_8multx4_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                             int32_t dst_stride, const int8_t *filter_x,
                             const int8_t *filter_y, int32_t width8mult)
 {
@@ -838,11 +838,11 @@ void hevc_hv_4t_8multx4_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
     for (cnt = width8mult; cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
         src += (8 - src_stride_4x);
         DUP2_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1,
                   vec0, vec1);
@@ -902,7 +902,7 @@ void hevc_hv_4t_8multx4_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static av_always_inline
-void hevc_hv_4t_8x6_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_4t_8x6_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y)
 {
@@ -939,10 +939,10 @@ void hevc_hv_4t_8x6_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
     mask1 = __lsx_vaddi_bu(mask0, 2);
 
     src0 = __lsx_vld(src, 0);
-    DUP4_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,src,
+    DUP4_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,src,
               src_stride_3x, src, src_stride_4x, src1, src2, src3, src4);
     src += src_stride_4x;
-    DUP4_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,src,
+    DUP4_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,src,
               src_stride_3x, src, src_stride_4x, src5, src6, src7, src8);
 
     DUP4_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1, src1, src1,
@@ -1009,13 +1009,13 @@ void hevc_hv_4t_8x6_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static av_always_inline
-void hevc_hv_4t_8multx4mult_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_4t_8multx4mult_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                 int32_t dst_stride, const int8_t *filter_x,
                                 const int8_t *filter_y, int32_t height,
                                 int32_t width8mult)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
@@ -1051,7 +1051,7 @@ void hevc_hv_4t_8multx4mult_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
         dst_tmp = dst;
 
         src0 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src1, src2);
         src_tmp += src_stride_3x;
 
@@ -1073,9 +1073,9 @@ void hevc_hv_4t_8multx4mult_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
         for (loop_cnt = (height >> 2); loop_cnt--;) {
             src3 = __lsx_vld(src_tmp, 0);
-            DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+            DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                       src4, src5);
-            src6 = __lsx_vldx(src_tmp, src_stride_3x);
+            src6 = LSX_VLDX(src_tmp, src_stride_3x);
             src_tmp += src_stride_4x;
 
             DUP4_ARG3(__lsx_vshuf_b, src3, src3, mask0, src3, src3, mask1, src4,
@@ -1128,7 +1128,7 @@ void hevc_hv_4t_8multx4mult_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static
-void hevc_hv_4t_8w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_4t_8w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                        int32_t dst_stride, const int8_t *filter_x,
                        const int8_t *filter_y, int32_t height)
 {
@@ -1146,12 +1146,13 @@ void hevc_hv_4t_8w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static av_always_inline
-void hevc_hv_4t_12w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_4t_12w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp, *dst_tmp;
+    const uint8_t *src_tmp;
+    uint8_t *dst_tmp;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
     const int32_t src_stride_4x = (src_stride << 2);
@@ -1185,7 +1186,7 @@ void hevc_hv_4t_12w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
     dst_tmp = dst;
 
     src0 = __lsx_vld(src_tmp, 0);
-    DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
               src1, src2);
     src_tmp += src_stride_3x;
 
@@ -1204,9 +1205,9 @@ void hevc_hv_4t_12w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
     for (loop_cnt = 4; loop_cnt--;) {
         src3 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src4, src5);
-        src6 = __lsx_vldx(src_tmp, src_stride_3x);
+        src6 = LSX_VLDX(src_tmp, src_stride_3x);
         src_tmp += src_stride_4x;
 
         DUP4_ARG3(__lsx_vshuf_b, src3, src3, mask0, src3, src3, mask1, src4,
@@ -1260,7 +1261,7 @@ void hevc_hv_4t_12w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
     mask3 = __lsx_vaddi_bu(mask2, 2);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
     src += src_stride_3x;
     DUP2_ARG3(__lsx_vshuf_b, src1, src0, mask2, src1, src0, mask3, vec0, vec1);
     DUP2_ARG3(__lsx_vshuf_b, src2, src1, mask2, src2, src1, mask3, vec2, vec3);
@@ -1275,12 +1276,12 @@ void hevc_hv_4t_12w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
     for (loop_cnt = 2; loop_cnt--;) {
         src3 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src4, src5);
-        src6 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src4, src5);
+        src6 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         DUP4_ARG3(__lsx_vshuf_b, src7, src3, mask2, src7, src3, mask3, src8,
                   src4, mask2, src8, src4, mask3, vec0, vec1, vec2, vec3);
@@ -1333,7 +1334,7 @@ void hevc_hv_4t_12w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
     }
 }
 
-static void hevc_hv_4t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_4t_16w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -1346,7 +1347,7 @@ static void hevc_hv_4t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
     }
 }
 
-static void hevc_hv_4t_24w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_4t_24w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -1354,7 +1355,7 @@ static void hevc_hv_4t_24w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
                                filter_x, filter_y, height, 3);
 }
 
-static void hevc_hv_4t_32w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+static void hevc_hv_4t_32w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                                int32_t dst_stride, const int8_t *filter_x,
                                const int8_t *filter_y, int32_t height)
 {
@@ -1365,7 +1366,7 @@ static void hevc_hv_4t_32w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 #define UNI_MC(PEL, DIR, WIDTH, TAP, DIR1, FILT_DIR)                           \
 void ff_hevc_put_hevc_uni_##PEL##_##DIR##WIDTH##_8_lsx(uint8_t *dst,           \
                                                        ptrdiff_t dst_stride,   \
-                                                       uint8_t *src,           \
+                                                       const uint8_t *src,     \
                                                        ptrdiff_t src_stride,   \
                                                        int height,             \
                                                        intptr_t mx,            \
@@ -1393,7 +1394,7 @@ UNI_MC(epel, v, 32, 4, vt, my);
 #define UNI_MC_HV(PEL, WIDTH, TAP)                                         \
 void ff_hevc_put_hevc_uni_##PEL##_hv##WIDTH##_8_lsx(uint8_t *dst,          \
                                                     ptrdiff_t dst_stride,  \
-                                                    uint8_t *src,          \
+                                                    const uint8_t *src,    \
                                                     ptrdiff_t src_stride,  \
                                                     int height,            \
                                                     intptr_t mx,           \
diff --git a/libavcodec/loongarch/hevc_mc_uniw_lsx.c b/libavcodec/loongarch/hevc_mc_uniw_lsx.c
index 118f5b8..502bf24 100644
--- a/libavcodec/loongarch/hevc_mc_uniw_lsx.c
+++ b/libavcodec/loongarch/hevc_mc_uniw_lsx.c
@@ -31,13 +31,13 @@ static const uint8_t ff_hevc_mask_arr[16 * 2] __attribute__((aligned(0x40))) = {
 };
 
 static av_always_inline
-void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_8x2_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height, int32_t weight,
                         int32_t offset, int32_t rnd_val, int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     const int32_t src_stride_2x = (src_stride << 1);
     const int32_t dst_stride_2x = (dst_stride << 1);
@@ -79,12 +79,12 @@ void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
         dst_tmp = dst;
 
         src0 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src_tmp, src_stride_3x);
+        src3 = LSX_VLDX(src_tmp, src_stride_3x);
         src_tmp += src_stride_4x;
         src4 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src5, src6);
         src_tmp += src_stride_3x;
 
@@ -127,7 +127,7 @@ void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 
         for (loop_cnt = height >> 1; loop_cnt--;) {
             src7 = __lsx_vld(src_tmp, 0);
-            src8 = __lsx_vldx(src_tmp, src_stride);
+            src8 = LSX_VLDX(src_tmp, src_stride);
             src_tmp += src_stride_2x;
             DUP4_ARG3(__lsx_vshuf_b, src7, src7, mask0, src7, src7, mask1, src7,
                       src7, mask2, src7, src7, mask3, vec0, vec1, vec2, vec3);
@@ -207,7 +207,7 @@ void hevc_hv_8t_8x2_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static
-void hevc_hv_8t_8w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_8w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                        int32_t dst_stride, const int8_t *filter_x,
                        const int8_t *filter_y, int32_t height, int32_t weight,
                        int32_t offset, int32_t rnd_val)
@@ -217,7 +217,7 @@ void hevc_hv_8t_8w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static
-void hevc_hv_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_16w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height, int32_t weight,
                         int32_t offset, int32_t rnd_val)
@@ -227,7 +227,7 @@ void hevc_hv_8t_16w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static
-void hevc_hv_8t_24w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_24w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height, int32_t weight,
                         int32_t offset, int32_t rnd_val)
@@ -237,7 +237,7 @@ void hevc_hv_8t_24w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static
-void hevc_hv_8t_32w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_32w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height, int32_t weight,
                         int32_t offset, int32_t rnd_val)
@@ -247,7 +247,7 @@ void hevc_hv_8t_32w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static
-void hevc_hv_8t_48w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_48w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height, int32_t weight,
                         int32_t offset, int32_t rnd_val)
@@ -257,7 +257,7 @@ void hevc_hv_8t_48w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 }
 
 static
-void hevc_hv_8t_64w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
+void hevc_hv_8t_64w_lsx(const uint8_t *src, int32_t src_stride, uint8_t *dst,
                         int32_t dst_stride, const int8_t *filter_x,
                         const int8_t *filter_y, int32_t height, int32_t weight,
                         int32_t offset, int32_t rnd_val)
@@ -270,7 +270,7 @@ void hevc_hv_8t_64w_lsx(uint8_t *src, int32_t src_stride, uint8_t *dst,
 #define UNI_W_MC_HV(PEL, WIDTH, TAP)                                           \
 void ff_hevc_put_hevc_uni_w_##PEL##_hv##WIDTH##_8_lsx(uint8_t *dst,            \
                                                       ptrdiff_t dst_stride,    \
-                                                      uint8_t *src,            \
+                                                      const uint8_t *src,      \
                                                       ptrdiff_t src_stride,    \
                                                       int height,              \
                                                       int denom,               \
diff --git a/libavcodec/loongarch/hevcdsp_lsx.c b/libavcodec/loongarch/hevcdsp_lsx.c
index a520f02..86fc5f0 100644
--- a/libavcodec/loongarch/hevcdsp_lsx.c
+++ b/libavcodec/loongarch/hevcdsp_lsx.c
@@ -31,7 +31,7 @@ static const uint8_t ff_hevc_mask_arr[16 * 2] __attribute__((aligned(0x40))) = {
 };
 
 /* hevc_copy: dst = src << 6 */
-static void hevc_copy_4w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_4w_lsx(const uint8_t *src, int32_t src_stride,
                              int16_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -48,14 +48,14 @@ static void hevc_copy_4w_lsx(uint8_t *src, int32_t src_stride,
     __m128i in0, in1, in2, in3;
     for (; loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src5, src6);
-        src7 = __lsx_vldx(src, src_stride_3x);
+        src7 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vilvl_w, src1, src0, src3, src2, src5, src4, src7, src6,
@@ -83,7 +83,7 @@ static void hevc_copy_4w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_6w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_6w_lsx(const uint8_t *src, int32_t src_stride,
                              int16_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -98,12 +98,12 @@ static void hevc_copy_6w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 3); loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
-        src7 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
+        src7 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vsllwil_hu_bu, src0, 6, src1, 6, src2, 6, src3, 6,
@@ -146,7 +146,7 @@ static void hevc_copy_6w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_8w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_8w_lsx(const uint8_t *src, int32_t src_stride,
                              int16_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -163,14 +163,14 @@ static void hevc_copy_8w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 3); loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src5, src6);
-        src7 = __lsx_vldx(src, src_stride_3x);
+        src7 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vsllwil_hu_bu, src0, 6, src1, 6, src2, 6, src3, 6,
@@ -197,7 +197,7 @@ static void hevc_copy_8w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_12w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_12w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -215,12 +215,12 @@ static void hevc_copy_12w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 3); loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
-        src7 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
+        src7 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vsllwil_hu_bu, src0, 6, src1, 6, src2, 6, src3, 6,
@@ -269,7 +269,7 @@ static void hevc_copy_12w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_16w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_16w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -288,14 +288,14 @@ static void hevc_copy_16w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 3); loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src5, src6);
-        src7 = __lsx_vldx(src, src_stride_3x);
+        src7 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         DUP4_ARG2(__lsx_vilvh_b, zero, src0, zero, src1, zero, src2, zero, src3,
                   in0_l, in1_l, in2_l, in3_l);
@@ -333,8 +333,8 @@ static void hevc_copy_16w_lsx(uint8_t *src, int32_t src_stride,
     }
     if (res) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
 
         DUP4_ARG2(__lsx_vilvh_b, zero, src0, zero, src1, zero, src2, zero, src3,
                   in0_l, in1_l, in2_l, in3_l);
@@ -354,7 +354,7 @@ static void hevc_copy_16w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_24w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_24w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -365,7 +365,7 @@ static void hevc_copy_24w_lsx(uint8_t *src, int32_t src_stride,
     int32_t dst_stride_2x = (dst_stride << 2);
     int32_t src_stride_3x = src_stride_2x + src_stride;
     int32_t dst_stride_3x = dst_stride_2x + dst_stride_x;
-    uint8_t *_src = src + 16;
+    const uint8_t *_src = src + 16;
     int16_t *dst1 = dst;
     __m128i zero = __lsx_vldi(0);
     __m128i src0, src1, src2, src3, src4, src5, src6, src7;
@@ -373,13 +373,13 @@ static void hevc_copy_24w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(_src, 0);
-        DUP2_ARG2(__lsx_vldx, _src, src_stride, _src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, _src, src_stride, _src, src_stride_2x,
                   src5, src6);
-        src7 = __lsx_vldx(_src, src_stride_3x);
+        src7 = LSX_VLDX(_src, src_stride_3x);
         _src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vilvh_b, zero, src0, zero, src1, zero, src2, zero,
@@ -408,7 +408,7 @@ static void hevc_copy_24w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_32w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_32w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -416,20 +416,20 @@ static void hevc_copy_32w_lsx(uint8_t *src, int32_t src_stride,
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_4x = (src_stride << 2);
     int32_t src_stride_3x = src_stride_2x + src_stride;
-    uint8_t *_src = src + 16;
+    const uint8_t *_src = src + 16;
     __m128i zero = {0};
     __m128i src0, src1, src2, src3, src4, src5, src6, src7;
     __m128i in0_r, in1_r, in2_r, in3_r, in0_l, in1_l, in2_l, in3_l;
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src2, src4);
-        src6 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src2, src4);
+        src6 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src1 = __lsx_vld(_src, 0);
-        DUP2_ARG2(__lsx_vldx, _src, src_stride, _src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, _src, src_stride, _src, src_stride_2x,
                   src3, src5);
-        src7 = __lsx_vldx(_src, src_stride_3x);
+        src7 = LSX_VLDX(_src, src_stride_3x);
         _src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vilvh_b, zero, src0, zero, src1, zero, src2, zero,
@@ -468,7 +468,7 @@ static void hevc_copy_32w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_48w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_48w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -543,7 +543,7 @@ static void hevc_copy_48w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_64w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_copy_64w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -595,7 +595,7 @@ static void hevc_copy_64w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_4w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_4w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -623,12 +623,12 @@ static void hevc_hz_8t_4w_lsx(uint8_t *src, int32_t src_stride,
 
     for (;loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src4 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
-        src7 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
+        src7 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         DUP4_ARG3(__lsx_vshuf_b, src1, src0, mask0, src1, src0, mask1, src1,
                   src0, mask2, src1, src0, mask3, vec0, vec1, vec2, vec3);
@@ -668,7 +668,7 @@ static void hevc_hz_8t_4w_lsx(uint8_t *src, int32_t src_stride,
     }
     for (;res--;) {
         src0 = __lsx_vld(src, 0);
-        src1 = __lsx_vldx(src, src_stride);
+        src1 = LSX_VLDX(src, src_stride);
         DUP4_ARG3(__lsx_vshuf_b, src1, src0, mask0, src1, src0, mask1, src1,
                   src0, mask2, src1, src0, mask3, vec0, vec1, vec2, vec3);
         dst0 = __lsx_vdp2_h_bu_b(vec0, filt0);
@@ -682,7 +682,7 @@ static void hevc_hz_8t_4w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_8w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_8w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -709,8 +709,8 @@ static void hevc_hz_8t_8w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1, src0,
@@ -746,7 +746,7 @@ static void hevc_hz_8t_8w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_12w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_12w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -754,7 +754,7 @@ static void hevc_hz_8t_12w_lsx(uint8_t *src, int32_t src_stride,
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_4x = (src_stride << 2);
     int32_t src_stride_3x = src_stride_2x + src_stride;
-    uint8_t *_src;
+    const uint8_t *_src;
     __m128i src0, src1, src2, src3, src4, src5, src6, src7;
     __m128i mask0, mask1, mask2, mask3, mask4, mask5, mask6, mask7;
     __m128i vec0, vec1, vec2, vec3, vec4, vec5;
@@ -774,12 +774,12 @@ static void hevc_hz_8t_12w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = 4; loop_cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-        src3 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+        src3 = LSX_VLDX(src, src_stride_3x);
         src4 = __lsx_vld(_src, 0);
-        DUP2_ARG2(__lsx_vldx, _src, src_stride, _src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, _src, src_stride, _src, src_stride_2x,
                   src5, src6);
-        src7 = __lsx_vldx(_src, src_stride_3x);
+        src7 = LSX_VLDX(_src, src_stride_3x);
         src += src_stride_4x;
         _src += src_stride_4x;
 
@@ -838,7 +838,7 @@ static void hevc_hz_8t_12w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_16w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_16w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -898,7 +898,7 @@ static void hevc_hz_8t_16w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_24w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_24w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -968,7 +968,7 @@ static void hevc_hz_8t_24w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_32w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_32w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1028,7 +1028,7 @@ static void hevc_hz_8t_32w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_48w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_48w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1097,7 +1097,7 @@ static void hevc_hz_8t_48w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_64w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_64w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1191,7 +1191,7 @@ static void hevc_hz_8t_64w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_4w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_4w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -1216,11 +1216,11 @@ static void hevc_vt_8t_4w_lsx(uint8_t *src, int32_t src_stride,
               filt0, filt1, filt2, filt3);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-    src3 = __lsx_vldx(src, src_stride_3x);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+    src3 = LSX_VLDX(src, src_stride_3x);
     src += src_stride_4x;
     src4 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
     src += src_stride_3x;
     DUP4_ARG2(__lsx_vilvl_b, src1, src0, src3, src2, src5, src4, src2, src1,
               src10_r, src32_r, src54_r, src21_r);
@@ -1231,13 +1231,13 @@ static void hevc_vt_8t_4w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 3); loop_cnt--;) {
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src11 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x,
                   src12, src13);
-        src14 = __lsx_vldx(src, src_stride_3x);
+        src14 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src9, src8, src10, src9,
@@ -1289,7 +1289,7 @@ static void hevc_vt_8t_4w_lsx(uint8_t *src, int32_t src_stride,
     }
     for (;res--;) {
         src7 = __lsx_vld(src, 0);
-        src8 = __lsx_vldx(src, src_stride);
+        src8 = LSX_VLDX(src, src_stride);
         DUP2_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src76_r, src87_r);
         src += src_stride_2x;
         src8776 = __lsx_vilvl_d(src87_r, src76_r);
@@ -1311,7 +1311,7 @@ static void hevc_vt_8t_4w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_8w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -1334,11 +1334,11 @@ static void hevc_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
               filt0, filt1, filt2, filt3);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-    src3 = __lsx_vldx(src, src_stride_3x);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+    src3 = LSX_VLDX(src, src_stride_3x);
     src += src_stride_4x;
     src4 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
     src += src_stride_3x;
     DUP4_ARG2(__lsx_vilvl_b, src1, src0, src3, src2, src5, src4, src2, src1,
               src10_r, src32_r, src54_r, src21_r);
@@ -1346,8 +1346,8 @@ static void hevc_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         DUP4_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src9, src8, src10,
                   src9, src76_r, src87_r, src98_r, src109_r);
@@ -1385,7 +1385,7 @@ static void hevc_vt_8t_8w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_12w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_12w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1408,11 +1408,11 @@ static void hevc_vt_8t_12w_lsx(uint8_t *src, int32_t src_stride,
     DUP4_ARG2(__lsx_vldrepl_h, filter, 0, filter, 2, filter, 4, filter, 6,
               filt0, filt1, filt2, filt3);
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-    src3 = __lsx_vldx(src, src_stride_3x);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+    src3 = LSX_VLDX(src, src_stride_3x);
     src += src_stride_4x;
     src4 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
     src += src_stride_3x;
     DUP4_ARG2(__lsx_vilvl_b, src1, src0, src3, src2, src5, src4, src2, src1,
               src10_r, src32_r, src54_r, src21_r);
@@ -1426,8 +1426,8 @@ static void hevc_vt_8t_12w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         DUP4_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src9, src8, src10,
                   src9, src76_r, src87_r, src98_r, src109_r);
@@ -1487,7 +1487,7 @@ static void hevc_vt_8t_12w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_16multx4mult_lsx(uint8_t *src,
+static void hevc_vt_8t_16multx4mult_lsx(const uint8_t *src,
                                         int32_t src_stride,
                                         int16_t *dst,
                                         int32_t dst_stride,
@@ -1495,7 +1495,7 @@ static void hevc_vt_8t_16multx4mult_lsx(uint8_t *src,
                                         int32_t height,
                                         int32_t width)
 {
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     int32_t loop_cnt, cnt;
     int32_t src_stride_2x = (src_stride << 1);
@@ -1520,12 +1520,12 @@ static void hevc_vt_8t_16multx4mult_lsx(uint8_t *src,
         dst_tmp = dst;
 
         src0 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src_tmp, src_stride_3x);
+        src3 = LSX_VLDX(src_tmp, src_stride_3x);
         src_tmp += src_stride_4x;
         src4 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src5, src6);
         src_tmp += src_stride_3x;
         DUP4_ARG2(__lsx_vilvl_b, src1, src0, src3, src2, src5, src4, src2, src1,
@@ -1537,9 +1537,9 @@ static void hevc_vt_8t_16multx4mult_lsx(uint8_t *src,
 
         for (loop_cnt = (height >> 2); loop_cnt--;) {
             src7 = __lsx_vld(src_tmp, 0);
-            DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+            DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                       src8, src9);
-            src10 = __lsx_vldx(src_tmp, src_stride_3x);
+            src10 = LSX_VLDX(src_tmp, src_stride_3x);
             src_tmp += src_stride_4x;
             DUP4_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src9, src8,
                       src10, src9, src76_r, src87_r, src98_r, src109_r);
@@ -1611,7 +1611,7 @@ static void hevc_vt_8t_16multx4mult_lsx(uint8_t *src,
     }
 }
 
-static void hevc_vt_8t_16w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_16w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1619,7 +1619,7 @@ static void hevc_vt_8t_16w_lsx(uint8_t *src, int32_t src_stride,
                                 filter, height, 16);
 }
 
-static void hevc_vt_8t_24w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_24w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1629,7 +1629,7 @@ static void hevc_vt_8t_24w_lsx(uint8_t *src, int32_t src_stride,
                       filter, height);
 }
 
-static void hevc_vt_8t_32w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_32w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1637,7 +1637,7 @@ static void hevc_vt_8t_32w_lsx(uint8_t *src, int32_t src_stride,
                                 filter, height, 32);
 }
 
-static void hevc_vt_8t_48w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_48w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1645,7 +1645,7 @@ static void hevc_vt_8t_48w_lsx(uint8_t *src, int32_t src_stride,
                                 filter, height, 48);
 }
 
-static void hevc_vt_8t_64w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_64w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1653,7 +1653,7 @@ static void hevc_vt_8t_64w_lsx(uint8_t *src, int32_t src_stride,
                                 filter, height, 64);
 }
 
-static void hevc_hv_8t_4w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_4w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter_x, const int8_t *filter_y,
                               int32_t height)
@@ -1689,11 +1689,11 @@ static void hevc_hv_8t_4w_lsx(uint8_t *src, int32_t src_stride,
     mask3 = __lsx_vaddi_bu(mask0, 6);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-    src3 = __lsx_vldx(src, src_stride_3x);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+    src3 = LSX_VLDX(src, src_stride_3x);
     src += src_stride_4x;
     src4 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
     src += src_stride_3x;
 
     DUP4_ARG3(__lsx_vshuf_b, src3, src0, mask0, src3, src0, mask1, src3, src0,
@@ -1729,8 +1729,8 @@ static void hevc_hv_8t_4w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = height >> 2; loop_cnt--;) {
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG3(__lsx_vshuf_b, src9, src7, mask0, src9, src7, mask1, src9, src7,
@@ -1785,7 +1785,7 @@ static void hevc_hv_8t_4w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hv_8t_8multx1mult_lsx(uint8_t *src,
+static void hevc_hv_8t_8multx1mult_lsx(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -1795,7 +1795,7 @@ static void hevc_hv_8t_8multx1mult_lsx(uint8_t *src,
                                        int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_4x = (src_stride << 2);
@@ -1830,12 +1830,12 @@ static void hevc_hv_8t_8multx1mult_lsx(uint8_t *src,
         src_tmp = src;
         dst_tmp = dst;
         src0 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src1, src2);
-        src3 = __lsx_vldx(src_tmp, src_stride_3x);
+        src3 = LSX_VLDX(src_tmp, src_stride_3x);
         src_tmp += src_stride_4x;
         src4 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src5, src6);
         src_tmp += src_stride_3x;
 
@@ -1928,7 +1928,7 @@ static void hevc_hv_8t_8multx1mult_lsx(uint8_t *src,
     }
 }
 
-static void hevc_hv_8t_8w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_8w_lsx(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter_x, const int8_t *filter_y,
                               int32_t height)
@@ -1937,13 +1937,13 @@ static void hevc_hv_8t_8w_lsx(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 8);
 }
 
-static void hevc_hv_8t_12w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_12w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_4x = (src_stride << 2);
@@ -1978,12 +1978,12 @@ static void hevc_hv_8t_12w_lsx(uint8_t *src, int32_t src_stride,
     dst_tmp = dst;
 
     src0 = __lsx_vld(src_tmp, 0);
-    DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
               src1, src2);
-    src3 = __lsx_vldx(src_tmp, src_stride_3x);
+    src3 = LSX_VLDX(src_tmp, src_stride_3x);
     src_tmp += src_stride_4x;
     src4 = __lsx_vld(src_tmp, 0);
-    DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
               src5, src6);
     src_tmp += src_stride_3x;
 
@@ -2077,11 +2077,11 @@ static void hevc_hv_8t_12w_lsx(uint8_t *src, int32_t src_stride,
     mask7 = __lsx_vaddi_bu(mask4, 6);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-    src3 = __lsx_vldx(src, src_stride_3x);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+    src3 = LSX_VLDX(src, src_stride_3x);
     src += src_stride_4x;
     src4 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
     src += src_stride_3x;
 
     DUP4_ARG3(__lsx_vshuf_b, src3, src0, mask4, src3, src0, mask5, src3, src0,
@@ -2118,8 +2118,8 @@ static void hevc_hv_8t_12w_lsx(uint8_t *src, int32_t src_stride,
 
     for (loop_cnt = height >> 2; loop_cnt--;) {
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
 
         DUP4_ARG3(__lsx_vshuf_b, src9, src7, mask4, src9, src7, mask5, src9,
@@ -2174,7 +2174,7 @@ static void hevc_hv_8t_12w_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hv_8t_16w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_16w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2183,7 +2183,7 @@ static void hevc_hv_8t_16w_lsx(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 16);
 }
 
-static void hevc_hv_8t_24w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_24w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2192,7 +2192,7 @@ static void hevc_hv_8t_24w_lsx(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 24);
 }
 
-static void hevc_hv_8t_32w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_32w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2201,7 +2201,7 @@ static void hevc_hv_8t_32w_lsx(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 32);
 }
 
-static void hevc_hv_8t_48w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_48w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2210,7 +2210,7 @@ static void hevc_hv_8t_48w_lsx(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 48);
 }
 
-static void hevc_hv_8t_64w_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_64w_lsx(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -2219,7 +2219,7 @@ static void hevc_hv_8t_64w_lsx(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 64);
 }
 
-static void hevc_hz_4t_32w_lsx(uint8_t *src,
+static void hevc_hz_4t_32w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2265,7 +2265,7 @@ static void hevc_hz_4t_32w_lsx(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_16w_lsx(uint8_t *src,
+static void hevc_vt_4t_16w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2285,14 +2285,14 @@ static void hevc_vt_4t_16w_lsx(uint8_t *src,
     DUP2_ARG2(__lsx_vldrepl_h, filter, 0, filter, 2, filt0, filt1);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
     src += src_stride_3x;
     DUP2_ARG2(__lsx_vilvl_b, src1, src0, src2, src1, src10_r, src21_r);
     DUP2_ARG2(__lsx_vilvh_b, src1, src0, src2, src1, src10_l, src21_l);
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         src3 = __lsx_vld(src, 0);
-        src4 = __lsx_vldx(src, src_stride);
+        src4 = LSX_VLDX(src, src_stride);
         src += src_stride_2x;
         DUP2_ARG2(__lsx_vilvl_b, src3, src2, src4, src3, src32_r, src43_r);
         DUP2_ARG2(__lsx_vilvh_b, src3, src2, src4, src3, src32_l, src43_l);
@@ -2309,7 +2309,7 @@ static void hevc_vt_4t_16w_lsx(uint8_t *src,
         dst += dst_stride;
 
         src5 = __lsx_vld(src, 0);
-        src2 = __lsx_vldx(src, src_stride);
+        src2 = LSX_VLDX(src, src_stride);
         src += src_stride_2x;
         DUP2_ARG2(__lsx_vilvl_b, src5, src4, src2, src5, src10_r, src21_r);
         DUP2_ARG2(__lsx_vilvh_b, src5, src4, src2, src5, src10_l, src21_l);
@@ -2327,7 +2327,7 @@ static void hevc_vt_4t_16w_lsx(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_24w_lsx(uint8_t *src,
+static void hevc_vt_4t_24w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2337,7 +2337,7 @@ static void hevc_vt_4t_24w_lsx(uint8_t *src,
     int32_t loop_cnt;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_3x = src_stride_2x + src_stride;
-    uint8_t *_src;
+    const uint8_t *_src;
 
     __m128i src0, src1, src2, src3, src4, src5;
     __m128i src6, src7, src8, src9, src10, src11;
@@ -2353,19 +2353,19 @@ static void hevc_vt_4t_24w_lsx(uint8_t *src,
     DUP2_ARG2(__lsx_vldrepl_h, filter, 0, filter, 2, filt0, filt1);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
     DUP2_ARG2(__lsx_vilvl_b, src1, src0, src2, src1, src10_r, src21_r);
     DUP2_ARG2(__lsx_vilvh_b, src1, src0, src2, src1, src10_l, src21_l);
 
     src6 = __lsx_vld(_src, 0);
-    DUP2_ARG2(__lsx_vldx, _src, src_stride, _src, src_stride_2x, src7, src8);
+    DUP2_ARG2(LSX_VLDX, _src, src_stride, _src, src_stride_2x, src7, src8);
     src  += src_stride_3x;
     _src += src_stride_3x;
     DUP2_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src76_r, src87_r);
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         DUP2_ARG2(__lsx_vld, src, 0, _src, 0, src3, src9);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, _src, src_stride, src4, src10);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, _src, src_stride, src4, src10);
         src  += src_stride_2x;
         _src += src_stride_2x;
         DUP2_ARG2(__lsx_vilvl_b, src3, src2, src4, src3, src32_r, src43_r);
@@ -2392,7 +2392,7 @@ static void hevc_vt_4t_24w_lsx(uint8_t *src,
         dst += dst_stride;
 
         DUP2_ARG2(__lsx_vld, src, 0, _src, 0, src5, src11);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, _src, src_stride, src2, src8);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, _src, src_stride, src2, src8);
         src  += src_stride_2x;
         _src += src_stride_2x;
         DUP2_ARG2(__lsx_vilvl_b, src5, src4, src2, src5, src10_r, src21_r);
@@ -2421,7 +2421,7 @@ static void hevc_vt_4t_24w_lsx(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_32w_lsx(uint8_t *src,
+static void hevc_vt_4t_32w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2431,7 +2431,7 @@ static void hevc_vt_4t_32w_lsx(uint8_t *src,
     int32_t loop_cnt;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t src_stride_3x = src_stride_2x + src_stride;
-    uint8_t *_src;
+    const uint8_t *_src;
 
     __m128i src0, src1, src2, src3, src4, src5;
     __m128i src6, src7, src8, src9, src10, src11;
@@ -2448,12 +2448,12 @@ static void hevc_vt_4t_32w_lsx(uint8_t *src,
     DUP2_ARG2(__lsx_vldrepl_h, filter, 0, filter, 2, filt0, filt1);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
     DUP2_ARG2(__lsx_vilvl_b, src1, src0, src2, src1, src10_r, src21_r);
     DUP2_ARG2(__lsx_vilvh_b, src1, src0, src2, src1, src10_l, src21_l);
 
     src6 = __lsx_vld(_src, 0);
-    DUP2_ARG2(__lsx_vldx, _src, src_stride, _src, src_stride_2x, src7, src8);
+    DUP2_ARG2(LSX_VLDX, _src, src_stride, _src, src_stride_2x, src7, src8);
     src  += src_stride_3x;
     _src += src_stride_3x;
     DUP2_ARG2(__lsx_vilvl_b, src7, src6, src8, src7, src76_r, src87_r);
@@ -2461,7 +2461,7 @@ static void hevc_vt_4t_32w_lsx(uint8_t *src,
 
     for (loop_cnt = (height >> 2); loop_cnt--;) {
         DUP2_ARG2(__lsx_vld, src, 0, _src, 0, src3, src9);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, _src, src_stride, src4, src10);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, _src, src_stride, src4, src10);
         src  += src_stride_2x;
         _src += src_stride_2x;
         DUP2_ARG2(__lsx_vilvl_b, src3, src2, src4, src3, src32_r, src43_r);
@@ -2493,7 +2493,7 @@ static void hevc_vt_4t_32w_lsx(uint8_t *src,
         dst += dst_stride;
 
         DUP2_ARG2(__lsx_vld, src, 0, _src, 0, src5, src11);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, _src, src_stride, src2, src8);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, _src, src_stride, src2, src8);
         src  += src_stride_2x;
         _src += src_stride_2x;
         DUP2_ARG2(__lsx_vilvl_b, src5, src4, src2, src5, src10_r, src21_r);
@@ -2527,7 +2527,7 @@ static void hevc_vt_4t_32w_lsx(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_8x2_lsx(uint8_t *src,
+static void hevc_hv_4t_8x2_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2560,9 +2560,9 @@ static void hevc_hv_4t_8x2_lsx(uint8_t *src,
     mask1 = __lsx_vaddi_bu(mask0, 2);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
-    src3 = __lsx_vldx(src, src_stride_3x);
-    src4 = __lsx_vldx(src, src_stride_4x);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
+    src3 = LSX_VLDX(src, src_stride_3x);
+    src4 = LSX_VLDX(src, src_stride_4x);
 
     DUP2_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1, vec0, vec1);
     DUP2_ARG3(__lsx_vshuf_b, src1, src1, mask0, src1, src1, mask1, vec2, vec3);
@@ -2594,7 +2594,7 @@ static void hevc_hv_4t_8x2_lsx(uint8_t *src,
     __lsx_vst(dst1_r, dst + dst_stride, 0);
 }
 
-static void hevc_hv_4t_8multx4_lsx(uint8_t *src, int32_t src_stride,
+static void hevc_hv_4t_8multx4_lsx(const uint8_t *src, int32_t src_stride,
                                    int16_t *dst, int32_t dst_stride,
                                    const int8_t *filter_x,
                                    const int8_t *filter_y, int32_t width8mult)
@@ -2627,10 +2627,10 @@ static void hevc_hv_4t_8multx4_lsx(uint8_t *src, int32_t src_stride,
 
     for (cnt = width8mult; cnt--;) {
         src0 = __lsx_vld(src, 0);
-        DUP4_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src,
+        DUP4_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src,
                   src_stride_3x, src, src_stride_4x, src1, src2, src3, src4);
         src += src_stride_4x;
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src5, src6);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src5, src6);
         src += (8 - src_stride_4x);
 
         DUP2_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1,
@@ -2694,7 +2694,7 @@ static void hevc_hv_4t_8multx4_lsx(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hv_4t_8x6_lsx(uint8_t *src,
+static void hevc_hv_4t_8x6_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2730,10 +2730,10 @@ static void hevc_hv_4t_8x6_lsx(uint8_t *src,
     mask1 = __lsx_vaddi_bu(mask0, 2);
 
     src0 = __lsx_vld(src, 0);
-    DUP4_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src,
+    DUP4_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src,
               src_stride_3x, src, src_stride_4x, src1, src2, src3, src4);
     src += src_stride_4x;
-    DUP4_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src,
+    DUP4_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src,
               src_stride_3x, src, src_stride_4x, src5, src6, src7, src8);
 
     DUP4_ARG3(__lsx_vshuf_b, src0, src0, mask0, src0, src0, mask1, src1, src1,
@@ -2803,7 +2803,7 @@ static void hevc_hv_4t_8x6_lsx(uint8_t *src,
     __lsx_vstx(dst5_r, dst, dst_stride_2x);
 }
 
-static void hevc_hv_4t_8multx4mult_lsx(uint8_t *src,
+static void hevc_hv_4t_8multx4mult_lsx(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -2813,7 +2813,7 @@ static void hevc_hv_4t_8multx4mult_lsx(uint8_t *src,
                                        int32_t width8mult)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t dst_stride_x  = (dst_stride << 1);
@@ -2847,7 +2847,7 @@ static void hevc_hv_4t_8multx4mult_lsx(uint8_t *src,
         dst_tmp = dst;
 
         src0 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src1, src2);
         src_tmp += src_stride_3x;
 
@@ -2869,9 +2869,9 @@ static void hevc_hv_4t_8multx4mult_lsx(uint8_t *src,
 
         for (loop_cnt = height >> 2; loop_cnt--;) {
             src3 = __lsx_vld(src_tmp, 0);
-            DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+            DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                       src4, src5);
-            src6 = __lsx_vldx(src_tmp, src_stride_3x);
+            src6 = LSX_VLDX(src_tmp, src_stride_3x);
             src_tmp += src_stride_4x;
 
             DUP2_ARG3(__lsx_vshuf_b, src3, src3, mask0, src3, src3, mask1,
@@ -2930,7 +2930,7 @@ static void hevc_hv_4t_8multx4mult_lsx(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_8w_lsx(uint8_t *src,
+static void hevc_hv_4t_8w_lsx(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -2954,7 +2954,7 @@ static void hevc_hv_4t_8w_lsx(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_12w_lsx(uint8_t *src,
+static void hevc_hv_4t_12w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2963,7 +2963,7 @@ static void hevc_hv_4t_12w_lsx(uint8_t *src,
                                int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     int32_t src_stride_2x = (src_stride << 1);
     int32_t dst_stride_x  = (dst_stride << 1);
@@ -2997,7 +2997,7 @@ static void hevc_hv_4t_12w_lsx(uint8_t *src,
     dst_tmp = dst;
 
     src0 = __lsx_vld(src_tmp, 0);
-    DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+    DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
               src1, src2);
     src_tmp += src_stride_3x;
 
@@ -3016,9 +3016,9 @@ static void hevc_hv_4t_12w_lsx(uint8_t *src,
 
     for (loop_cnt = 4; loop_cnt--;) {
         src3 = __lsx_vld(src_tmp, 0);
-        DUP2_ARG2(__lsx_vldx, src_tmp, src_stride, src_tmp, src_stride_2x,
+        DUP2_ARG2(LSX_VLDX, src_tmp, src_stride, src_tmp, src_stride_2x,
                   src4, src5);
-        src6 = __lsx_vldx(src_tmp, src_stride_3x);
+        src6 = LSX_VLDX(src_tmp, src_stride_3x);
         src_tmp += src_stride_4x;
 
         DUP2_ARG3(__lsx_vshuf_b, src3, src3, mask0, src3, src3, mask1,
@@ -3077,7 +3077,7 @@ static void hevc_hv_4t_12w_lsx(uint8_t *src,
     mask3 = __lsx_vaddi_bu(mask2, 2);
 
     src0 = __lsx_vld(src, 0);
-    DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src1, src2);
+    DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src1, src2);
     src += src_stride_3x;
     DUP2_ARG3(__lsx_vshuf_b, src1, src0, mask2, src1, src0, mask3, vec0, vec1);
     DUP2_ARG3(__lsx_vshuf_b, src2, src1, mask2, src2, src1, mask3, vec2, vec3);
@@ -3090,12 +3090,12 @@ static void hevc_hv_4t_12w_lsx(uint8_t *src,
 
     for (loop_cnt = 2; loop_cnt--;) {
         src3 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src4, src5);
-        src6 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src4, src5);
+        src6 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         src7 = __lsx_vld(src, 0);
-        DUP2_ARG2(__lsx_vldx, src, src_stride, src, src_stride_2x, src8, src9);
-        src10 = __lsx_vldx(src, src_stride_3x);
+        DUP2_ARG2(LSX_VLDX, src, src_stride, src, src_stride_2x, src8, src9);
+        src10 = LSX_VLDX(src, src_stride_3x);
         src += src_stride_4x;
         DUP2_ARG3(__lsx_vshuf_b, src7, src3, mask2, src7, src3, mask3,
                   vec0, vec1);
@@ -3159,7 +3159,7 @@ static void hevc_hv_4t_12w_lsx(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_16w_lsx(uint8_t *src,
+static void hevc_hv_4t_16w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3176,7 +3176,7 @@ static void hevc_hv_4t_16w_lsx(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_24w_lsx(uint8_t *src,
+static void hevc_hv_4t_24w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3188,7 +3188,7 @@ static void hevc_hv_4t_24w_lsx(uint8_t *src,
                                filter_x, filter_y, height, 3);
 }
 
-static void hevc_hv_4t_32w_lsx(uint8_t *src,
+static void hevc_hv_4t_32w_lsx(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3202,7 +3202,7 @@ static void hevc_hv_4t_32w_lsx(uint8_t *src,
 
 #define MC_COPY(WIDTH)                                                    \
 void ff_hevc_put_hevc_pel_pixels##WIDTH##_8_lsx(int16_t *dst,             \
-                                                uint8_t *src,             \
+                                                const uint8_t *src,       \
                                                 ptrdiff_t src_stride,     \
                                                 int height,               \
                                                 intptr_t mx,              \
@@ -3226,7 +3226,7 @@ MC_COPY(64);
 
 #define MC(PEL, DIR, WIDTH, TAP, DIR1, FILT_DIR)                          \
 void ff_hevc_put_hevc_##PEL##_##DIR##WIDTH##_8_lsx(int16_t *dst,          \
-                                                   uint8_t *src,          \
+                                                   const uint8_t *src,    \
                                                    ptrdiff_t src_stride,  \
                                                    int height,            \
                                                    intptr_t mx,           \
@@ -3267,7 +3267,7 @@ MC(epel, v, 32, 4, vt, my);
 
 #define MC_HV(PEL, WIDTH, TAP)                                          \
 void ff_hevc_put_hevc_##PEL##_hv##WIDTH##_8_lsx(int16_t *dst,           \
-                                                uint8_t *src,           \
+                                                const uint8_t *src,     \
                                                 ptrdiff_t src_stride,   \
                                                 int height,             \
                                                 intptr_t mx,            \
diff --git a/libavcodec/loongarch/hevcdsp_lsx.h b/libavcodec/loongarch/hevcdsp_lsx.h
index 0c517af..0d54196 100644
--- a/libavcodec/loongarch/hevcdsp_lsx.h
+++ b/libavcodec/loongarch/hevcdsp_lsx.h
@@ -27,7 +27,7 @@
 
 #define MC(PEL, DIR, WIDTH)                                               \
 void ff_hevc_put_hevc_##PEL##_##DIR##WIDTH##_8_lsx(int16_t *dst,          \
-                                                   uint8_t *src,          \
+                                                   const uint8_t *src,    \
                                                    ptrdiff_t src_stride,  \
                                                    int height,            \
                                                    intptr_t mx,           \
@@ -88,9 +88,9 @@ MC(epel, hv, 32);
 #define BI_MC(PEL, DIR, WIDTH)                                               \
 void ff_hevc_put_hevc_bi_##PEL##_##DIR##WIDTH##_8_lsx(uint8_t *dst,          \
                                                       ptrdiff_t dst_stride,  \
-                                                      uint8_t *src,          \
+                                                      const uint8_t *src,    \
                                                       ptrdiff_t src_stride,  \
-                                                      int16_t *src_16bit,    \
+                                                      const int16_t *src_16bit, \
                                                       int height,            \
                                                       intptr_t mx,           \
                                                       intptr_t my,           \
@@ -145,7 +145,7 @@ BI_MC(epel, hv, 32);
 #define UNI_MC(PEL, DIR, WIDTH)                                              \
 void ff_hevc_put_hevc_uni_##PEL##_##DIR##WIDTH##_8_lsx(uint8_t *dst,         \
                                                        ptrdiff_t dst_stride, \
-                                                       uint8_t *src,         \
+                                                       const uint8_t *src,   \
                                                        ptrdiff_t src_stride, \
                                                        int height,           \
                                                        intptr_t mx,          \
@@ -181,7 +181,7 @@ UNI_MC(epel, hv, 32);
 void ff_hevc_put_hevc_uni_w_##PEL##_##DIR##WIDTH##_8_lsx(uint8_t *dst,  \
                                                          ptrdiff_t      \
                                                          dst_stride,    \
-                                                         uint8_t *src,  \
+                                                         const uint8_t *src,  \
                                                          ptrdiff_t      \
                                                          src_stride,    \
                                                          int height,    \
@@ -202,24 +202,24 @@ UNI_W_MC(qpel, hv, 64);
 #undef UNI_W_MC
 
 void ff_hevc_loop_filter_luma_h_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *p_is_pcm, uint8_t *q_is_pcm);
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *p_is_pcm, const uint8_t *q_is_pcm);
 
 void ff_hevc_loop_filter_luma_v_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *p_is_pcm, uint8_t *q_is_pcm);
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *p_is_pcm, const uint8_t *q_is_pcm);
 
 void ff_hevc_loop_filter_chroma_h_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                        int32_t *tc, uint8_t *p_is_pcm,
-                                        uint8_t *q_is_pcm);
+                                        const int32_t *tc, const uint8_t *p_is_pcm,
+                                        const uint8_t *q_is_pcm);
 
 void ff_hevc_loop_filter_chroma_v_8_lsx(uint8_t *src, ptrdiff_t stride,
-                                        int32_t *tc, uint8_t *p_is_pcm,
-                                        uint8_t *q_is_pcm);
+                                        const int32_t *tc, const uint8_t *p_is_pcm,
+                                        const uint8_t *q_is_pcm);
 
-void ff_hevc_sao_edge_filter_8_lsx(uint8_t *dst, uint8_t *src,
+void ff_hevc_sao_edge_filter_8_lsx(uint8_t *dst, const uint8_t *src,
                                    ptrdiff_t stride_dst,
-                                   int16_t *sao_offset_val,
+                                   const int16_t *sao_offset_val,
                                    int eo, int width, int height);
 
 void ff_hevc_idct_4x4_lsx(int16_t *coeffs, int col_limit);
diff --git a/libavcodec/loongarch/vc1dsp_lasx.c b/libavcodec/loongarch/vc1dsp_lasx.c
index 40b8668..12f68ee 100644
--- a/libavcodec/loongarch/vc1dsp_lasx.c
+++ b/libavcodec/loongarch/vc1dsp_lasx.c
@@ -698,7 +698,7 @@ PUT_VC1_MSPEL_MC_LASX(3, 2);
 PUT_VC1_MSPEL_MC_LASX(3, 3);
 
 void ff_put_no_rnd_vc1_chroma_mc8_lasx(uint8_t *dst /* align 8 */,
-                                       uint8_t *src /* align 1 */,
+                                       const uint8_t *src /* align 1 */,
                                        ptrdiff_t stride, int h, int x, int y)
 {
     const int intA = (8 - x) * (8 - y);
@@ -831,20 +831,20 @@ static void put_vc1_mspel_mc_h_lasx(uint8_t *dst, const uint8_t *src,
     const_para1_2 = __lasx_xvreplgr2vr_h(*(para_v + 1));
 
     in0 = __lasx_xvld(_src, 0);
-    DUP2_ARG2(__lasx_xvldx, _src, stride, _src, stride2, in1, in2);
-    in3 = __lasx_xvldx(_src, stride3);
+    DUP2_ARG2(LASX_XVLDX, _src, stride, _src, stride2, in1, in2);
+    in3 = LASX_XVLDX(_src, stride3);
     _src += stride4;
     in4 = __lasx_xvld(_src, 0);
-    DUP2_ARG2(__lasx_xvldx, _src, stride, _src, stride2, in5, in6);
-    in7 = __lasx_xvldx(_src, stride3);
+    DUP2_ARG2(LASX_XVLDX, _src, stride, _src, stride2, in5, in6);
+    in7 = LASX_XVLDX(_src, stride3);
     _src += stride4;
     in8 = __lasx_xvld(_src, 0);
-    DUP2_ARG2(__lasx_xvldx, _src, stride, _src, stride2, in9, in10);
-    in11 = __lasx_xvldx(_src, stride3);
+    DUP2_ARG2(LASX_XVLDX, _src, stride, _src, stride2, in9, in10);
+    in11 = LASX_XVLDX(_src, stride3);
     _src += stride4;
     in12 = __lasx_xvld(_src, 0);
-    DUP2_ARG2(__lasx_xvldx, _src, stride, _src, stride2, in13, in14);
-    in15 = __lasx_xvldx(_src, stride3);
+    DUP2_ARG2(LASX_XVLDX, _src, stride, _src, stride2, in13, in14);
+    in15 = LASX_XVLDX(_src, stride3);
     DUP4_ARG2(__lasx_xvilvl_b, in2, in0, in3, in1, in6, in4, in7, in5,
               tmp0_m, tmp1_m, tmp2_m, tmp3_m);
     DUP4_ARG2(__lasx_xvilvl_b, in10, in8, in11, in9, in14, in12, in15, in13,
diff --git a/libavcodec/loongarch/vc1dsp_loongarch.h b/libavcodec/loongarch/vc1dsp_loongarch.h
index 398631a..e5ccbcb 100644
--- a/libavcodec/loongarch/vc1dsp_loongarch.h
+++ b/libavcodec/loongarch/vc1dsp_loongarch.h
@@ -73,7 +73,7 @@ FF_PUT_VC1_MSPEL_MC_H_LASX(2);
 FF_PUT_VC1_MSPEL_MC_H_LASX(3);
 
 void ff_put_no_rnd_vc1_chroma_mc8_lasx(uint8_t *dst /* align 8 */,
-                                       uint8_t *src /* align 1 */,
+                                       const uint8_t *src /* align 1 */,
                                        ptrdiff_t stride, int h, int x, int y);
 
 #endif /* AVCODEC_LOONGARCH_VC1DSP_LOONGARCH_H */
diff --git a/libavcodec/loongarch/videodsp_init.c b/libavcodec/loongarch/videodsp_init.c
index 6cbb776..92ade4f 100644
--- a/libavcodec/loongarch/videodsp_init.c
+++ b/libavcodec/loongarch/videodsp_init.c
@@ -22,7 +22,7 @@
 #include "libavcodec/videodsp.h"
 #include "libavutil/attributes.h"
 
-static void prefetch_loongarch(uint8_t *mem, ptrdiff_t stride, int h)
+static void prefetch_loongarch(const uint8_t *mem, ptrdiff_t stride, int h)
 {
     register const uint8_t *p = mem;
 
diff --git a/libavcodec/lossless_videoencdsp.c b/libavcodec/lossless_videoencdsp.c
index e0b78bb..b4130eb 100644
--- a/libavcodec/lossless_videoencdsp.c
+++ b/libavcodec/lossless_videoencdsp.c
@@ -74,7 +74,7 @@ static void sub_median_pred_c(uint8_t *dst, const uint8_t *src1,
     *left_top = lt;
 }
 
-static void sub_left_predict_c(uint8_t *dst, uint8_t *src,
+static void sub_left_predict_c(uint8_t *dst, const uint8_t *src,
                                ptrdiff_t stride, ptrdiff_t width, int height)
 {
     int i, j;
diff --git a/libavcodec/lossless_videoencdsp.h b/libavcodec/lossless_videoencdsp.h
index 7794f03..f2c2878 100644
--- a/libavcodec/lossless_videoencdsp.h
+++ b/libavcodec/lossless_videoencdsp.h
@@ -35,7 +35,7 @@ typedef struct LLVidEncDSPContext {
                             const uint8_t *src2, intptr_t w,
                             int *left, int *left_top);
 
-    void (*sub_left_predict)(uint8_t *dst, uint8_t *src,
+    void (*sub_left_predict)(uint8_t *dst, const uint8_t *src,
                           ptrdiff_t stride, ptrdiff_t width, int height);
 } LLVidEncDSPContext;
 
diff --git a/libavcodec/lscrdec.c b/libavcodec/lscrdec.c
index 9e7010c..0d6b29c 100644
--- a/libavcodec/lscrdec.c
+++ b/libavcodec/lscrdec.c
@@ -255,5 +255,5 @@ const FFCodec ff_lscr_decoder = {
     .close          = lscr_decode_close,
     FF_CODEC_DECODE_CB(decode_frame_lscr),
     .flush          = lscr_decode_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/m101.c b/libavcodec/m101.c
index fce3195..16ea6ed 100644
--- a/libavcodec/m101.c
+++ b/libavcodec/m101.c
@@ -113,5 +113,4 @@ const FFCodec ff_m101_decoder = {
     .init           = m101_decode_init,
     FF_CODEC_DECODE_CB(m101_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mace.c b/libavcodec/mace.c
index 110b320..675725a 100644
--- a/libavcodec/mace.c
+++ b/libavcodec/mace.c
@@ -295,7 +295,6 @@ const FFCodec ff_mace3_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 
 const FFCodec ff_mace6_decoder = {
@@ -309,5 +308,4 @@ const FFCodec ff_mace6_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/magicyuv.c b/libavcodec/magicyuv.c
index 634d45c..65dbb6a 100644
--- a/libavcodec/magicyuv.c
+++ b/libavcodec/magicyuv.c
@@ -115,7 +115,7 @@ static void magicyuv_median_pred16(uint16_t *dst, const uint16_t *src1,
 static int magy_decode_slice10(AVCodecContext *avctx, void *tdata,
                                int j, int threadnr)
 {
-    MagicYUVContext *s = avctx->priv_data;
+    const MagicYUVContext *s = avctx->priv_data;
     int interlaced = s->interlaced;
     const int bps = s->bps;
     const int max = s->max - 1;
@@ -247,7 +247,7 @@ static int magy_decode_slice10(AVCodecContext *avctx, void *tdata,
 static int magy_decode_slice(AVCodecContext *avctx, void *tdata,
                              int j, int threadnr)
 {
-    MagicYUVContext *s = avctx->priv_data;
+    const MagicYUVContext *s = avctx->priv_data;
     int interlaced = s->interlaced;
     AVFrame *p = s->p;
     int i, k, x, min_width;
@@ -705,5 +705,4 @@ const FFCodec ff_magicyuv_decoder = {
     .p.capabilities   = AV_CODEC_CAP_DR1 |
                         AV_CODEC_CAP_FRAME_THREADS |
                         AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/magicyuvenc.c b/libavcodec/magicyuvenc.c
index ce49236..7d77ef7 100644
--- a/libavcodec/magicyuvenc.c
+++ b/libavcodec/magicyuvenc.c
@@ -458,11 +458,12 @@ static int magy_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     }
 
     if (s->correlate) {
-        uint8_t *r, *g, *b, *decorrelated[2] = { s->decorrelate_buf[0],
+        uint8_t *decorrelated[2] = { s->decorrelate_buf[0],
                                                  s->decorrelate_buf[1] };
         const int decorrelate_linesize = FFALIGN(width, 16);
         const uint8_t *const data[4] = { decorrelated[0], frame->data[0],
                                          decorrelated[1], frame->data[3] };
+        const uint8_t *r, *g, *b;
         const int linesize[4]  = { decorrelate_linesize, frame->linesize[0],
                                    decorrelate_linesize, frame->linesize[3] };
 
@@ -579,5 +580,5 @@ const FFCodec ff_magicyuv_encoder = {
                           AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_YUVA444P, AV_PIX_FMT_GRAY8,
                           AV_PIX_FMT_NONE
                       },
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mdec.c b/libavcodec/mdec.c
index deabebd..59bf86b 100644
--- a/libavcodec/mdec.c
+++ b/libavcodec/mdec.c
@@ -259,5 +259,4 @@ const FFCodec ff_mdec_decoder = {
     .close            = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/me_cmp.c b/libavcodec/me_cmp.c
index d0cd14a..4242fbc 100644
--- a/libavcodec/me_cmp.c
+++ b/libavcodec/me_cmp.c
@@ -67,7 +67,7 @@ const uint32_t ff_square_tab[512] = {
     57600, 58081, 58564, 59049, 59536, 60025, 60516, 61009, 61504, 62001, 62500, 63001, 63504, 64009, 64516, 65025,
 };
 
-static int sse4_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sse4_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                   ptrdiff_t stride, int h)
 {
     int s = 0, i;
@@ -84,7 +84,7 @@ static int sse4_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int sse8_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sse8_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                   ptrdiff_t stride, int h)
 {
     int s = 0, i;
@@ -105,7 +105,7 @@ static int sse8_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int sse16_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sse16_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                    ptrdiff_t stride, int h)
 {
     int s = 0, i;
@@ -135,7 +135,7 @@ static int sse16_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int sum_abs_dctelem_c(int16_t *block)
+static int sum_abs_dctelem_c(const int16_t *block)
 {
     int sum = 0, i;
 
@@ -147,7 +147,7 @@ static int sum_abs_dctelem_c(int16_t *block)
 #define avg2(a, b) (((a) + (b) + 1) >> 1)
 #define avg4(a, b, c, d) (((a) + (b) + (c) + (d) + 2) >> 2)
 
-static inline int pix_abs16_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static inline int pix_abs16_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                               ptrdiff_t stride, int h)
 {
     int s = 0, i;
@@ -175,7 +175,7 @@ static inline int pix_abs16_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static inline int pix_median_abs16_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static inline int pix_median_abs16_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                              ptrdiff_t stride, int h)
 {
     int s = 0, i, j;
@@ -214,7 +214,7 @@ static inline int pix_median_abs16_c(MpegEncContext *v, uint8_t *pix1, uint8_t *
     return s;
 }
 
-static int pix_abs16_x2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int pix_abs16_x2_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                           ptrdiff_t stride, int h)
 {
     int s = 0, i;
@@ -242,11 +242,11 @@ static int pix_abs16_x2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int pix_abs16_y2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int pix_abs16_y2_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                           ptrdiff_t stride, int h)
 {
     int s = 0, i;
-    uint8_t *pix3 = pix2 + stride;
+    const uint8_t *pix3 = pix2 + stride;
 
     for (i = 0; i < h; i++) {
         s    += abs(pix1[0]  - avg2(pix2[0],  pix3[0]));
@@ -272,11 +272,11 @@ static int pix_abs16_y2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int pix_abs16_xy2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int pix_abs16_xy2_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                            ptrdiff_t stride, int h)
 {
     int s = 0, i;
-    uint8_t *pix3 = pix2 + stride;
+    const uint8_t *pix3 = pix2 + stride;
 
     for (i = 0; i < h; i++) {
         s    += abs(pix1[0]  - avg4(pix2[0],  pix2[1],  pix3[0],  pix3[1]));
@@ -302,7 +302,7 @@ static int pix_abs16_xy2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static inline int pix_abs8_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static inline int pix_abs8_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                              ptrdiff_t stride, int h)
 {
     int s = 0, i;
@@ -322,7 +322,7 @@ static inline int pix_abs8_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static inline int pix_median_abs8_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static inline int pix_median_abs8_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                              ptrdiff_t stride, int h)
 {
     int s = 0, i, j;
@@ -353,7 +353,7 @@ static inline int pix_median_abs8_c(MpegEncContext *v, uint8_t *pix1, uint8_t *p
     return s;
 }
 
-static int pix_abs8_x2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int pix_abs8_x2_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h)
 {
     int s = 0, i;
@@ -373,11 +373,11 @@ static int pix_abs8_x2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int pix_abs8_y2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int pix_abs8_y2_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h)
 {
     int s = 0, i;
-    uint8_t *pix3 = pix2 + stride;
+    const uint8_t *pix3 = pix2 + stride;
 
     for (i = 0; i < h; i++) {
         s    += abs(pix1[0] - avg2(pix2[0], pix3[0]));
@@ -395,11 +395,11 @@ static int pix_abs8_y2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int pix_abs8_xy2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int pix_abs8_xy2_c(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                           ptrdiff_t stride, int h)
 {
     int s = 0, i;
-    uint8_t *pix3 = pix2 + stride;
+    const uint8_t *pix3 = pix2 + stride;
 
     for (i = 0; i < h; i++) {
         s    += abs(pix1[0] - avg4(pix2[0], pix2[1], pix3[0], pix3[1]));
@@ -417,7 +417,7 @@ static int pix_abs8_xy2_c(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int nsse16_c(MpegEncContext *c, uint8_t *s1, uint8_t *s2,
+static int nsse16_c(MpegEncContext *c, const uint8_t *s1, const uint8_t *s2,
                     ptrdiff_t stride, int h)
 {
     int score1 = 0, score2 = 0, x, y;
@@ -442,7 +442,7 @@ static int nsse16_c(MpegEncContext *c, uint8_t *s1, uint8_t *s2,
         return score1 + FFABS(score2) * 8;
 }
 
-static int nsse8_c(MpegEncContext *c, uint8_t *s1, uint8_t *s2,
+static int nsse8_c(MpegEncContext *c, const uint8_t *s1, const uint8_t *s2,
                    ptrdiff_t stride, int h)
 {
     int score1 = 0, score2 = 0, x, y;
@@ -467,7 +467,7 @@ static int nsse8_c(MpegEncContext *c, uint8_t *s1, uint8_t *s2,
         return score1 + FFABS(score2) * 8;
 }
 
-static int zero_cmp(MpegEncContext *s, uint8_t *a, uint8_t *b,
+static int zero_cmp(MpegEncContext *s, const uint8_t *a, const uint8_t *b,
                     ptrdiff_t stride, int h)
 {
     return 0;
@@ -553,13 +553,11 @@ void ff_set_cmp(MECmpContext *c, me_cmp_func *cmp, int type)
 
 #define BUTTERFLYA(x, y) (FFABS((x) + (y)) + FFABS((x) - (y)))
 
-static int hadamard8_diff8x8_c(MpegEncContext *s, uint8_t *dst,
-                               uint8_t *src, ptrdiff_t stride, int h)
+static int hadamard8_diff8x8_c(MpegEncContext *s, const uint8_t *dst,
+                               const uint8_t *src, ptrdiff_t stride, int h)
 {
     int i, temp[64], sum = 0;
 
-    av_assert2(h == 8);
-
     for (i = 0; i < 8; i++) {
         // FIXME: try pointer walks
         BUTTERFLY2(temp[8 * i + 0], temp[8 * i + 1],
@@ -605,13 +603,11 @@ static int hadamard8_diff8x8_c(MpegEncContext *s, uint8_t *dst,
     return sum;
 }
 
-static int hadamard8_intra8x8_c(MpegEncContext *s, uint8_t *src,
-                                uint8_t *dummy, ptrdiff_t stride, int h)
+static int hadamard8_intra8x8_c(MpegEncContext *s, const uint8_t *src,
+                                const uint8_t *dummy, ptrdiff_t stride, int h)
 {
     int i, temp[64], sum = 0;
 
-    av_assert2(h == 8);
-
     for (i = 0; i < 8; i++) {
         // FIXME: try pointer walks
         BUTTERFLY2(temp[8 * i + 0], temp[8 * i + 1],
@@ -657,13 +653,11 @@ static int hadamard8_intra8x8_c(MpegEncContext *s, uint8_t *src,
     return sum;
 }
 
-static int dct_sad8x8_c(MpegEncContext *s, uint8_t *src1,
-                        uint8_t *src2, ptrdiff_t stride, int h)
+static int dct_sad8x8_c(MpegEncContext *s, const uint8_t *src1,
+                        const uint8_t *src2, ptrdiff_t stride, int h)
 {
     LOCAL_ALIGNED_16(int16_t, temp, [64]);
 
-    av_assert2(h == 8);
-
     s->pdsp.diff_pixels_unaligned(temp, src1, src2, stride);
     s->fdsp.fdct(temp);
     return s->mecc.sum_abs_dctelem(temp);
@@ -698,8 +692,8 @@ static int dct_sad8x8_c(MpegEncContext *s, uint8_t *src1,
         DST(7, (a4 >> 2) - a7);                         \
     }
 
-static int dct264_sad8x8_c(MpegEncContext *s, uint8_t *src1,
-                           uint8_t *src2, ptrdiff_t stride, int h)
+static int dct264_sad8x8_c(MpegEncContext *s, const uint8_t *src1,
+                           const uint8_t *src2, ptrdiff_t stride, int h)
 {
     int16_t dct[8][8];
     int i, sum = 0;
@@ -723,14 +717,12 @@ static int dct264_sad8x8_c(MpegEncContext *s, uint8_t *src1,
 }
 #endif
 
-static int dct_max8x8_c(MpegEncContext *s, uint8_t *src1,
-                        uint8_t *src2, ptrdiff_t stride, int h)
+static int dct_max8x8_c(MpegEncContext *s, const uint8_t *src1,
+                        const uint8_t *src2, ptrdiff_t stride, int h)
 {
     LOCAL_ALIGNED_16(int16_t, temp, [64]);
     int sum = 0, i;
 
-    av_assert2(h == 8);
-
     s->pdsp.diff_pixels_unaligned(temp, src1, src2, stride);
     s->fdsp.fdct(temp);
 
@@ -740,14 +732,13 @@ static int dct_max8x8_c(MpegEncContext *s, uint8_t *src1,
     return sum;
 }
 
-static int quant_psnr8x8_c(MpegEncContext *s, uint8_t *src1,
-                           uint8_t *src2, ptrdiff_t stride, int h)
+static int quant_psnr8x8_c(MpegEncContext *s, const uint8_t *src1,
+                           const uint8_t *src2, ptrdiff_t stride, int h)
 {
     LOCAL_ALIGNED_16(int16_t, temp, [64 * 2]);
     int16_t *const bak = temp + 64;
     int sum = 0, i;
 
-    av_assert2(h == 8);
     s->mb_intra = 0;
 
     s->pdsp.diff_pixels_unaligned(temp, src1, src2, stride);
@@ -765,7 +756,7 @@ static int quant_psnr8x8_c(MpegEncContext *s, uint8_t *src1,
     return sum;
 }
 
-static int rd8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,
+static int rd8x8_c(MpegEncContext *s, const uint8_t *src1, const uint8_t *src2,
                    ptrdiff_t stride, int h)
 {
     const uint8_t *scantable = s->intra_scantable.permutated;
@@ -776,8 +767,6 @@ static int rd8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,
     const int esc_length = s->ac_esc_length;
     uint8_t *length, *last_length;
 
-    av_assert2(h == 8);
-
     copy_block8(lsrc1, src1, 8, stride, 8);
     copy_block8(lsrc2, src2, 8, stride, 8);
 
@@ -842,7 +831,7 @@ static int rd8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,
     return distortion + ((bits * s->qscale * s->qscale * 109 + 64) >> 7);
 }
 
-static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,
+static int bit8x8_c(MpegEncContext *s, const uint8_t *src1, const uint8_t *src2,
                     ptrdiff_t stride, int h)
 {
     const uint8_t *scantable = s->intra_scantable.permutated;
@@ -851,8 +840,6 @@ static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,
     const int esc_length = s->ac_esc_length;
     uint8_t *length, *last_length;
 
-    av_assert2(h == 8);
-
     s->pdsp.diff_pixels_unaligned(temp, src1, src2, stride);
 
     s->block_last_index[0 /* FIXME */] =
@@ -905,7 +892,7 @@ static int bit8x8_c(MpegEncContext *s, uint8_t *src1, uint8_t *src2,
 
 #define VSAD_INTRA(size)                                                \
 static int vsad_intra ## size ## _c(MpegEncContext *c,                  \
-                                    uint8_t *s, uint8_t *dummy,         \
+                                    const uint8_t *s, const uint8_t *dummy, \
                                     ptrdiff_t stride, int h)            \
 {                                                                       \
     int score = 0, x, y;                                                \
@@ -927,7 +914,7 @@ VSAD_INTRA(16)
 
 #define VSAD(size)                                                             \
 static int vsad ## size ## _c(MpegEncContext *c,                               \
-                              uint8_t *s1, uint8_t *s2,                        \
+                              const uint8_t *s1, const uint8_t *s2,            \
                               ptrdiff_t stride, int h)                               \
 {                                                                              \
     int score = 0, x, y;                                                       \
@@ -947,7 +934,7 @@ VSAD(16)
 #define SQ(a) ((a) * (a))
 #define VSSE_INTRA(size)                                                \
 static int vsse_intra ## size ## _c(MpegEncContext *c,                  \
-                                    uint8_t *s, uint8_t *dummy,         \
+                                    const uint8_t *s, const uint8_t *dummy, \
                                     ptrdiff_t stride, int h)            \
 {                                                                       \
     int score = 0, x, y;                                                \
@@ -968,7 +955,7 @@ VSSE_INTRA(8)
 VSSE_INTRA(16)
 
 #define VSSE(size)                                                             \
-static int vsse ## size ## _c(MpegEncContext *c, uint8_t *s1, uint8_t *s2,     \
+static int vsse ## size ## _c(MpegEncContext *c, const uint8_t *s1, const uint8_t *s2, \
                               ptrdiff_t stride, int h)                         \
 {                                                                              \
     int score = 0, x, y;                                                       \
@@ -986,7 +973,7 @@ VSSE(8)
 VSSE(16)
 
 #define WRAPPER8_16_SQ(name8, name16)                                   \
-static int name16(MpegEncContext *s, uint8_t *dst, uint8_t *src,        \
+static int name16(MpegEncContext *s, const uint8_t *dst, const uint8_t *src, \
                   ptrdiff_t stride, int h)                              \
 {                                                                       \
     int score = 0;                                                      \
diff --git a/libavcodec/me_cmp.h b/libavcodec/me_cmp.h
index 7b057a9..c6de2d0 100644
--- a/libavcodec/me_cmp.h
+++ b/libavcodec/me_cmp.h
@@ -46,12 +46,12 @@ struct MpegEncContext;
  * Although currently h < 4 is not used as functions with
  * width < 8 are neither used nor implemented. */
 typedef int (*me_cmp_func)(struct MpegEncContext *c,
-                           uint8_t *blk1 /* align width (8 or 16) */,
-                           uint8_t *blk2 /* align 1 */, ptrdiff_t stride,
+                           const uint8_t *blk1 /* align width (8 or 16) */,
+                           const uint8_t *blk2 /* align 1 */, ptrdiff_t stride,
                            int h);
 
 typedef struct MECmpContext {
-    int (*sum_abs_dctelem)(int16_t *block /* align 16 */);
+    int (*sum_abs_dctelem)(const int16_t *block /* align 16 */);
 
     me_cmp_func sad[6]; /* identical to pix_absAxA except additional void * */
     me_cmp_func sse[6];
diff --git a/libavcodec/mediacodecdec.c b/libavcodec/mediacodecdec.c
index 6b4c39b..0bf2a05 100644
--- a/libavcodec/mediacodecdec.c
+++ b/libavcodec/mediacodecdec.c
@@ -544,7 +544,8 @@ const FFCodec ff_ ## short_name ## _mediacodec_decoder = {
     .flush          = mediacodec_decode_flush,                                                 \
     .close          = mediacodec_decode_close,                                                 \
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
-    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS,                                               \
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |                                       \
+                      FF_CODEC_CAP_SETS_PKT_DTS,                                               \
     .bsfs           = bsf,                                                                     \
     .hw_configs     = mediacodec_hw_configs,                                                   \
     .p.wrapper_name = "mediacodec",                                                            \
diff --git a/libavcodec/metasound.c b/libavcodec/metasound.c
index 9c5d036..6597563 100644
--- a/libavcodec/metasound.c
+++ b/libavcodec/metasound.c
@@ -385,5 +385,5 @@ const FFCodec ff_metasound_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mfenc.c b/libavcodec/mfenc.c
index bbe7860..d5c241d 100644
--- a/libavcodec/mfenc.c
+++ b/libavcodec/mfenc.c
@@ -344,7 +344,7 @@ static IMFSample *mf_v_avframe_to_sample(AVCodecContext *avctx, const AVFrame *f
         return NULL;
     }
 
-    IMFSample_SetSampleDuration(sample, mf_to_mf_time(avctx, frame->pkt_duration));
+    IMFSample_SetSampleDuration(sample, mf_to_mf_time(avctx, frame->duration));
 
     return sample;
 }
@@ -1239,8 +1239,7 @@ static int mf_init(AVCodecContext *avctx)
         FF_CODEC_RECEIVE_PACKET_CB(mf_receive_packet),                         \
         FMTS                                                                   \
         CAPS                                                                   \
-        .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |                       \
-                          FF_CODEC_CAP_INIT_CLEANUP,                           \
+        .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,                           \
     };
 
 #define AFMTS \
diff --git a/libavcodec/microdvddec.c b/libavcodec/microdvddec.c
index f36ad51..b675fc0 100644
--- a/libavcodec/microdvddec.c
+++ b/libavcodec/microdvddec.c
@@ -377,5 +377,4 @@ const FFCodec ff_microdvd_decoder = {
     FF_CODEC_DECODE_SUB_CB(microdvd_decode_frame),
     .flush        = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/midivid.c b/libavcodec/midivid.c
index e356fda..7448c8c 100644
--- a/libavcodec/midivid.c
+++ b/libavcodec/midivid.c
@@ -203,7 +203,12 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *rframe,
     bytestream2_skip(gb, 8);
     uncompressed = bytestream2_get_le32(gb);
 
-    if (!uncompressed) {
+    if ((ret = ff_reget_buffer(avctx, s->frame, 0)) < 0)
+        return ret;
+
+    if (uncompressed) {
+        ret = decode_mvdv(s, avctx, frame);
+    } else {
         av_fast_padded_malloc(&s->uncompressed, &s->uncompressed_size, 16LL * (avpkt->size - 12));
         if (!s->uncompressed)
             return AVERROR(ENOMEM);
@@ -212,13 +217,9 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *rframe,
         if (ret < 0)
             return ret;
         bytestream2_init(gb, s->uncompressed, ret);
+        ret = decode_mvdv(s, avctx, frame);
     }
 
-    if ((ret = ff_reget_buffer(avctx, s->frame, 0)) < 0)
-        return ret;
-
-    ret = decode_mvdv(s, avctx, frame);
-
     if (ret < 0)
         return ret;
     key = ret;
@@ -288,5 +289,5 @@ const FFCodec ff_mvdv_decoder = {
     .flush          = decode_flush,
     .close          = decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mimic.c b/libavcodec/mimic.c
index 74dd947..bcf10b7 100644
--- a/libavcodec/mimic.c
+++ b/libavcodec/mimic.c
@@ -268,8 +268,9 @@ static int decode(MimicContext *ctx, int quality, int num_coeffs,
         const int qscale    = av_clip(10000 - quality, is_chroma ? 1000 : 2000,
                                       10000) << 2;
         const int stride    = ctx->frames[ctx->cur_index ].f->linesize[plane];
-        const uint8_t *src  = ctx->frames[ctx->prev_index].f->data[plane];
         uint8_t       *dst  = ctx->frames[ctx->cur_index ].f->data[plane];
+        /* src is unused for I frames; set to avoid UB pointer arithmetic. */
+        const uint8_t *src  = is_iframe ? dst : ctx->frames[ctx->prev_index].f->data[plane];
 
         for (y = 0; y < ctx->num_vblocks[plane]; y++) {
             for (x = 0; x < ctx->num_hblocks[plane]; x++) {
@@ -449,5 +450,5 @@ const FFCodec ff_mimic_decoder = {
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
     .update_thread_context = ONLY_IF_THREADS_ENABLED(mimic_decode_update_thread_context),
     .caps_internal         = FF_CODEC_CAP_ALLOCATE_PROGRESS |
-                             FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+                             FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mips/aaccoder_mips.c b/libavcodec/mips/aaccoder_mips.c
index d690c8c..bf27a2a 100644
--- a/libavcodec/mips/aaccoder_mips.c
+++ b/libavcodec/mips/aaccoder_mips.c
@@ -1472,7 +1472,7 @@ static float (*const get_band_numbits_arr[])(struct AACEncContext *s,
 static float quantize_band_cost_bits(struct AACEncContext *s, const float *in,
                                      const float *scaled, int size, int scale_idx,
                                      int cb, const float lambda, const float uplim,
-                                     int *bits, float *energy, int rtz)
+                                     int *bits, float *energy)
 {
     return get_band_numbits(s, NULL, in, scaled, size, scale_idx, cb, lambda, uplim, bits);
 }
@@ -2326,7 +2326,7 @@ static float (*const get_band_cost_arr[])(struct AACEncContext *s,
 static float quantize_band_cost(struct AACEncContext *s, const float *in,
                                 const float *scaled, int size, int scale_idx,
                                 int cb, const float lambda, const float uplim,
-                                int *bits, float *energy, int rtz)
+                                int *bits, float *energy)
 {
     return get_band_cost(s, NULL, in, scaled, size, scale_idx, cb, lambda, uplim, bits, energy);
 }
@@ -2424,25 +2424,25 @@ static void search_for_ms_mips(AACEncContext *s, ChannelElement *cpe)
                                                     sce0->ics.swb_sizes[g],
                                                     sce0->sf_idx[w*16+g],
                                                     sce0->band_type[w*16+g],
-                                                    lambda / band0->threshold, INFINITY, &b1, NULL, 0);
+                                                    lambda / band0->threshold, INFINITY, &b1, NULL);
                         dist1 += quantize_band_cost(s, &sce1->coeffs[start + (w+w2)*128],
                                                     R34,
                                                     sce1->ics.swb_sizes[g],
                                                     sce1->sf_idx[w*16+g],
                                                     sce1->band_type[w*16+g],
-                                                    lambda / band1->threshold, INFINITY, &b2, NULL, 0);
+                                                    lambda / band1->threshold, INFINITY, &b2, NULL);
                         dist2 += quantize_band_cost(s, M,
                                                     M34,
                                                     sce0->ics.swb_sizes[g],
                                                     mididx,
                                                     midcb,
-                                                    lambda / minthr, INFINITY, &b3, NULL, 0);
+                                                    lambda / minthr, INFINITY, &b3, NULL);
                         dist2 += quantize_band_cost(s, S,
                                                     S34,
                                                     sce1->ics.swb_sizes[g],
                                                     sididx,
                                                     sidcb,
-                                                    mslambda / (minthr * bmax), INFINITY, &b4, NULL, 0);
+                                                    mslambda / (minthr * bmax), INFINITY, &b4, NULL);
                         B0 += b1+b2;
                         B1 += b3+b4;
                         dist1 -= b1+b2;
diff --git a/libavcodec/mips/h263dsp_mips.h b/libavcodec/mips/h263dsp_mips.h
index 99a43cd..f225ee5 100644
--- a/libavcodec/mips/h263dsp_mips.h
+++ b/libavcodec/mips/h263dsp_mips.h
@@ -31,6 +31,6 @@ void ff_dct_unquantize_h263_inter_msa(MpegEncContext *s, int16_t *block,
                                       int32_t index, int32_t q_scale);
 void ff_dct_unquantize_h263_intra_msa(MpegEncContext *s, int16_t *block,
                                       int32_t index, int32_t q_scale);
-int ff_pix_sum_msa(uint8_t *pix, int line_size);
+int ff_pix_sum_msa(const uint8_t *pix, int line_size);
 
 #endif  // #ifndef AVCODEC_MIPS_H263DSP_MIPS_H
diff --git a/libavcodec/mips/h264chroma_mips.h b/libavcodec/mips/h264chroma_mips.h
index 996384d..c694e34 100644
--- a/libavcodec/mips/h264chroma_mips.h
+++ b/libavcodec/mips/h264chroma_mips.h
@@ -22,26 +22,26 @@
 #define AVCODEC_MIPS_H264CHROMA_MIPS_H
 
 #include "libavcodec/h264dec.h"
-void ff_put_h264_chroma_mc8_msa(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int height, int x, int y);
-void ff_put_h264_chroma_mc4_msa(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int height, int x, int y);
-void ff_put_h264_chroma_mc2_msa(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc2_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int height, int x, int y);
-void ff_avg_h264_chroma_mc8_msa(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int height, int x, int y);
-void ff_avg_h264_chroma_mc4_msa(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc4_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int height, int x, int y);
-void ff_avg_h264_chroma_mc2_msa(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc2_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
                                 int height, int x, int y);
 
-void ff_put_h264_chroma_mc8_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y);
-void ff_avg_h264_chroma_mc8_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y);
-void ff_put_h264_chroma_mc4_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y);
-void ff_avg_h264_chroma_mc4_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc4_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y);
 
 #endif /* AVCODEC_MIPS_H264CHROMA_MIPS_H */
diff --git a/libavcodec/mips/h264chroma_mmi.c b/libavcodec/mips/h264chroma_mmi.c
index ec35c5a..fe05ccd 100644
--- a/libavcodec/mips/h264chroma_mmi.c
+++ b/libavcodec/mips/h264chroma_mmi.c
@@ -26,7 +26,7 @@
 #include "constants.h"
 #include "libavutil/mips/mmiutils.h"
 
-void ff_put_h264_chroma_mc8_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc8_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y)
 {
     double ftmp[12];
@@ -289,7 +289,7 @@ void ff_put_h264_chroma_mc8_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
     }
 }
 
-void ff_avg_h264_chroma_mc8_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc8_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y)
 {
     double ftmp[10];
@@ -497,7 +497,7 @@ void ff_avg_h264_chroma_mc8_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
     }
 }
 
-void ff_put_h264_chroma_mc4_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_put_h264_chroma_mc4_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y)
 {
     double ftmp[8];
@@ -618,7 +618,7 @@ void ff_put_h264_chroma_mc4_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
     }
 }
 
-void ff_avg_h264_chroma_mc4_mmi(uint8_t *dst, uint8_t *src, ptrdiff_t stride,
+void ff_avg_h264_chroma_mc4_mmi(uint8_t *dst, const uint8_t *src, ptrdiff_t stride,
         int h, int x, int y)
 {
     double ftmp[8];
diff --git a/libavcodec/mips/h264chroma_msa.c b/libavcodec/mips/h264chroma_msa.c
index 4a68d9e..141f52c 100644
--- a/libavcodec/mips/h264chroma_msa.c
+++ b/libavcodec/mips/h264chroma_msa.c
@@ -29,7 +29,7 @@ static const uint8_t chroma_mask_arr[16 * 5] = {
     0, 1, 1, 2, 16, 17, 17, 18, 16, 17, 17, 18, 18, 19, 19, 20
 };
 
-static void avc_chroma_hz_2x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_2x2_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     uint16_t out0, out1;
@@ -60,7 +60,7 @@ static void avc_chroma_hz_2x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     SH(out1, dst);
 }
 
-static void avc_chroma_hz_2x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_2x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3;
@@ -88,7 +88,7 @@ static void avc_chroma_hz_2x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_H4(res, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hz_2w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_2w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coeff0, uint32_t coeff1,
                                  int32_t height)
 {
@@ -99,7 +99,7 @@ static void avc_chroma_hz_2w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_hz_4x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_4x2_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16i8 src0, src1;
@@ -124,7 +124,7 @@ static void avc_chroma_hz_4x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W2(res, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hz_4x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_4x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, out;
@@ -147,7 +147,7 @@ static void avc_chroma_hz_4x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W4(out, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hz_4x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_4x8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, src4, src5, src6, src7, out0, out1;
@@ -171,7 +171,7 @@ static void avc_chroma_hz_4x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W8(out0, out1, 0, 1, 2, 3, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hz_4w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_4w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coeff0, uint32_t coeff1,
                                  int32_t height)
 {
@@ -184,7 +184,7 @@ static void avc_chroma_hz_4w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_hz_8x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_8x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, out0, out1;
@@ -207,7 +207,7 @@ static void avc_chroma_hz_8x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_D4(out0, out1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hz_8x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_8x8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
@@ -240,7 +240,7 @@ static void avc_chroma_hz_8x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_D8(out0, out1, out2, out3, 0, 1, 0, 1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hz_nonmult_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_nonmult_msa(const uint8_t *src, uint8_t *dst,
                                       int32_t stride, uint32_t coeff0,
                                       uint32_t coeff1, int32_t height)
 {
@@ -289,7 +289,7 @@ static void avc_chroma_hz_nonmult_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_hz_8w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hz_8w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coeff0, uint32_t coeff1,
                                  int32_t height)
 {
@@ -302,7 +302,7 @@ static void avc_chroma_hz_8w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_vt_2x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_2x2_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     uint16_t out0, out1;
@@ -334,7 +334,7 @@ static void avc_chroma_vt_2x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     SH(out1, dst);
 }
 
-static void avc_chroma_vt_2x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_2x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, src4;
@@ -362,7 +362,7 @@ static void avc_chroma_vt_2x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_H4(res, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_vt_2w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_2w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coeff0, uint32_t coeff1,
                                  int32_t height)
 {
@@ -373,7 +373,7 @@ static void avc_chroma_vt_2w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_vt_4x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_4x2_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2;
@@ -397,7 +397,7 @@ static void avc_chroma_vt_4x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W2(res, 0, 1, dst, stride);
 }
 
-static void avc_chroma_vt_4x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_4x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, src4;
@@ -421,7 +421,7 @@ static void avc_chroma_vt_4x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W4(out, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_vt_4x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_4x8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, src4, src5, src6, src7, src8;
@@ -449,7 +449,7 @@ static void avc_chroma_vt_4x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W8(out0, out1, 0, 1, 2, 3, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_vt_4w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_4w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coeff0, uint32_t coeff1,
                                  int32_t height)
 {
@@ -462,7 +462,7 @@ static void avc_chroma_vt_4w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_vt_8x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_8x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, src4, out0, out1;
@@ -483,7 +483,7 @@ static void avc_chroma_vt_8x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_D4(out0, out1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_vt_8x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_8x8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coeff0, uint32_t coeff1)
 {
     v16u8 src0, src1, src2, src3, src4, src5, src6, src7, src8;
@@ -515,7 +515,7 @@ static void avc_chroma_vt_8x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_D8(out0, out1, out2, out3, 0, 1, 0, 1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_vt_8w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_vt_8w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coeff0, uint32_t coeff1,
                                  int32_t height)
 {
@@ -526,7 +526,7 @@ static void avc_chroma_vt_8w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_hv_2x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_2x2_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -561,7 +561,7 @@ static void avc_chroma_hv_2x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     SH(out1, dst);
 }
 
-static void avc_chroma_hv_2x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_2x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -595,7 +595,7 @@ static void avc_chroma_hv_2x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_H4(res, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hv_2w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_2w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coef_hor0, uint32_t coef_hor1,
                                  uint32_t coef_ver0, uint32_t coef_ver1,
                                  int32_t height)
@@ -609,7 +609,7 @@ static void avc_chroma_hv_2w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_hv_4x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_4x2_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -637,7 +637,7 @@ static void avc_chroma_hv_4x2_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W2(res, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hv_4x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_4x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -670,7 +670,7 @@ static void avc_chroma_hv_4x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W2(res1, 0, 1, dst + 2 * stride, stride);
 }
 
-static void avc_chroma_hv_4x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_4x8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -710,7 +710,7 @@ static void avc_chroma_hv_4x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_W8(res0, res1, 0, 1, 2, 3, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hv_4w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_4w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coef_hor0, uint32_t coef_hor1,
                                  uint32_t coef_ver0, uint32_t coef_ver1,
                                  int32_t height)
@@ -727,7 +727,7 @@ static void avc_chroma_hv_4w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_hv_8x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_8x4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -770,7 +770,7 @@ static void avc_chroma_hv_8x4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_D4(out0, out1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hv_8x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_8x8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                   uint32_t coef_hor0, uint32_t coef_hor1,
                                   uint32_t coef_ver0, uint32_t coef_ver1)
 {
@@ -826,7 +826,7 @@ static void avc_chroma_hv_8x8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     ST_D8(out0, out1, out2, out3, 0, 1, 0, 1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hv_8w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avc_chroma_hv_8w_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                                  uint32_t coef_hor0, uint32_t coef_hor1,
                                  uint32_t coef_ver0, uint32_t coef_ver1,
                                  int32_t height)
@@ -840,7 +840,7 @@ static void avc_chroma_hv_8w_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avc_chroma_hz_and_aver_dst_2x2_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_2x2_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -882,7 +882,7 @@ static void avc_chroma_hz_and_aver_dst_2x2_msa(uint8_t *src, uint8_t *dst,
     SH(out1, dst);
 }
 
-static void avc_chroma_hz_and_aver_dst_2x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_2x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -922,7 +922,7 @@ static void avc_chroma_hz_and_aver_dst_2x4_msa(uint8_t *src, uint8_t *dst,
     ST_H4(dst0, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hz_and_aver_dst_2w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_2w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride, uint32_t coeff0,
                                               uint32_t coeff1, int32_t height)
 {
@@ -933,7 +933,7 @@ static void avc_chroma_hz_and_aver_dst_2w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_hz_and_aver_dst_4x2_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_4x2_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -966,7 +966,7 @@ static void avc_chroma_hz_and_aver_dst_4x2_msa(uint8_t *src, uint8_t *dst,
     ST_W2(dst_data, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hz_and_aver_dst_4x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_4x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -995,7 +995,7 @@ static void avc_chroma_hz_and_aver_dst_4x4_msa(uint8_t *src, uint8_t *dst,
     ST_W4(out, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hz_and_aver_dst_4x8_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_4x8_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1027,7 +1027,7 @@ static void avc_chroma_hz_and_aver_dst_4x8_msa(uint8_t *src, uint8_t *dst,
     ST_W8(out0, out1, 0, 1, 2, 3, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hz_and_aver_dst_4w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_4w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride, uint32_t coeff0,
                                               uint32_t coeff1, int32_t height)
 {
@@ -1040,7 +1040,7 @@ static void avc_chroma_hz_and_aver_dst_4w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_hz_and_aver_dst_8x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_8x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1070,7 +1070,7 @@ static void avc_chroma_hz_and_aver_dst_8x4_msa(uint8_t *src, uint8_t *dst,
     ST_D4(dst0, dst1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hz_and_aver_dst_8x8_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_8x8_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1114,7 +1114,7 @@ static void avc_chroma_hz_and_aver_dst_8x8_msa(uint8_t *src, uint8_t *dst,
     ST_D8(out0, out1, out2, out3, 0, 1, 0, 1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hz_and_aver_dst_8w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hz_and_aver_dst_8w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride, uint32_t coeff0,
                                               uint32_t coeff1, int32_t height)
 {
@@ -1125,7 +1125,7 @@ static void avc_chroma_hz_and_aver_dst_8w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_vt_and_aver_dst_2x2_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_2x2_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1162,7 +1162,7 @@ static void avc_chroma_vt_and_aver_dst_2x2_msa(uint8_t *src, uint8_t *dst,
     SH(out1, dst);
 }
 
-static void avc_chroma_vt_and_aver_dst_2x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_2x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1204,7 +1204,7 @@ static void avc_chroma_vt_and_aver_dst_2x4_msa(uint8_t *src, uint8_t *dst,
     ST_H4(res, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_vt_and_aver_dst_2w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_2w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride, uint32_t coeff0,
                                               uint32_t coeff1, int32_t height)
 {
@@ -1215,7 +1215,7 @@ static void avc_chroma_vt_and_aver_dst_2w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_vt_and_aver_dst_4x2_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_4x2_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1247,7 +1247,7 @@ static void avc_chroma_vt_and_aver_dst_4x2_msa(uint8_t *src, uint8_t *dst,
     ST_W2(res, 0, 1, dst, stride);
 }
 
-static void avc_chroma_vt_and_aver_dst_4x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_4x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1277,7 +1277,7 @@ static void avc_chroma_vt_and_aver_dst_4x4_msa(uint8_t *src, uint8_t *dst,
     ST_W4(out, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_vt_and_aver_dst_4x8_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_4x8_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1313,7 +1313,7 @@ static void avc_chroma_vt_and_aver_dst_4x8_msa(uint8_t *src, uint8_t *dst,
     ST_W8(out0, out1, 0, 1, 2, 3, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_vt_and_aver_dst_4w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_4w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride, uint32_t coeff0,
                                               uint32_t coeff1, int32_t height)
 {
@@ -1326,7 +1326,7 @@ static void avc_chroma_vt_and_aver_dst_4w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_vt_and_aver_dst_8x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_8x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1355,7 +1355,7 @@ static void avc_chroma_vt_and_aver_dst_8x4_msa(uint8_t *src, uint8_t *dst,
     ST_D4(out0, out1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_vt_and_aver_dst_8x8_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_8x8_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride, uint32_t coeff0,
                                                uint32_t coeff1)
 {
@@ -1398,7 +1398,7 @@ static void avc_chroma_vt_and_aver_dst_8x8_msa(uint8_t *src, uint8_t *dst,
     ST_D8(out0, out1, out2, out3, 0, 1, 0, 1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_vt_and_aver_dst_8w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_vt_and_aver_dst_8w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride, uint32_t coeff0,
                                               uint32_t coeff1, int32_t height)
 {
@@ -1409,7 +1409,7 @@ static void avc_chroma_vt_and_aver_dst_8w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_hv_and_aver_dst_2x2_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_2x2_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1451,7 +1451,7 @@ static void avc_chroma_hv_and_aver_dst_2x2_msa(uint8_t *src, uint8_t *dst,
     SH(out1, dst);
 }
 
-static void avc_chroma_hv_and_aver_dst_2x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_2x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1496,7 +1496,7 @@ static void avc_chroma_hv_and_aver_dst_2x4_msa(uint8_t *src, uint8_t *dst,
     ST_H4(dst0, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hv_and_aver_dst_2w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_2w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride,
                                               uint32_t coef_hor0,
                                               uint32_t coef_hor1,
@@ -1513,7 +1513,7 @@ static void avc_chroma_hv_and_aver_dst_2w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_hv_and_aver_dst_4x2_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_4x2_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1549,7 +1549,7 @@ static void avc_chroma_hv_and_aver_dst_4x2_msa(uint8_t *src, uint8_t *dst,
     ST_W2(dst0, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hv_and_aver_dst_4x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_4x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1588,7 +1588,7 @@ static void avc_chroma_hv_and_aver_dst_4x4_msa(uint8_t *src, uint8_t *dst,
     ST_W4(out, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hv_and_aver_dst_4x8_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_4x8_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1637,7 +1637,7 @@ static void avc_chroma_hv_and_aver_dst_4x8_msa(uint8_t *src, uint8_t *dst,
     ST_W8(res0, res1, 0, 1, 2, 3, 0, 1, 2, 3, dst, stride);
 }
 
-static void avc_chroma_hv_and_aver_dst_4w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_4w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride,
                                               uint32_t coef_hor0,
                                               uint32_t coef_hor1,
@@ -1657,7 +1657,7 @@ static void avc_chroma_hv_and_aver_dst_4w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void avc_chroma_hv_and_aver_dst_8x4_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_8x4_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1705,7 +1705,7 @@ static void avc_chroma_hv_and_aver_dst_8x4_msa(uint8_t *src, uint8_t *dst,
     ST_D4(out0, out1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hv_and_aver_dst_8x8_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_8x8_msa(const uint8_t *src, uint8_t *dst,
                                                int32_t stride,
                                                uint32_t coef_hor0,
                                                uint32_t coef_hor1,
@@ -1774,7 +1774,7 @@ static void avc_chroma_hv_and_aver_dst_8x8_msa(uint8_t *src, uint8_t *dst,
     ST_D8(out0, out1, out2, out3, 0, 1, 0, 1, 0, 1, 0, 1, dst, stride);
 }
 
-static void avc_chroma_hv_and_aver_dst_8w_msa(uint8_t *src, uint8_t *dst,
+static void avc_chroma_hv_and_aver_dst_8w_msa(const uint8_t *src, uint8_t *dst,
                                               int32_t stride,
                                               uint32_t coef_hor0,
                                               uint32_t coef_hor1,
@@ -1791,7 +1791,7 @@ static void avc_chroma_hv_and_aver_dst_8w_msa(uint8_t *src, uint8_t *dst,
     }
 }
 
-static void copy_width4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void copy_width4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                             int32_t height)
 {
     uint32_t tp0, tp1, tp2, tp3, tp4, tp5, tp6, tp7;
@@ -1814,7 +1814,7 @@ static void copy_width4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void copy_width8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void copy_width8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                             int32_t height)
 {
     uint64_t src0, src1, src2, src3, src4, src5, src6, src7;
@@ -1832,7 +1832,7 @@ static void copy_width8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avg_width4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avg_width4_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                            int32_t height)
 {
     uint32_t tp0, tp1, tp2, tp3;
@@ -1867,7 +1867,7 @@ static void avg_width4_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-static void avg_width8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
+static void avg_width8_msa(const uint8_t *src, uint8_t *dst, int32_t stride,
                            int32_t height)
 {
     uint64_t tp0, tp1, tp2, tp3, tp4, tp5, tp6, tp7;
@@ -1903,7 +1903,7 @@ static void avg_width8_msa(uint8_t *src, uint8_t *dst, int32_t stride,
     }
 }
 
-void ff_put_h264_chroma_mc8_msa(uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc8_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride, int height, int x, int y)
 {
     av_assert2(x < 8 && y < 8 && x >= 0 && y >= 0);
@@ -1919,7 +1919,7 @@ void ff_put_h264_chroma_mc8_msa(uint8_t *dst, uint8_t *src,
     }
 }
 
-void ff_put_h264_chroma_mc4_msa(uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc4_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride, int height, int x, int y)
 {
     av_assert2(x < 8 && y < 8 && x >= 0 && y >= 0);
@@ -1935,7 +1935,7 @@ void ff_put_h264_chroma_mc4_msa(uint8_t *dst, uint8_t *src,
     }
 }
 
-void ff_put_h264_chroma_mc2_msa(uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc2_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride, int height, int x, int y)
 {
     int32_t cnt;
@@ -1958,7 +1958,7 @@ void ff_put_h264_chroma_mc2_msa(uint8_t *dst, uint8_t *src,
     }
 }
 
-void ff_avg_h264_chroma_mc8_msa(uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc8_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride, int height, int x, int y)
 {
     av_assert2(x < 8 && y < 8 && x >= 0 && y >= 0);
@@ -1976,7 +1976,7 @@ void ff_avg_h264_chroma_mc8_msa(uint8_t *dst, uint8_t *src,
     }
 }
 
-void ff_avg_h264_chroma_mc4_msa(uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc4_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride, int height, int x, int y)
 {
     av_assert2(x < 8 && y < 8 && x >= 0 && y >= 0);
@@ -1993,7 +1993,7 @@ void ff_avg_h264_chroma_mc4_msa(uint8_t *dst, uint8_t *src,
     }
 }
 
-void ff_avg_h264_chroma_mc2_msa(uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc2_msa(uint8_t *dst, const uint8_t *src,
                                 ptrdiff_t stride, int height, int x, int y)
 {
     int32_t cnt;
diff --git a/libavcodec/mips/hevc_idct_msa.c b/libavcodec/mips/hevc_idct_msa.c
index 5ab6acd..5f34fd8 100644
--- a/libavcodec/mips/hevc_idct_msa.c
+++ b/libavcodec/mips/hevc_idct_msa.c
@@ -713,7 +713,7 @@ static void hevc_idct_dc_32x32_msa(int16_t *coeffs)
     }
 }
 
-static void hevc_addblk_4x4_msa(int16_t *coeffs, uint8_t *dst, int32_t stride)
+static void hevc_addblk_4x4_msa(const int16_t *coeffs, uint8_t *dst, int32_t stride)
 {
     uint32_t dst0, dst1, dst2, dst3;
     v8i16 dst_r0, dst_l0, in0, in1;
@@ -730,7 +730,7 @@ static void hevc_addblk_4x4_msa(int16_t *coeffs, uint8_t *dst, int32_t stride)
     ST_W4(dst_vec, 0, 1, 2, 3, dst, stride);
 }
 
-static void hevc_addblk_8x8_msa(int16_t *coeffs, uint8_t *dst, int32_t stride)
+static void hevc_addblk_8x8_msa(const int16_t *coeffs, uint8_t *dst, int32_t stride)
 {
     uint8_t *temp_dst = dst;
     uint64_t dst0, dst1, dst2, dst3;
@@ -766,7 +766,7 @@ static void hevc_addblk_8x8_msa(int16_t *coeffs, uint8_t *dst, int32_t stride)
     ST_D4(dst_r0, dst_r1, 0, 1, 0, 1, dst + 4 * stride, stride);
 }
 
-static void hevc_addblk_16x16_msa(int16_t *coeffs, uint8_t *dst, int32_t stride)
+static void hevc_addblk_16x16_msa(const int16_t *coeffs, uint8_t *dst, int32_t stride)
 {
     uint8_t loop_cnt;
     uint8_t *temp_dst = dst;
@@ -833,7 +833,7 @@ static void hevc_addblk_16x16_msa(int16_t *coeffs, uint8_t *dst, int32_t stride)
     ST_UB4(dst0, dst1, dst2, dst3, dst, stride);
 }
 
-static void hevc_addblk_32x32_msa(int16_t *coeffs, uint8_t *dst, int32_t stride)
+static void hevc_addblk_32x32_msa(const int16_t *coeffs, uint8_t *dst, int32_t stride)
 {
     uint8_t loop_cnt;
     uint8_t *temp_dst = dst;
@@ -980,22 +980,22 @@ void ff_hevc_idct_32x32_msa(int16_t *coeffs, int col_limit)
     hevc_idct_32x32_msa(coeffs);
 }
 
-void ff_hevc_addblk_4x4_msa(uint8_t *dst, int16_t *coeffs, ptrdiff_t stride)
+void ff_hevc_addblk_4x4_msa(uint8_t *dst, const int16_t *coeffs, ptrdiff_t stride)
 {
     hevc_addblk_4x4_msa(coeffs, dst, stride);
 }
 
-void ff_hevc_addblk_8x8_msa(uint8_t *dst, int16_t *coeffs, ptrdiff_t stride)
+void ff_hevc_addblk_8x8_msa(uint8_t *dst, const int16_t *coeffs, ptrdiff_t stride)
 {
     hevc_addblk_8x8_msa(coeffs, dst, stride);
 }
 
-void ff_hevc_addblk_16x16_msa(uint8_t *dst, int16_t *coeffs, ptrdiff_t stride)
+void ff_hevc_addblk_16x16_msa(uint8_t *dst, const int16_t *coeffs, ptrdiff_t stride)
 {
     hevc_addblk_16x16_msa(coeffs, dst, stride);
 }
 
-void ff_hevc_addblk_32x32_msa(uint8_t *dst, int16_t *coeffs, ptrdiff_t stride)
+void ff_hevc_addblk_32x32_msa(uint8_t *dst, const int16_t *coeffs, ptrdiff_t stride)
 {
     hevc_addblk_32x32_msa(coeffs, dst, stride);
 }
diff --git a/libavcodec/mips/hevc_lpf_sao_msa.c b/libavcodec/mips/hevc_lpf_sao_msa.c
index 26663dd..cd94460 100644
--- a/libavcodec/mips/hevc_lpf_sao_msa.c
+++ b/libavcodec/mips/hevc_lpf_sao_msa.c
@@ -22,8 +22,8 @@
 #include "libavcodec/mips/hevcdsp_mips.h"
 
 static void hevc_loopfilter_luma_hor_msa(uint8_t *src, int32_t stride,
-                                         int32_t beta, int32_t *tc,
-                                         uint8_t *p_is_pcm, uint8_t *q_is_pcm)
+                                         int32_t beta, const int32_t *tc,
+                                         const uint8_t *p_is_pcm, const uint8_t *q_is_pcm)
 {
     uint8_t *p3 = src - (stride << 2);
     uint8_t *p2 = src - ((stride << 1) + stride);
@@ -448,8 +448,8 @@ static void hevc_loopfilter_luma_hor_msa(uint8_t *src, int32_t stride,
 }
 
 static void hevc_loopfilter_luma_ver_msa(uint8_t *src, int32_t stride,
-                                         int32_t beta, int32_t *tc,
-                                         uint8_t *p_is_pcm, uint8_t *q_is_pcm)
+                                         int32_t beta, const int32_t *tc,
+                                         const uint8_t *p_is_pcm, const uint8_t *q_is_pcm)
 {
     uint8_t *p3 = src;
     uint8_t *p2 = src + 3 * stride;
@@ -914,8 +914,8 @@ static void hevc_loopfilter_luma_ver_msa(uint8_t *src, int32_t stride,
 }
 
 static void hevc_loopfilter_chroma_hor_msa(uint8_t *src, int32_t stride,
-                                           int32_t *tc, uint8_t *p_is_pcm,
-                                           uint8_t *q_is_pcm)
+                                           const int32_t *tc, const uint8_t *p_is_pcm,
+                                           const uint8_t *q_is_pcm)
 {
     uint8_t *p1_ptr = src - (stride << 1);
     uint8_t *p0_ptr = src - stride;
@@ -977,8 +977,8 @@ static void hevc_loopfilter_chroma_hor_msa(uint8_t *src, int32_t stride,
 }
 
 static void hevc_loopfilter_chroma_ver_msa(uint8_t *src, int32_t stride,
-                                           int32_t *tc, uint8_t *p_is_pcm,
-                                           uint8_t *q_is_pcm)
+                                           const int32_t *tc, const uint8_t *p_is_pcm,
+                                           const uint8_t *q_is_pcm)
 {
     v2i64 cmp0, cmp1, p_is_pcm_vec, q_is_pcm_vec;
     v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
@@ -1038,9 +1038,9 @@ static void hevc_loopfilter_chroma_ver_msa(uint8_t *src, int32_t stride,
 }
 
 static void hevc_sao_band_filter_4width_msa(uint8_t *dst, int32_t dst_stride,
-                                            uint8_t *src, int32_t src_stride,
+                                            const uint8_t *src, int32_t src_stride,
                                             int32_t sao_left_class,
-                                            int16_t *sao_offset_val,
+                                            const int16_t *sao_offset_val,
                                             int32_t height)
 {
     v16u8 src0, src1, src2, src3;
@@ -1100,9 +1100,9 @@ static void hevc_sao_band_filter_4width_msa(uint8_t *dst, int32_t dst_stride,
 }
 
 static void hevc_sao_band_filter_8width_msa(uint8_t *dst, int32_t dst_stride,
-                                            uint8_t *src, int32_t src_stride,
+                                            const uint8_t *src, int32_t src_stride,
                                             int32_t sao_left_class,
-                                            int16_t *sao_offset_val,
+                                            const int16_t *sao_offset_val,
                                             int32_t height)
 {
     v16u8 src0, src1, src2, src3;
@@ -1172,10 +1172,10 @@ static void hevc_sao_band_filter_8width_msa(uint8_t *dst, int32_t dst_stride,
 
 static void hevc_sao_band_filter_16multiple_msa(uint8_t *dst,
                                                 int32_t dst_stride,
-                                                uint8_t *src,
+                                                const uint8_t *src,
                                                 int32_t src_stride,
                                                 int32_t sao_left_class,
-                                                int16_t *sao_offset_val,
+                                                const int16_t *sao_offset_val,
                                                 int32_t width, int32_t height)
 {
     int32_t w_cnt;
@@ -1254,9 +1254,9 @@ static void hevc_sao_band_filter_16multiple_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_0degree_4width_msa(uint8_t *dst,
                                                     int32_t dst_stride,
-                                                    uint8_t *src,
+                                                    const uint8_t *src,
                                                     int32_t src_stride,
-                                                    int16_t *sao_offset_val,
+                                                    const int16_t *sao_offset_val,
                                                     int32_t height)
 {
     uint32_t dst_val0, dst_val1;
@@ -1346,9 +1346,9 @@ static void hevc_sao_edge_filter_0degree_4width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_0degree_8width_msa(uint8_t *dst,
                                                     int32_t dst_stride,
-                                                    uint8_t *src,
+                                                    const uint8_t *src,
                                                     int32_t src_stride,
-                                                    int16_t *sao_offset_val,
+                                                    const int16_t *sao_offset_val,
                                                     int32_t height)
 {
     uint64_t dst_val0, dst_val1;
@@ -1440,13 +1440,14 @@ static void hevc_sao_edge_filter_0degree_8width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_0degree_16multiple_msa(uint8_t *dst,
                                                         int32_t dst_stride,
-                                                        uint8_t *src,
+                                                        const uint8_t *src,
                                                         int32_t src_stride,
-                                                        int16_t *sao_offset_val,
+                                                        const int16_t *sao_offset_val,
                                                         int32_t width,
                                                         int32_t height)
 {
-    uint8_t *dst_ptr, *src_minus1;
+    const uint8_t *src_minus1;
+    uint8_t *dst_ptr;
     int32_t v_cnt;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
     v16u8 const1 = (v16u8) __msa_ldi_b(1);
@@ -1556,9 +1557,9 @@ static void hevc_sao_edge_filter_0degree_16multiple_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_90degree_4width_msa(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
     uint32_t dst_val0, dst_val1;
@@ -1661,9 +1662,9 @@ static void hevc_sao_edge_filter_90degree_4width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_90degree_8width_msa(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
     uint64_t dst_val0, dst_val1;
@@ -1763,14 +1764,14 @@ static void hevc_sao_edge_filter_90degree_8width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_90degree_16multiple_msa(uint8_t *dst,
                                                          int32_t dst_stride,
-                                                         uint8_t *src,
+                                                         const uint8_t *src,
                                                          int32_t src_stride,
-                                                         int16_t *
+                                                         const int16_t *
                                                          sao_offset_val,
                                                          int32_t width,
                                                          int32_t height)
 {
-    uint8_t *src_orig = src;
+    const uint8_t *src_orig = src;
     uint8_t *dst_orig = dst;
     int32_t h_cnt, v_cnt;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
@@ -1865,12 +1866,12 @@ static void hevc_sao_edge_filter_90degree_16multiple_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_45degree_4width_msa(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     uint32_t dst_val0, dst_val1;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
     v16u8 const1 = (v16u8) __msa_ldi_b(1);
@@ -1978,12 +1979,12 @@ static void hevc_sao_edge_filter_45degree_4width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_45degree_8width_msa(uint8_t *dst,
                                                      int32_t dst_stride,
-                                                     uint8_t *src,
+                                                     const uint8_t *src,
                                                      int32_t src_stride,
-                                                     int16_t *sao_offset_val,
+                                                     const int16_t *sao_offset_val,
                                                      int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     uint64_t dst_val0, dst_val1;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
     v16u8 const1 = (v16u8) __msa_ldi_b(1);
@@ -2094,14 +2095,14 @@ static void hevc_sao_edge_filter_45degree_8width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_45degree_16multiple_msa(uint8_t *dst,
                                                          int32_t dst_stride,
-                                                         uint8_t *src,
+                                                         const uint8_t *src,
                                                          int32_t src_stride,
-                                                         int16_t *
+                                                         const int16_t *
                                                          sao_offset_val,
                                                          int32_t width,
                                                          int32_t height)
 {
-    uint8_t *src_orig = src;
+    const uint8_t *src_orig = src;
     uint8_t *dst_orig = dst;
     int32_t v_cnt;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
@@ -2214,12 +2215,12 @@ static void hevc_sao_edge_filter_45degree_16multiple_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_135degree_4width_msa(uint8_t *dst,
                                                       int32_t dst_stride,
-                                                      uint8_t *src,
+                                                      const uint8_t *src,
                                                       int32_t src_stride,
-                                                      int16_t *sao_offset_val,
+                                                      const int16_t *sao_offset_val,
                                                       int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     uint32_t dst_val0, dst_val1;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
     v16u8 const1 = (v16u8) __msa_ldi_b(1);
@@ -2329,12 +2330,12 @@ static void hevc_sao_edge_filter_135degree_4width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_135degree_8width_msa(uint8_t *dst,
                                                       int32_t dst_stride,
-                                                      uint8_t *src,
+                                                      const uint8_t *src,
                                                       int32_t src_stride,
-                                                      int16_t *sao_offset_val,
+                                                      const int16_t *sao_offset_val,
                                                       int32_t height)
 {
-    uint8_t *src_orig;
+    const uint8_t *src_orig;
     uint64_t dst_val0, dst_val1;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
     v16u8 const1 = (v16u8) __msa_ldi_b(1);
@@ -2441,14 +2442,15 @@ static void hevc_sao_edge_filter_135degree_8width_msa(uint8_t *dst,
 
 static void hevc_sao_edge_filter_135degree_16multiple_msa(uint8_t *dst,
                                                           int32_t dst_stride,
-                                                          uint8_t *src,
+                                                          const uint8_t *src,
                                                           int32_t src_stride,
-                                                          int16_t *
+                                                          const int16_t *
                                                           sao_offset_val,
                                                           int32_t width,
                                                           int32_t height)
 {
-    uint8_t *src_orig, *dst_orig;
+    const uint8_t *src_orig;
+    uint8_t *dst_orig;
     int32_t v_cnt;
     v16i8 edge_idx = { 1, 2, 0, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
     v16u8 const1 = (v16u8) __msa_ldi_b(1);
@@ -2563,39 +2565,39 @@ static void hevc_sao_edge_filter_135degree_16multiple_msa(uint8_t *dst,
 
 void ff_hevc_loop_filter_luma_h_8_msa(uint8_t *src,
                                       ptrdiff_t src_stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *no_p, uint8_t *no_q)
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *no_p, const uint8_t *no_q)
 {
     hevc_loopfilter_luma_hor_msa(src, src_stride, beta, tc, no_p, no_q);
 }
 
 void ff_hevc_loop_filter_luma_v_8_msa(uint8_t *src,
                                       ptrdiff_t src_stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *no_p, uint8_t *no_q)
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *no_p, const uint8_t *no_q)
 {
     hevc_loopfilter_luma_ver_msa(src, src_stride, beta, tc, no_p, no_q);
 }
 
 void ff_hevc_loop_filter_chroma_h_8_msa(uint8_t *src,
                                         ptrdiff_t src_stride,
-                                        int32_t *tc, uint8_t *no_p,
-                                        uint8_t *no_q)
+                                        const int32_t *tc, const uint8_t *no_p,
+                                        const uint8_t *no_q)
 {
     hevc_loopfilter_chroma_hor_msa(src, src_stride, tc, no_p, no_q);
 }
 
 void ff_hevc_loop_filter_chroma_v_8_msa(uint8_t *src,
                                         ptrdiff_t src_stride,
-                                        int32_t *tc, uint8_t *no_p,
-                                        uint8_t *no_q)
+                                        const int32_t *tc, const uint8_t *no_p,
+                                        const uint8_t *no_q)
 {
     hevc_loopfilter_chroma_ver_msa(src, src_stride, tc, no_p, no_q);
 }
 
-void ff_hevc_sao_band_filter_0_8_msa(uint8_t *dst, uint8_t *src,
+void ff_hevc_sao_band_filter_0_8_msa(uint8_t *dst, const uint8_t *src,
                                      ptrdiff_t stride_dst, ptrdiff_t stride_src,
-                                     int16_t *sao_offset_val, int sao_left_class,
+                                     const int16_t *sao_offset_val, int sao_left_class,
                                      int width, int height)
 {
     if (width >> 4) {
@@ -2621,9 +2623,9 @@ void ff_hevc_sao_band_filter_0_8_msa(uint8_t *dst, uint8_t *src,
     }
 }
 
-void ff_hevc_sao_edge_filter_8_msa(uint8_t *dst, uint8_t *src,
+void ff_hevc_sao_edge_filter_8_msa(uint8_t *dst, const uint8_t *src,
                                    ptrdiff_t stride_dst,
-                                   int16_t *sao_offset_val,
+                                   const int16_t *sao_offset_val,
                                    int eo, int width, int height)
 {
     ptrdiff_t stride_src = (2 * MAX_PB_SIZE + AV_INPUT_BUFFER_PADDING_SIZE) / sizeof(uint8_t);
diff --git a/libavcodec/mips/hevc_mc_bi_msa.c b/libavcodec/mips/hevc_mc_bi_msa.c
index c6c8d27..701e12a 100644
--- a/libavcodec/mips/hevc_mc_bi_msa.c
+++ b/libavcodec/mips/hevc_mc_bi_msa.c
@@ -58,9 +58,9 @@ static const uint8_t ff_hevc_mask_arr[16 * 2] __attribute__((aligned(0x40))) = {
     HEVC_BI_RND_CLIP2_MAX_SATU(in2, in3, vec2, vec3, rnd_val, out2, out3);  \
 }
 
-static void hevc_bi_copy_4w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_4w_msa(const uint8_t *src0_ptr,
                                 int32_t src_stride,
-                                int16_t *src1_ptr,
+                                const int16_t *src1_ptr,
                                 int32_t src2_stride,
                                 uint8_t *dst,
                                 int32_t dst_stride,
@@ -126,9 +126,9 @@ static void hevc_bi_copy_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_6w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_6w_msa(const uint8_t *src0_ptr,
                                 int32_t src_stride,
-                                int16_t *src1_ptr,
+                                const int16_t *src1_ptr,
                                 int32_t src2_stride,
                                 uint8_t *dst,
                                 int32_t dst_stride,
@@ -178,9 +178,9 @@ static void hevc_bi_copy_6w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_8w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_8w_msa(const uint8_t *src0_ptr,
                                 int32_t src_stride,
-                                int16_t *src1_ptr,
+                                const int16_t *src1_ptr,
                                 int32_t src2_stride,
                                 uint8_t *dst,
                                 int32_t dst_stride,
@@ -266,9 +266,9 @@ static void hevc_bi_copy_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_12w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_12w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -305,9 +305,9 @@ static void hevc_bi_copy_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_16w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_16w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -343,9 +343,9 @@ static void hevc_bi_copy_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_24w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_24w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -389,9 +389,9 @@ static void hevc_bi_copy_24w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_32w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_32w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -433,9 +433,9 @@ static void hevc_bi_copy_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_48w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_48w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -487,9 +487,9 @@ static void hevc_bi_copy_48w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_bi_copy_64w_msa(uint8_t *src0_ptr,
+static void hevc_bi_copy_64w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -526,9 +526,9 @@ static void hevc_bi_copy_64w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_4w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -599,9 +599,9 @@ static void hevc_hz_bi_8t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_8w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -667,9 +667,9 @@ static void hevc_hz_bi_8t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_12w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -755,9 +755,9 @@ static void hevc_hz_bi_8t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_16w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -826,9 +826,9 @@ static void hevc_hz_bi_8t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_24w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -898,9 +898,9 @@ static void hevc_hz_bi_8t_24w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_32w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -970,9 +970,9 @@ static void hevc_hz_bi_8t_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_48w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_48w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1062,9 +1062,9 @@ static void hevc_hz_bi_8t_48w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_8t_64w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_8t_64w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1172,9 +1172,9 @@ static void hevc_hz_bi_8t_64w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_8t_4w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_4w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -1258,9 +1258,9 @@ static void hevc_vt_bi_8t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_8t_8w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_8w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -1336,9 +1336,9 @@ static void hevc_vt_bi_8t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_8t_12w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_12w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1443,17 +1443,17 @@ static void hevc_vt_bi_8t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_8t_16multx2mult_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_16multx2mult_msa(const uint8_t *src0_ptr,
                                            int32_t src_stride,
-                                           int16_t *src1_ptr,
+                                           const int16_t *src1_ptr,
                                            int32_t src2_stride,
                                            uint8_t *dst,
                                            int32_t dst_stride,
                                            const int8_t *filter,
                                            int32_t height, int32_t width)
 {
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt;
     uint32_t cnt;
@@ -1549,9 +1549,9 @@ static void hevc_vt_bi_8t_16multx2mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_8t_16w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_16w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1562,9 +1562,9 @@ static void hevc_vt_bi_8t_16w_msa(uint8_t *src0_ptr,
                                    dst, dst_stride, filter, height, 16);
 }
 
-static void hevc_vt_bi_8t_24w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_24w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1577,9 +1577,9 @@ static void hevc_vt_bi_8t_24w_msa(uint8_t *src0_ptr,
                          dst + 16, dst_stride, filter, height);
 }
 
-static void hevc_vt_bi_8t_32w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_32w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1590,9 +1590,9 @@ static void hevc_vt_bi_8t_32w_msa(uint8_t *src0_ptr,
                                    dst, dst_stride, filter, height, 32);
 }
 
-static void hevc_vt_bi_8t_48w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_48w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1603,9 +1603,9 @@ static void hevc_vt_bi_8t_48w_msa(uint8_t *src0_ptr,
                                    dst, dst_stride, filter, height, 48);
 }
 
-static void hevc_vt_bi_8t_64w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_8t_64w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1616,9 +1616,9 @@ static void hevc_vt_bi_8t_64w_msa(uint8_t *src0_ptr,
                                    dst, dst_stride, filter, height, 64);
 }
 
-static void hevc_hv_bi_8t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_4w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -1741,9 +1741,9 @@ static void hevc_hv_bi_8t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_8t_8multx1mult_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_8multx1mult_msa(const uint8_t *src0_ptr,
                                           int32_t src_stride,
-                                          int16_t *src1_ptr,
+                                          const int16_t *src1_ptr,
                                           int32_t src2_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -1753,8 +1753,8 @@ static void hevc_hv_bi_8t_8multx1mult_msa(uint8_t *src0_ptr,
 {
     uint32_t loop_cnt;
     uint32_t cnt;
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     v16u8 out;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7;
@@ -1874,9 +1874,9 @@ static void hevc_hv_bi_8t_8multx1mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_8t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_8w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -1889,9 +1889,9 @@ static void hevc_hv_bi_8t_8w_msa(uint8_t *src0_ptr,
                                   height, 8);
 }
 
-static void hevc_hv_bi_8t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_12w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1900,8 +1900,9 @@ static void hevc_hv_bi_8t_12w_msa(uint8_t *src0_ptr,
                                   int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src0_ptr_tmp, *dst_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    uint8_t *dst_tmp;
+    const int16_t *src1_ptr_tmp;
     uint64_t tp0, tp1;
     v16u8 out;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
@@ -2103,9 +2104,9 @@ static void hevc_hv_bi_8t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_8t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_16w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2118,9 +2119,9 @@ static void hevc_hv_bi_8t_16w_msa(uint8_t *src0_ptr,
                                   height, 16);
 }
 
-static void hevc_hv_bi_8t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_24w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2133,9 +2134,9 @@ static void hevc_hv_bi_8t_24w_msa(uint8_t *src0_ptr,
                                   height, 24);
 }
 
-static void hevc_hv_bi_8t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_32w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2148,9 +2149,9 @@ static void hevc_hv_bi_8t_32w_msa(uint8_t *src0_ptr,
                                   height, 32);
 }
 
-static void hevc_hv_bi_8t_48w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_48w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2163,9 +2164,9 @@ static void hevc_hv_bi_8t_48w_msa(uint8_t *src0_ptr,
                                   height, 48);
 }
 
-static void hevc_hv_bi_8t_64w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_8t_64w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2178,9 +2179,9 @@ static void hevc_hv_bi_8t_64w_msa(uint8_t *src0_ptr,
                                   height, 64);
 }
 
-static void hevc_hz_bi_4t_4x2_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_4x2_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2221,9 +2222,9 @@ static void hevc_hz_bi_4t_4x2_msa(uint8_t *src0_ptr,
     ST_W2(dst0, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_bi_4t_4x4_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_4x4_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2267,9 +2268,9 @@ static void hevc_hz_bi_4t_4x4_msa(uint8_t *src0_ptr,
     ST_W4(dst0, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_hz_bi_4t_4x8multiple_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_4x8multiple_msa(const uint8_t *src0_ptr,
                                           int32_t src_stride,
-                                          int16_t *src1_ptr,
+                                          const int16_t *src1_ptr,
                                           int32_t src2_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -2330,9 +2331,9 @@ static void hevc_hz_bi_4t_4x8multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_4w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -2352,9 +2353,9 @@ static void hevc_hz_bi_4t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_6w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_6w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -2413,9 +2414,9 @@ static void hevc_hz_bi_4t_6w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_8x2_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_8x2_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2456,9 +2457,9 @@ static void hevc_hz_bi_4t_8x2_msa(uint8_t *src0_ptr,
     ST_D2(dst0, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_bi_4t_8x6_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_8x6_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2520,9 +2521,9 @@ static void hevc_hz_bi_4t_8x6_msa(uint8_t *src0_ptr,
     ST_D2(dst2, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_hz_bi_4t_8x4multiple_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_8x4multiple_msa(const uint8_t *src0_ptr,
                                           int32_t src_stride,
-                                          int16_t *src1_ptr,
+                                          const int16_t *src1_ptr,
                                           int32_t src2_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -2578,9 +2579,9 @@ static void hevc_hz_bi_4t_8x4multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_8w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -2600,9 +2601,9 @@ static void hevc_hz_bi_4t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_12w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2674,9 +2675,9 @@ static void hevc_hz_bi_4t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_16w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2734,16 +2735,16 @@ static void hevc_hz_bi_4t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_24w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
                                   const int8_t *filter,
                                   int32_t height)
 {
-    int16_t *src1_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7;
@@ -2840,9 +2841,9 @@ static void hevc_hz_bi_4t_24w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_bi_4t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hz_bi_4t_32w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2901,9 +2902,9 @@ static void hevc_hz_bi_4t_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_4x2_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_4x2_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2949,9 +2950,9 @@ static void hevc_vt_bi_4t_4x2_msa(uint8_t *src0_ptr,
     ST_W2(dst10, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_bi_4t_4x4_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_4x4_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -2998,9 +2999,9 @@ static void hevc_vt_bi_4t_4x4_msa(uint8_t *src0_ptr,
     ST_W4(dst10, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_vt_bi_4t_4x8multiple_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_4x8multiple_msa(const uint8_t *src0_ptr,
                                           int32_t src_stride,
-                                          int16_t *src1_ptr,
+                                          const int16_t *src1_ptr,
                                           int32_t src2_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -3071,9 +3072,9 @@ static void hevc_vt_bi_4t_4x8multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_4w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_4w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -3093,9 +3094,9 @@ static void hevc_vt_bi_4t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_6w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_6w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -3191,9 +3192,9 @@ static void hevc_vt_bi_4t_6w_msa(uint8_t *src0_ptr,
     dst += (4 * dst_stride);
 }
 
-static void hevc_vt_bi_4t_8x2_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_8x2_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3235,9 +3236,9 @@ static void hevc_vt_bi_4t_8x2_msa(uint8_t *src0_ptr,
     ST_D2(dst0_r, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_bi_4t_8x6_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_8x6_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3295,9 +3296,9 @@ static void hevc_vt_bi_4t_8x6_msa(uint8_t *src0_ptr,
     ST_D2(dst2_r, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_vt_bi_4t_8x4multiple_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_8x4multiple_msa(const uint8_t *src0_ptr,
                                           int32_t src_stride,
-                                          int16_t *src1_ptr,
+                                          const int16_t *src1_ptr,
                                           int32_t src2_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -3357,9 +3358,9 @@ static void hevc_vt_bi_4t_8x4multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_8w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_8w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -3379,9 +3380,9 @@ static void hevc_vt_bi_4t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_12w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_12w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3462,9 +3463,9 @@ static void hevc_vt_bi_4t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_16w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_16w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3547,9 +3548,9 @@ static void hevc_vt_bi_4t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_24w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_24w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3671,9 +3672,9 @@ static void hevc_vt_bi_4t_24w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_bi_4t_32w_msa(uint8_t *src0_ptr,
+static void hevc_vt_bi_4t_32w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3781,9 +3782,9 @@ static void hevc_vt_bi_4t_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_4x2_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_4x2_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3848,9 +3849,9 @@ static void hevc_hv_bi_4t_4x2_msa(uint8_t *src0_ptr,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_bi_4t_4x4_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_4x4_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3924,9 +3925,9 @@ static void hevc_hv_bi_4t_4x4_msa(uint8_t *src0_ptr,
     ST_W4(out, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_hv_bi_4t_4multx8mult_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_4multx8mult_msa(const uint8_t *src0_ptr,
                                           int32_t src_stride,
-                                          int16_t *src1_ptr,
+                                          const int16_t *src1_ptr,
                                           int32_t src2_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -4043,9 +4044,9 @@ static void hevc_hv_bi_4t_4multx8mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_4w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -4067,9 +4068,9 @@ static void hevc_hv_bi_4t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_6w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_6w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -4217,9 +4218,9 @@ static void hevc_hv_bi_4t_6w_msa(uint8_t *src0_ptr,
     ST_H8(out2, 0, 1, 2, 3, 4, 5, 6, 7, dst + 4, dst_stride);
 }
 
-static void hevc_hv_bi_4t_8x2_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_8x2_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -4291,9 +4292,9 @@ static void hevc_hv_bi_4t_8x2_msa(uint8_t *src0_ptr,
     ST_D2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_bi_4t_8multx4_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_8multx4_msa(const uint8_t *src0_ptr,
                                       int32_t src_stride,
-                                      int16_t *src1_ptr,
+                                      const int16_t *src1_ptr,
                                       int32_t src2_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -4387,9 +4388,9 @@ static void hevc_hv_bi_4t_8multx4_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_8x6_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_8x6_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -4503,9 +4504,9 @@ static void hevc_hv_bi_4t_8x6_msa(uint8_t *src0_ptr,
     ST_D2(out2, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_hv_bi_4t_8multx4mult_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_8multx4mult_msa(const uint8_t *src0_ptr,
                                           int32_t src_stride,
-                                          int16_t *src1_ptr,
+                                          const int16_t *src1_ptr,
                                           int32_t src2_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -4515,8 +4516,8 @@ static void hevc_hv_bi_4t_8multx4mult_msa(uint8_t *src0_ptr,
                                           int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6;
@@ -4628,9 +4629,9 @@ static void hevc_hv_bi_4t_8multx4mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_8w_msa(const uint8_t *src0_ptr,
                                  int32_t src_stride,
-                                 int16_t *src1_ptr,
+                                 const int16_t *src1_ptr,
                                  int32_t src2_stride,
                                  uint8_t *dst,
                                  int32_t dst_stride,
@@ -4655,9 +4656,9 @@ static void hevc_hv_bi_4t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_12w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -4667,8 +4668,9 @@ static void hevc_hv_bi_4t_12w_msa(uint8_t *src0_ptr,
 {
     uint32_t loop_cnt;
     uint64_t tp0, tp1;
-    uint8_t *src0_ptr_tmp, *dst_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    uint8_t *dst_tmp;
+    const int16_t *src1_ptr_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 vec0, vec1, vec2, vec3, vec4, vec5, vec6, vec7;
@@ -4857,9 +4859,9 @@ static void hevc_hv_bi_4t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_16w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -4877,9 +4879,9 @@ static void hevc_hv_bi_4t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_bi_4t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_24w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -4892,9 +4894,9 @@ static void hevc_hv_bi_4t_24w_msa(uint8_t *src0_ptr,
                                   height, 24);
 }
 
-static void hevc_hv_bi_4t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hv_bi_4t_32w_msa(const uint8_t *src0_ptr,
                                   int32_t src_stride,
-                                  int16_t *src1_ptr,
+                                  const int16_t *src1_ptr,
                                   int32_t src2_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -4910,9 +4912,9 @@ static void hevc_hv_bi_4t_32w_msa(uint8_t *src0_ptr,
 #define BI_MC_COPY(WIDTH)                                                 \
 void ff_hevc_put_hevc_bi_pel_pixels##WIDTH##_8_msa(uint8_t *dst,          \
                                                    ptrdiff_t dst_stride,  \
-                                                   uint8_t *src,          \
+                                                   const uint8_t *src,    \
                                                    ptrdiff_t src_stride,  \
-                                                   int16_t *src_16bit,    \
+                                                   const int16_t *src_16bit, \
                                                    int height,            \
                                                    intptr_t mx,           \
                                                    intptr_t my,           \
@@ -4937,9 +4939,9 @@ BI_MC_COPY(64);
 #define BI_MC(PEL, DIR, WIDTH, TAP, DIR1, FILT_DIR)                          \
 void ff_hevc_put_hevc_bi_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,          \
                                                       ptrdiff_t dst_stride,  \
-                                                      uint8_t *src,          \
+                                                      const uint8_t *src,    \
                                                       ptrdiff_t src_stride,  \
-                                                      int16_t *src_16bit,    \
+                                                      const int16_t *src_16bit, \
                                                       int height,            \
                                                       intptr_t mx,           \
                                                       intptr_t my,           \
@@ -4991,9 +4993,9 @@ BI_MC(epel, v, 32, 4, vt, my);
 #define BI_MC_HV(PEL, WIDTH, TAP)                                         \
 void ff_hevc_put_hevc_bi_##PEL##_hv##WIDTH##_8_msa(uint8_t *dst,          \
                                                    ptrdiff_t dst_stride,  \
-                                                   uint8_t *src,          \
+                                                   const uint8_t *src,    \
                                                    ptrdiff_t src_stride,  \
-                                                   int16_t *src_16bit,    \
+                                                   const int16_t *src_16bit, \
                                                    int height,            \
                                                    intptr_t mx,           \
                                                    intptr_t my,           \
diff --git a/libavcodec/mips/hevc_mc_biw_msa.c b/libavcodec/mips/hevc_mc_biw_msa.c
index f775ea8..981c37d 100644
--- a/libavcodec/mips/hevc_mc_biw_msa.c
+++ b/libavcodec/mips/hevc_mc_biw_msa.c
@@ -79,9 +79,9 @@ static const uint8_t ff_hevc_mask_arr[16 * 2] __attribute__((aligned(0x40))) = {
                                 out2, out3);                               \
 }
 
-static void hevc_biwgt_copy_4w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_4w_msa(const uint8_t *src0_ptr,
                                    int32_t src_stride,
-                                   int16_t *src1_ptr,
+                                   const int16_t *src1_ptr,
                                    int32_t src2_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -168,9 +168,9 @@ static void hevc_biwgt_copy_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_6w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_6w_msa(const uint8_t *src0_ptr,
                                    int32_t src_stride,
-                                   int16_t *src1_ptr,
+                                   const int16_t *src1_ptr,
                                    int32_t src2_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -222,9 +222,9 @@ static void hevc_biwgt_copy_6w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_8w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_8w_msa(const uint8_t *src0_ptr,
                                    int32_t src_stride,
-                                   int16_t *src1_ptr,
+                                   const int16_t *src1_ptr,
                                    int32_t src2_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -310,9 +310,9 @@ static void hevc_biwgt_copy_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_12w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_12w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -369,9 +369,9 @@ static void hevc_biwgt_copy_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_16w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_16w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -424,9 +424,9 @@ static void hevc_biwgt_copy_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_24w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_24w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -488,9 +488,9 @@ static void hevc_biwgt_copy_24w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_32w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_32w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -549,9 +549,9 @@ static void hevc_biwgt_copy_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_48w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_48w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -601,9 +601,9 @@ static void hevc_biwgt_copy_48w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_biwgt_copy_64w_msa(uint8_t *src0_ptr,
+static void hevc_biwgt_copy_64w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -656,9 +656,9 @@ static void hevc_biwgt_copy_64w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_8t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_4w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -728,9 +728,9 @@ static void hevc_hz_biwgt_8t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_8t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_8w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -808,9 +808,9 @@ static void hevc_hz_biwgt_8t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_8t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_12w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -903,9 +903,9 @@ static void hevc_hz_biwgt_8t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_8t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_16w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -987,9 +987,9 @@ static void hevc_hz_biwgt_8t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_8t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_24w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1109,9 +1109,9 @@ static void hevc_hz_biwgt_8t_24w_msa(uint8_t *src0_ptr,
     dst += dst_stride;
 }
 
-static void hevc_hz_biwgt_8t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_32w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1195,9 +1195,9 @@ static void hevc_hz_biwgt_8t_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_8t_48w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_48w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1299,9 +1299,9 @@ static void hevc_hz_biwgt_8t_48w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_8t_64w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_8t_64w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1313,9 +1313,9 @@ static void hevc_hz_biwgt_8t_64w_msa(uint8_t *src0_ptr,
                                      int32_t offset1,
                                      int32_t rnd_val)
 {
-    uint8_t *src0_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
     uint8_t *dst_tmp;
-    int16_t *src1_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint32_t loop_cnt, cnt;
     int32_t offset, weight, constant;
     v16i8 src0, src1, src2;
@@ -1398,9 +1398,9 @@ static void hevc_hz_biwgt_8t_64w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_8t_4w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_4w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -1496,9 +1496,9 @@ static void hevc_vt_biwgt_8t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_8t_8w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_8w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -1584,9 +1584,9 @@ static void hevc_vt_biwgt_8t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_8t_12w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_12w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1694,9 +1694,9 @@ static void hevc_vt_biwgt_8t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_8t_16multx2mult_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_16multx2mult_msa(const uint8_t *src0_ptr,
                                               int32_t src_stride,
-                                              int16_t *src1_ptr,
+                                              const int16_t *src1_ptr,
                                               int32_t src2_stride,
                                               uint8_t *dst,
                                               int32_t dst_stride,
@@ -1709,8 +1709,8 @@ static void hevc_vt_biwgt_8t_16multx2mult_msa(uint8_t *src0_ptr,
                                               int32_t rnd_val,
                                               int32_t width)
 {
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt, cnt;
     int32_t offset, weight;
@@ -1810,9 +1810,9 @@ static void hevc_vt_biwgt_8t_16multx2mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_8t_16w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_16w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1831,9 +1831,9 @@ static void hevc_vt_biwgt_8t_16w_msa(uint8_t *src0_ptr,
                                       rnd_val, 16);
 }
 
-static void hevc_vt_biwgt_8t_24w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_24w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1856,9 +1856,9 @@ static void hevc_vt_biwgt_8t_24w_msa(uint8_t *src0_ptr,
                             weight0, weight1, offset0, offset1, rnd_val);
 }
 
-static void hevc_vt_biwgt_8t_32w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_32w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1877,9 +1877,9 @@ static void hevc_vt_biwgt_8t_32w_msa(uint8_t *src0_ptr,
                                       rnd_val, 32);
 }
 
-static void hevc_vt_biwgt_8t_48w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_48w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1898,9 +1898,9 @@ static void hevc_vt_biwgt_8t_48w_msa(uint8_t *src0_ptr,
                                       rnd_val, 48);
 }
 
-static void hevc_vt_biwgt_8t_64w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_8t_64w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1919,9 +1919,9 @@ static void hevc_vt_biwgt_8t_64w_msa(uint8_t *src0_ptr,
                                       rnd_val, 64);
 }
 
-static void hevc_hv_biwgt_8t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_4w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -2064,9 +2064,9 @@ static void hevc_hv_biwgt_8t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_8t_8multx2mult_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_8multx2mult_msa(const uint8_t *src0_ptr,
                                              int32_t src_stride,
-                                             int16_t *src1_ptr,
+                                             const int16_t *src1_ptr,
                                              int32_t src2_stride,
                                              uint8_t *dst,
                                              int32_t dst_stride,
@@ -2082,8 +2082,8 @@ static void hevc_hv_biwgt_8t_8multx2mult_msa(uint8_t *src0_ptr,
 {
     uint32_t loop_cnt, cnt;
     int32_t offset, weight;
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     v16u8 out;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;
@@ -2247,9 +2247,9 @@ static void hevc_hv_biwgt_8t_8multx2mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_8t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_8w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -2269,9 +2269,9 @@ static void hevc_hv_biwgt_8t_8w_msa(uint8_t *src0_ptr,
                                      offset1, rnd_val, 1);
 }
 
-static void hevc_hv_biwgt_8t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_12w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2285,8 +2285,9 @@ static void hevc_hv_biwgt_8t_12w_msa(uint8_t *src0_ptr,
                                      int32_t rnd_val)
 {
     uint32_t loop_cnt;
-    uint8_t *src0_ptr_tmp, *dst_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    uint8_t *dst_tmp;
+    const int16_t *src1_ptr_tmp;
     int32_t offset, weight;
     uint64_t tp0, tp1;
     v16u8 out;
@@ -2519,9 +2520,9 @@ static void hevc_hv_biwgt_8t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_8t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_16w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2541,9 +2542,9 @@ static void hevc_hv_biwgt_8t_16w_msa(uint8_t *src0_ptr,
                                      offset1, rnd_val, 2);
 }
 
-static void hevc_hv_biwgt_8t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_24w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2563,9 +2564,9 @@ static void hevc_hv_biwgt_8t_24w_msa(uint8_t *src0_ptr,
                                      offset1, rnd_val, 3);
 }
 
-static void hevc_hv_biwgt_8t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_32w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2585,9 +2586,9 @@ static void hevc_hv_biwgt_8t_32w_msa(uint8_t *src0_ptr,
                                      offset1, rnd_val, 4);
 }
 
-static void hevc_hv_biwgt_8t_48w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_48w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2607,9 +2608,9 @@ static void hevc_hv_biwgt_8t_48w_msa(uint8_t *src0_ptr,
                                      offset1, rnd_val, 6);
 }
 
-static void hevc_hv_biwgt_8t_64w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_8t_64w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2629,9 +2630,9 @@ static void hevc_hv_biwgt_8t_64w_msa(uint8_t *src0_ptr,
                                      offset1, rnd_val, 8);
 }
 
-static void hevc_hz_biwgt_4t_4x2_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_4x2_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2689,9 +2690,9 @@ static void hevc_hz_biwgt_4t_4x2_msa(uint8_t *src0_ptr,
     ST_W2(out0, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_biwgt_4t_4x4_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_4x4_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2749,9 +2750,9 @@ static void hevc_hz_biwgt_4t_4x4_msa(uint8_t *src0_ptr,
     ST_W4(dst0, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_hz_biwgt_4t_4x8multiple_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_4x8multiple_msa(const uint8_t *src0_ptr,
                                              int32_t src_stride,
-                                             int16_t *src1_ptr,
+                                             const int16_t *src1_ptr,
                                              int32_t src2_stride,
                                              uint8_t *dst,
                                              int32_t dst_stride,
@@ -2824,9 +2825,9 @@ static void hevc_hz_biwgt_4t_4x8multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_4w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -2855,9 +2856,9 @@ static void hevc_hz_biwgt_4t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_6w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_6w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -2929,9 +2930,9 @@ static void hevc_hz_biwgt_4t_6w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_8x2_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_8x2_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2985,9 +2986,9 @@ static void hevc_hz_biwgt_4t_8x2_msa(uint8_t *src0_ptr,
     ST_D2(dst0, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_biwgt_4t_8x6_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_8x6_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3059,9 +3060,9 @@ static void hevc_hz_biwgt_4t_8x6_msa(uint8_t *src0_ptr,
     ST_D2(dst3, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_hz_biwgt_4t_8x4multiple_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_8x4multiple_msa(const uint8_t *src0_ptr,
                                              int32_t src_stride,
-                                             int16_t *src1_ptr,
+                                             const int16_t *src1_ptr,
                                              int32_t src2_stride,
                                              uint8_t *dst,
                                              int32_t dst_stride,
@@ -3129,9 +3130,9 @@ static void hevc_hz_biwgt_4t_8x4multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_8w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -3160,9 +3161,9 @@ static void hevc_hz_biwgt_4t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_12w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3246,9 +3247,9 @@ static void hevc_hz_biwgt_4t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_16w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3335,9 +3336,9 @@ static void hevc_hz_biwgt_4t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_24w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3422,9 +3423,9 @@ static void hevc_hz_biwgt_4t_24w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hz_biwgt_4t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hz_biwgt_4t_32w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3495,9 +3496,9 @@ static void hevc_hz_biwgt_4t_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_4x2_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_4x2_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3560,9 +3561,9 @@ static void hevc_vt_biwgt_4t_4x2_msa(uint8_t *src0_ptr,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_biwgt_4t_4x4_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_4x4_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3627,9 +3628,9 @@ static void hevc_vt_biwgt_4t_4x4_msa(uint8_t *src0_ptr,
     dst += (4 * dst_stride);
 }
 
-static void hevc_vt_biwgt_4t_4x8multiple_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_4x8multiple_msa(const uint8_t *src0_ptr,
                                              int32_t src_stride,
-                                             int16_t *src1_ptr,
+                                             const int16_t *src1_ptr,
                                              int32_t src2_stride,
                                              uint8_t *dst,
                                              int32_t dst_stride,
@@ -3713,9 +3714,9 @@ static void hevc_vt_biwgt_4t_4x8multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_4w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_4w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -3744,9 +3745,9 @@ static void hevc_vt_biwgt_4t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_6w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_6w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -3821,9 +3822,9 @@ static void hevc_vt_biwgt_4t_6w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_8x2_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_8x2_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3878,9 +3879,9 @@ static void hevc_vt_biwgt_4t_8x2_msa(uint8_t *src0_ptr,
     ST_D2(tmp0, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_biwgt_4t_8x6_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_8x6_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3949,9 +3950,9 @@ static void hevc_vt_biwgt_4t_8x6_msa(uint8_t *src0_ptr,
     ST_D2(tmp3, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_vt_biwgt_4t_8x4multiple_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_8x4multiple_msa(const uint8_t *src0_ptr,
                                              int32_t src_stride,
-                                             int16_t *src1_ptr,
+                                             const int16_t *src1_ptr,
                                              int32_t src2_stride,
                                              uint8_t *dst,
                                              int32_t dst_stride,
@@ -4023,9 +4024,9 @@ static void hevc_vt_biwgt_4t_8x4multiple_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_8w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_8w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -4054,9 +4055,9 @@ static void hevc_vt_biwgt_4t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_12w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_12w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4146,9 +4147,9 @@ static void hevc_vt_biwgt_4t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_16w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_16w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4240,9 +4241,9 @@ static void hevc_vt_biwgt_4t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_24w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_24w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4377,9 +4378,9 @@ static void hevc_vt_biwgt_4t_24w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_vt_biwgt_4t_32w_msa(uint8_t *src0_ptr,
+static void hevc_vt_biwgt_4t_32w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4496,9 +4497,9 @@ static void hevc_vt_biwgt_4t_32w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_4x2_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_4x2_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4580,9 +4581,9 @@ static void hevc_hv_biwgt_4t_4x2_msa(uint8_t *src0_ptr,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_biwgt_4t_4x4_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_4x4_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4677,9 +4678,9 @@ static void hevc_hv_biwgt_4t_4x4_msa(uint8_t *src0_ptr,
     ST_W4(out, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_hv_biwgt_4t_4multx8mult_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_4multx8mult_msa(const uint8_t *src0_ptr,
                                              int32_t src_stride,
-                                             int16_t *src1_ptr,
+                                             const int16_t *src1_ptr,
                                              int32_t src2_stride,
                                              uint8_t *dst,
                                              int32_t dst_stride,
@@ -4821,9 +4822,9 @@ static void hevc_hv_biwgt_4t_4multx8mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_4w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_4w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -4853,9 +4854,9 @@ static void hevc_hv_biwgt_4t_4w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_6w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_6w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -5035,9 +5036,9 @@ static void hevc_hv_biwgt_4t_6w_msa(uint8_t *src0_ptr,
     ST_H8(out2, 0, 1, 2, 3, 4, 5, 6, 7, dst + 4, dst_stride);
 }
 
-static void hevc_hv_biwgt_4t_8x2_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_8x2_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -5131,9 +5132,9 @@ static void hevc_hv_biwgt_4t_8x2_msa(uint8_t *src0_ptr,
     ST_D2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_biwgt_4t_8multx4_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_8multx4_msa(const uint8_t *src0_ptr,
                                          int32_t src_stride,
-                                         int16_t *src1_ptr,
+                                         const int16_t *src1_ptr,
                                          int32_t src2_stride,
                                          uint8_t *dst,
                                          int32_t dst_stride,
@@ -5255,9 +5256,9 @@ static void hevc_hv_biwgt_4t_8multx4_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_8x6_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_8x6_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -5405,9 +5406,9 @@ static void hevc_hv_biwgt_4t_8x6_msa(uint8_t *src0_ptr,
     ST_D2(out2, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_hv_biwgt_4t_8multx4mult_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_8multx4mult_msa(const uint8_t *src0_ptr,
                                              int32_t src_stride,
-                                             int16_t *src1_ptr,
+                                             const int16_t *src1_ptr,
                                              int32_t src2_stride,
                                              uint8_t *dst,
                                              int32_t dst_stride,
@@ -5424,8 +5425,8 @@ static void hevc_hv_biwgt_4t_8multx4mult_msa(uint8_t *src0_ptr,
     uint32_t loop_cnt;
     uint32_t cnt;
     int32_t offset, weight;
-    uint8_t *src0_ptr_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
     uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6;
@@ -5555,9 +5556,9 @@ static void hevc_hv_biwgt_4t_8multx4mult_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_8w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_8w_msa(const uint8_t *src0_ptr,
                                     int32_t src_stride,
-                                    int16_t *src1_ptr,
+                                    const int16_t *src1_ptr,
                                     int32_t src2_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -5592,9 +5593,9 @@ static void hevc_hv_biwgt_4t_8w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_12w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_12w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -5610,8 +5611,9 @@ static void hevc_hv_biwgt_4t_12w_msa(uint8_t *src0_ptr,
     uint32_t loop_cnt;
     uint64_t tp0, tp1;
     int32_t offset, weight;
-    uint8_t *src0_ptr_tmp, *dst_tmp;
-    int16_t *src1_ptr_tmp;
+    const uint8_t *src0_ptr_tmp;
+    const int16_t *src1_ptr_tmp;
+    uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 vec0, vec1, vec2, vec3, vec4, vec5, vec6, vec7;
@@ -5831,9 +5833,9 @@ static void hevc_hv_biwgt_4t_12w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_16w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_16w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -5859,9 +5861,9 @@ static void hevc_hv_biwgt_4t_16w_msa(uint8_t *src0_ptr,
     }
 }
 
-static void hevc_hv_biwgt_4t_24w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_24w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -5881,9 +5883,9 @@ static void hevc_hv_biwgt_4t_24w_msa(uint8_t *src0_ptr,
                                      weight1, offset0, offset1, rnd_val, 24);
 }
 
-static void hevc_hv_biwgt_4t_32w_msa(uint8_t *src0_ptr,
+static void hevc_hv_biwgt_4t_32w_msa(const uint8_t *src0_ptr,
                                      int32_t src_stride,
-                                     int16_t *src1_ptr,
+                                     const int16_t *src1_ptr,
                                      int32_t src2_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -5906,9 +5908,9 @@ static void hevc_hv_biwgt_4t_32w_msa(uint8_t *src0_ptr,
 #define BI_W_MC_COPY(WIDTH)                                                  \
 void ff_hevc_put_hevc_bi_w_pel_pixels##WIDTH##_8_msa(uint8_t *dst,           \
                                                      ptrdiff_t dst_stride,   \
-                                                     uint8_t *src,           \
+                                                     const uint8_t *src,     \
                                                      ptrdiff_t src_stride,   \
-                                                     int16_t *src_16bit,     \
+                                                     const int16_t *src_16bit, \
                                                      int height,             \
                                                      int denom,              \
                                                      int weight0,            \
@@ -5944,10 +5946,10 @@ BI_W_MC_COPY(64);
 void ff_hevc_put_hevc_bi_w_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,         \
                                                         ptrdiff_t             \
                                                         dst_stride,           \
-                                                        uint8_t *src,         \
+                                                        const uint8_t *src,   \
                                                         ptrdiff_t             \
                                                         src_stride,           \
-                                                        int16_t *src_16bit,   \
+                                                        const int16_t *src_16bit, \
                                                         int height,           \
                                                         int denom,            \
                                                         int weight0,          \
@@ -6007,9 +6009,9 @@ BI_W_MC(epel, v, 32, 4, vt, my);
 #define BI_W_MC_HV(PEL, WIDTH, TAP)                                         \
 void ff_hevc_put_hevc_bi_w_##PEL##_hv##WIDTH##_8_msa(uint8_t *dst,          \
                                                      ptrdiff_t dst_stride,  \
-                                                     uint8_t *src,          \
+                                                     const uint8_t *src,    \
                                                      ptrdiff_t src_stride,  \
-                                                     int16_t *src_16bit,    \
+                                                     const int16_t *src_16bit, \
                                                      int height,            \
                                                      int denom,             \
                                                      int weight0,           \
diff --git a/libavcodec/mips/hevc_mc_uni_msa.c b/libavcodec/mips/hevc_mc_uni_msa.c
index 36e6552..c0571e1 100644
--- a/libavcodec/mips/hevc_mc_uni_msa.c
+++ b/libavcodec/mips/hevc_mc_uni_msa.c
@@ -101,7 +101,7 @@ static const uint8_t ff_hevc_mask_arr[16 * 3] __attribute__((aligned(0x40))) = {
                  out0, out1, out2, out3);                                     \
 }
 
-static void copy_width8_msa(uint8_t *src, int32_t src_stride,
+static void copy_width8_msa(const uint8_t *src, int32_t src_stride,
                             uint8_t *dst, int32_t dst_stride,
                             int32_t height)
 {
@@ -143,7 +143,7 @@ static void copy_width8_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void copy_width12_msa(uint8_t *src, int32_t src_stride,
+static void copy_width12_msa(const uint8_t *src, int32_t src_stride,
                              uint8_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -157,7 +157,7 @@ static void copy_width12_msa(uint8_t *src, int32_t src_stride,
     ST12x8_UB(src0, src1, src2, src3, src4, src5, src6, src7, dst, dst_stride);
 }
 
-static void copy_width16_msa(uint8_t *src, int32_t src_stride,
+static void copy_width16_msa(const uint8_t *src, int32_t src_stride,
                              uint8_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -193,7 +193,7 @@ static void copy_width16_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void copy_width24_msa(uint8_t *src, int32_t src_stride,
+static void copy_width24_msa(const uint8_t *src, int32_t src_stride,
                              uint8_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -216,7 +216,7 @@ static void copy_width24_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void copy_width32_msa(uint8_t *src, int32_t src_stride,
+static void copy_width32_msa(const uint8_t *src, int32_t src_stride,
                              uint8_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -233,7 +233,7 @@ static void copy_width32_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void copy_width48_msa(uint8_t *src, int32_t src_stride,
+static void copy_width48_msa(const uint8_t *src, int32_t src_stride,
                              uint8_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -254,7 +254,7 @@ static void copy_width48_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void copy_width64_msa(uint8_t *src, int32_t src_stride,
+static void copy_width64_msa(const uint8_t *src, int32_t src_stride,
                              uint8_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -283,7 +283,7 @@ static void copy_width64_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_4x4_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_4x4_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -312,7 +312,7 @@ static void common_hz_8t_4x4_msa(uint8_t *src, int32_t src_stride,
     ST_W4(out, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void common_hz_8t_4x8_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_4x8_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -349,7 +349,7 @@ static void common_hz_8t_4x8_msa(uint8_t *src, int32_t src_stride,
     ST_W4(out, 0, 1, 2, 3, dst + 4 * dst_stride, dst_stride);
 }
 
-static void common_hz_8t_4x16_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_4x16_msa(const uint8_t *src, int32_t src_stride,
                                   uint8_t *dst, int32_t dst_stride,
                                   const int8_t *filter)
 {
@@ -405,7 +405,7 @@ static void common_hz_8t_4x16_msa(uint8_t *src, int32_t src_stride,
     ST_W4(out, 0, 1, 2, 3, dst + 4 * dst_stride, dst_stride);
 }
 
-static void common_hz_8t_4w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_4w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -418,7 +418,7 @@ static void common_hz_8t_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_8w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_8w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -470,7 +470,7 @@ static void common_hz_8t_8w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_12w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_12w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -549,7 +549,7 @@ static void common_hz_8t_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_16w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_16w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -607,7 +607,7 @@ static void common_hz_8t_16w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_24w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_24w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -677,7 +677,7 @@ static void common_hz_8t_24w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_32w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_32w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -738,7 +738,7 @@ static void common_hz_8t_32w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_48w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_48w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -824,7 +824,7 @@ static void common_hz_8t_48w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_8t_64w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_8t_64w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -903,7 +903,7 @@ static void common_hz_8t_64w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_8t_4w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_4w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -972,7 +972,7 @@ static void common_vt_8t_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_8t_8w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_8w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -1027,7 +1027,7 @@ static void common_vt_8t_8w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_8t_12w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_12w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -1129,7 +1129,7 @@ static void common_vt_8t_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_8t_16w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_16w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -1208,12 +1208,12 @@ static void common_vt_8t_16w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_8t_16w_mult_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_16w_mult_msa(const uint8_t *src, int32_t src_stride,
                                       uint8_t *dst, int32_t dst_stride,
                                       const int8_t *filter, int32_t height,
                                       int32_t width)
 {
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt, cnt;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
@@ -1297,7 +1297,7 @@ static void common_vt_8t_16w_mult_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_8t_24w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_24w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -1308,7 +1308,7 @@ static void common_vt_8t_24w_msa(uint8_t *src, int32_t src_stride,
                         height);
 }
 
-static void common_vt_8t_32w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_32w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -1316,7 +1316,7 @@ static void common_vt_8t_32w_msa(uint8_t *src, int32_t src_stride,
                               32);
 }
 
-static void common_vt_8t_48w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_48w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -1324,7 +1324,7 @@ static void common_vt_8t_48w_msa(uint8_t *src, int32_t src_stride,
                               48);
 }
 
-static void common_vt_8t_64w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_8t_64w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -1332,7 +1332,7 @@ static void common_vt_8t_64w_msa(uint8_t *src, int32_t src_stride,
                               64);
 }
 
-static void hevc_hv_uni_8t_4w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_4w_msa(const uint8_t *src,
                                   int32_t src_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1466,7 +1466,7 @@ static void hevc_hv_uni_8t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_8t_8multx2mult_msa(uint8_t *src,
+static void hevc_hv_uni_8t_8multx2mult_msa(const uint8_t *src,
                                            int32_t src_stride,
                                            uint8_t *dst,
                                            int32_t dst_stride,
@@ -1475,7 +1475,7 @@ static void hevc_hv_uni_8t_8multx2mult_msa(uint8_t *src,
                                            int32_t height, int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     v16u8 out;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;
@@ -1605,7 +1605,7 @@ static void hevc_hv_uni_8t_8multx2mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_8t_8w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_8w_msa(const uint8_t *src,
                                   int32_t src_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -1617,7 +1617,7 @@ static void hevc_hv_uni_8t_8w_msa(uint8_t *src,
                                    filter_x, filter_y, height, 8);
 }
 
-static void hevc_hv_uni_8t_12w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_12w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -1626,7 +1626,8 @@ static void hevc_hv_uni_8t_12w_msa(uint8_t *src,
                                    int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp, *dst_tmp;
+    const uint8_t *src_tmp;
+    uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 src11, src12, src13, src14;
@@ -1851,7 +1852,7 @@ static void hevc_hv_uni_8t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_8t_16w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_16w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -1863,7 +1864,7 @@ static void hevc_hv_uni_8t_16w_msa(uint8_t *src,
                                    filter_x, filter_y, height, 16);
 }
 
-static void hevc_hv_uni_8t_24w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_24w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -1875,7 +1876,7 @@ static void hevc_hv_uni_8t_24w_msa(uint8_t *src,
                                    filter_x, filter_y, height, 24);
 }
 
-static void hevc_hv_uni_8t_32w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_32w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -1887,7 +1888,7 @@ static void hevc_hv_uni_8t_32w_msa(uint8_t *src,
                                    filter_x, filter_y, height, 32);
 }
 
-static void hevc_hv_uni_8t_48w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_48w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -1899,7 +1900,7 @@ static void hevc_hv_uni_8t_48w_msa(uint8_t *src,
                                    filter_x, filter_y, height, 48);
 }
 
-static void hevc_hv_uni_8t_64w_msa(uint8_t *src,
+static void hevc_hv_uni_8t_64w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -1911,7 +1912,7 @@ static void hevc_hv_uni_8t_64w_msa(uint8_t *src,
                                    filter_x, filter_y, height, 64);
 }
 
-static void common_hz_4t_4x2_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_4x2_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -1938,7 +1939,7 @@ static void common_hz_4t_4x2_msa(uint8_t *src, int32_t src_stride,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void common_hz_4t_4x4_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_4x4_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -1965,7 +1966,7 @@ static void common_hz_4t_4x4_msa(uint8_t *src, int32_t src_stride,
     ST_W4(out, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void common_hz_4t_4x8_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_4x8_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -2000,7 +2001,7 @@ static void common_hz_4t_4x8_msa(uint8_t *src, int32_t src_stride,
     ST_W4(out, 0, 1, 2, 3, dst + 4 * dst_stride, dst_stride);
 }
 
-static void common_hz_4t_4x16_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_4x16_msa(const uint8_t *src, int32_t src_stride,
                                   uint8_t *dst, int32_t dst_stride,
                                   const int8_t *filter)
 {
@@ -2048,7 +2049,7 @@ static void common_hz_4t_4x16_msa(uint8_t *src, int32_t src_stride,
     ST_W4(out, 0, 1, 2, 3, dst + 4 * dst_stride, dst_stride);
 }
 
-static void common_hz_4t_4w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_4w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -2063,7 +2064,7 @@ static void common_hz_4t_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_4t_6w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_6w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -2112,7 +2113,7 @@ static void common_hz_4t_6w_msa(uint8_t *src, int32_t src_stride,
     ST_H2(out5, 2, 6, dst + 2 * dst_stride + 4, dst_stride);
 }
 
-static void common_hz_4t_8x2mult_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_8x2mult_msa(const uint8_t *src, int32_t src_stride,
                                      uint8_t *dst, int32_t dst_stride,
                                      const int8_t *filter, int32_t height)
 {
@@ -2146,7 +2147,7 @@ static void common_hz_4t_8x2mult_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_4t_8x4mult_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_8x4mult_msa(const uint8_t *src, int32_t src_stride,
                                      uint8_t *dst, int32_t dst_stride,
                                      const int8_t *filter, int32_t height)
 {
@@ -2180,7 +2181,7 @@ static void common_hz_4t_8x4mult_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_4t_8w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_8w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -2193,7 +2194,7 @@ static void common_hz_4t_8w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_4t_12w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_12w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -2247,7 +2248,7 @@ static void common_hz_4t_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_4t_16w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_16w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -2310,7 +2311,7 @@ static void common_hz_4t_16w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_4t_24w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_24w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -2393,7 +2394,7 @@ static void common_hz_4t_24w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_hz_4t_32w_msa(uint8_t *src, int32_t src_stride,
+static void common_hz_4t_32w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -2461,7 +2462,7 @@ static void common_hz_4t_32w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_4x2_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_4x2_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -2492,7 +2493,7 @@ static void common_vt_4t_4x2_msa(uint8_t *src, int32_t src_stride,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void common_vt_4t_4x4multiple_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_4x4multiple_msa(const uint8_t *src, int32_t src_stride,
                                          uint8_t *dst, int32_t dst_stride,
                                          const int8_t *filter, int32_t height)
 {
@@ -2538,7 +2539,7 @@ static void common_vt_4t_4x4multiple_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_4w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_4w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -2550,7 +2551,7 @@ static void common_vt_4t_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_6w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_6w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -2621,7 +2622,7 @@ static void common_vt_4t_6w_msa(uint8_t *src, int32_t src_stride,
     ST_H2(out1, 2, 6, dst + 2 * dst_stride + 4, dst_stride);
 }
 
-static void common_vt_4t_8x2_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_8x2_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -2647,7 +2648,7 @@ static void common_vt_4t_8x2_msa(uint8_t *src, int32_t src_stride,
     ST_D2(out, 0, 1, dst, dst_stride);
 }
 
-static void common_vt_4t_8x6_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_8x6_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter)
 {
@@ -2700,7 +2701,7 @@ static void common_vt_4t_8x6_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_8x4mult_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_8x4mult_msa(const uint8_t *src, int32_t src_stride,
                                      uint8_t *dst, int32_t dst_stride,
                                      const int8_t *filter, int32_t height)
 {
@@ -2745,7 +2746,7 @@ static void common_vt_4t_8x4mult_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_8w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_8w_msa(const uint8_t *src, int32_t src_stride,
                                 uint8_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -2759,7 +2760,7 @@ static void common_vt_4t_8w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_12w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_12w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -2822,7 +2823,7 @@ static void common_vt_4t_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_16w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_16w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -2880,7 +2881,7 @@ static void common_vt_4t_16w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_24w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_24w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -2991,7 +2992,7 @@ static void common_vt_4t_24w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void common_vt_4t_32w_msa(uint8_t *src, int32_t src_stride,
+static void common_vt_4t_32w_msa(const uint8_t *src, int32_t src_stride,
                                  uint8_t *dst, int32_t dst_stride,
                                  const int8_t *filter, int32_t height)
 {
@@ -3084,7 +3085,7 @@ static void common_vt_4t_32w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hv_uni_4t_4x2_msa(uint8_t *src,
+static void hevc_hv_uni_4t_4x2_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -3139,7 +3140,7 @@ static void hevc_hv_uni_4t_4x2_msa(uint8_t *src,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_uni_4t_4x4_msa(uint8_t *src,
+static void hevc_hv_uni_4t_4x4_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -3198,7 +3199,7 @@ static void hevc_hv_uni_4t_4x4_msa(uint8_t *src,
     ST_W4(out, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_hv_uni_4t_4multx8mult_msa(uint8_t *src,
+static void hevc_hv_uni_4t_4multx8mult_msa(const uint8_t *src,
                                            int32_t src_stride,
                                            uint8_t *dst,
                                            int32_t dst_stride,
@@ -3296,7 +3297,7 @@ static void hevc_hv_uni_4t_4multx8mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_4t_4w_msa(uint8_t *src,
+static void hevc_hv_uni_4t_4w_msa(const uint8_t *src,
                                   int32_t src_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3316,7 +3317,7 @@ static void hevc_hv_uni_4t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_4t_6w_msa(uint8_t *src,
+static void hevc_hv_uni_4t_6w_msa(const uint8_t *src,
                                   int32_t src_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3435,7 +3436,7 @@ static void hevc_hv_uni_4t_6w_msa(uint8_t *src,
     ST_H8(out2, 0, 1, 2, 3, 4, 5, 6, 7, dst + 4, dst_stride);
 }
 
-static void hevc_hv_uni_4t_8x2_msa(uint8_t *src,
+static void hevc_hv_uni_4t_8x2_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -3497,7 +3498,7 @@ static void hevc_hv_uni_4t_8x2_msa(uint8_t *src,
     ST_D2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_uni_4t_8multx4_msa(uint8_t *src,
+static void hevc_hv_uni_4t_8multx4_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        uint8_t *dst,
                                        int32_t dst_stride,
@@ -3582,7 +3583,7 @@ static void hevc_hv_uni_4t_8multx4_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_4t_8x6_msa(uint8_t *src,
+static void hevc_hv_uni_4t_8x6_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -3685,7 +3686,7 @@ static void hevc_hv_uni_4t_8x6_msa(uint8_t *src,
     ST_D2(out2, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_hv_uni_4t_8multx4mult_msa(uint8_t *src,
+static void hevc_hv_uni_4t_8multx4mult_msa(const uint8_t *src,
                                            int32_t src_stride,
                                            uint8_t *dst,
                                            int32_t dst_stride,
@@ -3695,7 +3696,7 @@ static void hevc_hv_uni_4t_8multx4mult_msa(uint8_t *src,
                                            int32_t width8mult)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6;
@@ -3799,7 +3800,7 @@ static void hevc_hv_uni_4t_8multx4mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_4t_8w_msa(uint8_t *src,
+static void hevc_hv_uni_4t_8w_msa(const uint8_t *src,
                                   int32_t src_stride,
                                   uint8_t *dst,
                                   int32_t dst_stride,
@@ -3822,7 +3823,7 @@ static void hevc_hv_uni_4t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_4t_12w_msa(uint8_t *src,
+static void hevc_hv_uni_4t_12w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -3831,7 +3832,8 @@ static void hevc_hv_uni_4t_12w_msa(uint8_t *src,
                                    int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp, *dst_tmp;
+    const uint8_t *src_tmp;
+    uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 vec0, vec1, vec2, vec3, vec4, vec5, vec6, vec7;
@@ -3990,7 +3992,7 @@ static void hevc_hv_uni_4t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_4t_16w_msa(uint8_t *src,
+static void hevc_hv_uni_4t_16w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -4007,7 +4009,7 @@ static void hevc_hv_uni_4t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uni_4t_24w_msa(uint8_t *src,
+static void hevc_hv_uni_4t_24w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -4019,7 +4021,7 @@ static void hevc_hv_uni_4t_24w_msa(uint8_t *src,
                                    filter_x, filter_y, height, 3);
 }
 
-static void hevc_hv_uni_4t_32w_msa(uint8_t *src,
+static void hevc_hv_uni_4t_32w_msa(const uint8_t *src,
                                    int32_t src_stride,
                                    uint8_t *dst,
                                    int32_t dst_stride,
@@ -4034,7 +4036,7 @@ static void hevc_hv_uni_4t_32w_msa(uint8_t *src,
 #define UNI_MC_COPY(WIDTH)                                                 \
 void ff_hevc_put_hevc_uni_pel_pixels##WIDTH##_8_msa(uint8_t *dst,          \
                                                     ptrdiff_t dst_stride,  \
-                                                    uint8_t *src,          \
+                                                    const uint8_t *src,    \
                                                     ptrdiff_t src_stride,  \
                                                     int height,            \
                                                     intptr_t mx,           \
@@ -4057,7 +4059,7 @@ UNI_MC_COPY(64);
 #define UNI_MC(PEL, DIR, WIDTH, TAP, DIR1, FILT_DIR)                           \
 void ff_hevc_put_hevc_uni_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,           \
                                                        ptrdiff_t dst_stride,   \
-                                                       uint8_t *src,           \
+                                                       const uint8_t *src,     \
                                                        ptrdiff_t src_stride,   \
                                                        int height,             \
                                                        intptr_t mx,            \
@@ -4109,7 +4111,7 @@ UNI_MC(epel, v, 32, 4, vt, my);
 #define UNI_MC_HV(PEL, WIDTH, TAP)                                         \
 void ff_hevc_put_hevc_uni_##PEL##_hv##WIDTH##_8_msa(uint8_t *dst,          \
                                                     ptrdiff_t dst_stride,  \
-                                                    uint8_t *src,          \
+                                                    const uint8_t *src,    \
                                                     ptrdiff_t src_stride,  \
                                                     int height,            \
                                                     intptr_t mx,           \
diff --git a/libavcodec/mips/hevc_mc_uniw_msa.c b/libavcodec/mips/hevc_mc_uniw_msa.c
index 1a8c251..3c3d7a0 100644
--- a/libavcodec/mips/hevc_mc_uniw_msa.c
+++ b/libavcodec/mips/hevc_mc_uniw_msa.c
@@ -54,7 +54,7 @@ static const uint8_t ff_hevc_mask_arr[16 * 2] __attribute__((aligned(0x40))) = {
                                    out2_h, out3_h);                        \
 }
 
-static void hevc_uniwgt_copy_4w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_4w_msa(const uint8_t *src,
                                     int32_t src_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -121,7 +121,7 @@ static void hevc_uniwgt_copy_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_6w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_6w_msa(const uint8_t *src,
                                     int32_t src_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -183,7 +183,7 @@ static void hevc_uniwgt_copy_6w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_8w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_8w_msa(const uint8_t *src,
                                     int32_t src_stride,
                                     uint8_t *dst,
                                     int32_t dst_stride,
@@ -278,7 +278,7 @@ static void hevc_uniwgt_copy_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_12w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_12w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -323,7 +323,7 @@ static void hevc_uniwgt_copy_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_16w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_16w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -366,7 +366,7 @@ static void hevc_uniwgt_copy_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_24w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_24w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -419,7 +419,7 @@ static void hevc_uniwgt_copy_24w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_32w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_32w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -465,7 +465,7 @@ static void hevc_uniwgt_copy_32w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_48w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_48w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -522,7 +522,7 @@ static void hevc_uniwgt_copy_48w_msa(uint8_t *src,
     }
 }
 
-static void hevc_uniwgt_copy_64w_msa(uint8_t *src,
+static void hevc_uniwgt_copy_64w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -585,7 +585,7 @@ static void hevc_uniwgt_copy_64w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_4w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_4w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -661,7 +661,7 @@ static void hevc_hz_uniwgt_8t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_8w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_8w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -739,7 +739,7 @@ static void hevc_hz_uniwgt_8t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_12w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_12w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -833,7 +833,7 @@ static void hevc_hz_uniwgt_8t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_16w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_16w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -911,7 +911,7 @@ static void hevc_hz_uniwgt_8t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_24w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_24w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1004,7 +1004,7 @@ static void hevc_hz_uniwgt_8t_24w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_32w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_32w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1106,7 +1106,7 @@ static void hevc_hz_uniwgt_8t_32w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_48w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_48w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1200,7 +1200,7 @@ static void hevc_hz_uniwgt_8t_48w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_8t_64w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_8t_64w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1210,7 +1210,7 @@ static void hevc_hz_uniwgt_8t_64w_msa(uint8_t *src,
                                       int32_t offset,
                                       int32_t rnd_val)
 {
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     uint32_t loop_cnt, cnt;
     v16u8 out0, out1;
@@ -1291,7 +1291,7 @@ static void hevc_hz_uniwgt_8t_64w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_8t_4w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_4w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1383,7 +1383,7 @@ static void hevc_vt_uniwgt_8t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_8t_8w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_8w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1462,7 +1462,7 @@ static void hevc_vt_uniwgt_8t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_8t_12w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_12w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1565,7 +1565,7 @@ static void hevc_vt_uniwgt_8t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_8t_16multx4mult_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_16multx4mult_msa(const uint8_t *src,
                                                int32_t src_stride,
                                                uint8_t *dst,
                                                int32_t dst_stride,
@@ -1576,7 +1576,7 @@ static void hevc_vt_uniwgt_8t_16multx4mult_msa(uint8_t *src,
                                                int32_t rnd_val,
                                                int32_t weightmul16)
 {
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     int32_t loop_cnt, cnt;
     v16u8 out0, out1, out2, out3;
@@ -1676,7 +1676,7 @@ static void hevc_vt_uniwgt_8t_16multx4mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_8t_16w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_16w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1691,7 +1691,7 @@ static void hevc_vt_uniwgt_8t_16w_msa(uint8_t *src,
                                        offset, rnd_val, 1);
 }
 
-static void hevc_vt_uniwgt_8t_24w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_24w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1709,7 +1709,7 @@ static void hevc_vt_uniwgt_8t_24w_msa(uint8_t *src,
                              filter, 32, weight, offset, rnd_val);
 }
 
-static void hevc_vt_uniwgt_8t_32w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_32w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1724,7 +1724,7 @@ static void hevc_vt_uniwgt_8t_32w_msa(uint8_t *src,
                                        offset, rnd_val, 2);
 }
 
-static void hevc_vt_uniwgt_8t_48w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_48w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1739,7 +1739,7 @@ static void hevc_vt_uniwgt_8t_48w_msa(uint8_t *src,
                                        offset, rnd_val, 3);
 }
 
-static void hevc_vt_uniwgt_8t_64w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_8t_64w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -1754,7 +1754,7 @@ static void hevc_vt_uniwgt_8t_64w_msa(uint8_t *src,
                                        offset, rnd_val, 4);
 }
 
-static void hevc_hv_uniwgt_8t_4w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_4w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -1879,7 +1879,7 @@ static void hevc_hv_uniwgt_8t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_8t_8multx2mult_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_8multx2mult_msa(const uint8_t *src,
                                               int32_t src_stride,
                                               uint8_t *dst,
                                               int32_t dst_stride,
@@ -1892,7 +1892,7 @@ static void hevc_hv_uniwgt_8t_8multx2mult_msa(uint8_t *src,
                                               int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;
     v8i16 filt0, filt1, filt2, filt3;
@@ -2041,7 +2041,7 @@ static void hevc_hv_uniwgt_8t_8multx2mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_8t_8w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_8w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2057,7 +2057,7 @@ static void hevc_hv_uniwgt_8t_8w_msa(uint8_t *src,
                                       offset, rnd_val, 8);
 }
 
-static void hevc_hv_uniwgt_8t_12w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_12w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2069,7 +2069,8 @@ static void hevc_hv_uniwgt_8t_12w_msa(uint8_t *src,
                                       int32_t rnd_val)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp, *dst_tmp;
+    const uint8_t *src_tmp;
+    uint8_t *dst_tmp;
     v16u8 out;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 mask0, mask1, mask2, mask3, mask4, mask5, mask6, mask7;
@@ -2262,7 +2263,7 @@ static void hevc_hv_uniwgt_8t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_8t_16w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_16w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2278,7 +2279,7 @@ static void hevc_hv_uniwgt_8t_16w_msa(uint8_t *src,
                                       offset, rnd_val, 16);
 }
 
-static void hevc_hv_uniwgt_8t_24w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_24w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2294,7 +2295,7 @@ static void hevc_hv_uniwgt_8t_24w_msa(uint8_t *src,
                                       offset, rnd_val, 24);
 }
 
-static void hevc_hv_uniwgt_8t_32w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_32w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2310,7 +2311,7 @@ static void hevc_hv_uniwgt_8t_32w_msa(uint8_t *src,
                                       offset, rnd_val, 32);
 }
 
-static void hevc_hv_uniwgt_8t_48w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_48w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2326,7 +2327,7 @@ static void hevc_hv_uniwgt_8t_48w_msa(uint8_t *src,
                                       offset, rnd_val, 48);
 }
 
-static void hevc_hv_uniwgt_8t_64w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_8t_64w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2342,7 +2343,7 @@ static void hevc_hv_uniwgt_8t_64w_msa(uint8_t *src,
                                       offset, rnd_val, 64);
 }
 
-static void hevc_hz_uniwgt_4t_4x2_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_4x2_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2400,7 +2401,7 @@ static void hevc_hz_uniwgt_4t_4x2_msa(uint8_t *src,
     dst += (4 * dst_stride);
 }
 
-static void hevc_hz_uniwgt_4t_4x4_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_4x4_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2457,7 +2458,7 @@ static void hevc_hz_uniwgt_4t_4x4_msa(uint8_t *src,
     dst += (4 * dst_stride);
 }
 
-static void hevc_hz_uniwgt_4t_4x8multiple_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_4x8multiple_msa(const uint8_t *src,
                                               int32_t src_stride,
                                               uint8_t *dst,
                                               int32_t dst_stride,
@@ -2525,7 +2526,7 @@ static void hevc_hz_uniwgt_4t_4x8multiple_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_4t_4w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_4w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2548,7 +2549,7 @@ static void hevc_hz_uniwgt_4t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_4t_6w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_6w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2629,7 +2630,7 @@ static void hevc_hz_uniwgt_4t_6w_msa(uint8_t *src,
     ST_H2(out3, 2, 6, dst + 2 * dst_stride + 4, dst_stride);
 }
 
-static void hevc_hz_uniwgt_4t_8x2_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_8x2_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2684,7 +2685,7 @@ static void hevc_hz_uniwgt_4t_8x2_msa(uint8_t *src,
     ST_D2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_uniwgt_4t_8x4_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_8x4_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2741,7 +2742,7 @@ static void hevc_hz_uniwgt_4t_8x4_msa(uint8_t *src,
     ST_D4(out0, out1, 0, 1, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_uniwgt_4t_8x6_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_8x6_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2811,7 +2812,7 @@ static void hevc_hz_uniwgt_4t_8x6_msa(uint8_t *src,
     ST_D2(out2, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_hz_uniwgt_4t_8x8multiple_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_8x8multiple_msa(const uint8_t *src,
                                               int32_t src_stride,
                                               uint8_t *dst,
                                               int32_t dst_stride,
@@ -2891,7 +2892,7 @@ static void hevc_hz_uniwgt_4t_8x8multiple_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_4t_8w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_8w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -2917,7 +2918,7 @@ static void hevc_hz_uniwgt_4t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_4t_12w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_12w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -2997,7 +2998,7 @@ static void hevc_hz_uniwgt_4t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_4t_16w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_16w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3080,7 +3081,7 @@ static void hevc_hz_uniwgt_4t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_4t_24w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_24w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3158,7 +3159,7 @@ static void hevc_hz_uniwgt_4t_24w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_uniwgt_4t_32w_msa(uint8_t *src,
+static void hevc_hz_uniwgt_4t_32w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3245,7 +3246,7 @@ static void hevc_hz_uniwgt_4t_32w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_4x2_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_4x2_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3300,7 +3301,7 @@ static void hevc_vt_uniwgt_4t_4x2_msa(uint8_t *src,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_uniwgt_4t_4x4_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_4x4_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3354,7 +3355,7 @@ static void hevc_vt_uniwgt_4t_4x4_msa(uint8_t *src,
     ST_W4(out, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_vt_uniwgt_4t_4x8multiple_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_4x8multiple_msa(const uint8_t *src,
                                               int32_t src_stride,
                                               uint8_t *dst,
                                               int32_t dst_stride,
@@ -3430,7 +3431,7 @@ static void hevc_vt_uniwgt_4t_4x8multiple_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_4w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_4w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3453,7 +3454,7 @@ static void hevc_vt_uniwgt_4t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_6w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_6w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3531,7 +3532,7 @@ static void hevc_vt_uniwgt_4t_6w_msa(uint8_t *src,
     ST_H2(out3, 2, 6, dst + 2 * dst_stride + 4, dst_stride);
 }
 
-static void hevc_vt_uniwgt_4t_8x2_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_8x2_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3582,7 +3583,7 @@ static void hevc_vt_uniwgt_4t_8x2_msa(uint8_t *src,
     ST_D2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_uniwgt_4t_8x4_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_8x4_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3637,7 +3638,7 @@ static void hevc_vt_uniwgt_4t_8x4_msa(uint8_t *src,
     ST_D4(out0, out1, 0, 1, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_uniwgt_4t_8x6_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_8x6_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3700,7 +3701,7 @@ static void hevc_vt_uniwgt_4t_8x6_msa(uint8_t *src,
     ST_D2(out2, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_vt_uniwgt_4t_8x8mult_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_8x8mult_msa(const uint8_t *src,
                                           int32_t src_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -3779,7 +3780,7 @@ static void hevc_vt_uniwgt_4t_8x8mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_8w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_8w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -3805,7 +3806,7 @@ static void hevc_vt_uniwgt_4t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_12w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_12w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3910,7 +3911,7 @@ static void hevc_vt_uniwgt_4t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_16w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_16w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -3992,7 +3993,7 @@ static void hevc_vt_uniwgt_4t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_24w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_24w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -4094,7 +4095,7 @@ static void hevc_vt_uniwgt_4t_24w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_uniwgt_4t_32w_msa(uint8_t *src,
+static void hevc_vt_uniwgt_4t_32w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -4188,7 +4189,7 @@ static void hevc_vt_uniwgt_4t_32w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_4x2_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_4x2_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -4252,7 +4253,7 @@ static void hevc_hv_uniwgt_4t_4x2_msa(uint8_t *src,
     ST_W2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_uniwgt_4t_4x4_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_4x4_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -4321,7 +4322,7 @@ static void hevc_hv_uniwgt_4t_4x4_msa(uint8_t *src,
     ST_W4(out, 0, 1, 2, 3, dst, dst_stride);
 }
 
-static void hevc_hv_uniwgt_4t_4multx8mult_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_4multx8mult_msa(const uint8_t *src,
                                               int32_t src_stride,
                                               uint8_t *dst,
                                               int32_t dst_stride,
@@ -4428,7 +4429,7 @@ static void hevc_hv_uniwgt_4t_4multx8mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_4w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_4w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4454,7 +4455,7 @@ static void hevc_hv_uniwgt_4t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_6w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_6w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -4581,7 +4582,7 @@ static void hevc_hv_uniwgt_4t_6w_msa(uint8_t *src,
     ST_H8(out2, 0, 1, 2, 3, 4, 5, 6, 7, dst + 4, dst_stride);
 }
 
-static void hevc_hv_uniwgt_4t_8x2_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_8x2_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -4657,7 +4658,7 @@ static void hevc_hv_uniwgt_4t_8x2_msa(uint8_t *src,
     ST_D2(out, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_uniwgt_4t_8multx4_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_8multx4_msa(const uint8_t *src,
                                           int32_t src_stride,
                                           uint8_t *dst,
                                           int32_t dst_stride,
@@ -4752,7 +4753,7 @@ static void hevc_hv_uniwgt_4t_8multx4_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_8x6_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_8x6_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -4868,7 +4869,7 @@ static void hevc_hv_uniwgt_4t_8x6_msa(uint8_t *src,
     ST_D2(out2, 0, 1, dst + 4 * dst_stride, dst_stride);
 }
 
-static void hevc_hv_uniwgt_4t_8multx4mult_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_8multx4mult_msa(const uint8_t *src,
                                               int32_t src_stride,
                                               uint8_t *dst,
                                               int32_t dst_stride,
@@ -4881,7 +4882,7 @@ static void hevc_hv_uniwgt_4t_8multx4mult_msa(uint8_t *src,
                                               int32_t width8mult)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6;
@@ -4990,7 +4991,7 @@ static void hevc_hv_uniwgt_4t_8multx4mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_8w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_8w_msa(const uint8_t *src,
                                      int32_t src_stride,
                                      uint8_t *dst,
                                      int32_t dst_stride,
@@ -5021,7 +5022,7 @@ static void hevc_hv_uniwgt_4t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_12w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_12w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -5033,7 +5034,8 @@ static void hevc_hv_uniwgt_4t_12w_msa(uint8_t *src,
                                       int32_t rnd_val)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp, *dst_tmp;
+    const uint8_t *src_tmp;
+    uint8_t *dst_tmp;
     v16u8 out0, out1;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 vec0, vec1, vec2, vec3, vec4, vec5, vec6, vec7;
@@ -5198,7 +5200,7 @@ static void hevc_hv_uniwgt_4t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_16w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_16w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -5220,7 +5222,7 @@ static void hevc_hv_uniwgt_4t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_uniwgt_4t_24w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_24w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -5236,7 +5238,7 @@ static void hevc_hv_uniwgt_4t_24w_msa(uint8_t *src,
                                       offset, rnd_val, 3);
 }
 
-static void hevc_hv_uniwgt_4t_32w_msa(uint8_t *src,
+static void hevc_hv_uniwgt_4t_32w_msa(const uint8_t *src,
                                       int32_t src_stride,
                                       uint8_t *dst,
                                       int32_t dst_stride,
@@ -5255,7 +5257,7 @@ static void hevc_hv_uniwgt_4t_32w_msa(uint8_t *src,
 #define UNIWGT_MC_COPY(WIDTH)                                                \
 void ff_hevc_put_hevc_uni_w_pel_pixels##WIDTH##_8_msa(uint8_t *dst,          \
                                                       ptrdiff_t dst_stride,  \
-                                                      uint8_t *src,          \
+                                                      const uint8_t *src,    \
                                                       ptrdiff_t src_stride,  \
                                                       int height,            \
                                                       int denom,             \
@@ -5286,7 +5288,7 @@ UNIWGT_MC_COPY(64);
 void ff_hevc_put_hevc_uni_w_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,        \
                                                          ptrdiff_t            \
                                                          dst_stride,          \
-                                                         uint8_t *src,        \
+                                                         const uint8_t *src,  \
                                                          ptrdiff_t            \
                                                          src_stride,          \
                                                          int height,          \
@@ -5344,7 +5346,7 @@ UNI_W_MC(epel, v, 32, 4, vt, my);
 #define UNI_W_MC_HV(PEL, WIDTH, TAP)                                          \
 void ff_hevc_put_hevc_uni_w_##PEL##_hv##WIDTH##_8_msa(uint8_t *dst,           \
                                                       ptrdiff_t dst_stride,   \
-                                                      uint8_t *src,           \
+                                                      const uint8_t *src,     \
                                                       ptrdiff_t src_stride,   \
                                                       int height,             \
                                                       int denom,              \
diff --git a/libavcodec/mips/hevcdsp_mips.h b/libavcodec/mips/hevcdsp_mips.h
index c84e08d..a8f78ff 100644
--- a/libavcodec/mips/hevcdsp_mips.h
+++ b/libavcodec/mips/hevcdsp_mips.h
@@ -25,7 +25,7 @@
 
 #define MC(PEL, DIR, WIDTH)                                                 \
 void ff_hevc_put_hevc_##PEL##_##DIR##WIDTH##_8_msa(int16_t *dst,            \
-                                                     uint8_t *src,          \
+                                                   const uint8_t *src,      \
                                                      ptrdiff_t src_stride,  \
                                                      int height,            \
                                                      intptr_t mx,           \
@@ -104,7 +104,7 @@ MC(epel, hv, 64);
 #define UNI_MC(PEL, DIR, WIDTH)                                                \
 void ff_hevc_put_hevc_uni_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,           \
                                                          ptrdiff_t dst_stride, \
-                                                         uint8_t *src,         \
+                                                         const uint8_t *src,   \
                                                          ptrdiff_t src_stride, \
                                                          int height,           \
                                                          intptr_t mx,          \
@@ -184,7 +184,7 @@ UNI_MC(epel, hv, 64);
 void ff_hevc_put_hevc_uni_w_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,    \
                                                            ptrdiff_t      \
                                                            dst_stride,    \
-                                                           uint8_t *src,  \
+                                                           const uint8_t *src,  \
                                                            ptrdiff_t      \
                                                            src_stride,    \
                                                            int height,    \
@@ -267,9 +267,9 @@ UNI_W_MC(epel, hv, 64);
 #define BI_MC(PEL, DIR, WIDTH)                                                 \
 void ff_hevc_put_hevc_bi_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,            \
                                                         ptrdiff_t dst_stride,  \
-                                                        uint8_t *src,          \
+                                                        const uint8_t *src,    \
                                                         ptrdiff_t src_stride,  \
-                                                        int16_t *src_16bit,    \
+                                                        const int16_t *src_16bit,    \
                                                         int height,            \
                                                         intptr_t mx,           \
                                                         intptr_t my,           \
@@ -348,10 +348,10 @@ BI_MC(epel, hv, 64);
 void ff_hevc_put_hevc_bi_w_##PEL##_##DIR##WIDTH##_8_msa(uint8_t *dst,          \
                                                           ptrdiff_t            \
                                                           dst_stride,          \
-                                                          uint8_t *src,        \
+                                                          const uint8_t *src,  \
                                                           ptrdiff_t            \
                                                           src_stride,          \
-                                                          int16_t *src_16bit,  \
+                                                          const int16_t *src_16bit, \
                                                           int height,          \
                                                           int denom,           \
                                                           int weight0,         \
@@ -433,32 +433,32 @@ BI_W_MC(epel, hv, 64);
 
 void ff_hevc_loop_filter_luma_h_8_msa(uint8_t *src,
                                       ptrdiff_t src_stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *no_p, uint8_t *no_q);
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *no_p, const uint8_t *no_q);
 
 void ff_hevc_loop_filter_luma_v_8_msa(uint8_t *src,
                                       ptrdiff_t src_stride,
-                                      int32_t beta, int32_t *tc,
-                                      uint8_t *no_p, uint8_t *no_q);
+                                      int32_t beta, const int32_t *tc,
+                                      const uint8_t *no_p, const uint8_t *no_q);
 
 void ff_hevc_loop_filter_chroma_h_8_msa(uint8_t *src,
                                         ptrdiff_t src_stride,
-                                        int32_t *tc, uint8_t *no_p,
-                                        uint8_t *no_q);
+                                        const int32_t *tc, const uint8_t *no_p,
+                                        const uint8_t *no_q);
 
 void ff_hevc_loop_filter_chroma_v_8_msa(uint8_t *src,
                                         ptrdiff_t src_stride,
-                                        int32_t *tc, uint8_t *no_p,
-                                        uint8_t *no_q);
+                                        const int32_t *tc, const uint8_t *no_p,
+                                        const uint8_t *no_q);
 
-void ff_hevc_sao_band_filter_0_8_msa(uint8_t *dst, uint8_t *src,
+void ff_hevc_sao_band_filter_0_8_msa(uint8_t *dst, const uint8_t *src,
                                      ptrdiff_t stride_dst, ptrdiff_t stride_src,
-                                     int16_t *sao_offset_val, int sao_left_class,
+                                     const int16_t *sao_offset_val, int sao_left_class,
                                      int width, int height);
 
-void ff_hevc_sao_edge_filter_8_msa(uint8_t *dst, uint8_t *src,
+void ff_hevc_sao_edge_filter_8_msa(uint8_t *dst, const uint8_t *src,
                                    ptrdiff_t stride_dst,
-                                   int16_t *sao_offset_val,
+                                   const int16_t *sao_offset_val,
                                    int eo, int width, int height);
 
 void ff_hevc_idct_4x4_msa(int16_t *coeffs, int col_limit);
@@ -469,20 +469,20 @@ void ff_hevc_idct_dc_4x4_msa(int16_t *coeffs);
 void ff_hevc_idct_dc_8x8_msa(int16_t *coeffs);
 void ff_hevc_idct_dc_16x16_msa(int16_t *coeffs);
 void ff_hevc_idct_dc_32x32_msa(int16_t *coeffs);
-void ff_hevc_addblk_4x4_msa(uint8_t *dst, int16_t *pi16Coeffs,
+void ff_hevc_addblk_4x4_msa(uint8_t *dst, const int16_t *pi16Coeffs,
                             ptrdiff_t stride);
-void ff_hevc_addblk_8x8_msa(uint8_t *dst, int16_t *pi16Coeffs,
+void ff_hevc_addblk_8x8_msa(uint8_t *dst, const int16_t *pi16Coeffs,
                             ptrdiff_t stride);
-void ff_hevc_addblk_16x16_msa(uint8_t *dst, int16_t *pi16Coeffs,
+void ff_hevc_addblk_16x16_msa(uint8_t *dst, const int16_t *pi16Coeffs,
                               ptrdiff_t stride);
-void ff_hevc_addblk_32x32_msa(uint8_t *dst, int16_t *pi16Coeffs,
+void ff_hevc_addblk_32x32_msa(uint8_t *dst, const int16_t *pi16Coeffs,
                               ptrdiff_t stride);
 void ff_hevc_idct_luma_4x4_msa(int16_t *pi16Coeffs);
 
 /* Loongson optimization */
 #define L_MC(PEL, DIR, WIDTH, TYPE)                                          \
 void ff_hevc_put_hevc_##PEL##_##DIR##WIDTH##_8_##TYPE(int16_t *dst,          \
-                                                      uint8_t *src,          \
+                                                      const uint8_t *src,    \
                                                       ptrdiff_t src_stride,  \
                                                       int height,            \
                                                       intptr_t mx,           \
@@ -509,9 +509,9 @@ L_MC(qpel, hv, 64, mmi);
 #define L_BI_MC(PEL, DIR, WIDTH, TYPE)                                          \
 void ff_hevc_put_hevc_##PEL##_bi_##DIR##WIDTH##_8_##TYPE(uint8_t *dst,          \
                                                          ptrdiff_t dst_stride,  \
-                                                         uint8_t *src,          \
+                                                         const uint8_t *src,    \
                                                          ptrdiff_t src_stride,  \
-                                                         int16_t *src2,         \
+                                                         const int16_t *src2,   \
                                                          int height,            \
                                                          intptr_t mx,           \
                                                          intptr_t my,           \
@@ -553,7 +553,7 @@ L_BI_MC(epel, hv, 32, mmi);
 #define L_UNI_MC(PEL, DIR, WIDTH, TYPE)                                         \
 void ff_hevc_put_hevc_##PEL##_uni_##DIR##WIDTH##_8_##TYPE(uint8_t *dst,         \
                                                           ptrdiff_t dst_stride, \
-                                                          uint8_t *src,         \
+                                                          const uint8_t *src,   \
                                                           ptrdiff_t src_stride, \
                                                           int height,           \
                                                           intptr_t mx,          \
diff --git a/libavcodec/mips/hevcdsp_mmi.c b/libavcodec/mips/hevcdsp_mmi.c
index 6583bef..0ea88a7 100644
--- a/libavcodec/mips/hevcdsp_mmi.c
+++ b/libavcodec/mips/hevcdsp_mmi.c
@@ -24,13 +24,13 @@
 #include "libavutil/mips/mmiutils.h"
 
 #define PUT_HEVC_QPEL_H(w, x_step, src_step, dst_step)                   \
-void ff_hevc_put_hevc_qpel_h##w##_8_mmi(int16_t *dst, uint8_t *_src,     \
+void ff_hevc_put_hevc_qpel_h##w##_8_mmi(int16_t *dst, const uint8_t *_src, \
                                         ptrdiff_t _srcstride,            \
                                         int height, intptr_t mx,         \
                                         intptr_t my, int width)          \
 {                                                                        \
     int x, y;                                                            \
-    pixel *src = (pixel*)_src - 3;                                       \
+    const pixel *src = (const pixel*)_src - 3;                           \
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);                    \
     double ftmp[15];                                                     \
     uint64_t rtmp[1];                                                    \
@@ -118,14 +118,14 @@ PUT_HEVC_QPEL_H(48, 12, -48, -96);
 PUT_HEVC_QPEL_H(64, 16, -64, -128);
 
 #define PUT_HEVC_QPEL_HV(w, x_step, src_step, dst_step)                  \
-void ff_hevc_put_hevc_qpel_hv##w##_8_mmi(int16_t *dst, uint8_t *_src,    \
+void ff_hevc_put_hevc_qpel_hv##w##_8_mmi(int16_t *dst, const uint8_t *_src,\
                                      ptrdiff_t _srcstride,               \
                                      int height, intptr_t mx,            \
                                      intptr_t my, int width)             \
 {                                                                        \
     int x, y;                                                            \
     const int8_t *filter;                                                \
-    pixel *src = (pixel*)_src;                                           \
+    const pixel *src = (const pixel*)_src;                               \
     ptrdiff_t srcstride = _srcstride / sizeof(pixel);                    \
     int16_t tmp_array[(MAX_PB_SIZE + QPEL_EXTRA) * MAX_PB_SIZE];         \
     int16_t *tmp = tmp_array;                                            \
@@ -303,14 +303,14 @@ PUT_HEVC_QPEL_HV(64, 16, -64, -128);
 #define PUT_HEVC_QPEL_BI_H(w, x_step, src_step, src2_step, dst_step)    \
 void ff_hevc_put_hevc_qpel_bi_h##w##_8_mmi(uint8_t *_dst,               \
                                            ptrdiff_t _dststride,        \
-                                           uint8_t *_src,               \
+                                           const uint8_t *_src,         \
                                            ptrdiff_t _srcstride,        \
-                                           int16_t *src2, int height,   \
+                                           const int16_t *src2, int height, \
                                            intptr_t mx, intptr_t my,    \
                                            int width)                   \
 {                                                                       \
     int x, y;                                                           \
-    pixel        *src       = (pixel*)_src - 3;                         \
+    const pixel  *src       = (const pixel*)_src - 3;                   \
     ptrdiff_t     srcstride = _srcstride / sizeof(pixel);               \
     pixel *dst          = (pixel *)_dst;                                \
     ptrdiff_t dststride = _dststride / sizeof(pixel);                   \
@@ -434,9 +434,9 @@ PUT_HEVC_QPEL_BI_H(64, 16, -64, -128, -64);
 #define PUT_HEVC_QPEL_BI_HV(w, x_step, src_step, src2_step, dst_step)   \
 void ff_hevc_put_hevc_qpel_bi_hv##w##_8_mmi(uint8_t *_dst,              \
                                             ptrdiff_t _dststride,       \
-                                            uint8_t *_src,              \
+                                            const uint8_t *_src,        \
                                             ptrdiff_t _srcstride,       \
-                                            int16_t *src2, int height,  \
+                                            const int16_t *src2, int height, \
                                             intptr_t mx, intptr_t my,   \
                                             int width)                  \
 {                                                                       \
@@ -654,9 +654,9 @@ PUT_HEVC_QPEL_BI_HV(64, 16, -64, -128, -64);
 #define PUT_HEVC_EPEL_BI_HV(w, x_step, src_step, src2_step, dst_step)   \
 void ff_hevc_put_hevc_epel_bi_hv##w##_8_mmi(uint8_t *_dst,              \
                                             ptrdiff_t _dststride,       \
-                                            uint8_t *_src,              \
+                                            const uint8_t *_src,        \
                                             ptrdiff_t _srcstride,       \
-                                            int16_t *src2, int height,  \
+                                            const int16_t *src2, int height, \
                                             intptr_t mx, intptr_t my,   \
                                             int width)                  \
 {                                                                       \
@@ -835,9 +835,9 @@ PUT_HEVC_EPEL_BI_HV(32, 8, -32, -64, -32);
 #define PUT_HEVC_PEL_BI_PIXELS(w, x_step, src_step, dst_step, src2_step)  \
 void ff_hevc_put_hevc_pel_bi_pixels##w##_8_mmi(uint8_t *_dst,             \
                                                ptrdiff_t _dststride,      \
-                                               uint8_t *_src,             \
+                                               const uint8_t *_src,       \
                                                ptrdiff_t _srcstride,      \
-                                               int16_t *src2, int height, \
+                                               const int16_t *src2, int height, \
                                                intptr_t mx, intptr_t my,  \
                                                int width)                 \
 {                                                                         \
@@ -945,7 +945,7 @@ PUT_HEVC_PEL_BI_PIXELS(64, 8, -64, -64, -128);
 #define PUT_HEVC_QPEL_UNI_HV(w, x_step, src_step, dst_step, tmp_step)   \
 void ff_hevc_put_hevc_qpel_uni_hv##w##_8_mmi(uint8_t *_dst,             \
                                              ptrdiff_t _dststride,      \
-                                             uint8_t *_src,             \
+                                             const uint8_t *_src,       \
                                              ptrdiff_t _srcstride,      \
                                              int height,                \
                                              intptr_t mx, intptr_t my,  \
diff --git a/libavcodec/mips/hevcdsp_msa.c b/libavcodec/mips/hevcdsp_msa.c
index 2c57ec8..8841a31 100644
--- a/libavcodec/mips/hevcdsp_msa.c
+++ b/libavcodec/mips/hevcdsp_msa.c
@@ -29,7 +29,7 @@ static const uint8_t ff_hevc_mask_arr[16 * 2] __attribute__((aligned(0x40))) = {
     0, 1, 1, 2, 2, 3, 3, 4, 16, 17, 17, 18, 18, 19, 19, 20
 };
 
-static void hevc_copy_4w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_4w_msa(const uint8_t *src, int32_t src_stride,
                              int16_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -77,7 +77,7 @@ static void hevc_copy_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_6w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_6w_msa(const uint8_t *src, int32_t src_stride,
                              int16_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -101,7 +101,7 @@ static void hevc_copy_6w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_8w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_8w_msa(const uint8_t *src, int32_t src_stride,
                              int16_t *dst, int32_t dst_stride,
                              int32_t height)
 {
@@ -162,7 +162,7 @@ static void hevc_copy_8w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_12w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_12w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -199,7 +199,7 @@ static void hevc_copy_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_16w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_16w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -290,7 +290,7 @@ static void hevc_copy_16w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_24w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_24w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -319,7 +319,7 @@ static void hevc_copy_24w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_32w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_32w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -357,7 +357,7 @@ static void hevc_copy_32w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_48w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_48w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -408,7 +408,7 @@ static void hevc_copy_48w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_copy_64w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_copy_64w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               int32_t height)
 {
@@ -445,7 +445,7 @@ static void hevc_copy_64w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_4w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_4w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -500,7 +500,7 @@ static void hevc_hz_8t_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_8w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_8w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -555,7 +555,7 @@ static void hevc_hz_8t_8w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_12w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_12w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -630,7 +630,7 @@ static void hevc_hz_8t_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_16w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_16w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -687,7 +687,7 @@ static void hevc_hz_8t_16w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_24w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_24w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -762,7 +762,7 @@ static void hevc_hz_8t_24w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_32w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_32w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -822,7 +822,7 @@ static void hevc_hz_8t_32w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_48w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_48w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -893,7 +893,7 @@ static void hevc_hz_8t_48w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hz_8t_64w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hz_8t_64w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -987,7 +987,7 @@ static void hevc_hz_8t_64w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_4w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_4w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -1057,7 +1057,7 @@ static void hevc_vt_8t_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_8w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_8w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter, int32_t height)
 {
@@ -1120,7 +1120,7 @@ static void hevc_vt_8t_8w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_12w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_12w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1207,7 +1207,7 @@ static void hevc_vt_8t_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_vt_8t_16multx4mult_msa(uint8_t *src,
+static void hevc_vt_8t_16multx4mult_msa(const uint8_t *src,
                                         int32_t src_stride,
                                         int16_t *dst,
                                         int32_t dst_stride,
@@ -1215,7 +1215,7 @@ static void hevc_vt_8t_16multx4mult_msa(uint8_t *src,
                                         int32_t height,
                                         int32_t width)
 {
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     int32_t loop_cnt, cnt;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
@@ -1315,7 +1315,7 @@ static void hevc_vt_8t_16multx4mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_8t_16w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_16w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1323,7 +1323,7 @@ static void hevc_vt_8t_16w_msa(uint8_t *src, int32_t src_stride,
                                 filter, height, 16);
 }
 
-static void hevc_vt_8t_24w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_24w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1333,7 +1333,7 @@ static void hevc_vt_8t_24w_msa(uint8_t *src, int32_t src_stride,
                       filter, height);
 }
 
-static void hevc_vt_8t_32w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_32w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1341,7 +1341,7 @@ static void hevc_vt_8t_32w_msa(uint8_t *src, int32_t src_stride,
                                 filter, height, 32);
 }
 
-static void hevc_vt_8t_48w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_48w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1349,7 +1349,7 @@ static void hevc_vt_8t_48w_msa(uint8_t *src, int32_t src_stride,
                                 filter, height, 48);
 }
 
-static void hevc_vt_8t_64w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_8t_64w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter, int32_t height)
 {
@@ -1357,7 +1357,7 @@ static void hevc_vt_8t_64w_msa(uint8_t *src, int32_t src_stride,
                                 filter, height, 64);
 }
 
-static void hevc_hv_8t_4w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_4w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter_x, const int8_t *filter_y,
                               int32_t height)
@@ -1464,7 +1464,7 @@ static void hevc_hv_8t_4w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hv_8t_8multx1mult_msa(uint8_t *src,
+static void hevc_hv_8t_8multx1mult_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -1473,7 +1473,7 @@ static void hevc_hv_8t_8multx1mult_msa(uint8_t *src,
                                        int32_t height, int32_t width)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7;
     v8i16 filt0, filt1, filt2, filt3;
@@ -1591,7 +1591,7 @@ static void hevc_hv_8t_8multx1mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_8t_8w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_8w_msa(const uint8_t *src, int32_t src_stride,
                               int16_t *dst, int32_t dst_stride,
                               const int8_t *filter_x, const int8_t *filter_y,
                               int32_t height)
@@ -1600,13 +1600,13 @@ static void hevc_hv_8t_8w_msa(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 8);
 }
 
-static void hevc_hv_8t_12w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_12w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 mask0, mask1, mask2, mask3, mask4, mask5, mask6, mask7;
@@ -1795,7 +1795,7 @@ static void hevc_hv_8t_12w_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hv_8t_16w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_16w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1804,7 +1804,7 @@ static void hevc_hv_8t_16w_msa(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 16);
 }
 
-static void hevc_hv_8t_24w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_24w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1813,7 +1813,7 @@ static void hevc_hv_8t_24w_msa(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 24);
 }
 
-static void hevc_hv_8t_32w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_32w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1822,7 +1822,7 @@ static void hevc_hv_8t_32w_msa(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 32);
 }
 
-static void hevc_hv_8t_48w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_48w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1831,7 +1831,7 @@ static void hevc_hv_8t_48w_msa(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 48);
 }
 
-static void hevc_hv_8t_64w_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_8t_64w_msa(const uint8_t *src, int32_t src_stride,
                                int16_t *dst, int32_t dst_stride,
                                const int8_t *filter_x, const int8_t *filter_y,
                                int32_t height)
@@ -1840,7 +1840,7 @@ static void hevc_hv_8t_64w_msa(uint8_t *src, int32_t src_stride,
                                filter_x, filter_y, height, 64);
 }
 
-static void hevc_hz_4t_4x2_msa(uint8_t *src,
+static void hevc_hz_4t_4x2_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -1873,7 +1873,7 @@ static void hevc_hz_4t_4x2_msa(uint8_t *src,
     ST_D2(dst0, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_4t_4x4_msa(uint8_t *src,
+static void hevc_hz_4t_4x4_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -1910,7 +1910,7 @@ static void hevc_hz_4t_4x4_msa(uint8_t *src,
     ST_D4(dst0, dst1, 0, 1, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hz_4t_4x8multiple_msa(uint8_t *src,
+static void hevc_hz_4t_4x8multiple_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -1959,7 +1959,7 @@ static void hevc_hz_4t_4x8multiple_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_4w_msa(uint8_t *src,
+static void hevc_hz_4t_4w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -1976,7 +1976,7 @@ static void hevc_hz_4t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_6w_msa(uint8_t *src,
+static void hevc_hz_4t_6w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -2047,7 +2047,7 @@ static void hevc_hz_4t_6w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_8x2multiple_msa(uint8_t *src,
+static void hevc_hz_4t_8x2multiple_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -2091,7 +2091,7 @@ static void hevc_hz_4t_8x2multiple_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_8x4multiple_msa(uint8_t *src,
+static void hevc_hz_4t_8x4multiple_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -2144,7 +2144,7 @@ static void hevc_hz_4t_8x4multiple_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_8w_msa(uint8_t *src,
+static void hevc_hz_4t_8w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -2160,7 +2160,7 @@ static void hevc_hz_4t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_12w_msa(uint8_t *src,
+static void hevc_hz_4t_12w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2221,7 +2221,7 @@ static void hevc_hz_4t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_16w_msa(uint8_t *src,
+static void hevc_hz_4t_16w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2293,7 +2293,7 @@ static void hevc_hz_4t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_24w_msa(uint8_t *src,
+static void hevc_hz_4t_24w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2394,7 +2394,7 @@ static void hevc_hz_4t_24w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hz_4t_32w_msa(uint8_t *src,
+static void hevc_hz_4t_32w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2446,7 +2446,7 @@ static void hevc_hz_4t_32w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_4x2_msa(uint8_t *src,
+static void hevc_vt_4t_4x2_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2479,7 +2479,7 @@ static void hevc_vt_4t_4x2_msa(uint8_t *src,
     ST_D2(dst10, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_4t_4x4_msa(uint8_t *src,
+static void hevc_vt_4t_4x4_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2516,7 +2516,7 @@ static void hevc_vt_4t_4x4_msa(uint8_t *src,
     ST_D4(dst10, dst32, 0, 1, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_4t_4x8_msa(uint8_t *src,
+static void hevc_vt_4t_4x8_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2565,7 +2565,7 @@ static void hevc_vt_4t_4x8_msa(uint8_t *src,
     ST_D8(dst10, dst32, dst54, dst76, 0, 1, 0, 1, 0, 1, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_4t_4x16_msa(uint8_t *src, int32_t src_stride,
+static void hevc_vt_4t_4x16_msa(const uint8_t *src, int32_t src_stride,
                                 int16_t *dst, int32_t dst_stride,
                                 const int8_t *filter, int32_t height)
 {
@@ -2635,7 +2635,7 @@ static void hevc_vt_4t_4x16_msa(uint8_t *src, int32_t src_stride,
     ST_D8(dst10, dst32, dst54, dst76, 0, 1, 0, 1, 0, 1, 0, 1, dst, dst_stride);
 }
 
-static void hevc_vt_4t_4w_msa(uint8_t *src,
+static void hevc_vt_4t_4w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -2653,7 +2653,7 @@ static void hevc_vt_4t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_6w_msa(uint8_t *src,
+static void hevc_vt_4t_6w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -2727,7 +2727,7 @@ static void hevc_vt_4t_6w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_8x2_msa(uint8_t *src,
+static void hevc_vt_4t_8x2_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2762,7 +2762,7 @@ static void hevc_vt_4t_8x2_msa(uint8_t *src,
     ST_SH2(dst0_r, dst1_r, dst, dst_stride);
 }
 
-static void hevc_vt_4t_8x6_msa(uint8_t *src,
+static void hevc_vt_4t_8x6_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2824,7 +2824,7 @@ static void hevc_vt_4t_8x6_msa(uint8_t *src,
     ST_SH2(dst0_r, dst1_r, dst, dst_stride);
 }
 
-static void hevc_vt_4t_8x4multiple_msa(uint8_t *src,
+static void hevc_vt_4t_8x4multiple_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -2873,7 +2873,7 @@ static void hevc_vt_4t_8x4multiple_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_8w_msa(uint8_t *src,
+static void hevc_vt_4t_8w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -2890,7 +2890,7 @@ static void hevc_vt_4t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_12w_msa(uint8_t *src,
+static void hevc_vt_4t_12w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -2961,7 +2961,7 @@ static void hevc_vt_4t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_16w_msa(uint8_t *src,
+static void hevc_vt_4t_16w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3028,7 +3028,7 @@ static void hevc_vt_4t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_24w_msa(uint8_t *src,
+static void hevc_vt_4t_24w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3126,7 +3126,7 @@ static void hevc_vt_4t_24w_msa(uint8_t *src,
     }
 }
 
-static void hevc_vt_4t_32w_msa(uint8_t *src,
+static void hevc_vt_4t_32w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3232,7 +3232,7 @@ static void hevc_vt_4t_32w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_4x2_msa(uint8_t *src,
+static void hevc_hv_4t_4x2_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3286,7 +3286,7 @@ static void hevc_hv_4t_4x2_msa(uint8_t *src,
     ST_D2(dst0, 0, 1, dst, dst_stride);
 }
 
-static void hevc_hv_4t_4x4_msa(uint8_t *src,
+static void hevc_hv_4t_4x4_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3349,7 +3349,7 @@ static void hevc_hv_4t_4x4_msa(uint8_t *src,
 }
 
 
-static void hevc_hv_4t_4multx8mult_msa(uint8_t *src,
+static void hevc_hv_4t_4multx8mult_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -3445,7 +3445,7 @@ static void hevc_hv_4t_4multx8mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_4w_msa(uint8_t *src,
+static void hevc_hv_4t_4w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -3465,7 +3465,7 @@ static void hevc_hv_4t_4w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_6w_msa(uint8_t *src,
+static void hevc_hv_4t_6w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -3590,7 +3590,7 @@ static void hevc_hv_4t_6w_msa(uint8_t *src,
     ST_W4(tmp5, 0, 1, 2, 3, dst + 4, dst_stride);
 }
 
-static void hevc_hv_4t_8x2_msa(uint8_t *src,
+static void hevc_hv_4t_8x2_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3657,7 +3657,7 @@ static void hevc_hv_4t_8x2_msa(uint8_t *src,
     ST_SW2(dst0_r, dst1_r, dst, dst_stride);
 }
 
-static void hevc_hv_4t_8multx4_msa(uint8_t *src, int32_t src_stride,
+static void hevc_hv_4t_8multx4_msa(const uint8_t *src, int32_t src_stride,
                                    int16_t *dst, int32_t dst_stride,
                                    const int8_t *filter_x,
                                    const int8_t *filter_y, int32_t width8mult)
@@ -3741,7 +3741,7 @@ static void hevc_hv_4t_8multx4_msa(uint8_t *src, int32_t src_stride,
     }
 }
 
-static void hevc_hv_4t_8x6_msa(uint8_t *src,
+static void hevc_hv_4t_8x6_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -3852,7 +3852,7 @@ static void hevc_hv_4t_8x6_msa(uint8_t *src,
     ST_SW2(dst4_r, dst5_r, dst, dst_stride);
 }
 
-static void hevc_hv_4t_8multx4mult_msa(uint8_t *src,
+static void hevc_hv_4t_8multx4mult_msa(const uint8_t *src,
                                        int32_t src_stride,
                                        int16_t *dst,
                                        int32_t dst_stride,
@@ -3862,7 +3862,7 @@ static void hevc_hv_4t_8multx4mult_msa(uint8_t *src,
                                        int32_t width8mult)
 {
     uint32_t loop_cnt, cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     v16i8 src0, src1, src2, src3, src4, src5, src6;
     v8i16 filt0, filt1;
@@ -3969,7 +3969,7 @@ static void hevc_hv_4t_8multx4mult_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_8w_msa(uint8_t *src,
+static void hevc_hv_4t_8w_msa(const uint8_t *src,
                               int32_t src_stride,
                               int16_t *dst,
                               int32_t dst_stride,
@@ -3993,7 +3993,7 @@ static void hevc_hv_4t_8w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_12w_msa(uint8_t *src,
+static void hevc_hv_4t_12w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -4002,7 +4002,7 @@ static void hevc_hv_4t_12w_msa(uint8_t *src,
                                int32_t height)
 {
     uint32_t loop_cnt;
-    uint8_t *src_tmp;
+    const uint8_t *src_tmp;
     int16_t *dst_tmp;
     v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8, src9, src10;
     v16i8 vec0, vec1, vec2, vec3, vec4, vec5, vec6, vec7;
@@ -4166,7 +4166,7 @@ static void hevc_hv_4t_12w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_16w_msa(uint8_t *src,
+static void hevc_hv_4t_16w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -4183,7 +4183,7 @@ static void hevc_hv_4t_16w_msa(uint8_t *src,
     }
 }
 
-static void hevc_hv_4t_24w_msa(uint8_t *src,
+static void hevc_hv_4t_24w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -4195,7 +4195,7 @@ static void hevc_hv_4t_24w_msa(uint8_t *src,
                                filter_x, filter_y, height, 3);
 }
 
-static void hevc_hv_4t_32w_msa(uint8_t *src,
+static void hevc_hv_4t_32w_msa(const uint8_t *src,
                                int32_t src_stride,
                                int16_t *dst,
                                int32_t dst_stride,
@@ -4209,7 +4209,7 @@ static void hevc_hv_4t_32w_msa(uint8_t *src,
 
 #define MC_COPY(WIDTH)                                                    \
 void ff_hevc_put_hevc_pel_pixels##WIDTH##_8_msa(int16_t *dst,             \
-                                                uint8_t *src,             \
+                                                const uint8_t *src,       \
                                                 ptrdiff_t src_stride,     \
                                                 int height,               \
                                                 intptr_t mx,              \
@@ -4233,7 +4233,7 @@ MC_COPY(64);
 
 #define MC(PEL, DIR, WIDTH, TAP, DIR1, FILT_DIR)                          \
 void ff_hevc_put_hevc_##PEL##_##DIR##WIDTH##_8_msa(int16_t *dst,          \
-                                                   uint8_t *src,          \
+                                                   const uint8_t *src,    \
                                                    ptrdiff_t src_stride,  \
                                                    int height,            \
                                                    intptr_t mx,           \
@@ -4284,7 +4284,7 @@ MC(epel, v, 32, 4, vt, my);
 
 #define MC_HV(PEL, WIDTH, TAP)                                          \
 void ff_hevc_put_hevc_##PEL##_hv##WIDTH##_8_msa(int16_t *dst,           \
-                                                uint8_t *src,           \
+                                                const uint8_t *src,     \
                                                 ptrdiff_t src_stride,   \
                                                 int height,             \
                                                 intptr_t mx,            \
diff --git a/libavcodec/mips/hevcpred_mips.h b/libavcodec/mips/hevcpred_mips.h
index f22feff..6848700 100644
--- a/libavcodec/mips/hevcpred_mips.h
+++ b/libavcodec/mips/hevcpred_mips.h
@@ -67,7 +67,7 @@ void ff_pred_intra_pred_angular_3_msa(uint8_t *dst,
                                       const uint8_t *src_left,
                                       ptrdiff_t stride, int c_idx, int mode);
 
-void ff_intra_pred_8_16x16_msa(struct HEVCContext *s, int x0, int y0, int c_idx);
-void ff_intra_pred_8_32x32_msa(struct HEVCContext *s, int x0, int y0, int c_idx);
+void ff_intra_pred_8_16x16_msa(struct HEVCLocalContext *s, int x0, int y0, int c_idx);
+void ff_intra_pred_8_32x32_msa(struct HEVCLocalContext *s, int x0, int y0, int c_idx);
 
 #endif  // #ifndef AVCODEC_MIPS_HEVCPRED_MIPS_H
diff --git a/libavcodec/mips/hevcpred_msa.c b/libavcodec/mips/hevcpred_msa.c
index f53276d..b056ee9 100644
--- a/libavcodec/mips/hevcpred_msa.c
+++ b/libavcodec/mips/hevcpred_msa.c
@@ -1903,10 +1903,10 @@ void ff_pred_intra_pred_angular_3_msa(uint8_t *dst,
     }
 }
 
-void ff_intra_pred_8_16x16_msa(HEVCContext *s, int x0, int y0, int c_idx)
+void ff_intra_pred_8_16x16_msa(HEVCLocalContext *lc, int x0, int y0, int c_idx)
 {
     v16u8 vec0;
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int i;
     int hshift = s->ps.sps->hshift[c_idx];
     int vshift = s->ps.sps->vshift[c_idx];
@@ -2416,14 +2416,14 @@ void ff_intra_pred_8_16x16_msa(HEVCContext *s, int x0, int y0, int c_idx)
     }
 }
 
-void ff_intra_pred_8_32x32_msa(HEVCContext *s, int x0, int y0, int c_idx)
+void ff_intra_pred_8_32x32_msa(HEVCLocalContext *lc, int x0, int y0, int c_idx)
 {
     v16u8 vec0, vec1;
     v8i16 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
     v8i16 res0, res1, res2, res3;
     v8i16 mul_val0 = { 63, 62, 61, 60, 59, 58, 57, 56 };
     v8i16 mul_val1 = { 1, 2, 3, 4, 5, 6, 7, 8 };
-    HEVCLocalContext *lc = s->HEVClc;
+    const HEVCContext *const s = lc->parent;
     int i;
     int hshift = s->ps.sps->hshift[c_idx];
     int vshift = s->ps.sps->vshift[c_idx];
diff --git a/libavcodec/mips/me_cmp_mips.h b/libavcodec/mips/me_cmp_mips.h
index e0d0f51..7286401 100644
--- a/libavcodec/mips/me_cmp_mips.h
+++ b/libavcodec/mips/me_cmp_mips.h
@@ -24,37 +24,37 @@
 #include "../mpegvideo.h"
 #include "libavcodec/bit_depth_template.c"
 
-int ff_hadamard8_diff8x8_msa(MpegEncContext *s, uint8_t *dst, uint8_t *src,
+int ff_hadamard8_diff8x8_msa(MpegEncContext *s, const uint8_t *dst, const uint8_t *src,
                              ptrdiff_t stride, int h);
-int ff_hadamard8_intra8x8_msa(MpegEncContext *s, uint8_t *dst, uint8_t *src,
+int ff_hadamard8_intra8x8_msa(MpegEncContext *s, const uint8_t *dst, const uint8_t *src,
                               ptrdiff_t stride, int h);
-int ff_hadamard8_diff16_msa(MpegEncContext *s, uint8_t *dst, uint8_t *src,
+int ff_hadamard8_diff16_msa(MpegEncContext *s, const uint8_t *dst, const uint8_t *src,
                             ptrdiff_t stride, int h);
-int ff_hadamard8_intra16_msa(MpegEncContext *s, uint8_t *dst, uint8_t *src,
+int ff_hadamard8_intra16_msa(MpegEncContext *s, const uint8_t *dst, const uint8_t *src,
                              ptrdiff_t stride, int h);
-int ff_pix_abs16_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs16_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                      ptrdiff_t stride, int h);
-int ff_pix_abs16_x2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs16_x2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h);
-int ff_pix_abs16_y2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs16_y2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h);
-int ff_pix_abs16_xy2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs16_xy2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h);
-int ff_pix_abs8_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs8_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                     ptrdiff_t stride, int h);
-int ff_pix_abs8_x2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs8_x2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                        ptrdiff_t stride, int h);
-int ff_pix_abs8_y2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs8_y2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                        ptrdiff_t stride, int h);
-int ff_pix_abs8_xy2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs8_xy2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h);
-int ff_sse16_msa(MpegEncContext *v, uint8_t *pu8Src, uint8_t *pu8Ref,
+int ff_sse16_msa(MpegEncContext *v, const uint8_t *pu8Src, const uint8_t *pu8Ref,
                  ptrdiff_t stride, int i32Height);
-int ff_sse8_msa(MpegEncContext *v, uint8_t *pu8Src, uint8_t *pu8Ref,
+int ff_sse8_msa(MpegEncContext *v, const uint8_t *pu8Src, const uint8_t *pu8Ref,
                 ptrdiff_t stride, int i32Height);
-int ff_sse4_msa(MpegEncContext *v, uint8_t *pu8Src, uint8_t *pu8Ref,
+int ff_sse4_msa(MpegEncContext *v, const uint8_t *pu8Src, const uint8_t *pu8Ref,
                 ptrdiff_t stride, int i32Height);
-void ff_add_pixels8_msa(uint8_t *av_restrict pixels, int16_t *block,
+void ff_add_pixels8_msa(const uint8_t *av_restrict pixels, int16_t *block,
                         ptrdiff_t stride);
 
 #endif  // #ifndef AVCODEC_MIPS_ME_CMP_MIPS_H
diff --git a/libavcodec/mips/me_cmp_msa.c b/libavcodec/mips/me_cmp_msa.c
index 7cb7af0..00a3cfd 100644
--- a/libavcodec/mips/me_cmp_msa.c
+++ b/libavcodec/mips/me_cmp_msa.c
@@ -21,8 +21,8 @@
 #include "libavutil/mips/generic_macros_msa.h"
 #include "me_cmp_mips.h"
 
-static uint32_t sad_8width_msa(uint8_t *src, int32_t src_stride,
-                               uint8_t *ref, int32_t ref_stride,
+static uint32_t sad_8width_msa(const uint8_t *src, int32_t src_stride,
+                               const uint8_t *ref, int32_t ref_stride,
                                int32_t height)
 {
     int32_t ht_cnt;
@@ -43,8 +43,8 @@ static uint32_t sad_8width_msa(uint8_t *src, int32_t src_stride,
     return (HADD_UH_U32(sad));
 }
 
-static uint32_t sad_16width_msa(uint8_t *src, int32_t src_stride,
-                                uint8_t *ref, int32_t ref_stride,
+static uint32_t sad_16width_msa(const uint8_t *src, int32_t src_stride,
+                                const uint8_t *ref, int32_t ref_stride,
                                 int32_t height)
 {
     int32_t ht_cnt;
@@ -68,9 +68,9 @@ static uint32_t sad_16width_msa(uint8_t *src, int32_t src_stride,
     return (HADD_UH_U32(sad));
 }
 
-static uint32_t sad_horiz_bilinear_filter_8width_msa(uint8_t *src,
+static uint32_t sad_horiz_bilinear_filter_8width_msa(const uint8_t *src,
                                                      int32_t src_stride,
-                                                     uint8_t *ref,
+                                                     const uint8_t *ref,
                                                      int32_t ref_stride,
                                                      int32_t height)
 {
@@ -110,9 +110,9 @@ static uint32_t sad_horiz_bilinear_filter_8width_msa(uint8_t *src,
     return (HADD_UH_U32(sad));
 }
 
-static uint32_t sad_horiz_bilinear_filter_16width_msa(uint8_t *src,
+static uint32_t sad_horiz_bilinear_filter_16width_msa(const uint8_t *src,
                                                       int32_t src_stride,
-                                                      uint8_t *ref,
+                                                      const uint8_t *ref,
                                                       int32_t ref_stride,
                                                       int32_t height)
 {
@@ -148,9 +148,9 @@ static uint32_t sad_horiz_bilinear_filter_16width_msa(uint8_t *src,
     return (HADD_UH_U32(sad));
 }
 
-static uint32_t sad_vert_bilinear_filter_8width_msa(uint8_t *src,
+static uint32_t sad_vert_bilinear_filter_8width_msa(const uint8_t *src,
                                                     int32_t src_stride,
-                                                    uint8_t *ref,
+                                                    const uint8_t *ref,
                                                     int32_t ref_stride,
                                                     int32_t height)
 {
@@ -186,9 +186,9 @@ static uint32_t sad_vert_bilinear_filter_8width_msa(uint8_t *src,
     return (HADD_UH_U32(sad));
 }
 
-static uint32_t sad_vert_bilinear_filter_16width_msa(uint8_t *src,
+static uint32_t sad_vert_bilinear_filter_16width_msa(const uint8_t *src,
                                                      int32_t src_stride,
-                                                     uint8_t *ref,
+                                                     const uint8_t *ref,
                                                      int32_t ref_stride,
                                                      int32_t height)
 {
@@ -224,9 +224,9 @@ static uint32_t sad_vert_bilinear_filter_16width_msa(uint8_t *src,
     return (HADD_UH_U32(sad));
 }
 
-static uint32_t sad_hv_bilinear_filter_8width_msa(uint8_t *src,
+static uint32_t sad_hv_bilinear_filter_8width_msa(const uint8_t *src,
                                                   int32_t src_stride,
-                                                  uint8_t *ref,
+                                                  const uint8_t *ref,
                                                   int32_t ref_stride,
                                                   int32_t height)
 {
@@ -280,9 +280,9 @@ static uint32_t sad_hv_bilinear_filter_8width_msa(uint8_t *src,
     return (HADD_UH_U32(sad));
 }
 
-static uint32_t sad_hv_bilinear_filter_16width_msa(uint8_t *src,
+static uint32_t sad_hv_bilinear_filter_16width_msa(const uint8_t *src,
                                                    int32_t src_stride,
-                                                   uint8_t *ref,
+                                                   const uint8_t *ref,
                                                    int32_t ref_stride,
                                                    int32_t height)
 {
@@ -403,8 +403,8 @@ static uint32_t sad_hv_bilinear_filter_16width_msa(uint8_t *src,
     DPADD_SH2_SW(res_l0_m, res_l1_m, res_l0_m, res_l1_m, var, var);  \
 }
 
-static uint32_t sse_4width_msa(uint8_t *src_ptr, int32_t src_stride,
-                               uint8_t *ref_ptr, int32_t ref_stride,
+static uint32_t sse_4width_msa(const uint8_t *src_ptr, int32_t src_stride,
+                               const uint8_t *ref_ptr, int32_t ref_stride,
                                int32_t height)
 {
     int32_t ht_cnt;
@@ -431,8 +431,8 @@ static uint32_t sse_4width_msa(uint8_t *src_ptr, int32_t src_stride,
     return sse;
 }
 
-static uint32_t sse_8width_msa(uint8_t *src_ptr, int32_t src_stride,
-                               uint8_t *ref_ptr, int32_t ref_stride,
+static uint32_t sse_8width_msa(const uint8_t *src_ptr, int32_t src_stride,
+                               const uint8_t *ref_ptr, int32_t ref_stride,
                                int32_t height)
 {
     int32_t ht_cnt;
@@ -458,8 +458,8 @@ static uint32_t sse_8width_msa(uint8_t *src_ptr, int32_t src_stride,
     return sse;
 }
 
-static uint32_t sse_16width_msa(uint8_t *src_ptr, int32_t src_stride,
-                                uint8_t *ref_ptr, int32_t ref_stride,
+static uint32_t sse_16width_msa(const uint8_t *src_ptr, int32_t src_stride,
+                                const uint8_t *ref_ptr, int32_t ref_stride,
                                 int32_t height)
 {
     int32_t ht_cnt;
@@ -498,8 +498,8 @@ static uint32_t sse_16width_msa(uint8_t *src_ptr, int32_t src_stride,
     return sse;
 }
 
-static int32_t hadamard_diff_8x8_msa(uint8_t *src, int32_t src_stride,
-                                     uint8_t *ref, int32_t ref_stride)
+static int32_t hadamard_diff_8x8_msa(const uint8_t *src, int32_t src_stride,
+                                     const uint8_t *ref, int32_t ref_stride)
 {
     v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
     v16u8 ref0, ref1, ref2, ref3, ref4, ref5, ref6, ref7;
@@ -543,8 +543,8 @@ static int32_t hadamard_diff_8x8_msa(uint8_t *src, int32_t src_stride,
     return (HADD_UH_U32(sum));
 }
 
-static int32_t hadamard_intra_8x8_msa(uint8_t *src, int32_t src_stride,
-                                      uint8_t *ref, int32_t ref_stride)
+static int32_t hadamard_intra_8x8_msa(const uint8_t *src, int32_t src_stride,
+                                      const uint8_t *ref, int32_t ref_stride)
 {
     int32_t sum_res = 0;
     v16u8 src0, src1, src2, src3, src4, src5, src6, src7;
@@ -587,79 +587,79 @@ static int32_t hadamard_intra_8x8_msa(uint8_t *src, int32_t src_stride,
     return sum_res;
 }
 
-int ff_pix_abs16_msa(MpegEncContext *v, uint8_t *src, uint8_t *ref,
+int ff_pix_abs16_msa(MpegEncContext *v, const uint8_t *src, const uint8_t *ref,
                      ptrdiff_t stride, int height)
 {
     return sad_16width_msa(src, stride, ref, stride, height);
 }
 
-int ff_pix_abs8_msa(MpegEncContext *v, uint8_t *src, uint8_t *ref,
+int ff_pix_abs8_msa(MpegEncContext *v, const uint8_t *src, const uint8_t *ref,
                     ptrdiff_t stride, int height)
 {
     return sad_8width_msa(src, stride, ref, stride, height);
 }
 
-int ff_pix_abs16_x2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs16_x2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h)
 {
     return sad_horiz_bilinear_filter_16width_msa(pix1, stride, pix2, stride, h);
 }
 
-int ff_pix_abs16_y2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs16_y2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h)
 {
     return sad_vert_bilinear_filter_16width_msa(pix1, stride, pix2, stride, h);
 }
 
-int ff_pix_abs16_xy2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs16_xy2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h)
 {
     return sad_hv_bilinear_filter_16width_msa(pix1, stride, pix2, stride, h);
 }
 
-int ff_pix_abs8_x2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs8_x2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                        ptrdiff_t stride, int h)
 {
     return sad_horiz_bilinear_filter_8width_msa(pix1, stride, pix2, stride, h);
 }
 
-int ff_pix_abs8_y2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs8_y2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                        ptrdiff_t stride, int h)
 {
     return sad_vert_bilinear_filter_8width_msa(pix1, stride, pix2, stride, h);
 }
 
-int ff_pix_abs8_xy2_msa(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_pix_abs8_xy2_msa(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h)
 {
     return sad_hv_bilinear_filter_8width_msa(pix1, stride, pix2, stride, h);
 }
 
-int ff_sse16_msa(MpegEncContext *v, uint8_t *src, uint8_t *ref,
+int ff_sse16_msa(MpegEncContext *v, const uint8_t *src, const uint8_t *ref,
                  ptrdiff_t stride, int height)
 {
     return sse_16width_msa(src, stride, ref, stride, height);
 }
 
-int ff_sse8_msa(MpegEncContext *v, uint8_t *src, uint8_t *ref,
+int ff_sse8_msa(MpegEncContext *v, const uint8_t *src, const uint8_t *ref,
                 ptrdiff_t stride, int height)
 {
     return sse_8width_msa(src, stride, ref, stride, height);
 }
 
-int ff_sse4_msa(MpegEncContext *v, uint8_t *src, uint8_t *ref,
+int ff_sse4_msa(MpegEncContext *v, const uint8_t *src, const uint8_t *ref,
                 ptrdiff_t stride, int height)
 {
     return sse_4width_msa(src, stride, ref, stride, height);
 }
 
-int ff_hadamard8_diff8x8_msa(MpegEncContext *s, uint8_t *dst, uint8_t *src,
+int ff_hadamard8_diff8x8_msa(MpegEncContext *s, const uint8_t *dst, const uint8_t *src,
                              ptrdiff_t stride, int h)
 {
     return hadamard_diff_8x8_msa(src, stride, dst, stride);
 }
 
-int ff_hadamard8_intra8x8_msa(MpegEncContext *s, uint8_t *dst, uint8_t *src,
+int ff_hadamard8_intra8x8_msa(MpegEncContext *s, const uint8_t *dst, const uint8_t *src,
                               ptrdiff_t stride, int h)
 {
     return hadamard_intra_8x8_msa(src, stride, dst, stride);
@@ -667,7 +667,7 @@ int ff_hadamard8_intra8x8_msa(MpegEncContext *s, uint8_t *dst, uint8_t *src,
 
 /* Hadamard Transform functions */
 #define WRAPPER8_16_SQ(name8, name16)                      \
-int name16(MpegEncContext *s, uint8_t *dst, uint8_t *src,  \
+int name16(MpegEncContext *s, const uint8_t *dst, const uint8_t *src,  \
            ptrdiff_t stride, int h)                        \
 {                                                          \
     int score = 0;                                         \
diff --git a/libavcodec/mips/mpegvideoencdsp_msa.c b/libavcodec/mips/mpegvideoencdsp_msa.c
index 46473da..9043730 100644
--- a/libavcodec/mips/mpegvideoencdsp_msa.c
+++ b/libavcodec/mips/mpegvideoencdsp_msa.c
@@ -21,7 +21,7 @@
 #include "h263dsp_mips.h"
 #include "libavutil/mips/generic_macros_msa.h"
 
-static int32_t sum_u8src_16width_msa(uint8_t *src, int32_t stride)
+static int32_t sum_u8src_16width_msa(const uint8_t *src, int32_t stride)
 {
     uint32_t sum = 0;
     v16u8 in0, in1, in2, in3, in4, in5, in6, in7;
@@ -56,7 +56,7 @@ static int32_t sum_u8src_16width_msa(uint8_t *src, int32_t stride)
     return sum;
 }
 
-int ff_pix_sum_msa(uint8_t *pix, int line_size)
+int ff_pix_sum_msa(const uint8_t *pix, int line_size)
 {
     return sum_u8src_16width_msa(pix, line_size);
 }
diff --git a/libavcodec/mips/vc1dsp_mips.h b/libavcodec/mips/vc1dsp_mips.h
index 356153c..8fcff26 100644
--- a/libavcodec/mips/vc1dsp_mips.h
+++ b/libavcodec/mips/vc1dsp_mips.h
@@ -179,16 +179,16 @@ void ff_vc1_v_loop_filter16_mmi(uint8_t *src, ptrdiff_t stride, int pq);
 void ff_vc1_h_loop_filter16_mmi(uint8_t *src, ptrdiff_t stride, int pq);
 
 void ff_put_no_rnd_vc1_chroma_mc8_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y);
 void ff_put_no_rnd_vc1_chroma_mc4_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y);
 void ff_avg_no_rnd_vc1_chroma_mc8_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y);
 void ff_avg_no_rnd_vc1_chroma_mc4_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y);
 
 void ff_vc1_inv_trans_8x8_msa(int16_t block[64]);
diff --git a/libavcodec/mips/vc1dsp_mmi.c b/libavcodec/mips/vc1dsp_mmi.c
index 278aa56..290b47d 100644
--- a/libavcodec/mips/vc1dsp_mmi.c
+++ b/libavcodec/mips/vc1dsp_mmi.c
@@ -2235,7 +2235,7 @@ DECLARE_FUNCTION(3, 3)
 
 
 void ff_put_no_rnd_vc1_chroma_mc8_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y)
 {
     union mmi_intfloat64 A, B, C, D;
@@ -2291,7 +2291,7 @@ void ff_put_no_rnd_vc1_chroma_mc8_mmi(uint8_t *dst /* align 8 */,
 }
 
 void ff_put_no_rnd_vc1_chroma_mc4_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y)
 {
     union mmi_intfloat64 A, B, C, D;
@@ -2345,7 +2345,7 @@ void ff_put_no_rnd_vc1_chroma_mc4_mmi(uint8_t *dst /* align 8 */,
 }
 
 void ff_avg_no_rnd_vc1_chroma_mc8_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y)
 {
     union mmi_intfloat64 A, B, C, D;
@@ -2404,7 +2404,7 @@ void ff_avg_no_rnd_vc1_chroma_mc8_mmi(uint8_t *dst /* align 8 */,
 }
 
 void ff_avg_no_rnd_vc1_chroma_mc4_mmi(uint8_t *dst /* align 8 */,
-                                      uint8_t *src /* align 1 */,
+                                      const uint8_t *src /* align 1 */,
                                       ptrdiff_t stride, int h, int x, int y)
 {
     union mmi_intfloat64 A, B, C, D;
diff --git a/libavcodec/mips/videodsp_init.c b/libavcodec/mips/videodsp_init.c
index 07c23bc..89409fc 100644
--- a/libavcodec/mips/videodsp_init.c
+++ b/libavcodec/mips/videodsp_init.c
@@ -24,7 +24,7 @@
 #include "libavutil/mips/asmdefs.h"
 #include "libavcodec/videodsp.h"
 
-static void prefetch_mips(uint8_t *mem, ptrdiff_t stride, int h)
+static void prefetch_mips(const uint8_t *mem, ptrdiff_t stride, int h)
 {
     register const uint8_t *p = mem;
 
diff --git a/libavcodec/mjpegbdec.c b/libavcodec/mjpegbdec.c
index 8c1809e..2778332 100644
--- a/libavcodec/mjpegbdec.c
+++ b/libavcodec/mjpegbdec.c
@@ -167,5 +167,5 @@ const FFCodec ff_mjpegb_decoder = {
     FF_CODEC_DECODE_CB(mjpegb_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.max_lowres   = 3,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mjpegdec.c b/libavcodec/mjpegdec.c
index f5ad325..5f058d0 100644
--- a/libavcodec/mjpegdec.c
+++ b/libavcodec/mjpegdec.c
@@ -1092,10 +1092,6 @@ static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int p
         return AVERROR_INVALIDDATA;
     if (s->v_max != 1 || s->h_max != 1 || !s->lossless)
         return AVERROR_INVALIDDATA;
-    if (s->bayer) {
-        if (s->rct || s->pegasus_rct)
-            return AVERROR_INVALIDDATA;
-    }
 
 
     s->restart_count = s->restart_interval;
@@ -1212,8 +1208,6 @@ static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int p
                 ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];
             }
         } else if (s->bayer) {
-            if (s->bits <= 8)
-                return AVERROR_PATCHWELCOME;
             if (nb_components == 1) {
                 /* Leave decoding to the TIFF/DNG decoder (see comment in ff_mjpeg_decode_sof) */
                 for (mb_x = 0; mb_x < width; mb_x++)
@@ -1948,8 +1942,6 @@ static int mjpeg_decode_app(MJpegDecodeContext *s)
         }
 
         len -= 9;
-        if (s->bayer)
-            goto out;
         if (s->got_picture)
             if (rgb != s->rgb || pegasus_rct != s->pegasus_rct) {
                 av_log(s->avctx, AV_LOG_WARNING, "Mismatching LJIF tag\n");
@@ -3034,8 +3026,10 @@ const FFCodec ff_mjpeg_decoder = {
     .p.max_lowres   = 3,
     .p.priv_class   = &mjpegdec_class,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_mjpeg_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM | FF_CODEC_CAP_SETS_PKT_DTS,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
+                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM |
+                      FF_CODEC_CAP_SETS_PKT_DTS |
+                      FF_CODEC_CAP_ICC_PROFILES,
     .hw_configs     = (const AVCodecHWConfigInternal *const []) {
 #if CONFIG_MJPEG_NVDEC_HWACCEL
                         HWACCEL_NVDEC(mjpeg),
@@ -3060,7 +3054,7 @@ const FFCodec ff_thp_decoder = {
     .flush          = decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.max_lowres   = 3,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_SETS_PKT_DTS,
 };
 #endif
@@ -3077,7 +3071,7 @@ const FFCodec ff_smvjpeg_decoder = {
     FF_CODEC_RECEIVE_FRAME_CB(ff_mjpeg_receive_frame),
     .flush          = decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_EXPORTS_CROPPING |
+    .caps_internal  = FF_CODEC_CAP_EXPORTS_CROPPING |
                       FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/mjpegenc.c b/libavcodec/mjpegenc.c
index 2721744..3df0b51 100644
--- a/libavcodec/mjpegenc.c
+++ b/libavcodec/mjpegenc.c
@@ -652,7 +652,7 @@ const FFCodec ff_mjpeg_encoder = {
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
     .close          = mjpeg_encode_close,
     .p.capabilities = AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_ICC_PROFILES,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_YUVJ422P, AV_PIX_FMT_YUVJ444P,
         AV_PIX_FMT_YUV420P,  AV_PIX_FMT_YUV422P,  AV_PIX_FMT_YUV444P,
@@ -680,7 +680,7 @@ const FFCodec ff_amv_encoder = {
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(amv_encode_picture),
     .close          = mjpeg_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUVJ420P, AV_PIX_FMT_NONE
     },
diff --git a/libavcodec/mlpdec.c b/libavcodec/mlpdec.c
index caf35dc..8bf7c15 100644
--- a/libavcodec/mlpdec.c
+++ b/libavcodec/mlpdec.c
@@ -1427,7 +1427,6 @@ const FFCodec ff_mlp_decoder = {
     FF_CODEC_DECODE_CB(read_access_unit),
     .flush          = mlp_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_TRUEHD_DECODER
@@ -1442,6 +1441,5 @@ const FFCodec ff_truehd_decoder = {
     FF_CODEC_DECODE_CB(read_access_unit),
     .flush          = mlp_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif /* CONFIG_TRUEHD_DECODER */
diff --git a/libavcodec/mlpenc.c b/libavcodec/mlpenc.c
index 52ddec3..c25f48f 100644
--- a/libavcodec/mlpenc.c
+++ b/libavcodec/mlpenc.c
@@ -1202,7 +1202,7 @@ static void input_data_internal(MLPEncodeContext *ctx, const uint8_t *samples,
 }
 
 /** Wrapper function for inputting data in two different bit-depths. */
-static void input_data(MLPEncodeContext *ctx, void *samples, int nb_samples)
+static void input_data(MLPEncodeContext *ctx, const void *samples, int nb_samples)
 {
     input_data_internal(ctx, samples, nb_samples, ctx->avctx->sample_fmt == AV_SAMPLE_FMT_S32);
 }
@@ -2069,7 +2069,7 @@ static int mlp_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,
     int bytes_written = 0;
     int channels = avctx->ch_layout.nb_channels;
     int restart_frame, ret;
-    uint8_t *data;
+    const uint8_t *data;
 
     if (!frame && !ctx->last_frames)
         ctx->last_frames = (ctx->afq.remaining_samples + avctx->frame_size - 1) / avctx->frame_size;
@@ -2224,7 +2224,7 @@ const FFCodec ff_mlp_encoder = {
     .p.channel_layouts      = ff_mlp_channel_layouts,
 #endif
     .p.ch_layouts           = ff_mlp_ch_layouts,
-    .caps_internal          = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal          = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
 #if CONFIG_TRUEHD_ENCODER
@@ -2249,6 +2249,6 @@ const FFCodec ff_truehd_encoder = {
                                   AV_CHANNEL_LAYOUT_5POINT1_BACK,
                                   { 0 }
                               },
-    .caps_internal          = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal          = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/mmaldec.c b/libavcodec/mmaldec.c
index 7fd24ad..c9b7b16 100644
--- a/libavcodec/mmaldec.c
+++ b/libavcodec/mmaldec.c
@@ -841,7 +841,8 @@ static const AVClass ffmmal_dec_class = {
         .flush          = ffmmal_flush, \
         .p.priv_class   = &ffmmal_dec_class, \
         .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE, \
-        .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS, \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
+                          FF_CODEC_CAP_SETS_PKT_DTS, \
         .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_MMAL, \
                                                          AV_PIX_FMT_YUV420P, \
                                                          AV_PIX_FMT_NONE}, \
diff --git a/libavcodec/mmvideo.c b/libavcodec/mmvideo.c
index fc80ec4..85e126b 100644
--- a/libavcodec/mmvideo.c
+++ b/libavcodec/mmvideo.c
@@ -248,5 +248,4 @@ const FFCodec ff_mmvideo_decoder = {
     .close          = mm_decode_end,
     FF_CODEC_DECODE_CB(mm_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mobiclip.c b/libavcodec/mobiclip.c
index a1e5dca..b5ec806 100644
--- a/libavcodec/mobiclip.c
+++ b/libavcodec/mobiclip.c
@@ -330,7 +330,7 @@ static av_cold int mobiclip_init(AVCodecContext *avctx)
     return 0;
 }
 
-static int setup_qtables(AVCodecContext *avctx, int64_t quantizer)
+static int setup_qtables(AVCodecContext *avctx, int quantizer)
 {
     MobiClipContext *s = avctx->priv_data;
     int qx, qy;
@@ -1256,7 +1256,7 @@ static int mobiclip_decode(AVCodecContext *avctx, AVFrame *rframe,
         frame->key_frame = 0;
         s->dct_tab_idx = 0;
 
-        ret = setup_qtables(avctx, s->quantizer + (int64_t)get_se_golomb(gb));
+        ret = setup_qtables(avctx, s->quantizer + get_se_golomb(gb));
         if (ret < 0)
             return ret;
 
@@ -1351,5 +1351,5 @@ const FFCodec ff_mobiclip_decoder = {
     .flush          = mobiclip_flush,
     .close          = mobiclip_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/motion_est.c b/libavcodec/motion_est.c
index 62c5b28..d17ffe4 100644
--- a/libavcodec/motion_est.c
+++ b/libavcodec/motion_est.c
@@ -79,7 +79,10 @@ static int minima_cmp(const void *a, const void *b){
 #define FLAG_CHROMA 2
 #define FLAG_DIRECT 4
 
-static inline void init_ref(MotionEstContext *c, uint8_t *src[3], uint8_t *ref[3], uint8_t *ref2[3], int x, int y, int ref_index){
+static inline void init_ref(MotionEstContext *c, uint8_t *const src[3],
+                            uint8_t *const ref[3], uint8_t *const ref2[3],
+                            int x, int y, int ref_index)
+{
     const int offset[3]= {
           y*c->  stride + x,
         ((y*c->uvstride + x)>>1),
@@ -110,8 +113,8 @@ static av_always_inline int cmp_direct_inline(MpegEncContext *s, const int x, co
     const int stride= c->stride;
     const int hx = subx + x * (1 << (1 + qpel));
     const int hy = suby + y * (1 << (1 + qpel));
-    uint8_t * const * const ref= c->ref[ref_index];
-    uint8_t * const * const src= c->src[src_index];
+    const uint8_t * const * const ref = c->ref[ref_index];
+    const uint8_t * const * const src = c->src[src_index];
     int d;
     //FIXME check chroma 4mv, (no crashes ...)
         av_assert2(x >= c->xmin && hx <= c->xmax<<(qpel+1) && y >= c->ymin && hy <= c->ymax<<(qpel+1));
@@ -184,8 +187,8 @@ static av_always_inline int cmp_inline(MpegEncContext *s, const int x, const int
     const int dxy= subx + (suby<<(1+qpel)); //FIXME log2_subpel?
     const int hx= subx + x*(1<<(1+qpel));
     const int hy= suby + y*(1<<(1+qpel));
-    uint8_t * const * const ref= c->ref[ref_index];
-    uint8_t * const * const src= c->src[src_index];
+    const uint8_t * const * const ref = c->ref[ref_index];
+    const uint8_t * const * const src = c->src[src_index];
     int d;
     //FIXME check chroma 4mv, (no crashes ...)
         int uvdxy;              /* no, it might not be used uninitialized */
@@ -293,7 +296,7 @@ static int cmp_qpel(MpegEncContext *s, const int x, const int y, const int subx,
 
 #include "motion_est_template.c"
 
-static int zero_cmp(MpegEncContext *s, uint8_t *a, uint8_t *b,
+static int zero_cmp(MpegEncContext *s, const uint8_t *a, const uint8_t *b,
                     ptrdiff_t stride, int h)
 {
     return 0;
@@ -396,7 +399,7 @@ static int sad_hpel_motion_search(MpegEncContext * s,
     MotionEstContext * const c= &s->me;
     const int penalty_factor= c->sub_penalty_factor;
     int mx, my, dminh;
-    uint8_t *pix, *ptr;
+    const uint8_t *pix, *ptr;
     int stride= c->stride;
     LOAD_COMMON
 
@@ -641,7 +644,7 @@ static inline int h263_mv4_search(MpegEncContext *s, int mx, int my, int shift)
             const int offset= ((block&1) + (block>>1)*stride)*8;
             uint8_t *dest_y = c->scratchpad + offset;
             if(s->quarter_sample){
-                uint8_t *ref= c->ref[block][0] + (mx4>>2) + (my4>>2)*stride;
+                const uint8_t *ref = c->ref[block][0] + (mx4>>2) + (my4>>2)*stride;
                 dxy = ((my4 & 3) << 2) | (mx4 & 3);
 
                 if(s->no_rounding)
@@ -649,7 +652,7 @@ static inline int h263_mv4_search(MpegEncContext *s, int mx, int my, int shift)
                 else
                     s->qdsp.put_qpel_pixels_tab[1][dxy](dest_y, ref, stride);
             }else{
-                uint8_t *ref= c->ref[block][0] + (mx4>>1) + (my4>>1)*stride;
+                const uint8_t *ref = c->ref[block][0] + (mx4>>1) + (my4>>1)*stride;
                 dxy = ((my4 & 1) << 1) | (mx4 & 1);
 
                 if(s->no_rounding)
@@ -805,7 +808,7 @@ static int interlaced_search(MpegEncContext *s, int ref_index,
                 int dxy;
 
                 //FIXME chroma ME
-                uint8_t *ref= c->ref[field_select+ref_index][0] + (mx_i>>1) + (my_i>>1)*stride;
+                const uint8_t *ref = c->ref[field_select+ref_index][0] + (mx_i>>1) + (my_i>>1)*stride;
                 dxy = ((my_i & 1) << 1) | (mx_i & 1);
 
                 if(s->no_rounding){
@@ -885,14 +888,13 @@ void ff_estimate_p_frame_motion(MpegEncContext * s,
                                 int mb_x, int mb_y)
 {
     MotionEstContext * const c= &s->me;
-    uint8_t *pix, *ppix;
+    const uint8_t *pix, *ppix;
     int sum, mx = 0, my = 0, dmin = 0;
     int varc;            ///< the variance of the block (sum of squared (p[y][x]-average))
     int vard;            ///< sum of squared differences with the estimated motion vector
     int P[10][2];
     const int shift= 1+s->quarter_sample;
     int mb_type=0;
-    Picture * const pic= &s->current_picture;
 
     init_ref(c, s->new_picture->data, s->last_picture.f->data, NULL, 16*mb_x, 16*mb_y, 0);
 
@@ -914,8 +916,8 @@ void ff_estimate_p_frame_motion(MpegEncContext * s,
     varc = s->mpvencdsp.pix_norm1(pix, s->linesize) -
            (((unsigned) sum * sum) >> 8) + 500;
 
-    pic->mb_mean[s->mb_stride * mb_y + mb_x] = (sum+128)>>8;
-    pic->mb_var [s->mb_stride * mb_y + mb_x] = (varc+128)>>8;
+    s->mb_mean[s->mb_stride * mb_y + mb_x] = (sum+128)>>8;
+    s->mb_var [s->mb_stride * mb_y + mb_x] = (varc+128)>>8;
     c->mb_var_sum_temp += (varc+128)>>8;
 
     if (s->motion_est != FF_ME_ZERO) {
@@ -962,7 +964,7 @@ void ff_estimate_p_frame_motion(MpegEncContext * s,
 
     vard = s->mecc.sse[0](NULL, pix, ppix, s->linesize, 16);
 
-    pic->mc_mb_var[s->mb_stride * mb_y + mb_x] = (vard+128)>>8;
+    s->mc_mb_var[s->mb_stride * mb_y + mb_x] = (vard+128)>>8;
     c->mc_mb_var_sum_temp += (vard+128)>>8;
 
     if (c->avctx->mb_decision > FF_MB_DECISION_SIMPLE) {
@@ -1187,13 +1189,13 @@ static inline int check_bidir_mv(MpegEncContext * s,
     const uint8_t * const mv_penalty_b = c->mv_penalty[s->b_code] + MAX_DMV; // f_code of the prev frame
     int stride= c->stride;
     uint8_t *dest_y = c->scratchpad;
-    uint8_t *ptr;
+    const uint8_t *ptr;
     int dxy;
     int src_x, src_y;
     int fbmin;
-    uint8_t **src_data= c->src[0];
-    uint8_t **ref_data= c->ref[0];
-    uint8_t **ref2_data= c->ref[2];
+    const uint8_t *const *src_data  = c->src[0];
+    const uint8_t *const *ref_data  = c->ref[0];
+    const uint8_t *const *ref2_data = c->ref[2];
 
     if(s->quarter_sample){
         dxy = ((motion_fy & 3) << 2) | (motion_fx & 3);
@@ -1506,7 +1508,7 @@ void ff_estimate_b_frame_motion(MpegEncContext * s,
 
         score= ((unsigned)(score*score + 128*256))>>16;
         c->mc_mb_var_sum_temp += score;
-        s->current_picture.mc_mb_var[mb_y*s->mb_stride + mb_x] = score; //FIXME use SSE
+        s->mc_mb_var[mb_y*s->mb_stride + mb_x] = score; //FIXME use SSE
         s->mb_type[mb_y*s->mb_stride + mb_x]= CANDIDATE_MB_TYPE_DIRECT0;
 
         return;
@@ -1571,7 +1573,7 @@ void ff_estimate_b_frame_motion(MpegEncContext * s,
 
         score= ((unsigned)(score*score + 128*256))>>16;
         c->mc_mb_var_sum_temp += score;
-        s->current_picture.mc_mb_var[mb_y*s->mb_stride + mb_x] = score; //FIXME use SSE
+        s->mc_mb_var[mb_y*s->mb_stride + mb_x] = score; //FIXME use SSE
     }
 
     if(c->avctx->mb_decision > FF_MB_DECISION_SIMPLE){
@@ -1626,7 +1628,8 @@ int ff_get_best_fcode(MpegEncContext * s, const int16_t (*mv_table)[2], int type
                         continue;
 
                     for(j=0; j<fcode && j<8; j++){
-                        if(s->pict_type==AV_PICTURE_TYPE_B || s->current_picture.mc_mb_var[xy] < s->current_picture.mb_var[xy])
+                        if (s->pict_type == AV_PICTURE_TYPE_B ||
+                            s->mc_mb_var[xy] < s->mb_var[xy])
                             score[j]-= 170;
                     }
                 }
diff --git a/libavcodec/motion_est.h b/libavcodec/motion_est.h
index d0950bf..292bdc7 100644
--- a/libavcodec/motion_est.h
+++ b/libavcodec/motion_est.h
@@ -77,8 +77,8 @@ typedef struct MotionEstContext {
     int ymax;
     int pred_x;
     int pred_y;
-    uint8_t *src[4][4];
-    uint8_t *ref[4][4];
+    const uint8_t *src[4][4];
+    const uint8_t *ref[4][4];
     int stride;
     int uvstride;
     /* temp variables for picture complexity calculation */
diff --git a/libavcodec/motionpixels.c b/libavcodec/motionpixels.c
index 29454fd..8b4f5c1 100644
--- a/libavcodec/motionpixels.c
+++ b/libavcodec/motionpixels.c
@@ -355,5 +355,5 @@ const FFCodec ff_motionpixels_decoder = {
     .close          = mp_decode_end,
     FF_CODEC_DECODE_CB(mp_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/movtextdec.c b/libavcodec/movtextdec.c
index 70162b4..42a9649 100644
--- a/libavcodec/movtextdec.c
+++ b/libavcodec/movtextdec.c
@@ -602,5 +602,4 @@ const FFCodec ff_movtext_decoder = {
     FF_CODEC_DECODE_SUB_CB(mov_text_decode_frame),
     .close        = mov_text_decode_close,
     .flush        = mov_text_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/movtextenc.c b/libavcodec/movtextenc.c
index 728338f..9c17ca8 100644
--- a/libavcodec/movtextenc.c
+++ b/libavcodec/movtextenc.c
@@ -709,5 +709,5 @@ const FFCodec ff_movtext_encoder = {
     .init           = mov_text_encode_init,
     FF_CODEC_ENCODE_SUB_CB(mov_text_encode_frame),
     .close          = mov_text_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mpc7.c b/libavcodec/mpc7.c
index 837507b..5dabc1b 100644
--- a/libavcodec/mpc7.c
+++ b/libavcodec/mpc7.c
@@ -322,5 +322,4 @@ const FFCodec ff_mpc7_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mpc8.c b/libavcodec/mpc8.c
index 9d084e1..f9277e6 100644
--- a/libavcodec/mpc8.c
+++ b/libavcodec/mpc8.c
@@ -395,5 +395,4 @@ const FFCodec ff_mpc8_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mpeg12dec.c b/libavcodec/mpeg12dec.c
index e9bde48..0e0bb3d 100644
--- a/libavcodec/mpeg12dec.c
+++ b/libavcodec/mpeg12dec.c
@@ -2876,8 +2876,7 @@ const FFCodec ff_mpeg1video_decoder = {
                              AV_CODEC_CAP_TRUNCATED |
 #endif
                              AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE |
-                             FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal         = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .flush                 = flush,
     .p.max_lowres          = 3,
     .update_thread_context = ONLY_IF_THREADS_ENABLED(mpeg_decode_update_thread_context),
@@ -2909,8 +2908,7 @@ const FFCodec ff_mpeg2video_decoder = {
                       AV_CODEC_CAP_TRUNCATED |
 #endif
                       AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .flush          = flush,
     .p.max_lowres   = 3,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_mpeg2_video_profiles),
@@ -2955,8 +2953,7 @@ const FFCodec ff_mpegvideo_decoder = {
                       AV_CODEC_CAP_TRUNCATED |
 #endif
                       AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .flush          = flush,
     .p.max_lowres   = 3,
 };
@@ -3116,5 +3113,5 @@ const FFCodec ff_ipu_decoder = {
     FF_CODEC_DECODE_CB(ipu_decode_frame),
     .close          = ipu_decode_end,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mpeg12enc.c b/libavcodec/mpeg12enc.c
index 09d63ff..a7e7aef 100644
--- a/libavcodec/mpeg12enc.c
+++ b/libavcodec/mpeg12enc.c
@@ -1231,7 +1231,7 @@ const FFCodec ff_mpeg1video_encoder = {
     .p.pix_fmts           = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                            AV_PIX_FMT_NONE },
     .p.capabilities       = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal        = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal        = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class         = &mpeg1_class,
 };
 
@@ -1249,7 +1249,7 @@ const FFCodec ff_mpeg2video_encoder = {
                                                            AV_PIX_FMT_YUV422P,
                                                            AV_PIX_FMT_NONE },
     .p.capabilities       = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal        = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal        = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class         = &mpeg2_class,
 };
 #endif /* CONFIG_MPEG1VIDEO_ENCODER || CONFIG_MPEG2VIDEO_ENCODER */
diff --git a/libavcodec/mpeg4videodec.c b/libavcodec/mpeg4videodec.c
index 220d415..bfebc38 100644
--- a/libavcodec/mpeg4videodec.c
+++ b/libavcodec/mpeg4videodec.c
@@ -772,7 +772,8 @@ static int mpeg4_decode_partition_a(Mpeg4DecContext *ctx)
             int dir = 0;
 
             mb_num++;
-            ff_update_block_index(s);
+            ff_update_block_index(s, s->avctx->bits_per_raw_sample,
+                                  s->avctx->lowres, s->chroma_x_shift);
             if (s->mb_x == s->resync_mb_x && s->mb_y == s->resync_mb_y + 1)
                 s->first_slice_line = 0;
 
@@ -963,7 +964,8 @@ static int mpeg4_decode_partition_b(MpegEncContext *s, int mb_count)
             const int xy = s->mb_x + s->mb_y * s->mb_stride;
 
             mb_num++;
-            ff_update_block_index(s);
+            ff_update_block_index(s, s->avctx->bits_per_raw_sample,
+                                  s->avctx->lowres, s->chroma_x_shift);
             if (s->mb_x == s->resync_mb_x && s->mb_y == s->resync_mb_y + 1)
                 s->first_slice_line = 0;
 
@@ -3676,8 +3678,7 @@ const FFCodec ff_mpeg4_decoder = {
                              AV_CODEC_CAP_TRUNCATED |
 #endif
                              AV_CODEC_CAP_DELAY | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE |
-                             FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM |
+    .caps_internal         = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM |
                              FF_CODEC_CAP_ALLOCATE_PROGRESS,
     .flush                 = ff_mpeg_flush,
     .p.max_lowres          = 3,
diff --git a/libavcodec/mpeg4videoenc.c b/libavcodec/mpeg4videoenc.c
index 8f0452d..339a3c2 100644
--- a/libavcodec/mpeg4videoenc.c
+++ b/libavcodec/mpeg4videoenc.c
@@ -639,7 +639,7 @@ void ff_mpeg4_encode_mb(MpegEncContext *s, int16_t block[6][64],
                 if (s->max_b_frames > 0) {
                     int i;
                     int x, y, offset;
-                    uint8_t *p_pic;
+                    const uint8_t *p_pic;
 
                     x = s->mb_x * 16;
                     y = s->mb_y * 16;
@@ -649,7 +649,7 @@ void ff_mpeg4_encode_mb(MpegEncContext *s, int16_t block[6][64],
 
                     s->mb_skipped = 1;
                     for (i = 0; i < s->max_b_frames; i++) {
-                        uint8_t *b_pic;
+                        const uint8_t *b_pic;
                         int diff;
                         Picture *pic = s->reordered_input_picture[i + 1];
 
@@ -1081,8 +1081,8 @@ int ff_mpeg4_encode_picture_header(MpegEncContext *s, int picture_number)
     time_mod  = FFUMOD(s->time, s->avctx->time_base.den);
     time_incr = time_div - s->last_time_base;
 
-    // This limits the frame duration to max 1 hour
-    if (time_incr > 3600) {
+    // This limits the frame duration to max 1 day
+    if (time_incr > 3600*24) {
         av_log(s->avctx, AV_LOG_ERROR, "time_incr %"PRIu64" too large\n", time_incr);
         return AVERROR(EINVAL);
     }
@@ -1402,6 +1402,6 @@ const FFCodec ff_mpeg4_encoder = {
     .close          = ff_mpv_encode_end,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class   = &mpeg4enc_class,
 };
diff --git a/libavcodec/mpeg_er.c b/libavcodec/mpeg_er.c
index f54cb85..02f407d 100644
--- a/libavcodec/mpeg_er.c
+++ b/libavcodec/mpeg_er.c
@@ -75,7 +75,8 @@ static void mpeg_er_decode_mb(void *opaque, int ref, int mv_dir, int mv_type,
     memcpy(s->mv, mv, sizeof(*mv));
 
     ff_init_block_index(s);
-    ff_update_block_index(s);
+    ff_update_block_index(s, s->avctx->bits_per_raw_sample,
+                          s->avctx->lowres, s->chroma_x_shift);
 
     s->bdsp.clear_blocks(s->block[0]);
     if (!s->chroma_y_shift)
diff --git a/libavcodec/mpegaudiodec_fixed.c b/libavcodec/mpegaudiodec_fixed.c
index 8a5721d..59e1072 100644
--- a/libavcodec/mpegaudiodec_fixed.c
+++ b/libavcodec/mpegaudiodec_fixed.c
@@ -75,7 +75,6 @@ const FFCodec ff_mp1_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP2_DECODER
@@ -93,7 +92,6 @@ const FFCodec ff_mp2_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3_DECODER
@@ -111,7 +109,6 @@ const FFCodec ff_mp3_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3ADU_DECODER
@@ -129,7 +126,6 @@ const FFCodec ff_mp3adu_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S16,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3ON4_DECODER
@@ -147,6 +143,6 @@ const FFCodec ff_mp3on4_decoder = {
     .flush          = flush_mp3on4,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/mpegaudiodec_float.c b/libavcodec/mpegaudiodec_float.c
index bcd5506..1a83f40 100644
--- a/libavcodec/mpegaudiodec_float.c
+++ b/libavcodec/mpegaudiodec_float.c
@@ -88,7 +88,6 @@ const FFCodec ff_mp1float_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_FLT,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP2FLOAT_DECODER
@@ -106,7 +105,6 @@ const FFCodec ff_mp2float_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_FLT,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3FLOAT_DECODER
@@ -124,7 +122,6 @@ const FFCodec ff_mp3float_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_FLT,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3ADUFLOAT_DECODER
@@ -142,7 +139,6 @@ const FFCodec ff_mp3adufloat_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_FLT,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_MP3ON4FLOAT_DECODER
@@ -160,6 +156,6 @@ const FFCodec ff_mp3on4float_decoder = {
     .flush          = flush_mp3on4,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/mpegaudiodec_template.c b/libavcodec/mpegaudiodec_template.c
index a711154..a28cac9 100644
--- a/libavcodec/mpegaudiodec_template.c
+++ b/libavcodec/mpegaudiodec_template.c
@@ -374,7 +374,7 @@ static int handle_crc(MPADecodeContext *s, int sec_len)
         crc_val = av_crc(crc_tab, crc_val, &buf[6], sec_byte_len);
 
         AV_WB32(tmp_buf,
-                ((buf[6 + sec_byte_len] & (0xFF00U >> sec_rem_bits)) << 24) +
+                ((buf[6 + sec_byte_len] & (0xFF00 >> sec_rem_bits)) << 24) +
                 ((s->crc << 16) >> sec_rem_bits));
 
         crc_val = av_crc(crc_tab, crc_val, tmp_buf, 3);
diff --git a/libavcodec/mpegaudioenc_fixed.c b/libavcodec/mpegaudioenc_fixed.c
index 74cb4b8..0176011 100644
--- a/libavcodec/mpegaudioenc_fixed.c
+++ b/libavcodec/mpegaudioenc_fixed.c
@@ -45,5 +45,4 @@ const FFCodec ff_mp2fixed_encoder = {
                                                         AV_CHANNEL_LAYOUT_STEREO,
                                                         { 0 } },
     .defaults              = mp2_defaults,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mpegaudioenc_float.c b/libavcodec/mpegaudioenc_float.c
index 0a597b7..2bcad42 100644
--- a/libavcodec/mpegaudioenc_float.c
+++ b/libavcodec/mpegaudioenc_float.c
@@ -46,5 +46,4 @@ const FFCodec ff_mp2_encoder = {
                                                         AV_CHANNEL_LAYOUT_STEREO,
                                                         { 0 } },
     .defaults              = mp2_defaults,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mpegpicture.c b/libavcodec/mpegpicture.c
index aaa1df0..711ce35 100644
--- a/libavcodec/mpegpicture.c
+++ b/libavcodec/mpegpicture.c
@@ -37,9 +37,6 @@ static void av_noinline free_picture_tables(Picture *pic)
     pic->alloc_mb_width  =
     pic->alloc_mb_height = 0;
 
-    av_buffer_unref(&pic->mb_var_buf);
-    av_buffer_unref(&pic->mc_mb_var_buf);
-    av_buffer_unref(&pic->mb_mean_buf);
     av_buffer_unref(&pic->mbskip_table_buf);
     av_buffer_unref(&pic->qscale_table_buf);
     av_buffer_unref(&pic->mb_type_buf);
@@ -50,26 +47,38 @@ static void av_noinline free_picture_tables(Picture *pic)
     }
 }
 
+static int make_table_writable(AVBufferRef **ref)
+{
+    AVBufferRef *old = *ref, *new;
+
+    if (av_buffer_is_writable(old))
+        return 0;
+    new = av_buffer_allocz(old->size);
+    if (!new)
+        return AVERROR(ENOMEM);
+    av_buffer_unref(ref);
+    *ref = new;
+    return 0;
+}
+
 static int make_tables_writable(Picture *pic)
 {
-    int ret, i;
 #define MAKE_WRITABLE(table) \
 do {\
-    if (pic->table &&\
-       (ret = av_buffer_make_writable(&pic->table)) < 0)\
-    return ret;\
+    int ret = make_table_writable(&pic->table); \
+    if (ret < 0) \
+        return ret; \
 } while (0)
 
-    MAKE_WRITABLE(mb_var_buf);
-    MAKE_WRITABLE(mc_mb_var_buf);
-    MAKE_WRITABLE(mb_mean_buf);
     MAKE_WRITABLE(mbskip_table_buf);
     MAKE_WRITABLE(qscale_table_buf);
     MAKE_WRITABLE(mb_type_buf);
 
-    for (i = 0; i < 2; i++) {
-        MAKE_WRITABLE(motion_val_buf[i]);
-        MAKE_WRITABLE(ref_index_buf[i]);
+    if (pic->motion_val_buf[0]) {
+        for (int i = 0; i < 2; i++) {
+            MAKE_WRITABLE(motion_val_buf[i]);
+            MAKE_WRITABLE(ref_index_buf[i]);
+        }
     }
 
     return 0;
@@ -218,14 +227,6 @@ static int alloc_picture_tables(AVCodecContext *avctx, Picture *pic, int encodin
     if (!pic->mbskip_table_buf || !pic->qscale_table_buf || !pic->mb_type_buf)
         return AVERROR(ENOMEM);
 
-    if (encoding) {
-        pic->mb_var_buf    = av_buffer_allocz(mb_array_size * sizeof(int16_t));
-        pic->mc_mb_var_buf = av_buffer_allocz(mb_array_size * sizeof(int16_t));
-        pic->mb_mean_buf   = av_buffer_allocz(mb_array_size);
-        if (!pic->mb_var_buf || !pic->mc_mb_var_buf || !pic->mb_mean_buf)
-            return AVERROR(ENOMEM);
-    }
-
     if (out_format == FMT_H263 || encoding ||
         (avctx->export_side_data & AV_CODEC_EXPORT_DATA_MVS)) {
         int mv_size        = 2 * (b8_array_size + 4) * sizeof(int16_t);
@@ -285,12 +286,6 @@ int ff_alloc_picture(AVCodecContext *avctx, Picture *pic, MotionEstContext *me,
     if (ret < 0)
         goto fail;
 
-    if (encoding) {
-        pic->mb_var    = (uint16_t*)pic->mb_var_buf->data;
-        pic->mc_mb_var = (uint16_t*)pic->mc_mb_var_buf->data;
-        pic->mb_mean   = pic->mb_mean_buf->data;
-    }
-
     pic->mbskip_table = pic->mbskip_table_buf->data;
     pic->qscale_table = pic->qscale_table_buf->data + 2 * mb_stride + 1;
     pic->mb_type      = (uint32_t*)pic->mb_type_buf->data + 2 * mb_stride + 1;
@@ -316,7 +311,7 @@ fail:
  */
 void ff_mpeg_unref_picture(AVCodecContext *avctx, Picture *pic)
 {
-    int off = offsetof(Picture, mb_mean) + sizeof(pic->mb_mean);
+    int off = offsetof(Picture, hwaccel_priv_buf) + sizeof(pic->hwaccel_priv_buf);
 
     pic->tf.f = pic->f;
     /* WM Image / Screen codecs allocate internal buffers with different
@@ -340,10 +335,7 @@ int ff_update_picture_tables(Picture *dst, const Picture *src)
 {
     int i, ret;
 
-    ret  = av_buffer_replace(&dst->mb_var_buf,       src->mb_var_buf);
-    ret |= av_buffer_replace(&dst->mc_mb_var_buf,    src->mc_mb_var_buf);
-    ret |= av_buffer_replace(&dst->mb_mean_buf,      src->mb_mean_buf);
-    ret |= av_buffer_replace(&dst->mbskip_table_buf, src->mbskip_table_buf);
+    ret  = av_buffer_replace(&dst->mbskip_table_buf, src->mbskip_table_buf);
     ret |= av_buffer_replace(&dst->qscale_table_buf, src->qscale_table_buf);
     ret |= av_buffer_replace(&dst->mb_type_buf,      src->mb_type_buf);
     for (i = 0; i < 2; i++) {
@@ -356,9 +348,6 @@ int ff_update_picture_tables(Picture *dst, const Picture *src)
         return ret;
     }
 
-    dst->mb_var        = src->mb_var;
-    dst->mc_mb_var     = src->mc_mb_var;
-    dst->mb_mean       = src->mb_mean;
     dst->mbskip_table  = src->mbskip_table;
     dst->qscale_table  = src->qscale_table;
     dst->mb_type       = src->mb_type;
@@ -401,16 +390,11 @@ int ff_mpeg_ref_picture(AVCodecContext *avctx, Picture *dst, Picture *src)
     }
 
     dst->field_picture           = src->field_picture;
-    dst->mb_var_sum              = src->mb_var_sum;
-    dst->mc_mb_var_sum           = src->mc_mb_var_sum;
     dst->b_frame_score           = src->b_frame_score;
     dst->needs_realloc           = src->needs_realloc;
     dst->reference               = src->reference;
     dst->shared                  = src->shared;
 
-    memcpy(dst->encoding_error, src->encoding_error,
-           sizeof(dst->encoding_error));
-
     return 0;
 fail:
     ff_mpeg_unref_picture(avctx, dst);
diff --git a/libavcodec/mpegpicture.h b/libavcodec/mpegpicture.h
index 0671bba..a1455ee 100644
--- a/libavcodec/mpegpicture.h
+++ b/libavcodec/mpegpicture.h
@@ -62,34 +62,20 @@ typedef struct Picture {
     AVBufferRef *ref_index_buf[2];
     int8_t *ref_index[2];
 
-    AVBufferRef *mb_var_buf;
-    uint16_t *mb_var;           ///< Table for MB variances
-
-    AVBufferRef *mc_mb_var_buf;
-    uint16_t *mc_mb_var;        ///< Table for motion compensated MB variances
-
     int alloc_mb_width;         ///< mb_width used to allocate tables
     int alloc_mb_height;        ///< mb_height used to allocate tables
     int alloc_mb_stride;        ///< mb_stride used to allocate tables
 
-    AVBufferRef *mb_mean_buf;
-    uint8_t *mb_mean;           ///< Table for MB luminance
-
     AVBufferRef *hwaccel_priv_buf;
     void *hwaccel_picture_private; ///< Hardware accelerator private data
 
     int field_picture;          ///< whether or not the picture was encoded in separate fields
 
-    int64_t mb_var_sum;         ///< sum of MB variance for current frame
-    int64_t mc_mb_var_sum;      ///< motion compensated MB variance for current frame
-
     int b_frame_score;
     int needs_realloc;          ///< Picture needs to be reallocated (eg due to a frame size change)
 
     int reference;
     int shared;
-
-    uint64_t encoding_error[MPEGVIDEO_MAX_PLANES];
 } Picture;
 
 /**
diff --git a/libavcodec/mpegutils.c b/libavcodec/mpegutils.c
index 4cbc474..ff94182 100644
--- a/libavcodec/mpegutils.c
+++ b/libavcodec/mpegutils.c
@@ -49,7 +49,7 @@ static int add_mb(AVMotionVector *mb, uint32_t mb_type,
 }
 
 void ff_draw_horiz_band(AVCodecContext *avctx,
-                        AVFrame *cur, AVFrame *last,
+                        const AVFrame *cur, const AVFrame *last,
                         int y, int h, int picture_structure,
                         int first_field, int low_delay)
 {
@@ -68,7 +68,7 @@ void ff_draw_horiz_band(AVCodecContext *avctx,
         return;
 
     if (avctx->draw_horiz_band) {
-        AVFrame *src;
+        const AVFrame *src;
         int offset[AV_NUM_DATA_POINTERS];
         int i;
 
@@ -100,9 +100,63 @@ void ff_draw_horiz_band(AVCodecContext *avctx,
     }
 }
 
-void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict, uint8_t *mbskip_table,
-                         uint32_t *mbtype_table, int8_t *qscale_table, int16_t (*motion_val[2])[2],
-                         int mb_width, int mb_height, int mb_stride, int quarter_sample)
+static char get_type_mv_char(int mb_type)
+{
+    // Type & MV direction
+    if (IS_PCM(mb_type))
+        return 'P';
+    else if (IS_INTRA(mb_type) && IS_ACPRED(mb_type))
+        return 'A';
+    else if (IS_INTRA4x4(mb_type))
+        return 'i';
+    else if (IS_INTRA16x16(mb_type))
+        return 'I';
+    else if (IS_DIRECT(mb_type) && IS_SKIP(mb_type))
+        return 'd';
+    else if (IS_DIRECT(mb_type))
+        return 'D';
+    else if (IS_GMC(mb_type) && IS_SKIP(mb_type))
+        return 'g';
+    else if (IS_GMC(mb_type))
+        return 'G';
+    else if (IS_SKIP(mb_type))
+        return 'S';
+    else if (!USES_LIST(mb_type, 1))
+        return '>';
+    else if (!USES_LIST(mb_type, 0))
+        return '<';
+    else {
+        av_assert2(USES_LIST(mb_type, 0) && USES_LIST(mb_type, 1));
+        return 'X';
+    }
+}
+
+static char get_segmentation_char(int mb_type)
+{
+    if (IS_8X8(mb_type))
+        return '+';
+    else if (IS_16X8(mb_type))
+        return '-';
+    else if (IS_8X16(mb_type))
+        return '|';
+    else if (IS_INTRA(mb_type) || IS_16X16(mb_type))
+        return ' ';
+
+    return '?';
+}
+
+static char get_interlacement_char(int mb_type)
+{
+    if (IS_INTERLACED(mb_type))
+        return '=';
+    else
+        return ' ';
+}
+
+void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict,
+                          const uint8_t *mbskip_table, const uint32_t *mbtype_table,
+                          const int8_t *qscale_table, int16_t (*const motion_val[2])[2],
+                          int mb_width, int mb_height, int mb_stride, int quarter_sample)
 {
     if ((avctx->export_side_data & AV_CODEC_EXPORT_DATA_MVS) && mbtype_table && motion_val[0]) {
         const int shift = 1 + quarter_sample;
@@ -211,51 +265,11 @@ void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict, uint8_t *mbskip_
                 }
                 if (avctx->debug & FF_DEBUG_MB_TYPE) {
                     int mb_type = mbtype_table[x + y * mb_stride];
-                    // Type & MV direction
-                    if (IS_PCM(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "P");
-                    else if (IS_INTRA(mb_type) && IS_ACPRED(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "A");
-                    else if (IS_INTRA4x4(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "i");
-                    else if (IS_INTRA16x16(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "I");
-                    else if (IS_DIRECT(mb_type) && IS_SKIP(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "d");
-                    else if (IS_DIRECT(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "D");
-                    else if (IS_GMC(mb_type) && IS_SKIP(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "g");
-                    else if (IS_GMC(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "G");
-                    else if (IS_SKIP(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "S");
-                    else if (!USES_LIST(mb_type, 1))
-                        av_log(avctx, AV_LOG_DEBUG, ">");
-                    else if (!USES_LIST(mb_type, 0))
-                        av_log(avctx, AV_LOG_DEBUG, "<");
-                    else {
-                        av_assert2(USES_LIST(mb_type, 0) && USES_LIST(mb_type, 1));
-                        av_log(avctx, AV_LOG_DEBUG, "X");
-                    }
-
-                    // segmentation
-                    if (IS_8X8(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "+");
-                    else if (IS_16X8(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "-");
-                    else if (IS_8X16(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "|");
-                    else if (IS_INTRA(mb_type) || IS_16X16(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, " ");
-                    else
-                        av_log(avctx, AV_LOG_DEBUG, "?");
-
 
-                    if (IS_INTERLACED(mb_type))
-                        av_log(avctx, AV_LOG_DEBUG, "=");
-                    else
-                        av_log(avctx, AV_LOG_DEBUG, " ");
+                    av_log(avctx, AV_LOG_DEBUG, "%c%c%c",
+                           get_type_mv_char(mb_type),
+                           get_segmentation_char(mb_type),
+                           get_interlacement_char(mb_type));
                 }
             }
             av_log(avctx, AV_LOG_DEBUG, "\n");
diff --git a/libavcodec/mpegutils.h b/libavcodec/mpegutils.h
index c92f919..386110b 100644
--- a/libavcodec/mpegutils.h
+++ b/libavcodec/mpegutils.h
@@ -127,15 +127,16 @@ enum OutputFormat {
  *
  * @param h is the normal height, this will be reduced automatically if needed
  */
-void ff_draw_horiz_band(AVCodecContext *avctx, AVFrame *cur, AVFrame *last,
+void ff_draw_horiz_band(AVCodecContext *avctx, const AVFrame *cur, const AVFrame *last,
                         int y, int h, int picture_structure, int first_field,
                         int low_delay);
 
 /**
  * Print debugging info for the given picture.
  */
-void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict, uint8_t *mbskip_table,
-                         uint32_t *mbtype_table, int8_t *qscale_table, int16_t (*motion_val[2])[2],
-                         int mb_width, int mb_height, int mb_stride, int quarter_sample);
+void ff_print_debug_info2(AVCodecContext *avctx, AVFrame *pict,
+                          const uint8_t *mbskip_table, const uint32_t *mbtype_table,
+                          const int8_t *qscale_table, int16_t (*const motion_val[2])[2],
+                          int mb_width, int mb_height, int mb_stride, int quarter_sample);
 
 #endif /* AVCODEC_MPEGUTILS_H */
diff --git a/libavcodec/mpegvideo.c b/libavcodec/mpegvideo.c
index 319934a..1190f29 100644
--- a/libavcodec/mpegvideo.c
+++ b/libavcodec/mpegvideo.c
@@ -526,6 +526,11 @@ int ff_mpv_init_context_frame(MpegEncContext *s)
 {
     int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y;
 
+    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)
+        s->mb_height = (s->height + 31) / 32 * 2;
+    else
+        s->mb_height = (s->height + 15) / 16;
+
     s->mb_width   = (s->width + 15) / 16;
     s->mb_stride  = s->mb_width + 1;
     s->b8_stride  = s->mb_width * 2 + 1;
@@ -646,10 +651,10 @@ int ff_mpv_init_context_frame(MpegEncContext *s)
             s->dc_val_base[i] = 1024;
     }
 
-    /* which mb is an intra block,  init macroblock skip table */
-    if (!(s->mbintra_table = av_mallocz(mb_array_size)) ||
-        // Note the + 1 is for a quicker MPEG-4 slice_end detection
-        !(s->mbskip_table  = av_mallocz(mb_array_size + 2)))
+    // Note the + 1 is for a quicker MPEG-4 slice_end detection
+    if (!(s->mbskip_table  = av_mallocz(mb_array_size + 2)) ||
+        /* which mb is an intra block,  init macroblock skip table */
+        !(s->mbintra_table = av_malloc(mb_array_size)))
         return AVERROR(ENOMEM);
     memset(s->mbintra_table, 1, mb_array_size);
 
@@ -747,28 +752,12 @@ av_cold int ff_mpv_common_init(MpegEncContext *s)
     if (s->encoding && s->avctx->slices)
         nb_slices = s->avctx->slices;
 
-    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)
-        s->mb_height = (s->height + 31) / 32 * 2;
-    else
-        s->mb_height = (s->height + 15) / 16;
-
     if (s->avctx->pix_fmt == AV_PIX_FMT_NONE) {
         av_log(s->avctx, AV_LOG_ERROR,
                "decoding to AV_PIX_FMT_NONE is not supported.\n");
         return AVERROR(EINVAL);
     }
 
-    if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {
-        int max_slices;
-        if (s->mb_height)
-            max_slices = FFMIN(MAX_THREADS, s->mb_height);
-        else
-            max_slices = MAX_THREADS;
-        av_log(s->avctx, AV_LOG_WARNING, "too many threads/slices (%d),"
-               " reducing to %d\n", nb_slices, max_slices);
-        nb_slices = max_slices;
-    }
-
     if ((s->width || s->height) &&
         av_image_check_size(s->width, s->height, 0, s->avctx))
         return AVERROR(EINVAL);
@@ -799,6 +788,17 @@ av_cold int ff_mpv_common_init(MpegEncContext *s)
     if ((ret = ff_mpv_init_context_frame(s)))
         goto fail;
 
+    if (nb_slices > MAX_THREADS || (nb_slices > s->mb_height && s->mb_height)) {
+        int max_slices;
+        if (s->mb_height)
+            max_slices = FFMIN(MAX_THREADS, s->mb_height);
+        else
+            max_slices = MAX_THREADS;
+        av_log(s->avctx, AV_LOG_WARNING, "too many threads/slices (%d),"
+               " reducing to %d\n", nb_slices, max_slices);
+        nb_slices = max_slices;
+    }
+
 #if FF_API_FLAG_TRUNCATED
     s->parse_context.state = -1;
 #endif
@@ -916,12 +916,12 @@ void ff_mpv_common_end(MpegEncContext *s)
 
 
 static inline int hpel_motion_lowres(MpegEncContext *s,
-                                     uint8_t *dest, uint8_t *src,
+                                     uint8_t *dest, const uint8_t *src,
                                      int field_based, int field_select,
                                      int src_x, int src_y,
                                      int width, int height, ptrdiff_t stride,
                                      int h_edge_pos, int v_edge_pos,
-                                     int w, int h, h264_chroma_mc_func *pix_op,
+                                     int w, int h, const h264_chroma_mc_func *pix_op,
                                      int motion_x, int motion_y)
 {
     const int lowres   = s->avctx->lowres;
@@ -969,12 +969,12 @@ static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,
                                                 int field_based,
                                                 int bottom_field,
                                                 int field_select,
-                                                uint8_t **ref_picture,
-                                                h264_chroma_mc_func *pix_op,
+                                                uint8_t *const *ref_picture,
+                                                const h264_chroma_mc_func *pix_op,
                                                 int motion_x, int motion_y,
                                                 int h, int mb_y)
 {
-    uint8_t *ptr_y, *ptr_cb, *ptr_cr;
+    const uint8_t *ptr_y, *ptr_cb, *ptr_cr;
     int mx, my, src_x, src_y, uvsrc_x, uvsrc_y, sx, sy, uvsx, uvsy;
     ptrdiff_t uvlinesize, linesize;
     const int lowres     = s->avctx->lowres;
@@ -1103,8 +1103,8 @@ static av_always_inline void mpeg_motion_lowres(MpegEncContext *s,
 
 static inline void chroma_4mv_motion_lowres(MpegEncContext *s,
                                             uint8_t *dest_cb, uint8_t *dest_cr,
-                                            uint8_t **ref_picture,
-                                            h264_chroma_mc_func * pix_op,
+                                            uint8_t *const *ref_picture,
+                                            const h264_chroma_mc_func * pix_op,
                                             int mx, int my)
 {
     const int lowres     = s->avctx->lowres;
@@ -1115,7 +1115,7 @@ static inline void chroma_4mv_motion_lowres(MpegEncContext *s,
     const int v_edge_pos = s->v_edge_pos >> lowres + 1;
     int emu = 0, src_x, src_y, sx, sy;
     ptrdiff_t offset;
-    uint8_t *ptr;
+    const uint8_t *ptr;
 
     if (s->quarter_sample) {
         mx /= 2;
@@ -1172,8 +1172,8 @@ static inline void chroma_4mv_motion_lowres(MpegEncContext *s,
 static inline void MPV_motion_lowres(MpegEncContext *s,
                                      uint8_t *dest_y, uint8_t *dest_cb,
                                      uint8_t *dest_cr,
-                                     int dir, uint8_t **ref_picture,
-                                     h264_chroma_mc_func *pix_op)
+                                     int dir, uint8_t *const *ref_picture,
+                                     const h264_chroma_mc_func *pix_op)
 {
     int mx, my;
     int mb_x, mb_y, i;
@@ -1242,7 +1242,7 @@ static inline void MPV_motion_lowres(MpegEncContext *s,
         break;
     case MV_TYPE_16X8:
         for (i = 0; i < 2; i++) {
-            uint8_t **ref2picture;
+            uint8_t *const *ref2picture;
 
             if (s->picture_structure == s->field_select[dir][i] + 1 ||
                 s->pict_type == AV_PICTURE_TYPE_B || s->first_field) {
@@ -1492,7 +1492,7 @@ void mpv_reconstruct_mb_internal(MpegEncContext *s, int16_t block[12][64],
                 }
 
                 if(lowres_flag){
-                    h264_chroma_mc_func *op_pix = s->h264chroma.put_h264_chroma_pixels_tab;
+                    const h264_chroma_mc_func *op_pix = s->h264chroma.put_h264_chroma_pixels_tab;
 
                     if (s->mv_dir & MV_DIR_FORWARD) {
                         MPV_motion_lowres(s, dest_y, dest_cb, dest_cr, 0, s->last_picture.f->data, op_pix);
diff --git a/libavcodec/mpegvideo.h b/libavcodec/mpegvideo.h
index 82889a0..1ddf803 100644
--- a/libavcodec/mpegvideo.h
+++ b/libavcodec/mpegvideo.h
@@ -235,6 +235,15 @@ typedef struct MpegEncContext {
     int16_t (*b_field_mv_table[2][2][2])[2];///< MV table (4MV per MB) interlaced B-frame encoding
     uint8_t (*p_field_select_table[2]);  ///< Only the first element is allocated
     uint8_t (*b_field_select_table[2][2]); ///< Only the first element is allocated
+
+    /* The following fields are encoder-only */
+    uint16_t *mb_var;           ///< Table for MB variances
+    uint16_t *mc_mb_var;        ///< Table for motion compensated MB variances
+    uint8_t *mb_mean;           ///< Table for MB luminance
+    int64_t mb_var_sum;         ///< sum of MB variance for current frame
+    int64_t mc_mb_var_sum;      ///< motion compensated MB variance for current frame
+    uint64_t encoding_error[MPEGVIDEO_MAX_PLANES];
+
     int motion_est;                      ///< ME algorithm
     int me_penalty_compensation;
     int me_pre;                          ///< prepass for motion estimation
@@ -586,13 +595,15 @@ void ff_init_block_index(MpegEncContext *s);
 void ff_mpv_motion(MpegEncContext *s,
                    uint8_t *dest_y, uint8_t *dest_cb,
                    uint8_t *dest_cr, int dir,
-                   uint8_t **ref_picture,
+                   uint8_t *const *ref_picture,
                    op_pixels_func (*pix_op)[4],
                    qpel_mc_func (*qpix_op)[16]);
 
-static inline void ff_update_block_index(MpegEncContext *s){
-    const int bytes_per_pixel = 1 + (s->avctx->bits_per_raw_sample > 8);
-    const int block_size= (8*bytes_per_pixel) >> s->avctx->lowres;
+static inline void ff_update_block_index(MpegEncContext *s, int bits_per_raw_sample,
+                                         int lowres, int chroma_x_shift)
+{
+    const int bytes_per_pixel = 1 + (bits_per_raw_sample > 8);
+    const int block_size = (8 * bytes_per_pixel) >> lowres;
 
     s->block_index[0]+=2;
     s->block_index[1]+=2;
@@ -601,8 +612,8 @@ static inline void ff_update_block_index(MpegEncContext *s){
     s->block_index[4]++;
     s->block_index[5]++;
     s->dest[0]+= 2*block_size;
-    s->dest[1]+= (2 >> s->chroma_x_shift) * block_size;
-    s->dest[2]+= (2 >> s->chroma_x_shift) * block_size;
+    s->dest[1] += (2 >> chroma_x_shift) * block_size;
+    s->dest[2] += (2 >> chroma_x_shift) * block_size;
 }
 
 #endif /* AVCODEC_MPEGVIDEO_H */
diff --git a/libavcodec/mpegvideo_dec.c b/libavcodec/mpegvideo_dec.c
index 7caaf05..7566fe6 100644
--- a/libavcodec/mpegvideo_dec.c
+++ b/libavcodec/mpegvideo_dec.c
@@ -208,12 +208,6 @@ int ff_mpv_common_frame_size_change(MpegEncContext *s)
     s->next_picture_ptr         =
     s->current_picture_ptr      = NULL;
 
-    // init
-    if (s->codec_id == AV_CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)
-        s->mb_height = (s->height + 31) / 32 * 2;
-    else
-        s->mb_height = (s->height + 15) / 16;
-
     if ((s->width || s->height) &&
         (err = av_image_check_size(s->width, s->height, 0, s->avctx)) < 0)
         goto fail;
@@ -503,14 +497,14 @@ void ff_mpv_frame_end(MpegEncContext *s)
         ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
 }
 
-void ff_print_debug_info(MpegEncContext *s, Picture *p, AVFrame *pict)
+void ff_print_debug_info(const MpegEncContext *s, const Picture *p, AVFrame *pict)
 {
     ff_print_debug_info2(s->avctx, pict, s->mbskip_table, p->mb_type,
                          p->qscale_table, p->motion_val,
                          s->mb_width, s->mb_height, s->mb_stride, s->quarter_sample);
 }
 
-int ff_mpv_export_qp_table(MpegEncContext *s, AVFrame *f, Picture *p, int qp_type)
+int ff_mpv_export_qp_table(const MpegEncContext *s, AVFrame *f, const Picture *p, int qp_type)
 {
     AVVideoEncParams *par;
     int mult = (qp_type == FF_MPV_QSCALE_TYPE_MPEG1) ? 2 : 1;
diff --git a/libavcodec/mpegvideo_enc.c b/libavcodec/mpegvideo_enc.c
index c9d9e2a..63fa066 100644
--- a/libavcodec/mpegvideo_enc.c
+++ b/libavcodec/mpegvideo_enc.c
@@ -313,6 +313,7 @@ av_cold int ff_mpv_encode_init(AVCodecContext *avctx)
     MpegEncContext *s = avctx->priv_data;
     AVCPBProperties *cpb_props;
     int i, ret;
+    int mb_array_size;
 
     mpv_encode_defaults(s);
 
@@ -823,6 +824,12 @@ av_cold int ff_mpv_encode_init(AVCodecContext *avctx)
         !FF_ALLOCZ_TYPED_ARRAY(s->reordered_input_picture, MAX_PICTURE_COUNT))
         return AVERROR(ENOMEM);
 
+    mb_array_size = s->mb_stride * s->mb_height;
+    if (!FF_ALLOCZ_TYPED_ARRAY(s->mc_mb_var, mb_array_size) ||
+        !FF_ALLOCZ_TYPED_ARRAY(s->mb_var, mb_array_size) ||
+        !(s->mb_mean = av_mallocz(mb_array_size)))
+        return AVERROR(ENOMEM);
+
     if (s->noise_reduction) {
         if (!FF_ALLOCZ_TYPED_ARRAY(s->dct_offset, 2))
             return AVERROR(ENOMEM);
@@ -852,7 +859,7 @@ av_cold int ff_mpv_encode_init(AVCodecContext *avctx)
         ff_mpeg1_encode_init(s);
     } else if (CONFIG_H263_ENCODER && s->out_format == FMT_H263) {
         ff_h263_encode_init(s);
-        if (CONFIG_MSMPEG4_ENCODER && s->msmpeg4_version)
+        if (CONFIG_MSMPEG4ENC && s->msmpeg4_version)
             ff_msmpeg4_encode_init(s);
     }
 
@@ -949,11 +956,14 @@ av_cold int ff_mpv_encode_end(AVCodecContext *avctx)
     av_freep(&s->input_picture);
     av_freep(&s->reordered_input_picture);
     av_freep(&s->dct_offset);
+    av_freep(&s->mb_var);
+    av_freep(&s->mc_mb_var);
+    av_freep(&s->mb_mean);
 
     return 0;
 }
 
-static int get_sae(uint8_t *src, int ref, int stride)
+static int get_sae(const uint8_t *src, int ref, int stride)
 {
     int x,y;
     int acc = 0;
@@ -967,8 +977,8 @@ static int get_sae(uint8_t *src, int ref, int stride)
     return acc;
 }
 
-static int get_intra_count(MpegEncContext *s, uint8_t *src,
-                           uint8_t *ref, int stride)
+static int get_intra_count(MpegEncContext *s, const uint8_t *src,
+                           const uint8_t *ref, int stride)
 {
     int x, y, w, h;
     int acc = 0;
@@ -1087,7 +1097,7 @@ static int load_input_picture(MpegEncContext *s, const AVFrame *pic_arg)
                     int v_shift = i ? v_chroma_shift : 0;
                     int w = s->width  >> h_shift;
                     int h = s->height >> v_shift;
-                    uint8_t *src = pic_arg->data[i];
+                    const uint8_t *src = pic_arg->data[i];
                     uint8_t *dst = pic->f->data[i];
                     int vpad = 16;
 
@@ -1144,12 +1154,12 @@ static int load_input_picture(MpegEncContext *s, const AVFrame *pic_arg)
     for (i = flush_offset; i < MAX_PICTURE_COUNT /*s->encoding_delay + 1*/; i++)
         s->input_picture[i - flush_offset] = s->input_picture[i];
 
-    s->input_picture[encoding_delay] = (Picture*) pic;
+    s->input_picture[encoding_delay] = pic;
 
     return 0;
 }
 
-static int skip_check(MpegEncContext *s, Picture *p, Picture *ref)
+static int skip_check(MpegEncContext *s, const Picture *p, const Picture *ref)
 {
     int x, y, plane;
     int score = 0;
@@ -1161,8 +1171,8 @@ static int skip_check(MpegEncContext *s, Picture *p, Picture *ref)
         for (y = 0; y < s->mb_height * bw; y++) {
             for (x = 0; x < s->mb_width * bw; x++) {
                 int off = p->shared ? 0 : 16;
-                uint8_t *dptr = p->f->data[plane] + 8 * (x + y * stride) + off;
-                uint8_t *rptr = ref->f->data[plane] + 8 * (x + y * stride);
+                const uint8_t *dptr = p->f->data[plane] + 8 * (x + y * stride) + off;
+                const uint8_t *rptr = ref->f->data[plane] + 8 * (x + y * stride);
                 int v = s->mecc.frame_skip_cmp[1](s, dptr, rptr, stride, 8);
 
                 switch (FFABS(s->frame_skip_exp)) {
@@ -1190,7 +1200,7 @@ static int skip_check(MpegEncContext *s, Picture *p, Picture *ref)
     return 0;
 }
 
-static int encode_frame(AVCodecContext *c, AVFrame *frame, AVPacket *pkt)
+static int encode_frame(AVCodecContext *c, const AVFrame *frame, AVPacket *pkt)
 {
     int ret;
     int size = 0;
@@ -1239,15 +1249,14 @@ static int estimate_best_b_count(MpegEncContext *s)
                FF_LAMBDA_SHIFT;
 
     for (i = 0; i < s->max_b_frames + 2; i++) {
-        Picture pre_input, *pre_input_ptr = i ? s->input_picture[i - 1] :
-                                                s->next_picture_ptr;
-        uint8_t *data[4];
+        const Picture *pre_input_ptr = i ? s->input_picture[i - 1] :
+                                           s->next_picture_ptr;
 
-        if (pre_input_ptr && (!i || s->input_picture[i - 1])) {
-            pre_input = *pre_input_ptr;
+        if (pre_input_ptr) {
+            const uint8_t *data[4];
             memcpy(data, pre_input_ptr->f->data, sizeof(data));
 
-            if (!pre_input.shared && i) {
+            if (!pre_input_ptr->shared && i) {
                 data[0] += INPLACE_OFFSET;
                 data[1] += INPLACE_OFFSET;
                 data[2] += INPLACE_OFFSET;
@@ -1256,17 +1265,17 @@ static int estimate_best_b_count(MpegEncContext *s)
             s->mpvencdsp.shrink[scale](s->tmp_frames[i]->data[0],
                                        s->tmp_frames[i]->linesize[0],
                                        data[0],
-                                       pre_input.f->linesize[0],
+                                       pre_input_ptr->f->linesize[0],
                                        width, height);
             s->mpvencdsp.shrink[scale](s->tmp_frames[i]->data[1],
                                        s->tmp_frames[i]->linesize[1],
                                        data[1],
-                                       pre_input.f->linesize[1],
+                                       pre_input_ptr->f->linesize[1],
                                        width >> 1, height >> 1);
             s->mpvencdsp.shrink[scale](s->tmp_frames[i]->data[2],
                                        s->tmp_frames[i]->linesize[2],
                                        data[2],
-                                       pre_input.f->linesize[2],
+                                       pre_input_ptr->f->linesize[2],
                                        width >> 1, height >> 1);
         }
     }
@@ -1773,11 +1782,10 @@ vbv_retry:
             ff_write_pass1_stats(s);
 
         for (i = 0; i < 4; i++) {
-            s->current_picture_ptr->encoding_error[i] = s->current_picture.encoding_error[i];
-            avctx->error[i] += s->current_picture_ptr->encoding_error[i];
+            avctx->error[i] += s->encoding_error[i];
         }
         ff_side_data_set_encoder_stats(pkt, s->current_picture.f->quality,
-                                       s->current_picture_ptr->encoding_error,
+                                       s->encoding_error,
                                        (avctx->flags&AV_CODEC_FLAG_PSNR) ? MPEGVIDEO_MAX_PLANES : 0,
                                        s->pict_type);
 
@@ -1990,7 +1998,7 @@ static inline void clip_coeffs(MpegEncContext *s, int16_t *block,
                overflow, minlevel, maxlevel);
 }
 
-static void get_visual_weight(int16_t *weight, uint8_t *ptr, int stride)
+static void get_visual_weight(int16_t *weight, const uint8_t *ptr, int stride)
 {
     int x, y;
     // FIXME optimize
@@ -2035,7 +2043,7 @@ static av_always_inline void encode_mb_internal(MpegEncContext *s,
     int skip_dct[12];
     int dct_offset = s->linesize * 8; // default for progressive frames
     int uv_dct_offset = s->uvlinesize * 8;
-    uint8_t *ptr_y, *ptr_cb, *ptr_cr;
+    const uint8_t *ptr_y, *ptr_cb, *ptr_cr;
     ptrdiff_t wrap_y, wrap_c;
 
     for (i = 0; i < mb_block_count; i++)
@@ -2235,8 +2243,7 @@ static av_always_inline void encode_mb_internal(MpegEncContext *s,
             }
         }
         /* pre quantization */
-        if (s->current_picture.mc_mb_var[s->mb_stride * mb_y + mb_x] <
-                2 * s->qscale * s->qscale) {
+        if (s->mc_mb_var[s->mb_stride * mb_y + mb_x] < 2 * s->qscale * s->qscale) {
             // FIXME optimize
             if (s->mecc.sad[1](NULL, ptr_y, dest_y, wrap_y, 8) < 20 * s->qscale)
                 skip_dct[0] = 1;
@@ -2372,7 +2379,7 @@ static av_always_inline void encode_mb_internal(MpegEncContext *s,
     case AV_CODEC_ID_MSMPEG4V2:
     case AV_CODEC_ID_MSMPEG4V3:
     case AV_CODEC_ID_WMV1:
-        if (CONFIG_MSMPEG4_ENCODER)
+        if (CONFIG_MSMPEG4ENC)
             ff_msmpeg4_encode_mb(s, s->block, motion_x, motion_y);
         break;
     case AV_CODEC_ID_WMV2:
@@ -2534,7 +2541,7 @@ static inline void encode_mb_hq(MpegEncContext *s, MpegEncContext *backup, MpegE
     }
 }
 
-static int sse(MpegEncContext *s, uint8_t *src1, uint8_t *src2, int w, int h, int stride){
+static int sse(MpegEncContext *s, const uint8_t *src1, const uint8_t *src2, int w, int h, int stride){
     const uint32_t *sq = ff_square_tab + 256;
     int acc=0;
     int x,y;
@@ -2641,15 +2648,15 @@ static int mb_var_thread(AVCodecContext *c, void *arg){
         for(mb_x=0; mb_x < s->mb_width; mb_x++) {
             int xx = mb_x * 16;
             int yy = mb_y * 16;
-            uint8_t *pix = s->new_picture->data[0] + (yy * s->linesize) + xx;
+            const uint8_t *pix = s->new_picture->data[0] + (yy * s->linesize) + xx;
             int varc;
             int sum = s->mpvencdsp.pix_sum(pix, s->linesize);
 
             varc = (s->mpvencdsp.pix_norm1(pix, s->linesize) -
                     (((unsigned) sum * sum) >> 8) + 500 + 128) >> 8;
 
-            s->current_picture.mb_var [s->mb_stride * mb_y + mb_x] = varc;
-            s->current_picture.mb_mean[s->mb_stride * mb_y + mb_x] = (sum+128)>>8;
+            s->mb_var [s->mb_stride * mb_y + mb_x] = varc;
+            s->mb_mean[s->mb_stride * mb_y + mb_x] = (sum+128)>>8;
             s->me.mb_var_sum_temp    += varc;
         }
     }
@@ -2783,7 +2790,7 @@ static int encode_thread(AVCodecContext *c, void *arg){
         /* note: quant matrix value (8) is implied here */
         s->last_dc[i] = 128 << s->intra_dc_precision;
 
-        s->current_picture.encoding_error[i] = 0;
+        s->encoding_error[i] = 0;
     }
     if(s->codec_id==AV_CODEC_ID_AMV){
         s->last_dc[0] = 128*8/13;
@@ -2852,7 +2859,7 @@ static int encode_thread(AVCodecContext *c, void *arg){
 
             s->mb_x = mb_x;
             s->mb_y = mb_y;  // moved into loop, can get changed by H.261
-            ff_update_block_index(s);
+            ff_update_block_index(s, 8, 0, s->chroma_x_shift);
 
             if(CONFIG_H261_ENCODER && s->codec_id == AV_CODEC_ID_H261){
                 ff_h261_reorder_mb_index(s);
@@ -3361,13 +3368,13 @@ static int encode_thread(AVCodecContext *c, void *arg){
                 if(s->mb_x*16 + 16 > s->width ) w= s->width - s->mb_x*16;
                 if(s->mb_y*16 + 16 > s->height) h= s->height- s->mb_y*16;
 
-                s->current_picture.encoding_error[0] += sse(
+                s->encoding_error[0] += sse(
                     s, s->new_picture->data[0] + s->mb_x*16 + s->mb_y*s->linesize*16,
                     s->dest[0], w, h, s->linesize);
-                s->current_picture.encoding_error[1] += sse(
+                s->encoding_error[1] += sse(
                     s, s->new_picture->data[1] + s->mb_x*8  + s->mb_y*s->uvlinesize*chr_h,
                     s->dest[1], w>>1, h>>s->chroma_y_shift, s->uvlinesize);
-                s->current_picture.encoding_error[2] += sse(
+                s->encoding_error[2] += sse(
                     s, s->new_picture->data[2] + s->mb_x*8  + s->mb_y*s->uvlinesize*chr_h,
                     s->dest[2], w>>1, h>>s->chroma_y_shift, s->uvlinesize);
             }
@@ -3381,7 +3388,7 @@ static int encode_thread(AVCodecContext *c, void *arg){
     }
 
     //not beautiful here but we must write it before flushing so it has to be here
-    if (CONFIG_MSMPEG4_ENCODER && s->msmpeg4_version && s->msmpeg4_version<4 && s->pict_type == AV_PICTURE_TYPE_I)
+    if (CONFIG_MSMPEG4ENC && s->msmpeg4_version && s->msmpeg4_version<4 && s->pict_type == AV_PICTURE_TYPE_I)
         ff_msmpeg4_encode_ext_header(s);
 
     write_slice_end(s);
@@ -3407,9 +3414,9 @@ static void merge_context_after_encode(MpegEncContext *dst, MpegEncContext *src)
     MERGE(i_count);
     MERGE(skip_count);
     MERGE(misc_bits);
-    MERGE(current_picture.encoding_error[0]);
-    MERGE(current_picture.encoding_error[1]);
-    MERGE(current_picture.encoding_error[2]);
+    MERGE(encoding_error[0]);
+    MERGE(encoding_error[1]);
+    MERGE(encoding_error[2]);
 
     if (dst->noise_reduction){
         for(i=0; i<64; i++){
@@ -3561,8 +3568,8 @@ static int encode_picture(MpegEncContext *s, int picture_number)
     for(i=1; i<context_count; i++){
         merge_context_after_me(s, s->thread_context[i]);
     }
-    s->current_picture.mc_mb_var_sum= s->current_picture_ptr->mc_mb_var_sum= s->me.mc_mb_var_sum_temp;
-    s->current_picture.   mb_var_sum= s->current_picture_ptr->   mb_var_sum= s->me.   mb_var_sum_temp;
+    s->mc_mb_var_sum = s->me.mc_mb_var_sum_temp;
+    s->mb_var_sum    = s->me.   mb_var_sum_temp;
     emms_c();
 
     if (s->me.scene_change_score > s->scenechange_threshold &&
@@ -3573,7 +3580,7 @@ static int encode_picture(MpegEncContext *s, int picture_number)
         if(s->msmpeg4_version >= 3)
             s->no_rounding=1;
         ff_dlog(s, "Scene change detected, encoding as I Frame %"PRId64" %"PRId64"\n",
-                s->current_picture.mb_var_sum, s->current_picture.mc_mb_var_sum);
+                s->mb_var_sum, s->mc_mb_var_sum);
     }
 
     if(!s->umvplus){
@@ -3716,7 +3723,7 @@ static int encode_picture(MpegEncContext *s, int picture_number)
     case FMT_H263:
         if (CONFIG_WMV2_ENCODER && s->codec_id == AV_CODEC_ID_WMV2)
             ff_wmv2_encode_picture_header(s, picture_number);
-        else if (CONFIG_MSMPEG4_ENCODER && s->msmpeg4_version)
+        else if (CONFIG_MSMPEG4ENC && s->msmpeg4_version)
             ff_msmpeg4_encode_picture_header(s, picture_number);
         else if (CONFIG_MPEG4_ENCODER && s->h263_pred) {
             ret = ff_mpeg4_encode_picture_header(s, picture_number);
diff --git a/libavcodec/mpegvideo_motion.c b/libavcodec/mpegvideo_motion.c
index 9a450b7..fe3bfc4 100644
--- a/libavcodec/mpegvideo_motion.c
+++ b/libavcodec/mpegvideo_motion.c
@@ -36,9 +36,9 @@
 
 static void gmc1_motion(MpegEncContext *s,
                         uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                        uint8_t **ref_picture)
+                        uint8_t *const *ref_picture)
 {
-    uint8_t *ptr;
+    const uint8_t *ptr;
     int src_x, src_y, motion_x, motion_y;
     ptrdiff_t offset, linesize, uvlinesize;
     int emu = 0;
@@ -133,9 +133,9 @@ static void gmc1_motion(MpegEncContext *s,
 
 static void gmc_motion(MpegEncContext *s,
                        uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                       uint8_t **ref_picture)
+                       uint8_t *const *ref_picture)
 {
-    uint8_t *ptr;
+    const uint8_t *ptr;
     int linesize, uvlinesize;
     const int a = s->sprite_warping_accuracy;
     int ox, oy;
@@ -232,7 +232,7 @@ void mpeg_motion_internal(MpegEncContext *s,
                           int field_based,
                           int bottom_field,
                           int field_select,
-                          uint8_t **ref_picture,
+                          uint8_t *const *ref_picture,
                           op_pixels_func (*pix_op)[4],
                           int motion_x,
                           int motion_y,
@@ -241,7 +241,7 @@ void mpeg_motion_internal(MpegEncContext *s,
                           int is_16x8,
                           int mb_y)
 {
-    uint8_t *ptr_y, *ptr_cb, *ptr_cr;
+    const uint8_t *ptr_y, *ptr_cb, *ptr_cr;
     int dxy, uvdxy, mx, my, src_x, src_y,
         uvsrc_x, uvsrc_y, v_edge_pos, block_y_half;
     ptrdiff_t uvlinesize, linesize;
@@ -369,7 +369,7 @@ void mpeg_motion_internal(MpegEncContext *s,
 /* apply one mpeg motion vector to the three components */
 static void mpeg_motion(MpegEncContext *s,
                         uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                        int field_select, uint8_t **ref_picture,
+                        int field_select, uint8_t *const *ref_picture,
                         op_pixels_func (*pix_op)[4],
                         int motion_x, int motion_y, int h, int is_16x8, int mb_y)
 {
@@ -388,7 +388,7 @@ static void mpeg_motion(MpegEncContext *s,
 static void mpeg_motion_field(MpegEncContext *s, uint8_t *dest_y,
                               uint8_t *dest_cb, uint8_t *dest_cr,
                               int bottom_field, int field_select,
-                              uint8_t **ref_picture,
+                              uint8_t *const *ref_picture,
                               op_pixels_func (*pix_op)[4],
                               int motion_x, int motion_y, int h, int mb_y)
 {
@@ -489,12 +489,12 @@ static inline void qpel_motion(MpegEncContext *s,
                                uint8_t *dest_cb,
                                uint8_t *dest_cr,
                                int field_based, int bottom_field,
-                               int field_select, uint8_t **ref_picture,
+                               int field_select, uint8_t *const *ref_picture,
                                op_pixels_func (*pix_op)[4],
                                qpel_mc_func (*qpix_op)[16],
                                int motion_x, int motion_y, int h)
 {
-    uint8_t *ptr_y, *ptr_cb, *ptr_cr;
+    const uint8_t *ptr_y, *ptr_cb, *ptr_cr;
     int dxy, uvdxy, mx, my, src_x, src_y, uvsrc_x, uvsrc_y, v_edge_pos;
     ptrdiff_t linesize, uvlinesize;
 
@@ -593,11 +593,11 @@ static inline void qpel_motion(MpegEncContext *s,
  */
 static void chroma_4mv_motion(MpegEncContext *s,
                               uint8_t *dest_cb, uint8_t *dest_cr,
-                              uint8_t **ref_picture,
+                              uint8_t *const *ref_picture,
                               op_pixels_func *pix_op,
                               int mx, int my)
 {
-    uint8_t *ptr;
+    const uint8_t *ptr;
     int src_x, src_y, dxy, emu = 0;
     ptrdiff_t offset;
 
@@ -643,7 +643,7 @@ static void chroma_4mv_motion(MpegEncContext *s,
     pix_op[dxy](dest_cr, ptr, s->uvlinesize, 8);
 }
 
-static inline void prefetch_motion(MpegEncContext *s, uint8_t **pix, int dir)
+static inline void prefetch_motion(MpegEncContext *s, uint8_t *const *pix, int dir)
 {
     /* fetch pixels for estimated mv 4 macroblocks ahead
      * optimized for 64byte cache lines */
@@ -661,11 +661,11 @@ static inline void apply_obmc(MpegEncContext *s,
                               uint8_t *dest_y,
                               uint8_t *dest_cb,
                               uint8_t *dest_cr,
-                              uint8_t **ref_picture,
+                              uint8_t *const *ref_picture,
                               op_pixels_func (*pix_op)[4])
 {
     LOCAL_ALIGNED_8(int16_t, mv_cache, [4], [4][2]);
-    Picture *cur_frame   = &s->current_picture;
+    const Picture *cur_frame = &s->current_picture;
     int mb_x = s->mb_x;
     int mb_y = s->mb_y;
     const int xy         = mb_x + mb_y * s->mb_stride;
@@ -749,7 +749,7 @@ static inline void apply_8x8(MpegEncContext *s,
                              uint8_t *dest_cb,
                              uint8_t *dest_cr,
                              int dir,
-                             uint8_t **ref_picture,
+                             uint8_t *const *ref_picture,
                              qpel_mc_func (*qpix_op)[16],
                              op_pixels_func (*pix_op)[4])
 {
@@ -757,7 +757,8 @@ static inline void apply_8x8(MpegEncContext *s,
     int i;
     int mb_x = s->mb_x;
     int mb_y = s->mb_y;
-    uint8_t *ptr, *dest;
+    uint8_t *dest;
+    const uint8_t *ptr;
 
     mx = 0;
     my = 0;
@@ -833,7 +834,7 @@ static av_always_inline void mpv_motion_internal(MpegEncContext *s,
                                                  uint8_t *dest_cb,
                                                  uint8_t *dest_cr,
                                                  int dir,
-                                                 uint8_t **ref_picture,
+                                                 uint8_t *const *ref_picture,
                                                  op_pixels_func (*pix_op)[4],
                                                  qpel_mc_func (*qpix_op)[16],
                                                  int is_mpeg12)
@@ -912,7 +913,7 @@ static av_always_inline void mpv_motion_internal(MpegEncContext *s,
     case MV_TYPE_16X8:
         if (CONFIG_SMALL || is_mpeg12) {
             for (i = 0; i < 2; i++) {
-                uint8_t **ref2picture;
+                uint8_t *const *ref2picture;
 
                 if ((s->picture_structure == s->field_select[dir][i] + 1 ||
                      s->pict_type == AV_PICTURE_TYPE_B || s->first_field) &&
@@ -974,7 +975,7 @@ static av_always_inline void mpv_motion_internal(MpegEncContext *s,
 void ff_mpv_motion(MpegEncContext *s,
                    uint8_t *dest_y, uint8_t *dest_cb,
                    uint8_t *dest_cr, int dir,
-                   uint8_t **ref_picture,
+                   uint8_t *const *ref_picture,
                    op_pixels_func (*pix_op)[4],
                    qpel_mc_func (*qpix_op)[16])
 {
diff --git a/libavcodec/mpegvideodec.h b/libavcodec/mpegvideodec.h
index fabc1b2..250034b 100644
--- a/libavcodec/mpegvideodec.h
+++ b/libavcodec/mpegvideodec.h
@@ -53,12 +53,12 @@ int ff_mpv_frame_start(MpegEncContext *s, AVCodecContext *avctx);
 void ff_mpv_report_decode_progress(MpegEncContext *s);
 void ff_mpv_frame_end(MpegEncContext *s);
 
-int ff_mpv_export_qp_table(MpegEncContext *s, AVFrame *f, Picture *p, int qp_type);
+int ff_mpv_export_qp_table(const MpegEncContext *s, AVFrame *f, const Picture *p, int qp_type);
 int ff_mpeg_update_thread_context(AVCodecContext *dst, const AVCodecContext *src);
 void ff_mpeg_draw_horiz_band(MpegEncContext *s, int y, int h);
 void ff_mpeg_flush(AVCodecContext *avctx);
 
-void ff_print_debug_info(MpegEncContext *s, Picture *p, AVFrame *pict);
+void ff_print_debug_info(const MpegEncContext *s, const Picture *p, AVFrame *pict);
 
 static inline int mpeg_get_qscale(MpegEncContext *s)
 {
diff --git a/libavcodec/mpegvideodsp.c b/libavcodec/mpegvideodsp.c
index a8cf7fb..05893d0 100644
--- a/libavcodec/mpegvideodsp.c
+++ b/libavcodec/mpegvideodsp.c
@@ -21,7 +21,7 @@
 #include "libavutil/common.h"
 #include "mpegvideodsp.h"
 
-static void gmc1_c(uint8_t *dst, uint8_t *src, int stride, int h,
+static void gmc1_c(uint8_t *dst, const uint8_t *src, int stride, int h,
                    int x16, int y16, int rounder)
 {
     const int A = (16 - x16) * (16 - y16);
@@ -44,7 +44,7 @@ static void gmc1_c(uint8_t *dst, uint8_t *src, int stride, int h,
     }
 }
 
-void ff_gmc_c(uint8_t *dst, uint8_t *src, int stride, int h, int ox, int oy,
+void ff_gmc_c(uint8_t *dst, const uint8_t *src, int stride, int h, int ox, int oy,
               int dxx, int dxy, int dyx, int dyy, int shift, int r,
               int width, int height)
 {
diff --git a/libavcodec/mpegvideodsp.h b/libavcodec/mpegvideodsp.h
index 293e254..69e6053 100644
--- a/libavcodec/mpegvideodsp.h
+++ b/libavcodec/mpegvideodsp.h
@@ -21,7 +21,7 @@
 
 #include <stdint.h>
 
-void ff_gmc_c(uint8_t *dst, uint8_t *src, int stride, int h, int ox, int oy,
+void ff_gmc_c(uint8_t *dst, const uint8_t *src, int stride, int h, int ox, int oy,
               int dxx, int dxy, int dyx, int dyy, int shift, int r,
               int width, int height);
 
@@ -29,12 +29,12 @@ typedef struct MpegVideoDSPContext {
     /**
      * translational global motion compensation.
      */
-    void (*gmc1)(uint8_t *dst /* align 8 */, uint8_t *src /* align 1 */,
+    void (*gmc1)(uint8_t *dst /* align 8 */, const uint8_t *src /* align 1 */,
                  int srcStride, int h, int x16, int y16, int rounder);
     /**
      * global motion compensation.
      */
-    void (*gmc)(uint8_t *dst /* align 8 */, uint8_t *src /* align 1 */,
+    void (*gmc)(uint8_t *dst /* align 8 */, const uint8_t *src /* align 1 */,
                 int stride, int h, int ox, int oy,
                 int dxx, int dxy, int dyx, int dyy,
                 int shift, int r, int width, int height);
diff --git a/libavcodec/mpegvideoencdsp.c b/libavcodec/mpegvideoencdsp.c
index adf19e6..997d048 100644
--- a/libavcodec/mpegvideoencdsp.c
+++ b/libavcodec/mpegvideoencdsp.c
@@ -28,8 +28,8 @@
 #include "me_cmp.h"
 #include "mpegvideoencdsp.h"
 
-static int try_8x8basis_c(int16_t rem[64], int16_t weight[64],
-                          int16_t basis[64], int scale)
+static int try_8x8basis_c(const int16_t rem[64], const int16_t weight[64],
+                          const int16_t basis[64], int scale)
 {
     int i;
     unsigned int sum = 0;
@@ -47,7 +47,7 @@ static int try_8x8basis_c(int16_t rem[64], int16_t weight[64],
     return sum >> 2;
 }
 
-static void add_8x8basis_c(int16_t rem[64], int16_t basis[64], int scale)
+static void add_8x8basis_c(int16_t rem[64], const int16_t basis[64], int scale)
 {
     int i;
 
@@ -57,7 +57,7 @@ static void add_8x8basis_c(int16_t rem[64], int16_t basis[64], int scale)
                   (BASIS_SHIFT - RECON_SHIFT);
 }
 
-static int pix_sum_c(uint8_t *pix, int line_size)
+static int pix_sum_c(const uint8_t *pix, int line_size)
 {
     int s = 0, i, j;
 
@@ -78,7 +78,7 @@ static int pix_sum_c(uint8_t *pix, int line_size)
     return s;
 }
 
-static int pix_norm1_c(uint8_t *pix, int line_size)
+static int pix_norm1_c(const uint8_t *pix, int line_size)
 {
     int s = 0, i, j;
     const uint32_t *sq = ff_square_tab + 256;
diff --git a/libavcodec/mpegvideoencdsp.h b/libavcodec/mpegvideoencdsp.h
index 33f0282..9508467 100644
--- a/libavcodec/mpegvideoencdsp.h
+++ b/libavcodec/mpegvideoencdsp.h
@@ -30,12 +30,12 @@
 #define EDGE_BOTTOM 2
 
 typedef struct MpegvideoEncDSPContext {
-    int (*try_8x8basis)(int16_t rem[64], int16_t weight[64],
-                        int16_t basis[64], int scale);
-    void (*add_8x8basis)(int16_t rem[64], int16_t basis[64], int scale);
+    int (*try_8x8basis)(const int16_t rem[64], const int16_t weight[64],
+                        const int16_t basis[64], int scale);
+    void (*add_8x8basis)(int16_t rem[64], const int16_t basis[64], int scale);
 
-    int (*pix_sum)(uint8_t *pix, int line_size);
-    int (*pix_norm1)(uint8_t *pix, int line_size);
+    int (*pix_sum)(const uint8_t *pix, int line_size);
+    int (*pix_norm1)(const uint8_t *pix, int line_size);
 
     void (*shrink[4])(uint8_t *dst, int dst_wrap, const uint8_t *src,
                       int src_wrap, int width, int height);
diff --git a/libavcodec/mpl2dec.c b/libavcodec/mpl2dec.c
index 56f008b..3645a3a 100644
--- a/libavcodec/mpl2dec.c
+++ b/libavcodec/mpl2dec.c
@@ -90,5 +90,4 @@ const FFCodec ff_mpl2_decoder = {
     .init           = ff_ass_subtitle_header_default,
     .flush          = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mscc.c b/libavcodec/mscc.c
index 3666b88..f7d33e1 100644
--- a/libavcodec/mscc.c
+++ b/libavcodec/mscc.c
@@ -261,7 +261,7 @@ const FFCodec ff_mscc_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_srgc_decoder = {
@@ -274,5 +274,5 @@ const FFCodec ff_srgc_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/msmpeg4dec.c b/libavcodec/msmpeg4dec.c
index abebeff..a2b1ab1 100644
--- a/libavcodec/msmpeg4dec.c
+++ b/libavcodec/msmpeg4dec.c
@@ -874,8 +874,7 @@ const FFCodec ff_msmpeg4v1_decoder = {
     .close          = ff_h263_decode_end,
     FF_CODEC_DECODE_CB(ff_h263_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.max_lowres   = 3,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
@@ -893,8 +892,7 @@ const FFCodec ff_msmpeg4v2_decoder = {
     .close          = ff_h263_decode_end,
     FF_CODEC_DECODE_CB(ff_h263_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.max_lowres   = 3,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
@@ -912,8 +910,7 @@ const FFCodec ff_msmpeg4v3_decoder = {
     .close          = ff_h263_decode_end,
     FF_CODEC_DECODE_CB(ff_h263_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.max_lowres   = 3,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
@@ -931,8 +928,7 @@ const FFCodec ff_wmv1_decoder = {
     .close          = ff_h263_decode_end,
     FF_CODEC_DECODE_CB(ff_h263_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM,
     .p.max_lowres   = 3,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
diff --git a/libavcodec/msmpeg4dec.h b/libavcodec/msmpeg4dec.h
index af2591c..19b5c12 100644
--- a/libavcodec/msmpeg4dec.h
+++ b/libavcodec/msmpeg4dec.h
@@ -22,7 +22,6 @@
 #ifndef AVCODEC_MSMPEG4DEC_H
 #define AVCODEC_MSMPEG4DEC_H
 
-#include "config.h"
 #include "avcodec.h"
 #include "mpegvideo.h"
 
@@ -40,11 +39,4 @@ void ff_msmpeg4_decode_motion(MpegEncContext * s, int *mx_ptr, int *my_ptr);
 int ff_msmpeg4_decode_block(MpegEncContext * s, int16_t * block,
                             int n, int coded, const uint8_t *scan_table);
 
-#define CONFIG_MSMPEG4_DECODER (CONFIG_MSMPEG4V1_DECODER || \
-                                CONFIG_MSMPEG4V2_DECODER || \
-                                CONFIG_MSMPEG4V3_DECODER || \
-                                CONFIG_WMV1_DECODER      || \
-                                CONFIG_WMV2_DECODER      || \
-                                CONFIG_VC1_DECODER)
-
 #endif
diff --git a/libavcodec/msmpeg4enc.c b/libavcodec/msmpeg4enc.c
index e597dbb..3bd37d8 100644
--- a/libavcodec/msmpeg4enc.c
+++ b/libavcodec/msmpeg4enc.c
@@ -683,7 +683,7 @@ const FFCodec ff_msmpeg4v2_encoder = {
     .p.id           = AV_CODEC_ID_MSMPEG4V2,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
     .p.priv_class   = &ff_mpv_enc_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(MSMPEG4EncContext),
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
@@ -697,7 +697,7 @@ const FFCodec ff_msmpeg4v3_encoder = {
     .p.id           = AV_CODEC_ID_MSMPEG4V3,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
     .p.priv_class   = &ff_mpv_enc_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(MSMPEG4EncContext),
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
@@ -711,7 +711,7 @@ const FFCodec ff_wmv1_encoder = {
     .p.id           = AV_CODEC_ID_WMV1,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
     .p.priv_class   = &ff_mpv_enc_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(MSMPEG4EncContext),
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
diff --git a/libavcodec/msmpeg4enc.h b/libavcodec/msmpeg4enc.h
index 9804491..602e601 100644
--- a/libavcodec/msmpeg4enc.h
+++ b/libavcodec/msmpeg4enc.h
@@ -22,7 +22,6 @@
 #ifndef AVCODEC_MSMPEG4ENC_H
 #define AVCODEC_MSMPEG4ENC_H
 
-#include "config.h"
 #include "mpegvideo.h"
 #include "put_bits.h"
 #include "rl.h"
@@ -45,9 +44,4 @@ void ff_msmpeg4_encode_motion(MpegEncContext * s, int mx, int my);
 
 void ff_msmpeg4_code012(PutBitContext *pb, int n);
 
-#define CONFIG_MSMPEG4_ENCODER (CONFIG_MSMPEG4V2_ENCODER || \
-                                CONFIG_MSMPEG4V3_ENCODER || \
-                                CONFIG_WMV1_ENCODER      || \
-                                CONFIG_WMV2_ENCODER)
-
 #endif
diff --git a/libavcodec/msrle.c b/libavcodec/msrle.c
index f9d7141..72134bc 100644
--- a/libavcodec/msrle.c
+++ b/libavcodec/msrle.c
@@ -170,5 +170,4 @@ const FFCodec ff_msrle_decoder = {
     FF_CODEC_DECODE_CB(msrle_decode_frame),
     .flush          = msrle_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mss1.c b/libavcodec/mss1.c
index bc00a11..d130a8f 100644
--- a/libavcodec/mss1.c
+++ b/libavcodec/mss1.c
@@ -229,5 +229,4 @@ const FFCodec ff_mss1_decoder = {
     .close          = mss1_decode_end,
     FF_CODEC_DECODE_CB(mss1_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mss2.c b/libavcodec/mss2.c
index 228f66a..6019368 100644
--- a/libavcodec/mss2.c
+++ b/libavcodec/mss2.c
@@ -854,5 +854,4 @@ const FFCodec ff_mss2_decoder = {
     .close          = mss2_decode_end,
     FF_CODEC_DECODE_CB(mss2_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mss3.c b/libavcodec/mss3.c
index 55d2d10..2e331ac 100644
--- a/libavcodec/mss3.c
+++ b/libavcodec/mss3.c
@@ -870,5 +870,5 @@ const FFCodec ff_msa1_decoder = {
     .close          = mss3_decode_end,
     FF_CODEC_DECODE_CB(mss3_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mss4.c b/libavcodec/mss4.c
index 43eb102..53b7910 100644
--- a/libavcodec/mss4.c
+++ b/libavcodec/mss4.c
@@ -619,5 +619,5 @@ const FFCodec ff_mts2_decoder = {
     .close          = mss4_decode_end,
     FF_CODEC_DECODE_CB(mss4_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/msvideo1.c b/libavcodec/msvideo1.c
index a39f684..8db3167 100644
--- a/libavcodec/msvideo1.c
+++ b/libavcodec/msvideo1.c
@@ -351,5 +351,4 @@ const FFCodec ff_msvideo1_decoder = {
     .close          = msvideo1_decode_end,
     FF_CODEC_DECODE_CB(msvideo1_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/msvideo1enc.c b/libavcodec/msvideo1enc.c
index 53f4a4b..4e1e94e 100644
--- a/libavcodec/msvideo1enc.c
+++ b/libavcodec/msvideo1enc.c
@@ -69,7 +69,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
 {
     Msvideo1EncContext * const c = avctx->priv_data;
     const AVFrame *p = pict;
-    uint16_t *src;
+    const uint16_t *src;
     uint8_t *prevptr;
     uint8_t *dst, *buf;
     int keyframe = 0;
@@ -85,7 +85,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     if(!c->prev)
         c->prev = av_malloc(avctx->width * 3 * (avctx->height + 3));
     prevptr = c->prev + avctx->width * 3 * (FFALIGN(avctx->height, 4) - 1);
-    src = (uint16_t*)(p->data[0] + p->linesize[0]*(FFALIGN(avctx->height, 4) - 1));
+    src = (const uint16_t*)(p->data[0] + p->linesize[0]*(FFALIGN(avctx->height, 4) - 1));
     if(c->keyint >= avctx->keyint_min)
         keyframe = 1;
 
@@ -312,5 +312,4 @@ const FFCodec ff_msvideo1_encoder = {
     FF_CODEC_ENCODE_CB(encode_frame),
     .close          = encode_end,
     .p.pix_fmts = (const enum AVPixelFormat[]){AV_PIX_FMT_RGB555, AV_PIX_FMT_NONE},
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/mv30.c b/libavcodec/mv30.c
index a32fab2..88c360f 100644
--- a/libavcodec/mv30.c
+++ b/libavcodec/mv30.c
@@ -713,6 +713,5 @@ const FFCodec ff_mv30_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .flush            = decode_flush,
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mvcdec.c b/libavcodec/mvcdec.c
index 4ee8d10..3fa665a 100644
--- a/libavcodec/mvcdec.c
+++ b/libavcodec/mvcdec.c
@@ -264,7 +264,6 @@ const FFCodec ff_mvc1_decoder = {
     .init           = mvc_decode_init,
     FF_CODEC_DECODE_CB(mvc_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -278,6 +277,5 @@ const FFCodec ff_mvc2_decoder = {
     .init           = mvc_decode_init,
     FF_CODEC_DECODE_CB(mvc_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/mvha.c b/libavcodec/mvha.c
index 8a65c42..097a52e 100644
--- a/libavcodec/mvha.c
+++ b/libavcodec/mvha.c
@@ -308,6 +308,5 @@ const FFCodec ff_mvha_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mwsc.c b/libavcodec/mwsc.c
index 499b220..d804433 100644
--- a/libavcodec/mwsc.c
+++ b/libavcodec/mwsc.c
@@ -178,6 +178,5 @@ const FFCodec ff_mwsc_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/mxpegdec.c b/libavcodec/mxpegdec.c
index e5cdd44..a9f2a2b 100644
--- a/libavcodec/mxpegdec.c
+++ b/libavcodec/mxpegdec.c
@@ -353,5 +353,5 @@ const FFCodec ff_mxpeg_decoder = {
     FF_CODEC_DECODE_CB(mxpeg_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.max_lowres   = 3,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/nellymoserdec.c b/libavcodec/nellymoserdec.c
index 63b60f2..5c8b23e 100644
--- a/libavcodec/nellymoserdec.c
+++ b/libavcodec/nellymoserdec.c
@@ -198,5 +198,4 @@ const FFCodec ff_nellymoser_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_PARAM_CHANGE | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLT,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/nellymoserenc.c b/libavcodec/nellymoserenc.c
index c11dfe5..5a50ee6 100644
--- a/libavcodec/nellymoserenc.c
+++ b/libavcodec/nellymoserenc.c
@@ -427,5 +427,5 @@ const FFCodec ff_nellymoser_encoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLT,
                                                      AV_SAMPLE_FMT_NONE },
     .p.ch_layouts   = (const AVChannelLayout[]){ AV_CHANNEL_LAYOUT_MONO, { 0 } },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/notchlc.c b/libavcodec/notchlc.c
index f6d62b8..7f2bca3 100644
--- a/libavcodec/notchlc.c
+++ b/libavcodec/notchlc.c
@@ -545,5 +545,4 @@ const FFCodec ff_notchlc_decoder = {
     .close            = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/nuv.c b/libavcodec/nuv.c
index 71420a6..3f03775 100644
--- a/libavcodec/nuv.c
+++ b/libavcodec/nuv.c
@@ -372,5 +372,5 @@ const FFCodec ff_nuv_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/nvdec.c b/libavcodec/nvdec.c
index edff46d..fbaedf0 100644
--- a/libavcodec/nvdec.c
+++ b/libavcodec/nvdec.c
@@ -524,16 +524,16 @@ static int nvdec_retrieve_data(void *logctx, AVFrame *frame)
         goto copy_fail;
     }
 
-    av_buffer_unref(&frame->hw_frames_ctx);
-    frame->hw_frames_ctx = av_buffer_ref(decoder->real_hw_frames_ref);
-    if (!frame->hw_frames_ctx) {
-        ret = AVERROR(ENOMEM);
+    ret = av_buffer_replace(&frame->hw_frames_ctx, decoder->real_hw_frames_ref);
+    if (ret < 0)
         goto copy_fail;
-    }
 
     unmap_data->idx = cf->idx;
-    unmap_data->idx_ref = av_buffer_ref(cf->idx_ref);
-    unmap_data->decoder_ref = av_buffer_ref(cf->decoder_ref);
+    if (!(unmap_data->idx_ref     = av_buffer_ref(cf->idx_ref)) ||
+        !(unmap_data->decoder_ref = av_buffer_ref(cf->decoder_ref))) {
+        ret = AVERROR(ENOMEM);
+        goto copy_fail;
+    }
 
     av_pix_fmt_get_chroma_sub_sample(hwctx->sw_format, &shift_h, &shift_v);
     for (i = 0; frame->linesize[i]; i++) {
diff --git a/libavcodec/nvdec_hevc.c b/libavcodec/nvdec_hevc.c
index 590278b..cd549d2 100644
--- a/libavcodec/nvdec_hevc.c
+++ b/libavcodec/nvdec_hevc.c
@@ -204,8 +204,8 @@ static int nvdec_hevc_start_frame(AVCodecContext *avctx,
         ppc->row_height_minus1[i] = pps->row_height[i] - 1;
 
 #if NVDECAPI_CHECK_VERSION(9, 0)
-    if (pps->chroma_qp_offset_list_len_minus1 > FF_ARRAY_ELEMS(ppc->cb_qp_offset_list) ||
-        pps->chroma_qp_offset_list_len_minus1 > FF_ARRAY_ELEMS(ppc->cr_qp_offset_list)) {
+    if (pps->chroma_qp_offset_list_len_minus1 >= FF_ARRAY_ELEMS(ppc->cb_qp_offset_list) ||
+        pps->chroma_qp_offset_list_len_minus1 >= FF_ARRAY_ELEMS(ppc->cr_qp_offset_list)) {
         av_log(avctx, AV_LOG_ERROR, "Too many chroma_qp_offsets\n");
         return AVERROR(ENOSYS);
     }
diff --git a/libavcodec/nvdec_vp8.c b/libavcodec/nvdec_vp8.c
index 9c4608d..f174ca4 100644
--- a/libavcodec/nvdec_vp8.c
+++ b/libavcodec/nvdec_vp8.c
@@ -39,7 +39,7 @@ static int nvdec_vp8_start_frame(AVCodecContext *avctx, const uint8_t *buffer, u
     CUVIDPICPARAMS     *pp = &ctx->pic_params;
     FrameDecodeData *fdd;
     NVDECFrame *cf;
-    AVFrame *cur_frame = h->framep[VP56_FRAME_CURRENT]->tf.f;
+    AVFrame *cur_frame = h->framep[VP8_FRAME_CURRENT]->tf.f;
 
     int ret;
 
@@ -61,9 +61,9 @@ static int nvdec_vp8_start_frame(AVCodecContext *avctx, const uint8_t *buffer, u
 
             .first_partition_size        = h->header_partition_size,
 
-            .LastRefIdx                  = safe_get_ref_idx(h->framep[VP56_FRAME_PREVIOUS]),
-            .GoldenRefIdx                = safe_get_ref_idx(h->framep[VP56_FRAME_GOLDEN]),
-            .AltRefIdx                   = safe_get_ref_idx(h->framep[VP56_FRAME_GOLDEN2]),
+            .LastRefIdx                  = safe_get_ref_idx(h->framep[VP8_FRAME_PREVIOUS]),
+            .GoldenRefIdx                = safe_get_ref_idx(h->framep[VP8_FRAME_GOLDEN]),
+            .AltRefIdx                   = safe_get_ref_idx(h->framep[VP8_FRAME_ALTREF]),
             /*
              * Explicit braces for anonymous inners and unnamed fields
              * to work around limitations in ancient versions of gcc.
diff --git a/libavcodec/nvenc.c b/libavcodec/nvenc.c
index e193787..11bd21f 100644
--- a/libavcodec/nvenc.c
+++ b/libavcodec/nvenc.c
@@ -1096,11 +1096,20 @@ static av_cold int nvenc_setup_h264_config(AVCodecContext *avctx)
     NV_ENC_CONFIG_H264 *h264               = &cc->encodeCodecConfig.h264Config;
     NV_ENC_CONFIG_H264_VUI_PARAMETERS *vui = &h264->h264VUIParameters;
 
-    vui->colourMatrix = IS_GBRP(ctx->data_pix_fmt) ? AVCOL_SPC_RGB : avctx->colorspace;
-    vui->colourPrimaries = avctx->color_primaries;
-    vui->transferCharacteristics = avctx->color_trc;
-    vui->videoFullRangeFlag = (avctx->color_range == AVCOL_RANGE_JPEG
-        || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ420P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ422P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ444P);
+    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(ctx->data_pix_fmt);
+
+    if ((pixdesc->flags & AV_PIX_FMT_FLAG_RGB) && !IS_GBRP(ctx->data_pix_fmt)) {
+        vui->colourMatrix = AVCOL_SPC_BT470BG;
+        vui->colourPrimaries = avctx->color_primaries;
+        vui->transferCharacteristics = avctx->color_trc;
+        vui->videoFullRangeFlag = 0;
+    } else {
+        vui->colourMatrix = IS_GBRP(ctx->data_pix_fmt) ? AVCOL_SPC_RGB : avctx->colorspace;
+        vui->colourPrimaries = avctx->color_primaries;
+        vui->transferCharacteristics = avctx->color_trc;
+        vui->videoFullRangeFlag = (avctx->color_range == AVCOL_RANGE_JPEG
+            || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ420P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ422P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ444P);
+    }
 
     vui->colourDescriptionPresentFlag =
         (vui->colourMatrix != 2 || vui->colourPrimaries != 2 || vui->transferCharacteristics != 2);
@@ -1208,11 +1217,20 @@ static av_cold int nvenc_setup_hevc_config(AVCodecContext *avctx)
     NV_ENC_CONFIG_HEVC *hevc               = &cc->encodeCodecConfig.hevcConfig;
     NV_ENC_CONFIG_HEVC_VUI_PARAMETERS *vui = &hevc->hevcVUIParameters;
 
-    vui->colourMatrix = IS_GBRP(ctx->data_pix_fmt) ? AVCOL_SPC_RGB : avctx->colorspace;
-    vui->colourPrimaries = avctx->color_primaries;
-    vui->transferCharacteristics = avctx->color_trc;
-    vui->videoFullRangeFlag = (avctx->color_range == AVCOL_RANGE_JPEG
-        || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ420P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ422P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ444P);
+    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(ctx->data_pix_fmt);
+
+    if ((pixdesc->flags & AV_PIX_FMT_FLAG_RGB) && !IS_GBRP(ctx->data_pix_fmt)) {
+        vui->colourMatrix = AVCOL_SPC_BT470BG;
+        vui->colourPrimaries = avctx->color_primaries;
+        vui->transferCharacteristics = avctx->color_trc;
+        vui->videoFullRangeFlag = 0;
+    } else {
+        vui->colourMatrix = IS_GBRP(ctx->data_pix_fmt) ? AVCOL_SPC_RGB : avctx->colorspace;
+        vui->colourPrimaries = avctx->color_primaries;
+        vui->transferCharacteristics = avctx->color_trc;
+        vui->videoFullRangeFlag = (avctx->color_range == AVCOL_RANGE_JPEG
+            || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ420P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ422P || ctx->data_pix_fmt == AV_PIX_FMT_YUVJ444P);
+    }
 
     vui->colourDescriptionPresentFlag =
         (vui->colourMatrix != 2 || vui->colourPrimaries != 2 || vui->transferCharacteristics != 2);
diff --git a/libavcodec/nvenc_h264.c b/libavcodec/nvenc_h264.c
index 1860c60..7fa6c23 100644
--- a/libavcodec/nvenc_h264.c
+++ b/libavcodec/nvenc_h264.c
@@ -233,7 +233,8 @@ const FFCodec ff_h264_nvenc_encoder = {
     .defaults       = defaults,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_ENCODER_FLUSH | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = ff_nvenc_pix_fmts,
     .p.wrapper_name = "nvenc",
     .hw_configs     = ff_nvenc_hw_configs,
diff --git a/libavcodec/nvenc_hevc.c b/libavcodec/nvenc_hevc.c
index 2c64cce..290bb1e 100644
--- a/libavcodec/nvenc_hevc.c
+++ b/libavcodec/nvenc_hevc.c
@@ -215,7 +215,8 @@ const FFCodec ff_hevc_nvenc_encoder = {
     .p.pix_fmts     = ff_nvenc_pix_fmts,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_ENCODER_FLUSH | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name = "nvenc",
     .hw_configs     = ff_nvenc_hw_configs,
 };
diff --git a/libavcodec/omx.c b/libavcodec/omx.c
index d481c06..97a2cc0 100644
--- a/libavcodec/omx.c
+++ b/libavcodec/omx.c
@@ -947,7 +947,7 @@ const FFCodec ff_mpeg4_omx_encoder = {
     .close            = omx_encode_end,
     .p.pix_fmts       = omx_encoder_pix_fmts,
     .p.capabilities   = AV_CODEC_CAP_DELAY,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class     = &omx_mpeg4enc_class,
 };
 
@@ -968,6 +968,6 @@ const FFCodec ff_h264_omx_encoder = {
     .close            = omx_encode_end,
     .p.pix_fmts       = omx_encoder_pix_fmts,
     .p.capabilities   = AV_CODEC_CAP_DELAY,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class     = &omx_h264enc_class,
 };
diff --git a/libavcodec/on2avc.c b/libavcodec/on2avc.c
index 5477f6f..1fccdc8 100644
--- a/libavcodec/on2avc.c
+++ b/libavcodec/on2avc.c
@@ -1014,7 +1014,7 @@ const FFCodec ff_on2avc_decoder = {
     FF_CODEC_DECODE_CB(on2avc_decode_frame),
     .close          = on2avc_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
 };
diff --git a/libavcodec/options_table.h b/libavcodec/options_table.h
index e72b4d1..cd02f50 100644
--- a/libavcodec/options_table.h
+++ b/libavcodec/options_table.h
@@ -57,6 +57,7 @@ static const AVOption avcodec_options[] = {
 {"qpel", "use 1/4-pel motion compensation", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QPEL }, INT_MIN, INT_MAX, V|E, "flags"},
 {"loop", "use loop filter", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_LOOP_FILTER }, INT_MIN, INT_MAX, V|E, "flags"},
 {"qscale", "use fixed qscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_QSCALE }, INT_MIN, INT_MAX, 0, "flags"},
+{"recon_frame", "export reconstructed frames", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_RECON_FRAME}, .unit = "flags"},
 {"pass1", "use internal 2-pass ratecontrol in first  pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS1 }, INT_MIN, INT_MAX, 0, "flags"},
 {"pass2", "use internal 2-pass ratecontrol in second pass mode", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_PASS2 }, INT_MIN, INT_MAX, 0, "flags"},
 {"gray", "only decode/encode grayscale", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG_GRAY }, INT_MIN, INT_MAX, V|E|D, "flags"},
@@ -83,6 +84,7 @@ static const AVOption avcodec_options[] = {
 {"export_mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_EXPORT_MVS}, INT_MIN, INT_MAX, V|D, "flags2"},
 {"skip_manual", "do not skip samples and export skip information as frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_SKIP_MANUAL}, INT_MIN, INT_MAX, A|D, "flags2"},
 {"ass_ro_flush_noop", "do not reset ASS ReadOrder field on flush", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_RO_FLUSH_NOOP}, INT_MIN, INT_MAX, S|D, "flags2"},
+{"icc_profiles", "generate/parse embedded ICC profiles from/to colorimetry tags", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_FLAG2_ICC_PROFILES}, INT_MIN, INT_MAX, S|D, "flags2"},
 {"export_side_data", "Export metadata as side data", OFFSET(export_side_data), AV_OPT_TYPE_FLAGS, {.i64 = DEFAULT}, 0, UINT_MAX, A|V|S|D|E, "export_side_data"},
 {"mvs", "export motion vectors through frame side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_MVS}, INT_MIN, INT_MAX, V|D, "export_side_data"},
 {"prft", "export Producer Reference Time through packet side data", 0, AV_OPT_TYPE_CONST, {.i64 = AV_CODEC_EXPORT_DATA_PRFT}, INT_MIN, INT_MAX, A|V|S|E, "export_side_data"},
diff --git a/libavcodec/opusdec.c b/libavcodec/opusdec.c
index 8ca9936..17a4fc9 100644
--- a/libavcodec/opusdec.c
+++ b/libavcodec/opusdec.c
@@ -716,5 +716,5 @@ const FFCodec ff_opus_decoder = {
     FF_CODEC_DECODE_CB(opus_decode_packet),
     .flush           = opus_decode_flush,
     .p.capabilities  = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/opusenc.c b/libavcodec/opusenc.c
index b4b7c47..703c802 100644
--- a/libavcodec/opusenc.c
+++ b/libavcodec/opusenc.c
@@ -736,7 +736,7 @@ const FFCodec ff_opus_encoder = {
     .init           = opus_encode_init,
     FF_CODEC_ENCODE_CB(opus_encode_frame),
     .close          = opus_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.capabilities = AV_CODEC_CAP_EXPERIMENTAL | AV_CODEC_CAP_SMALL_LAST_FRAME | AV_CODEC_CAP_DELAY,
     .p.supported_samplerates = (const int []){ 48000, 0 },
 #if FF_API_OLD_CHANNEL_LAYOUT
diff --git a/libavcodec/pafaudio.c b/libavcodec/pafaudio.c
index 9f694d2..fc642db 100644
--- a/libavcodec/pafaudio.c
+++ b/libavcodec/pafaudio.c
@@ -81,5 +81,4 @@ const FFCodec ff_paf_audio_decoder = {
     .init         = paf_audio_init,
     FF_CODEC_DECODE_CB(paf_audio_decode),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/pafvideo.c b/libavcodec/pafvideo.c
index 60cdd34..d9fbd19 100644
--- a/libavcodec/pafvideo.c
+++ b/libavcodec/pafvideo.c
@@ -418,5 +418,5 @@ const FFCodec ff_paf_video_decoder = {
     .close          = paf_video_close,
     FF_CODEC_DECODE_CB(paf_video_decode),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/pamenc.c b/libavcodec/pamenc.c
index 8a94f8a..6e934ba 100644
--- a/libavcodec/pamenc.c
+++ b/libavcodec/pamenc.c
@@ -28,7 +28,8 @@ static int pam_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                             const AVFrame *p, int *got_packet)
 {
     int i, h, w, n, linesize, depth, maxval, ret, header_size;
-    uint8_t *bytestream, *ptr;
+    uint8_t *bytestream;
+    const uint8_t *ptr;
     const char *tuple_type;
     char header[100];
 
@@ -141,5 +142,4 @@ const FFCodec ff_pam_encoder = {
         AV_PIX_FMT_GRAY16BE, AV_PIX_FMT_YA16BE,
         AV_PIX_FMT_MONOBLACK, AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/parsers.c b/libavcodec/parsers.c
index b593888..a8d52af 100644
--- a/libavcodec/parsers.c
+++ b/libavcodec/parsers.c
@@ -50,6 +50,7 @@ extern const AVCodecParser ff_h261_parser;
 extern const AVCodecParser ff_h263_parser;
 extern const AVCodecParser ff_h264_parser;
 extern const AVCodecParser ff_hevc_parser;
+extern const AVCodecParser ff_hdr_parser;
 extern const AVCodecParser ff_ipu_parser;
 extern const AVCodecParser ff_jpeg2000_parser;
 extern const AVCodecParser ff_mjpeg_parser;
diff --git a/libavcodec/pcm-blurayenc.c b/libavcodec/pcm-blurayenc.c
index a139b54..6a5cdb2 100644
--- a/libavcodec/pcm-blurayenc.c
+++ b/libavcodec/pcm-blurayenc.c
@@ -310,6 +310,5 @@ const FFCodec ff_pcm_bluray_encoder = {
         { 0 } },
     .p.sample_fmts         = (const enum AVSampleFormat[]) {
         AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_S32, AV_SAMPLE_FMT_NONE },
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.capabilities        = AV_CODEC_CAP_DR1,
 };
diff --git a/libavcodec/pcm-dvd.c b/libavcodec/pcm-dvd.c
index 57d0ff8..0f37c6e 100644
--- a/libavcodec/pcm-dvd.c
+++ b/libavcodec/pcm-dvd.c
@@ -308,5 +308,4 @@ const FFCodec ff_pcm_dvd_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) {
         AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_S32, AV_SAMPLE_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/pcm-dvdenc.c b/libavcodec/pcm-dvdenc.c
index 0881697..a7023d1 100644
--- a/libavcodec/pcm-dvdenc.c
+++ b/libavcodec/pcm-dvdenc.c
@@ -199,5 +199,4 @@ const FFCodec ff_pcm_dvd_encoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_S32,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/pcm.c b/libavcodec/pcm.c
index 471075a..d097900 100644
--- a/libavcodec/pcm.c
+++ b/libavcodec/pcm.c
@@ -564,7 +564,6 @@ const FFCodec ff_ ## name_ ## _encoder = {                                  \
     FF_CODEC_ENCODE_CB(pcm_encode_frame),                                   \
     .p.sample_fmts = (const enum AVSampleFormat[]){ sample_fmt_,             \
                                                    AV_SAMPLE_FMT_NONE },    \
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,                          \
 }
 
 #define PCM_ENCODER_2(cf, id, sample_fmt, name, long_name)                  \
@@ -587,7 +586,6 @@ const FFCodec ff_ ## name_ ## _decoder = {                                  \
     .p.capabilities = AV_CODEC_CAP_DR1,                                     \
     .p.sample_fmts  = (const enum AVSampleFormat[]){ sample_fmt_,           \
                                                      AV_SAMPLE_FMT_NONE },  \
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,                         \
 }
 
 #define PCM_DECODER_2(cf, id, sample_fmt, name, long_name)                  \
diff --git a/libavcodec/pcxenc.c b/libavcodec/pcxenc.c
index e6eb387..8d3178e 100644
--- a/libavcodec/pcxenc.c
+++ b/libavcodec/pcxenc.c
@@ -205,5 +205,4 @@ const FFCodec ff_pcx_encoder = {
         AV_PIX_FMT_MONOBLACK,
         AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/pgssubdec.c b/libavcodec/pgssubdec.c
index e50c676..13c570c 100644
--- a/libavcodec/pgssubdec.c
+++ b/libavcodec/pgssubdec.c
@@ -700,5 +700,4 @@ const FFCodec ff_pgssub_decoder = {
     .close          = close_decoder,
     FF_CODEC_DECODE_SUB_CB(decode),
     .p.priv_class   = &pgsdec_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/photocd.c b/libavcodec/photocd.c
index 0f3001f..239b7a1 100644
--- a/libavcodec/photocd.c
+++ b/libavcodec/photocd.c
@@ -467,5 +467,4 @@ const FFCodec ff_photocd_decoder = {
     FF_CODEC_DECODE_CB(photocd_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
     .p.long_name    = NULL_IF_CONFIG_SMALL("Kodak Photo CD"),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/pixlet.c b/libavcodec/pixlet.c
index 4f9282b..1f43b4c 100644
--- a/libavcodec/pixlet.c
+++ b/libavcodec/pixlet.c
@@ -703,6 +703,5 @@ const FFCodec ff_pixlet_decoder = {
     .priv_data_size   = sizeof(PixletContext),
     .p.capabilities   = AV_CODEC_CAP_DR1 |
                         AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/pngdec.c b/libavcodec/pngdec.c
index 5fa9491..3b88819 100644
--- a/libavcodec/pngdec.c
+++ b/libavcodec/pngdec.c
@@ -78,8 +78,11 @@ typedef struct PNGDecContext {
     enum PNGImageState pic_state;
     int width, height;
     int cur_w, cur_h;
+    int last_w, last_h;
     int x_offset, y_offset;
+    int last_x_offset, last_y_offset;
     uint8_t dispose_op, blend_op;
+    uint8_t last_dispose_op;
     int bit_depth;
     int color_type;
     int compression_type;
@@ -91,6 +94,8 @@ typedef struct PNGDecContext {
     int has_trns;
     uint8_t transparent_color_be[6];
 
+    uint8_t *background_buf;
+    unsigned background_buf_allocated;
     uint32_t palette[256];
     uint8_t *crow_buf;
     uint8_t *last_row;
@@ -720,30 +725,9 @@ static int decode_idat_chunk(AVCodecContext *avctx, PNGDecContext *s,
         }
 
         ff_thread_release_ext_buffer(avctx, &s->picture);
-        if (s->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {
-            /* We only need a buffer for the current picture. */
-            ret = ff_thread_get_buffer(avctx, p, 0);
-            if (ret < 0)
-                return ret;
-        } else if (s->dispose_op == APNG_DISPOSE_OP_BACKGROUND) {
-            /* We need a buffer for the current picture as well as
-             * a buffer for the reference to retain. */
-            ret = ff_thread_get_ext_buffer(avctx, &s->picture,
-                                           AV_GET_BUFFER_FLAG_REF);
-            if (ret < 0)
-                return ret;
-            ret = ff_thread_get_buffer(avctx, p, 0);
-            if (ret < 0)
-                return ret;
-        } else {
-            /* The picture output this time and the reference to retain coincide. */
-            if ((ret = ff_thread_get_ext_buffer(avctx, &s->picture,
-                                                AV_GET_BUFFER_FLAG_REF)) < 0)
-                return ret;
-            ret = av_frame_ref(p, s->picture.f);
-            if (ret < 0)
-                return ret;
-        }
+        if ((ret = ff_thread_get_ext_buffer(avctx, &s->picture,
+                                            AV_GET_BUFFER_FLAG_REF)) < 0)
+            return ret;
 
         p->pict_type        = AV_PICTURE_TYPE_I;
         p->key_frame        = 1;
@@ -1001,6 +985,12 @@ static int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,
         return AVERROR_INVALIDDATA;
     }
 
+    s->last_w = s->cur_w;
+    s->last_h = s->cur_h;
+    s->last_x_offset = s->x_offset;
+    s->last_y_offset = s->y_offset;
+    s->last_dispose_op = s->dispose_op;
+
     sequence_number = bytestream2_get_be32(gb);
     cur_w           = bytestream2_get_be32(gb);
     cur_h           = bytestream2_get_be32(gb);
@@ -1096,6 +1086,23 @@ static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s,
 
     ff_thread_await_progress(&s->last_picture, INT_MAX, 0);
 
+    // need to reset a rectangle to background:
+    if (s->last_dispose_op == APNG_DISPOSE_OP_BACKGROUND) {
+        av_fast_malloc(&s->background_buf, &s->background_buf_allocated,
+                       src_stride * p->height);
+        if (!s->background_buf)
+            return AVERROR(ENOMEM);
+
+        memcpy(s->background_buf, src, src_stride * p->height);
+
+        for (y = s->last_y_offset; y < s->last_y_offset + s->last_h; y++) {
+            memset(s->background_buf + src_stride * y +
+                   bpp * s->last_x_offset, 0, bpp * s->last_w);
+        }
+
+        src = s->background_buf;
+    }
+
     // copy unchanged rectangles from the last frame
     for (y = 0; y < s->y_offset; y++)
         memcpy(dst + y * dst_stride, src + y * src_stride, p->width * bpp);
@@ -1164,22 +1171,6 @@ static int handle_p_frame_apng(AVCodecContext *avctx, PNGDecContext *s,
     return 0;
 }
 
-static void apng_reset_background(PNGDecContext *s, const AVFrame *p)
-{
-    // need to reset a rectangle to black
-    av_unused int ret = av_frame_copy(s->picture.f, p);
-    const int bpp = s->color_type == PNG_COLOR_TYPE_PALETTE ? 4 : s->bpp;
-    const ptrdiff_t dst_stride = s->picture.f->linesize[0];
-    uint8_t *dst = s->picture.f->data[0] + s->y_offset * dst_stride + bpp * s->x_offset;
-
-    av_assert1(ret >= 0);
-
-    for (size_t y = 0; y < s->cur_h; y++) {
-        memset(dst, 0, bpp * s->cur_w);
-        dst += dst_stride;
-    }
-}
-
 static int decode_frame_common(AVCodecContext *avctx, PNGDecContext *s,
                                AVFrame *p, const AVPacket *avpkt)
 {
@@ -1443,9 +1434,6 @@ exit_loop:
                 goto fail;
         }
     }
-    if (CONFIG_APNG_DECODER && s->dispose_op == APNG_DISPOSE_OP_BACKGROUND)
-        apng_reset_background(s, p);
-
     ff_thread_report_progress(&s->picture, INT_MAX, 0);
 
     return 0;
@@ -1468,10 +1456,15 @@ static void clear_frame_metadata(PNGDecContext *s)
     av_dict_free(&s->frame_metadata);
 }
 
-static int output_frame(PNGDecContext *s, AVFrame *f)
+static int output_frame(PNGDecContext *s, AVFrame *f,
+                        const AVFrame *src)
 {
     int ret;
 
+    ret = av_frame_ref(f, src);
+    if (ret < 0)
+        return ret;
+
     if (s->iccp_data) {
         AVFrameSideData *sd = av_frame_new_side_data(f, AV_FRAME_DATA_ICC_PROFILE, s->iccp_data_len);
         if (!sd) {
@@ -1522,12 +1515,13 @@ fail:
 }
 
 #if CONFIG_PNG_DECODER
-static int decode_frame_png(AVCodecContext *avctx, AVFrame *p,
+static int decode_frame_png(AVCodecContext *avctx, AVFrame *dst_frame,
                             int *got_frame, AVPacket *avpkt)
 {
     PNGDecContext *const s = avctx->priv_data;
     const uint8_t *buf     = avpkt->data;
     int buf_size           = avpkt->size;
+    AVFrame *p = s->picture.f;
     int64_t sig;
     int ret;
 
@@ -1561,7 +1555,7 @@ static int decode_frame_png(AVCodecContext *avctx, AVFrame *p,
         goto the_end;
     }
 
-    ret = output_frame(s, p);
+    ret = output_frame(s, dst_frame, s->picture.f);
     if (ret < 0)
         goto the_end;
 
@@ -1580,11 +1574,12 @@ the_end:
 #endif
 
 #if CONFIG_APNG_DECODER
-static int decode_frame_apng(AVCodecContext *avctx, AVFrame *p,
+static int decode_frame_apng(AVCodecContext *avctx, AVFrame *dst_frame,
                              int *got_frame, AVPacket *avpkt)
 {
     PNGDecContext *const s = avctx->priv_data;
     int ret;
+    AVFrame *p = s->picture.f;
 
     clear_frame_metadata(s);
 
@@ -1613,7 +1608,7 @@ static int decode_frame_apng(AVCodecContext *avctx, AVFrame *p,
     if (!(s->pic_state & (PNG_ALLIMAGE|PNG_IDAT)))
         return AVERROR_INVALIDDATA;
 
-    ret = output_frame(s, p);
+    ret = output_frame(s, dst_frame, s->picture.f);
     if (ret < 0)
         return ret;
 
@@ -1651,9 +1646,15 @@ static int update_thread_context(AVCodecContext *dst, const AVCodecContext *src)
         pdst->compression_type  = psrc->compression_type;
         pdst->interlace_type    = psrc->interlace_type;
         pdst->filter_type       = psrc->filter_type;
+        pdst->cur_w = psrc->cur_w;
+        pdst->cur_h = psrc->cur_h;
+        pdst->x_offset = psrc->x_offset;
+        pdst->y_offset = psrc->y_offset;
         pdst->has_trns = psrc->has_trns;
         memcpy(pdst->transparent_color_be, psrc->transparent_color_be, sizeof(pdst->transparent_color_be));
 
+        pdst->dispose_op = psrc->dispose_op;
+
         memcpy(pdst->palette, psrc->palette, sizeof(pdst->palette));
 
         pdst->hdr_state |= psrc->hdr_state;
@@ -1704,6 +1705,7 @@ static av_cold int png_dec_end(AVCodecContext *avctx)
     s->last_row_size = 0;
     av_freep(&s->tmp_row);
     s->tmp_row_size = 0;
+    av_freep(&s->background_buf);
 
     av_freep(&s->iccp_data);
     av_dict_free(&s->frame_metadata);
@@ -1724,8 +1726,9 @@ const FFCodec ff_apng_decoder = {
     FF_CODEC_DECODE_CB(decode_frame_apng),
     .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
-                      FF_CODEC_CAP_ALLOCATE_PROGRESS,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
+                      FF_CODEC_CAP_ALLOCATE_PROGRESS |
+                      FF_CODEC_CAP_ICC_PROFILES,
 };
 #endif
 
@@ -1741,7 +1744,8 @@ const FFCodec ff_png_decoder = {
     FF_CODEC_DECODE_CB(decode_frame_png),
     .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,
-    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM | FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_SKIP_FRAME_FILL_PARAM |
+                      FF_CODEC_CAP_ALLOCATE_PROGRESS | FF_CODEC_CAP_INIT_CLEANUP |
+                      FF_CODEC_CAP_ICC_PROFILES,
 };
 #endif
diff --git a/libavcodec/pngenc.c b/libavcodec/pngenc.c
index 93463dd..ca9873f 100644
--- a/libavcodec/pngenc.c
+++ b/libavcodec/pngenc.c
@@ -120,7 +120,7 @@ static void png_get_interlaced_row(uint8_t *dst, int row_size,
     }
 }
 
-static void sub_png_paeth_prediction(uint8_t *dst, uint8_t *src, uint8_t *top,
+static void sub_png_paeth_prediction(uint8_t *dst, const uint8_t *src, const uint8_t *top,
                                      int w, int bpp)
 {
     int i;
@@ -165,7 +165,7 @@ static void sub_left_prediction(PNGEncContext *c, uint8_t *dst, const uint8_t *s
 }
 
 static void png_filter_row(PNGEncContext *c, uint8_t *dst, int filter_type,
-                           uint8_t *src, uint8_t *top, int size, int bpp)
+                           const uint8_t *src, const uint8_t *top, int size, int bpp)
 {
     int i;
 
@@ -194,7 +194,7 @@ static void png_filter_row(PNGEncContext *c, uint8_t *dst, int filter_type,
 }
 
 static uint8_t *png_choose_filter(PNGEncContext *s, uint8_t *dst,
-                                  uint8_t *src, uint8_t *top, int size, int bpp)
+                                  const uint8_t *src, const uint8_t *top, int size, int bpp)
 {
     int pred = s->filter_type;
     av_assert0(bpp || !pred);
@@ -486,7 +486,7 @@ static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
     const AVFrame *const p = pict;
     int y, len, ret;
     int row_size, pass_row_size;
-    uint8_t *ptr, *top, *crow_buf, *crow;
+    uint8_t *crow_buf, *crow;
     uint8_t *crow_base       = NULL;
     uint8_t *progressive_buf = NULL;
     uint8_t *top_buf         = NULL;
@@ -520,10 +520,10 @@ static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
              * output */
             pass_row_size = ff_png_pass_row_size(pass, s->bits_per_pixel, pict->width);
             if (pass_row_size > 0) {
-                top = NULL;
+                uint8_t *top = NULL;
                 for (y = 0; y < pict->height; y++)
                     if ((ff_png_pass_ymask[pass] << (y & 7)) & 0x80) {
-                        ptr = p->data[0] + y * p->linesize[0];
+                        const uint8_t *ptr = p->data[0] + y * p->linesize[0];
                         FFSWAP(uint8_t *, progressive_buf, top_buf);
                         png_get_interlaced_row(progressive_buf, pass_row_size,
                                                s->bits_per_pixel, pass,
@@ -536,9 +536,9 @@ static int encode_frame(AVCodecContext *avctx, const AVFrame *pict)
             }
         }
     } else {
-        top = NULL;
+        const uint8_t *top = NULL;
         for (y = 0; y < pict->height; y++) {
-            ptr = p->data[0] + y * p->linesize[0];
+            const uint8_t *ptr = p->data[0] + y * p->linesize[0];
             crow = png_choose_filter(s, crow_buf, ptr, top,
                                      row_size, s->bits_per_pixel >> 3);
             png_write_row(avctx, crow, row_size + 1);
@@ -723,7 +723,7 @@ static int apng_do_inverse_blend(AVFrame *output, const AVFrame *input,
         }
 
         for (y = topmost_y; y < bottommost_y; ++y) {
-            uint8_t *foreground = input->data[0] + input_linesize * y + bpp * leftmost_x;
+            const uint8_t *foreground = input->data[0] + input_linesize * y + bpp * leftmost_x;
             uint8_t *background = output->data[0] + output_linesize * y + bpp * leftmost_x;
             output_data = output->data[0] + output_linesize * (y - topmost_y);
             for (x = leftmost_x; x < rightmost_x; ++x, foreground += bpp, background += bpp, output_data += bpp) {
@@ -1056,7 +1056,7 @@ static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,
         }
 
         av_frame_unref(s->last_frame);
-        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);
+        ret = av_frame_ref(s->last_frame, pict);
         if (ret < 0)
             return ret;
 
@@ -1210,7 +1210,7 @@ const FFCodec ff_png_encoder = {
         AV_PIX_FMT_MONOBLACK, AV_PIX_FMT_NONE
     },
     .p.priv_class   = &pngenc_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_ICC_PROFILES,
 };
 
 const FFCodec ff_apng_encoder = {
@@ -1232,5 +1232,5 @@ const FFCodec ff_apng_encoder = {
         AV_PIX_FMT_NONE
     },
     .p.priv_class   = &pngenc_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_ICC_PROFILES,
 };
diff --git a/libavcodec/pnm.c b/libavcodec/pnm.c
index 605a529..aabc788 100644
--- a/libavcodec/pnm.c
+++ b/libavcodec/pnm.c
@@ -38,7 +38,7 @@ static void pnm_get(PNMContext *sc, char *str, int buf_size)
 {
     char *s;
     int c;
-    uint8_t *bs  = sc->bytestream;
+    const uint8_t *bs  = sc->bytestream;
     const uint8_t *end = sc->bytestream_end;
 
     /* skip spaces and comments */
diff --git a/libavcodec/pnm.h b/libavcodec/pnm.h
index f109d16..5bf2eaa 100644
--- a/libavcodec/pnm.h
+++ b/libavcodec/pnm.h
@@ -25,9 +25,9 @@
 #include "avcodec.h"
 
 typedef struct PNMContext {
-    uint8_t *bytestream;
-    uint8_t *bytestream_start;
-    uint8_t *bytestream_end;
+    const uint8_t *bytestream;
+    const uint8_t *bytestream_start;
+    const uint8_t *bytestream_end;
     int maxval;                 ///< maximum value of a pixel
     int type;
     int endian;
diff --git a/libavcodec/pnm_parser.c b/libavcodec/pnm_parser.c
index 6607ac7..74f918a 100644
--- a/libavcodec/pnm_parser.c
+++ b/libavcodec/pnm_parser.c
@@ -65,8 +65,8 @@ retry:
         pnmctx.bytestream_end   = pc->buffer + pc->index;
     } else {
         pnmctx.bytestream_start =
-        pnmctx.bytestream       = (uint8_t *) buf + skip; /* casts avoid warnings */
-        pnmctx.bytestream_end   = (uint8_t *) buf + buf_size - skip;
+        pnmctx.bytestream       = buf + skip;
+        pnmctx.bytestream_end   = buf + buf_size - skip;
     }
     if (ff_pnm_decode_header(avctx, &pnmctx) < 0) {
         if (pnmctx.bytestream < pnmctx.bytestream_end) {
@@ -81,9 +81,9 @@ retry:
             goto retry;
         }
     } else if (pnmctx.type < 4) {
-              uint8_t *bs  = pnmctx.bytestream;
+        const uint8_t *bs   = pnmctx.bytestream;
         const uint8_t *end = pnmctx.bytestream_end;
-        uint8_t *sync      = bs;
+        const uint8_t *sync = bs;
 
         if (pc->index) {
             av_assert0(pnmpc->ascii_scan <= end - bs);
diff --git a/libavcodec/pnmdec.c b/libavcodec/pnmdec.c
index bb2ce53..130407d 100644
--- a/libavcodec/pnmdec.c
+++ b/libavcodec/pnmdec.c
@@ -52,8 +52,8 @@ static int pnm_decode_frame(AVCodecContext *avctx, AVFrame *p,
     float scale;
 
     s->bytestream_start =
-    s->bytestream       = (uint8_t *)buf;
-    s->bytestream_end   = (uint8_t *)buf + buf_size;
+    s->bytestream       = buf;
+    s->bytestream_end   = buf + buf_size;
 
     if ((ret = ff_pnm_decode_header(avctx, s)) < 0)
         return ret;
@@ -166,23 +166,23 @@ static int pnm_decode_frame(AVCodecContext *avctx, AVFrame *p,
                 ptr+= linesize;
             }
         }else{
-        for (i = 0; i < avctx->height; i++) {
-            if (!upgrade)
-                samplecpy(ptr, s->bytestream, n, s->maxval);
-            else if (upgrade == 1) {
-                unsigned int j, f = (255 * 128 + s->maxval / 2) / s->maxval;
-                for (j = 0; j < n; j++)
-                    ptr[j] = (s->bytestream[j] * f + 64) >> 7;
-            } else if (upgrade == 2) {
-                unsigned int j, v, f = (65535 * 32768 + s->maxval / 2) / s->maxval;
-                for (j = 0; j < n / 2; j++) {
-                    v = AV_RB16(s->bytestream + 2*j);
-                    ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15;
+            for (int i = 0; i < avctx->height; i++) {
+                if (!upgrade)
+                    samplecpy(ptr, s->bytestream, n, s->maxval);
+                else if (upgrade == 1) {
+                    unsigned int f = (255 * 128 + s->maxval / 2) / s->maxval;
+                    for (unsigned j = 0; j < n; j++)
+                        ptr[j] = (s->bytestream[j] * f + 64) >> 7;
+                } else if (upgrade == 2) {
+                    unsigned int f = (65535 * 32768 + s->maxval / 2) / s->maxval;
+                    for (unsigned j = 0; j < n / 2; j++) {
+                        unsigned v = AV_RB16(s->bytestream + 2*j);
+                        ((uint16_t *)ptr)[j] = (v * f + 16384) >> 15;
+                    }
                 }
+                s->bytestream += n;
+                ptr           += linesize;
             }
-            s->bytestream += n;
-            ptr           += linesize;
-        }
         }
         break;
     case AV_PIX_FMT_YUV420P:
@@ -260,46 +260,46 @@ static int pnm_decode_frame(AVCodecContext *avctx, AVFrame *p,
         break;
     case AV_PIX_FMT_GBRPF32:
         if (!s->half) {
-        if (avctx->width * avctx->height * 12 > s->bytestream_end - s->bytestream)
-            return AVERROR_INVALIDDATA;
-        scale = 1.f / s->scale;
-        if (s->endian) {
-            float *r, *g, *b;
+            if (avctx->width * avctx->height * 12 > s->bytestream_end - s->bytestream)
+                return AVERROR_INVALIDDATA;
+            scale = 1.f / s->scale;
+            if (s->endian) {
+                float *r, *g, *b;
 
-            r = (float *)p->data[2];
-            g = (float *)p->data[0];
-            b = (float *)p->data[1];
-            for (int i = 0; i < avctx->height; i++) {
-                for (int j = 0; j < avctx->width; j++) {
-                    r[j] = av_int2float(AV_RL32(s->bytestream+0)) * scale;
-                    g[j] = av_int2float(AV_RL32(s->bytestream+4)) * scale;
-                    b[j] = av_int2float(AV_RL32(s->bytestream+8)) * scale;
-                    s->bytestream += 12;
+                r = (float *)p->data[2];
+                g = (float *)p->data[0];
+                b = (float *)p->data[1];
+                for (int i = 0; i < avctx->height; i++) {
+                    for (int j = 0; j < avctx->width; j++) {
+                        r[j] = av_int2float(AV_RL32(s->bytestream+0)) * scale;
+                        g[j] = av_int2float(AV_RL32(s->bytestream+4)) * scale;
+                        b[j] = av_int2float(AV_RL32(s->bytestream+8)) * scale;
+                        s->bytestream += 12;
+                    }
+
+                    r += p->linesize[2] / 4;
+                    g += p->linesize[0] / 4;
+                    b += p->linesize[1] / 4;
                 }
+            } else {
+                float *r, *g, *b;
 
-                r += p->linesize[2] / 4;
-                g += p->linesize[0] / 4;
-                b += p->linesize[1] / 4;
-            }
-        } else {
-            float *r, *g, *b;
+                r = (float *)p->data[2];
+                g = (float *)p->data[0];
+                b = (float *)p->data[1];
+                for (int i = 0; i < avctx->height; i++) {
+                    for (int j = 0; j < avctx->width; j++) {
+                        r[j] = av_int2float(AV_RB32(s->bytestream+0)) * scale;
+                        g[j] = av_int2float(AV_RB32(s->bytestream+4)) * scale;
+                        b[j] = av_int2float(AV_RB32(s->bytestream+8)) * scale;
+                        s->bytestream += 12;
+                    }
 
-            r = (float *)p->data[2];
-            g = (float *)p->data[0];
-            b = (float *)p->data[1];
-            for (int i = 0; i < avctx->height; i++) {
-                for (int j = 0; j < avctx->width; j++) {
-                    r[j] = av_int2float(AV_RB32(s->bytestream+0)) * scale;
-                    g[j] = av_int2float(AV_RB32(s->bytestream+4)) * scale;
-                    b[j] = av_int2float(AV_RB32(s->bytestream+8)) * scale;
-                    s->bytestream += 12;
+                    r += p->linesize[2] / 4;
+                    g += p->linesize[0] / 4;
+                    b += p->linesize[1] / 4;
                 }
-
-                r += p->linesize[2] / 4;
-                g += p->linesize[0] / 4;
-                b += p->linesize[1] / 4;
             }
-        }
         } else {
             if (avctx->width * avctx->height * 6 > s->bytestream_end - s->bytestream)
                 return AVERROR_INVALIDDATA;
@@ -358,32 +358,33 @@ static int pnm_decode_frame(AVCodecContext *avctx, AVFrame *p,
                     g += p->linesize[0] / 4;
                     b += p->linesize[1] / 4;
                 }
-            }        }
+            }
+        }
         break;
     case AV_PIX_FMT_GRAYF32:
         if (!s->half) {
-        if (avctx->width * avctx->height * 4 > s->bytestream_end - s->bytestream)
-            return AVERROR_INVALIDDATA;
-        scale = 1.f / s->scale;
-        if (s->endian) {
-            float *g = (float *)p->data[0];
-            for (int i = 0; i < avctx->height; i++) {
-                for (int j = 0; j < avctx->width; j++) {
-                    g[j] = av_int2float(AV_RL32(s->bytestream)) * scale;
-                    s->bytestream += 4;
+            if (avctx->width * avctx->height * 4 > s->bytestream_end - s->bytestream)
+                return AVERROR_INVALIDDATA;
+            scale = 1.f / s->scale;
+            if (s->endian) {
+                float *g = (float *)p->data[0];
+                for (int i = 0; i < avctx->height; i++) {
+                    for (int j = 0; j < avctx->width; j++) {
+                        g[j] = av_int2float(AV_RL32(s->bytestream)) * scale;
+                        s->bytestream += 4;
+                    }
+                    g += p->linesize[0] / 4;
                 }
-                g += p->linesize[0] / 4;
-            }
-        } else {
-            float *g = (float *)p->data[0];
-            for (int i = 0; i < avctx->height; i++) {
-                for (int j = 0; j < avctx->width; j++) {
-                    g[j] = av_int2float(AV_RB32(s->bytestream)) * scale;
-                    s->bytestream += 4;
+            } else {
+                float *g = (float *)p->data[0];
+                for (int i = 0; i < avctx->height; i++) {
+                    for (int j = 0; j < avctx->width; j++) {
+                        g[j] = av_int2float(AV_RB32(s->bytestream)) * scale;
+                        s->bytestream += 4;
+                    }
+                    g += p->linesize[0] / 4;
                 }
-                g += p->linesize[0] / 4;
             }
-        }
         } else {
             if (avctx->width * avctx->height * 2 > s->bytestream_end - s->bytestream)
                 return AVERROR_INVALIDDATA;
diff --git a/libavcodec/pnmenc.c b/libavcodec/pnmenc.c
index db40f4b..b16c93c 100644
--- a/libavcodec/pnmenc.c
+++ b/libavcodec/pnmenc.c
@@ -40,7 +40,6 @@ static int pnm_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     PHMEncContext *s = avctx->priv_data;
     uint8_t *bytestream, *bytestream_start, *bytestream_end;
     int i, h, h1, c, n, linesize, ret;
-    uint8_t *ptr, *ptr1, *ptr2;
     int size = av_image_get_buffer_size(avctx->pix_fmt,
                                         avctx->width, avctx->height, 1);
 
@@ -135,9 +134,9 @@ static int pnm_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
 
     if ((avctx->pix_fmt == AV_PIX_FMT_GBRPF32LE ||
          avctx->pix_fmt == AV_PIX_FMT_GBRPF32BE) && c == 'F') {
-        float *r = (float *)p->data[2];
-        float *g = (float *)p->data[0];
-        float *b = (float *)p->data[1];
+        const float *r = (const float *)p->data[2];
+        const float *g = (const float *)p->data[0];
+        const float *b = (const float *)p->data[1];
 
         for (int i = 0; i < avctx->height; i++) {
             for (int j = 0; j < avctx->width; j++) {
@@ -164,9 +163,9 @@ static int pnm_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             g += p->linesize[0] / 4;
         }
     } else if (avctx->pix_fmt == AV_PIX_FMT_GBRPF32 && c == 'H') {
-        float *r = (float *)p->data[2];
-        float *g = (float *)p->data[0];
-        float *b = (float *)p->data[1];
+        const float *r = (const float *)p->data[2];
+        const float *g = (const float *)p->data[0];
+        const float *b = (const float *)p->data[1];
 
         for (int i = 0; i < avctx->height; i++) {
             for (int j = 0; j < avctx->width; j++) {
@@ -192,7 +191,7 @@ static int pnm_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             g += p->linesize[0] / 4;
         }
     } else {
-        ptr      = p->data[0];
+        const uint8_t *ptr = p->data[0];
         linesize = p->linesize[0];
         for (i = 0; i < h; i++) {
             memcpy(bytestream, ptr, n);
@@ -202,10 +201,9 @@ static int pnm_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     }
 
     if (avctx->pix_fmt == AV_PIX_FMT_YUV420P || avctx->pix_fmt == AV_PIX_FMT_YUV420P16BE) {
+        const uint8_t *ptr1 = p->data[1], *ptr2 = p->data[2];
         h >>= 1;
         n >>= 1;
-        ptr1 = p->data[1];
-        ptr2 = p->data[2];
         for (i = 0; i < h; i++) {
             memcpy(bytestream, ptr1, n);
             bytestream += n;
@@ -232,7 +230,6 @@ const FFCodec ff_pgm_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]){
         AV_PIX_FMT_GRAY8, AV_PIX_FMT_GRAY16BE, AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -247,7 +244,6 @@ const FFCodec ff_pgmyuv_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]){
         AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV420P16BE, AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -262,7 +258,6 @@ const FFCodec ff_ppm_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]){
         AV_PIX_FMT_RGB24, AV_PIX_FMT_RGB48BE, AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -276,7 +271,6 @@ const FFCodec ff_pbm_encoder = {
     FF_CODEC_ENCODE_CB(pnm_encode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_MONOWHITE,
                                                   AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -293,7 +287,6 @@ const FFCodec ff_pfm_encoder = {
                                                     AV_PIX_FMT_GBRPF32BE,
                                                     AV_PIX_FMT_GRAYF32BE,
                                                     AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -319,6 +312,5 @@ const FFCodec ff_phm_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_GBRPF32,
                                                     AV_PIX_FMT_GRAYF32,
                                                     AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/ppc/h264chroma_template.c b/libavcodec/ppc/h264chroma_template.c
index eda98c6..c64856b 100644
--- a/libavcodec/ppc/h264chroma_template.c
+++ b/libavcodec/ppc/h264chroma_template.c
@@ -109,7 +109,7 @@
 #endif /* HAVE_BIGENDIAN */
 
 #ifdef PREFIX_h264_chroma_mc8_altivec
-static void PREFIX_h264_chroma_mc8_altivec(uint8_t * dst, uint8_t * src,
+static void PREFIX_h264_chroma_mc8_altivec(uint8_t * dst, const uint8_t * src,
                                            ptrdiff_t stride, int h,
                                            int x, int y)
 {
@@ -184,7 +184,7 @@ static void PREFIX_h264_chroma_mc8_altivec(uint8_t * dst, uint8_t * src,
 
 /* this code assume that stride % 16 == 0 */
 #ifdef PREFIX_no_rnd_vc1_chroma_mc8_altivec
-static void PREFIX_no_rnd_vc1_chroma_mc8_altivec(uint8_t *dst, uint8_t *src,
+static void PREFIX_no_rnd_vc1_chroma_mc8_altivec(uint8_t *dst, const uint8_t *src,
                                                  ptrdiff_t stride, int h,
                                                  int x, int y)
 {
diff --git a/libavcodec/ppc/me_cmp.c b/libavcodec/ppc/me_cmp.c
index 17f9a4f..90f2152 100644
--- a/libavcodec/ppc/me_cmp.c
+++ b/libavcodec/ppc/me_cmp.c
@@ -51,7 +51,7 @@
     iv = vec_vsx_ld(1,  pix);\
 }
 #endif
-static int sad16_x2_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sad16_x2_altivec(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                             ptrdiff_t stride, int h)
 {
     int i;
@@ -91,7 +91,7 @@ static int sad16_x2_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int sad16_y2_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sad16_y2_altivec(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                             ptrdiff_t stride, int h)
 {
     int i;
@@ -102,7 +102,7 @@ static int sad16_y2_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     vector unsigned int sad = (vector unsigned int) vec_splat_u32(0);
     vector signed int sumdiffs;
 
-    uint8_t *pix3 = pix2 + stride;
+    const uint8_t *pix3 = pix2 + stride;
 
     /* Due to the fact that pix3 = pix2 + stride, the pix3 of one
      * iteration becomes pix2 in the next iteration. We can use this
@@ -141,12 +141,12 @@ static int sad16_y2_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int sad16_xy2_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sad16_xy2_altivec(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                              ptrdiff_t stride, int h)
 {
     int i;
     int  __attribute__((aligned(16))) s = 0;
-    uint8_t *pix3 = pix2 + stride;
+    const uint8_t *pix3 = pix2 + stride;
     const vector unsigned char zero =
         (const vector unsigned char) vec_splat_u8(0);
     const vector unsigned short two =
@@ -230,7 +230,7 @@ static int sad16_xy2_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int sad16_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sad16_altivec(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h)
 {
     int i;
@@ -265,7 +265,7 @@ static int sad16_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int sad8_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sad8_altivec(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h)
 {
     int i;
@@ -309,7 +309,7 @@ static int sad8_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
 
 /* Sum of Squared Errors for an 8x8 block, AltiVec-enhanced.
  * It's the sad8_altivec code above w/ squaring added. */
-static int sse8_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sse8_altivec(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                         ptrdiff_t stride, int h)
 {
     int i;
@@ -354,7 +354,7 @@ static int sse8_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
 
 /* Sum of Squared Errors for a 16x16 block, AltiVec-enhanced.
  * It's the sad16_altivec code above w/ squaring added. */
-static int sse16_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+static int sse16_altivec(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h)
 {
     int i;
@@ -392,8 +392,8 @@ static int sse16_altivec(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
     return s;
 }
 
-static int hadamard8_diff8x8_altivec(MpegEncContext *s, uint8_t *dst,
-                                     uint8_t *src, ptrdiff_t stride, int h)
+static int hadamard8_diff8x8_altivec(MpegEncContext *s, const uint8_t *dst,
+                                     const uint8_t *src, ptrdiff_t stride, int h)
 {
     int __attribute__((aligned(16))) sum;
     register const vector unsigned char vzero =
@@ -518,8 +518,8 @@ static int hadamard8_diff8x8_altivec(MpegEncContext *s, uint8_t *dst,
  * On the 970, the hand-made RA is still a win (around 690 vs. around 780),
  * but xlc goes to around 660 on the regular C code...
  */
-static int hadamard8_diff16x8_altivec(MpegEncContext *s, uint8_t *dst,
-                                      uint8_t *src, ptrdiff_t stride, int h)
+static int hadamard8_diff16x8_altivec(MpegEncContext *s, const uint8_t *dst,
+                                      const uint8_t *src, ptrdiff_t stride, int h)
 {
     int __attribute__((aligned(16))) sum;
     register vector signed short
@@ -709,8 +709,8 @@ static int hadamard8_diff16x8_altivec(MpegEncContext *s, uint8_t *dst,
     return sum;
 }
 
-static int hadamard8_diff16_altivec(MpegEncContext *s, uint8_t *dst,
-                                    uint8_t *src, ptrdiff_t stride, int h)
+static int hadamard8_diff16_altivec(MpegEncContext *s, const uint8_t *dst,
+                                    const uint8_t *src, ptrdiff_t stride, int h)
 {
     int score = hadamard8_diff16x8_altivec(s, dst, src, stride, 8);
 
diff --git a/libavcodec/ppc/mpegvideodsp.c b/libavcodec/ppc/mpegvideodsp.c
index 42d65db..3e99e08 100644
--- a/libavcodec/ppc/mpegvideodsp.c
+++ b/libavcodec/ppc/mpegvideodsp.c
@@ -31,7 +31,7 @@
 #if HAVE_ALTIVEC
 /* AltiVec-enhanced gmc1. ATM this code assumes stride is a multiple of 8
  * to preserve proper dst alignment. */
-static void gmc1_altivec(uint8_t *dst /* align 8 */, uint8_t *src /* align1 */,
+static void gmc1_altivec(uint8_t *dst /* align 8 */, const uint8_t *src /* align1 */,
                          int stride, int h, int x16, int y16, int rounder)
 {
     int i;
diff --git a/libavcodec/ppc/mpegvideoencdsp.c b/libavcodec/ppc/mpegvideoencdsp.c
index b96487b..07d3e76 100644
--- a/libavcodec/ppc/mpegvideoencdsp.c
+++ b/libavcodec/ppc/mpegvideoencdsp.c
@@ -30,7 +30,7 @@
 #if HAVE_ALTIVEC
 
 #if HAVE_VSX
-static int pix_norm1_altivec(uint8_t *pix, int line_size)
+static int pix_norm1_altivec(const uint8_t *pix, int line_size)
 {
     int i, s = 0;
     const vector unsigned int zero =
@@ -57,7 +57,7 @@ static int pix_norm1_altivec(uint8_t *pix, int line_size)
     return s;
 }
 #else
-static int pix_norm1_altivec(uint8_t *pix, int line_size)
+static int pix_norm1_altivec(const uint8_t *pix, int line_size)
 {
     int i, s = 0;
     const vector unsigned int zero =
@@ -87,7 +87,7 @@ static int pix_norm1_altivec(uint8_t *pix, int line_size)
 #endif /* HAVE_VSX */
 
 #if HAVE_VSX
-static int pix_sum_altivec(uint8_t *pix, int line_size)
+static int pix_sum_altivec(const uint8_t *pix, int line_size)
 {
     int i, s;
     const vector unsigned int zero =
@@ -115,7 +115,7 @@ static int pix_sum_altivec(uint8_t *pix, int line_size)
     return s;
 }
 #else
-static int pix_sum_altivec(uint8_t *pix, int line_size)
+static int pix_sum_altivec(const uint8_t *pix, int line_size)
 {
     int i, s;
     const vector unsigned int zero =
diff --git a/libavcodec/ppc/videodsp.c b/libavcodec/ppc/videodsp.c
index 9157022..a7ab5a6 100644
--- a/libavcodec/ppc/videodsp.c
+++ b/libavcodec/ppc/videodsp.c
@@ -21,7 +21,7 @@
 #include "libavutil/attributes.h"
 #include "libavcodec/videodsp.h"
 
-static void prefetch_ppc(uint8_t *mem, ptrdiff_t stride, int h)
+static void prefetch_ppc(const uint8_t *mem, ptrdiff_t stride, int h)
 {
     register const uint8_t *p = mem;
     do {
diff --git a/libavcodec/proresdata.c b/libavcodec/proresdata.c
index 9849b5c..4787907 100644
--- a/libavcodec/proresdata.c
+++ b/libavcodec/proresdata.c
@@ -43,30 +43,3 @@ const uint8_t ff_prores_interlaced_scan[64] = {
     30, 23, 31, 38, 45, 52, 60, 53,
     46, 39, 47, 54, 61, 62, 55, 63
 };
-
-
-const uint8_t ff_prores_dc_codebook[4] = {
-    0x04, // rice_order = 0, exp_golomb_order = 1, switch_bits = 0
-    0x28, // rice_order = 1, exp_golomb_order = 2, switch_bits = 0
-    0x4D, // rice_order = 2, exp_golomb_order = 3, switch_bits = 1
-    0x70  // rice_order = 3, exp_golomb_order = 4, switch_bits = 0
-};
-
-const uint8_t ff_prores_ac_codebook[7] = {
-    0x04, // rice_order = 0, exp_golomb_order = 1, switch_bits = 0
-    0x28, // rice_order = 1, exp_golomb_order = 2, switch_bits = 0
-    0x4C, // rice_order = 2, exp_golomb_order = 3, switch_bits = 0
-    0x05, // rice_order = 0, exp_golomb_order = 1, switch_bits = 1
-    0x29, // rice_order = 1, exp_golomb_order = 2, switch_bits = 1
-    0x06, // rice_order = 0, exp_golomb_order = 1, switch_bits = 2
-    0x0A, // rice_order = 0, exp_golomb_order = 2, switch_bits = 2
-};
-
-/**
- * Lookup tables for adaptive switching between codebooks
- * according with previous run/level value.
- */
-const uint8_t ff_prores_run_to_cb_index[16] =
-    { 5, 5, 3, 3, 0, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 2 };
-
-const uint8_t ff_prores_lev_to_cb_index[10] = { 0, 6, 3, 5, 0, 1, 1, 1, 1, 2 };
diff --git a/libavcodec/proresdata.h b/libavcodec/proresdata.h
index ee8278d..d8c8786 100644
--- a/libavcodec/proresdata.h
+++ b/libavcodec/proresdata.h
@@ -31,9 +31,5 @@ extern const uint8_t ff_prores_progressive_scan[64];
 extern const uint8_t ff_prores_interlaced_scan[64];
 
 #define FIRST_DC_CB 0xB8 // rice_order = 5, exp_golomb_order = 6, switch_bits = 0
-extern const uint8_t ff_prores_dc_codebook[4];
-extern const uint8_t ff_prores_ac_codebook[7];
-extern const uint8_t ff_prores_run_to_cb_index[16];
-extern const uint8_t ff_prores_lev_to_cb_index[10];
 
 #endif /* AVCODEC_PRORESDATA_H */
diff --git a/libavcodec/proresdec2.c b/libavcodec/proresdec2.c
index 385ca2f..659f9ff 100644
--- a/libavcodec/proresdec2.c
+++ b/libavcodec/proresdec2.c
@@ -500,7 +500,7 @@ static const uint8_t lev_to_cb[10] = { 0x04, 0x0A, 0x05, 0x06, 0x04, 0x28, 0x28,
 static av_always_inline int decode_ac_coeffs(AVCodecContext *avctx, GetBitContext *gb,
                                              int16_t *out, int blocks_per_slice)
 {
-    ProresContext *ctx = avctx->priv_data;
+    const ProresContext *ctx = avctx->priv_data;
     int block_mask, sign;
     unsigned pos, run, level;
     int max_coeffs, i, bits_left;
@@ -545,7 +545,7 @@ static int decode_slice_luma(AVCodecContext *avctx, SliceContext *slice,
                              const uint8_t *buf, unsigned buf_size,
                              const int16_t *qmat)
 {
-    ProresContext *ctx = avctx->priv_data;
+    const ProresContext *ctx = avctx->priv_data;
     LOCAL_ALIGNED_32(int16_t, blocks, [8*4*64]);
     int16_t *block;
     GetBitContext gb;
@@ -611,7 +611,7 @@ static int decode_slice_chroma(AVCodecContext *avctx, SliceContext *slice,
 /**
  * Decode alpha slice plane.
  */
-static void decode_slice_alpha(ProresContext *ctx,
+static void decode_slice_alpha(const ProresContext *ctx,
                                uint16_t *dst, int dst_stride,
                                const uint8_t *buf, int buf_size,
                                int blocks_per_slice)
@@ -643,7 +643,7 @@ static void decode_slice_alpha(ProresContext *ctx,
 
 static int decode_slice_thread(AVCodecContext *avctx, void *arg, int jobnr, int threadnr)
 {
-    ProresContext *ctx = avctx->priv_data;
+    const ProresContext *ctx = avctx->priv_data;
     SliceContext *slice = &ctx->slices[jobnr];
     const uint8_t *buf = slice->data;
     AVFrame *pic = ctx->frame;
@@ -882,7 +882,6 @@ const FFCodec ff_prores_decoder = {
     .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_FRAME_THREADS,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_prores_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .hw_configs     = (const AVCodecHWConfigInternal *const []) {
 #if CONFIG_PRORES_VIDEOTOOLBOX_HWACCEL
         HWACCEL_VIDEOTOOLBOX(prores),
diff --git a/libavcodec/proresenc_anatoliy.c b/libavcodec/proresenc_anatoliy.c
index 914c3fb..cfc735b 100644
--- a/libavcodec/proresenc_anatoliy.c
+++ b/libavcodec/proresenc_anatoliy.c
@@ -305,7 +305,7 @@ static void encode_ac_coeffs(PutBitContext *pb,
     }
 }
 
-static void get(uint8_t *pixels, int stride, int16_t* block)
+static void get(const uint8_t *pixels, int stride, int16_t* block)
 {
     int i;
 
@@ -317,13 +317,13 @@ static void get(uint8_t *pixels, int stride, int16_t* block)
     }
 }
 
-static void fdct_get(FDCTDSPContext *fdsp, uint8_t *pixels, int stride, int16_t* block)
+static void fdct_get(FDCTDSPContext *fdsp, const uint8_t *pixels, int stride, int16_t* block)
 {
     get(pixels, stride, block);
     fdsp->fdct(block);
 }
 
-static void calc_plane_dct(FDCTDSPContext *fdsp, uint8_t *src, int16_t * blocks, int src_stride, int mb_count, int chroma, int is_422)
+static void calc_plane_dct(FDCTDSPContext *fdsp, const uint8_t *src, int16_t * blocks, int src_stride, int mb_count, int chroma, int is_422)
 {
     int16_t *block;
     int i;
@@ -473,7 +473,7 @@ static av_always_inline int encode_alpha_slice_data(AVCodecContext *avctx, int8_
     }
 }
 
-static inline void subimage_with_fill_template(uint16_t *src, unsigned x, unsigned y,
+static inline void subimage_with_fill_template(const uint16_t *src, unsigned x, unsigned y,
                                                unsigned stride, unsigned width, unsigned height, uint16_t *dst,
                                                unsigned dst_width, unsigned dst_height, int is_alpha_plane,
                                                int is_interlaced, int is_top_field)
@@ -521,7 +521,7 @@ static inline void subimage_with_fill_template(uint16_t *src, unsigned x, unsign
     }
 }
 
-static void subimage_with_fill(uint16_t *src, unsigned x, unsigned y,
+static void subimage_with_fill(const uint16_t *src, unsigned x, unsigned y,
         unsigned stride, unsigned width, unsigned height, uint16_t *dst,
         unsigned dst_width, unsigned dst_height, int is_interlaced, int is_top_field)
 {
@@ -529,7 +529,7 @@ static void subimage_with_fill(uint16_t *src, unsigned x, unsigned y,
 }
 
 /* reorganize alpha data and convert 10b -> 16b */
-static void subimage_alpha_with_fill(uint16_t *src, unsigned x, unsigned y,
+static void subimage_alpha_with_fill(const uint16_t *src, unsigned x, unsigned y,
                                unsigned stride, unsigned width, unsigned height, uint16_t *dst,
                                unsigned dst_width, unsigned dst_height, int is_interlaced, int is_top_field)
 {
@@ -544,7 +544,7 @@ static int encode_slice(AVCodecContext *avctx, const AVFrame *pic, int mb_x,
     ProresContext* ctx = avctx->priv_data;
     int hdr_size = 6 + (ctx->need_alpha * 2); /* v data size is write when there is alpha */
     int ret = 0, slice_size;
-    uint8_t *dest_y, *dest_u, *dest_v;
+    const uint8_t *dest_y, *dest_u, *dest_v;
     unsigned y_data_size = 0, u_data_size = 0, v_data_size = 0, a_data_size = 0;
     FDCTDSPContext *fdsp = &ctx->fdsp;
     int tgt_bits   = (mb_count * bitrate_table[avctx->profile]) >> 2;
@@ -577,13 +577,13 @@ static int encode_slice(AVCodecContext *avctx, const AVFrame *pic, int mb_x,
     }
 
     if (unsafe) {
-        subimage_with_fill((uint16_t *) pic->data[0], mb_x << 4, mb_y << 4,
+        subimage_with_fill((const uint16_t *) pic->data[0], mb_x << 4, mb_y << 4,
                 luma_stride, avctx->width, avctx->height,
                 (uint16_t *) ctx->fill_y, mb_count << 4, 16, is_interlaced, is_top_field);
-        subimage_with_fill((uint16_t *) pic->data[1], mb_x << (4 - ctx->is_422), mb_y << 4,
+        subimage_with_fill((const uint16_t *) pic->data[1], mb_x << (4 - ctx->is_422), mb_y << 4,
                            chroma_stride, avctx->width >> ctx->is_422, avctx->height,
                            (uint16_t *) ctx->fill_u, mb_count << (4 - ctx->is_422), 16, is_interlaced, is_top_field);
-        subimage_with_fill((uint16_t *) pic->data[2], mb_x << (4 - ctx->is_422), mb_y << 4,
+        subimage_with_fill((const uint16_t *) pic->data[2], mb_x << (4 - ctx->is_422), mb_y << 4,
                            chroma_stride, avctx->width >> ctx->is_422, avctx->height,
                            (uint16_t *) ctx->fill_v, mb_count << (4 - ctx->is_422), 16, is_interlaced, is_top_field);
 
@@ -640,7 +640,7 @@ static int encode_slice(AVCodecContext *avctx, const AVFrame *pic, int mb_x,
     if (ctx->need_alpha) {
         AV_WB16(buf + 6, v_data_size); /* write v data size only if there is alpha */
 
-        subimage_alpha_with_fill((uint16_t *) pic->data[3], mb_x << 4, mb_y << 4,
+        subimage_alpha_with_fill((const uint16_t *) pic->data[3], mb_x << 4, mb_y << 4,
                            alpha_stride, avctx->width, avctx->height,
                            (uint16_t *) ctx->fill_a, mb_count << 4, 16, is_interlaced, is_top_field);
         ret = encode_alpha_slice_data(avctx, ctx->fill_a, mb_count,
@@ -953,7 +953,7 @@ const FFCodec ff_prores_aw_encoder = {
     .p.capabilities = AV_CODEC_CAP_FRAME_THREADS,
     .p.priv_class   = &prores_enc_class,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_prores_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_prores_encoder = {
@@ -969,5 +969,5 @@ const FFCodec ff_prores_encoder = {
     .p.capabilities = AV_CODEC_CAP_FRAME_THREADS,
     .p.priv_class   = &prores_enc_class,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_prores_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/proresenc_kostya.c b/libavcodec/proresenc_kostya.c
index 1062ca1..60bb228 100644
--- a/libavcodec/proresenc_kostya.c
+++ b/libavcodec/proresenc_kostya.c
@@ -135,6 +135,32 @@ static const uint8_t prores_quant_matrices[][64] = {
     },
 };
 
+static const uint8_t prores_dc_codebook[4] = {
+    0x04, // rice_order = 0, exp_golomb_order = 1, switch_bits = 0
+    0x28, // rice_order = 1, exp_golomb_order = 2, switch_bits = 0
+    0x4D, // rice_order = 2, exp_golomb_order = 3, switch_bits = 1
+    0x70  // rice_order = 3, exp_golomb_order = 4, switch_bits = 0
+};
+
+static const uint8_t prores_ac_codebook[7] = {
+    0x04, // rice_order = 0, exp_golomb_order = 1, switch_bits = 0
+    0x28, // rice_order = 1, exp_golomb_order = 2, switch_bits = 0
+    0x4C, // rice_order = 2, exp_golomb_order = 3, switch_bits = 0
+    0x05, // rice_order = 0, exp_golomb_order = 1, switch_bits = 1
+    0x29, // rice_order = 1, exp_golomb_order = 2, switch_bits = 1
+    0x06, // rice_order = 0, exp_golomb_order = 1, switch_bits = 2
+    0x0A, // rice_order = 0, exp_golomb_order = 2, switch_bits = 2
+};
+
+/**
+ * Lookup tables for adaptive switching between codebooks
+ * according with previous run/level value.
+ */
+static const uint8_t prores_run_to_cb_index[16] =
+    { 5, 5, 3, 3, 0, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 2 };
+
+static const uint8_t prores_lev_to_cb_index[10] = { 0, 6, 3, 5, 0, 1, 1, 1, 1, 2 };
+
 #define NUM_MB_LIMITS 4
 static const int prores_mb_limits[NUM_MB_LIMITS] = {
     1620, // up to 720x576
@@ -423,7 +449,7 @@ static void encode_dcs(PutBitContext *pb, int16_t *blocks,
         new_sign = GET_SIGN(delta);
         delta    = (delta ^ sign) - sign;
         code     = MAKE_CODE(delta);
-        encode_vlc_codeword(pb, ff_prores_dc_codebook[codebook], code);
+        encode_vlc_codeword(pb, prores_dc_codebook[codebook], code);
         codebook = (code + (code & 1)) >> 1;
         codebook = FFMIN(codebook, 3);
         sign     = new_sign;
@@ -441,8 +467,8 @@ static void encode_acs(PutBitContext *pb, int16_t *blocks,
     int max_coeffs, abs_level;
 
     max_coeffs = blocks_per_slice << 6;
-    run_cb     = ff_prores_run_to_cb_index[4];
-    lev_cb     = ff_prores_lev_to_cb_index[2];
+    run_cb     = prores_run_to_cb_index[4];
+    lev_cb     = prores_lev_to_cb_index[2];
     run        = 0;
 
     for (i = 1; i < 64; i++) {
@@ -450,13 +476,13 @@ static void encode_acs(PutBitContext *pb, int16_t *blocks,
             level = blocks[idx] / qmat[scan[i]];
             if (level) {
                 abs_level = FFABS(level);
-                encode_vlc_codeword(pb, ff_prores_ac_codebook[run_cb], run);
-                encode_vlc_codeword(pb, ff_prores_ac_codebook[lev_cb],
+                encode_vlc_codeword(pb, prores_ac_codebook[run_cb], run);
+                encode_vlc_codeword(pb, prores_ac_codebook[lev_cb],
                                     abs_level - 1);
                 put_sbits(pb, 1, GET_SIGN(level));
 
-                run_cb = ff_prores_run_to_cb_index[FFMIN(run, 15)];
-                lev_cb = ff_prores_lev_to_cb_index[FFMIN(abs_level, 9)];
+                run_cb = prores_run_to_cb_index[FFMIN(run, 15)];
+                lev_cb = prores_lev_to_cb_index[FFMIN(abs_level, 9)];
                 run    = 0;
             } else {
                 run++;
@@ -667,7 +693,7 @@ static int estimate_dcs(int *error, int16_t *blocks, int blocks_per_slice,
         new_sign = GET_SIGN(delta);
         delta    = (delta ^ sign) - sign;
         code     = MAKE_CODE(delta);
-        bits    += estimate_vlc(ff_prores_dc_codebook[codebook], code);
+        bits    += estimate_vlc(prores_dc_codebook[codebook], code);
         codebook = (code + (code & 1)) >> 1;
         codebook = FFMIN(codebook, 3);
         sign     = new_sign;
@@ -687,8 +713,8 @@ static int estimate_acs(int *error, int16_t *blocks, int blocks_per_slice,
     int bits = 0;
 
     max_coeffs = blocks_per_slice << 6;
-    run_cb     = ff_prores_run_to_cb_index[4];
-    lev_cb     = ff_prores_lev_to_cb_index[2];
+    run_cb     = prores_run_to_cb_index[4];
+    lev_cb     = prores_lev_to_cb_index[2];
     run        = 0;
 
     for (i = 1; i < 64; i++) {
@@ -697,12 +723,12 @@ static int estimate_acs(int *error, int16_t *blocks, int blocks_per_slice,
             *error += FFABS(blocks[idx]) % qmat[scan[i]];
             if (level) {
                 abs_level = FFABS(level);
-                bits += estimate_vlc(ff_prores_ac_codebook[run_cb], run);
-                bits += estimate_vlc(ff_prores_ac_codebook[lev_cb],
+                bits += estimate_vlc(prores_ac_codebook[run_cb], run);
+                bits += estimate_vlc(prores_ac_codebook[lev_cb],
                                      abs_level - 1) + 1;
 
-                run_cb = ff_prores_run_to_cb_index[FFMIN(run, 15)];
-                lev_cb = ff_prores_lev_to_cb_index[FFMIN(abs_level, 9)];
+                run_cb = prores_run_to_cb_index[FFMIN(run, 15)];
+                lev_cb = prores_lev_to_cb_index[FFMIN(abs_level, 9)];
                 run    = 0;
             } else {
                 run++;
@@ -1409,5 +1435,5 @@ const FFCodec ff_prores_ks_encoder = {
                       },
     .p.priv_class   = &proresenc_class,
     .p.profiles     = NULL_IF_CONFIG_SMALL(ff_prores_profiles),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/prosumer.c b/libavcodec/prosumer.c
index 8a91d5e..c038b9d 100644
--- a/libavcodec/prosumer.c
+++ b/libavcodec/prosumer.c
@@ -375,6 +375,5 @@ const FFCodec ff_prosumer_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .close          = decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/pthread_frame.c b/libavcodec/pthread_frame.c
index 43d6cc8..726bd1b 100644
--- a/libavcodec/pthread_frame.c
+++ b/libavcodec/pthread_frame.c
@@ -147,12 +147,6 @@ typedef struct FrameThreadContext {
                                     * Set for the first N packets, where N is the number of threads.
                                     * While it is set, ff_thread_en/decode_frame won't return any results.
                                     */
-
-    /* hwaccel state is temporarily stored here in order to transfer its ownership
-     * to the next decoding thread without the need for extra synchronization */
-    const AVHWAccel *stash_hwaccel;
-    void            *stash_hwaccel_context;
-    void            *stash_hwaccel_priv;
 } FrameThreadContext;
 
 #if FF_API_THREAD_SAFE_CALLBACKS
@@ -233,17 +227,9 @@ FF_ENABLE_DEPRECATION_WARNINGS
             ff_thread_finish_setup(avctx);
 
         if (p->hwaccel_serializing) {
-            /* wipe hwaccel state to avoid stale pointers lying around;
-             * the state was transferred to FrameThreadContext in
-             * ff_thread_finish_setup(), so nothing is leaked */
-            avctx->hwaccel                     = NULL;
-            avctx->hwaccel_context             = NULL;
-            avctx->internal->hwaccel_priv_data = NULL;
-
             p->hwaccel_serializing = 0;
             pthread_mutex_unlock(&p->parent->hwaccel_mutex);
         }
-        av_assert0(!avctx->hwaccel);
 
         if (p->async_serializing) {
             p->async_serializing = 0;
@@ -307,6 +293,9 @@ static int update_context_from_thread(AVCodecContext *dst, AVCodecContext *src,
         dst->color_range = src->color_range;
         dst->chroma_sample_location = src->chroma_sample_location;
 
+        dst->hwaccel = src->hwaccel;
+        dst->hwaccel_context = src->hwaccel_context;
+
         dst->sample_rate    = src->sample_rate;
         dst->sample_fmt     = src->sample_fmt;
 #if FF_API_OLD_CHANNEL_LAYOUT
@@ -319,6 +308,8 @@ FF_ENABLE_DEPRECATION_WARNINGS
         if (err < 0)
             return err;
 
+        dst->internal->hwaccel_priv_data = src->internal->hwaccel_priv_data;
+
         if (!!dst->hw_frames_ctx != !!src->hw_frames_ctx ||
             (dst->hw_frames_ctx && dst->hw_frames_ctx->data != src->hw_frames_ctx->data)) {
             av_buffer_unref(&dst->hw_frames_ctx);
@@ -460,12 +451,6 @@ static int submit_packet(PerThreadContext *p, AVCodecContext *user_avctx,
         }
     }
 
-    /* transfer the stashed hwaccel state, if any */
-    av_assert0(!p->avctx->hwaccel);
-    FFSWAP(const AVHWAccel*, p->avctx->hwaccel,                     fctx->stash_hwaccel);
-    FFSWAP(void*,            p->avctx->hwaccel_context,             fctx->stash_hwaccel_context);
-    FFSWAP(void*,            p->avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
-
     av_packet_unref(p->avpkt);
     ret = av_packet_ref(p->avpkt, avpkt);
     if (ret < 0) {
@@ -630,7 +615,7 @@ void ff_thread_report_progress(ThreadFrame *f, int n, int field)
     pthread_mutex_unlock(&p->progress_mutex);
 }
 
-void ff_thread_await_progress(ThreadFrame *f, int n, int field)
+void ff_thread_await_progress(const ThreadFrame *f, int n, int field)
 {
     PerThreadContext *p;
     atomic_int *progress = f->progress ? (atomic_int*)f->progress->data : NULL;
@@ -669,14 +654,6 @@ void ff_thread_finish_setup(AVCodecContext *avctx) {
         async_lock(p->parent);
     }
 
-    /* save hwaccel state for passing to the next thread;
-     * this is done here so that this worker thread can wipe its own hwaccel
-     * state after decoding, without requiring synchronization */
-    av_assert0(!p->parent->stash_hwaccel);
-    p->parent->stash_hwaccel         = avctx->hwaccel;
-    p->parent->stash_hwaccel_context = avctx->hwaccel_context;
-    p->parent->stash_hwaccel_priv    = avctx->internal->hwaccel_priv_data;
-
     pthread_mutex_lock(&p->progress_mutex);
     if(atomic_load(&p->state) == STATE_SETUP_FINISHED){
         av_log(avctx, AV_LOG_WARNING, "Multiple ff_thread_finish_setup() calls\n");
@@ -730,6 +707,13 @@ void ff_frame_thread_free(AVCodecContext *avctx, int thread_count)
 
     park_frame_worker_threads(fctx, thread_count);
 
+    if (fctx->prev_thread && avctx->internal->hwaccel_priv_data !=
+                             fctx->prev_thread->avctx->internal->hwaccel_priv_data) {
+        if (update_context_from_thread(avctx, fctx->prev_thread->avctx, 1) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to update user thread.\n");
+        }
+    }
+
     for (i = 0; i < thread_count; i++) {
         PerThreadContext *p = &fctx->threads[i];
         AVCodecContext *ctx = p->avctx;
@@ -776,13 +760,6 @@ void ff_frame_thread_free(AVCodecContext *avctx, int thread_count)
     av_freep(&fctx->threads);
     ff_pthread_free(fctx, thread_ctx_offsets);
 
-    /* if we have stashed hwaccel state, move it to the user-facing context,
-     * so it will be freed in avcodec_close() */
-    av_assert0(!avctx->hwaccel);
-    FFSWAP(const AVHWAccel*, avctx->hwaccel,                     fctx->stash_hwaccel);
-    FFSWAP(void*,            avctx->hwaccel_context,             fctx->stash_hwaccel_context);
-    FFSWAP(void*,            avctx->internal->hwaccel_priv_data, fctx->stash_hwaccel_priv);
-
     av_freep(&avctx->internal->thread_ctx);
 }
 
@@ -993,7 +970,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
 
     pthread_mutex_lock(&p->parent->buffer_mutex);
 #if !FF_API_THREAD_SAFE_CALLBACKS
-    err = ff_get_buffer(avctx, f->f, flags);
+    err = ff_get_buffer(avctx, f, flags);
 #else
 FF_DISABLE_DEPRECATION_WARNINGS
     if (THREAD_SAFE_CALLBACKS(avctx)) {
@@ -1114,7 +1091,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
         av_log(avctx, AV_LOG_DEBUG, "thread_release_buffer called on pic %p\n", f);
 
 #if !FF_API_THREAD_SAFE_CALLBACKS
-    av_frame_unref(f->f);
+    av_frame_unref(f);
 #else
     // when the frame buffers are not allocated, just reset it to clean state
     if (can_direct_free || !f->buf[0]) {
diff --git a/libavcodec/pthread_slice.c b/libavcodec/pthread_slice.c
index e341161..a4d31c6 100644
--- a/libavcodec/pthread_slice.c
+++ b/libavcodec/pthread_slice.c
@@ -237,14 +237,16 @@ void ff_thread_await_progress2(AVCodecContext *avctx, int field, int thread, int
     pthread_mutex_unlock(&progress->mutex);
 }
 
-int ff_alloc_entries(AVCodecContext *avctx, int count)
+int ff_slice_thread_allocz_entries(AVCodecContext *avctx, int count)
 {
     if (avctx->active_thread_type & FF_THREAD_SLICE)  {
         SliceThreadContext *p = avctx->internal->thread_ctx;
 
-        if (p->entries) {
-            av_freep(&p->entries);
+        if (p->entries_count == count) {
+            memset(p->entries, 0, p->entries_count * sizeof(*p->entries));
+            return 0;
         }
+        av_freep(&p->entries);
 
         p->entries       = av_calloc(count, sizeof(*p->entries));
         if (!p->entries) {
@@ -256,9 +258,3 @@ int ff_alloc_entries(AVCodecContext *avctx, int count)
 
     return 0;
 }
-
-void ff_reset_entries(AVCodecContext *avctx)
-{
-    SliceThreadContext *p = avctx->internal->thread_ctx;
-    memset(p->entries, 0, p->entries_count * sizeof(int));
-}
diff --git a/libavcodec/qcelpdec.c b/libavcodec/qcelpdec.c
index 1a4d308..8a46ec5 100644
--- a/libavcodec/qcelpdec.c
+++ b/libavcodec/qcelpdec.c
@@ -799,5 +799,4 @@ const FFCodec ff_qcelp_decoder = {
     FF_CODEC_DECODE_CB(qcelp_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .priv_data_size = sizeof(QCELPContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/qdm2.c b/libavcodec/qdm2.c
index 427e8e8..12db585 100644
--- a/libavcodec/qdm2.c
+++ b/libavcodec/qdm2.c
@@ -1879,5 +1879,4 @@ const FFCodec ff_qdm2_decoder = {
     .close            = qdm2_decode_close,
     FF_CODEC_DECODE_CB(qdm2_decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/qdmc.c b/libavcodec/qdmc.c
index f24e94b..0a66d66 100644
--- a/libavcodec/qdmc.c
+++ b/libavcodec/qdmc.c
@@ -739,5 +739,4 @@ const FFCodec ff_qdmc_decoder = {
     FF_CODEC_DECODE_CB(qdmc_decode_frame),
     .flush            = qdmc_flush,
     .p.capabilities   = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/qoienc.c b/libavcodec/qoienc.c
index bd13767..110297d 100644
--- a/libavcodec/qoienc.c
+++ b/libavcodec/qoienc.c
@@ -33,7 +33,8 @@ static int qoi_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     uint8_t px[4] = { 0, 0, 0, 255 };
     uint8_t index[64][4] = { 0 };
     int64_t packet_size;
-    uint8_t *buf, *src;
+    uint8_t *buf;
+    const uint8_t *src;
     int ret, run = 0;
 
     packet_size = avctx->width * avctx->height * (channels + 1LL) + 14LL + 8LL;
@@ -136,5 +137,4 @@ const FFCodec ff_qoi_encoder = {
         AV_PIX_FMT_RGBA, AV_PIX_FMT_RGB24,
         AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/qpeg.c b/libavcodec/qpeg.c
index 9e787cb..ea92b69 100644
--- a/libavcodec/qpeg.c
+++ b/libavcodec/qpeg.c
@@ -362,6 +362,5 @@ const FFCodec ff_qpeg_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .flush          = decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/qsv.c b/libavcodec/qsv.c
index 385b43b..3449789 100644
--- a/libavcodec/qsv.c
+++ b/libavcodec/qsv.c
@@ -18,9 +18,8 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <mfx/mfxvideo.h>
-#include <mfx/mfxplugin.h>
-#include <mfx/mfxjpeg.h>
+#include <mfxvideo.h>
+#include <mfxjpeg.h>
 
 #include <stdio.h>
 #include <string.h>
@@ -37,8 +36,20 @@
 #include "qsv_internal.h"
 
 #define MFX_IMPL_VIA_MASK(impl) (0x0f00 & (impl))
+#define QSV_HAVE_USER_PLUGIN    !QSV_ONEVPL
+#define QSV_HAVE_AUDIO          !QSV_ONEVPL
 
-#include "mfx/mfxvp8.h"
+#include "mfxvp8.h"
+
+#if QSV_HAVE_USER_PLUGIN
+#include <mfxplugin.h>
+#endif
+
+#if QSV_ONEVPL
+#include <mfxdispatcher.h>
+#else
+#define MFXUnload(a) do { } while(0)
+#endif
 
 int ff_qsv_codec_id_to_mfx(enum AVCodecID codec_id)
 {
@@ -76,10 +87,14 @@ static const struct {
 } qsv_iopatterns[] = {
     {MFX_IOPATTERN_IN_VIDEO_MEMORY,     "input is video memory surface"         },
     {MFX_IOPATTERN_IN_SYSTEM_MEMORY,    "input is system memory surface"        },
+#if QSV_HAVE_OPAQUE
     {MFX_IOPATTERN_IN_OPAQUE_MEMORY,    "input is opaque memory surface"        },
+#endif
     {MFX_IOPATTERN_OUT_VIDEO_MEMORY,    "output is video memory surface"        },
     {MFX_IOPATTERN_OUT_SYSTEM_MEMORY,   "output is system memory surface"       },
+#if QSV_HAVE_OPAQUE
     {MFX_IOPATTERN_OUT_OPAQUE_MEMORY,   "output is opaque memory surface"       },
+#endif
 };
 
 int ff_qsv_print_iopattern(void *log_ctx, int mfx_iopattern,
@@ -125,8 +140,12 @@ static const struct {
     { MFX_ERR_INVALID_VIDEO_PARAM,      AVERROR(EINVAL), "invalid video parameters"             },
     { MFX_ERR_UNDEFINED_BEHAVIOR,       AVERROR_BUG,     "undefined behavior"                   },
     { MFX_ERR_DEVICE_FAILED,            AVERROR(EIO),    "device failed"                        },
+#if QSV_HAVE_AUDIO
     { MFX_ERR_INCOMPATIBLE_AUDIO_PARAM, AVERROR(EINVAL), "incompatible audio parameters"        },
     { MFX_ERR_INVALID_AUDIO_PARAM,      AVERROR(EINVAL), "invalid audio parameters"             },
+#endif
+    { MFX_ERR_GPU_HANG,                 AVERROR(EIO),    "GPU Hang"                             },
+    { MFX_ERR_REALLOC_SURFACE,          AVERROR_UNKNOWN, "need bigger surface for output"       },
 
     { MFX_WRN_IN_EXECUTION,             0,               "operation in execution"               },
     { MFX_WRN_DEVICE_BUSY,              0,               "device busy"                          },
@@ -136,7 +155,13 @@ static const struct {
     { MFX_WRN_VALUE_NOT_CHANGED,        0,               "value is saturated"                   },
     { MFX_WRN_OUT_OF_RANGE,             0,               "value out of range"                   },
     { MFX_WRN_FILTER_SKIPPED,           0,               "filter skipped"                       },
+#if QSV_HAVE_AUDIO
     { MFX_WRN_INCOMPATIBLE_AUDIO_PARAM, 0,               "incompatible audio parameters"        },
+#endif
+
+#if QSV_VERSION_ATLEAST(1, 31)
+    { MFX_ERR_NONE_PARTIAL_OUTPUT,      0,               "partial output"                       },
+#endif
 };
 
 /**
@@ -323,6 +348,7 @@ enum AVPictureType ff_qsv_map_pictype(int mfx_pic_type)
 static int qsv_load_plugins(mfxSession session, const char *load_plugins,
                             void *logctx)
 {
+#if QSV_HAVE_USER_PLUGIN
     if (!load_plugins || !*load_plugins)
         return 0;
 
@@ -366,6 +392,7 @@ load_plugin_fail:
         if (err < 0)
             return err;
     }
+#endif
 
     return 0;
 
@@ -404,6 +431,193 @@ static int ff_qsv_set_display_handle(AVCodecContext *avctx, QSVSession *qs)
 }
 #endif //AVCODEC_QSV_LINUX_SESSION_HANDLE
 
+#if QSV_ONEVPL
+static int qsv_new_mfx_loader(AVCodecContext *avctx,
+                              mfxIMPL implementation,
+                              mfxVersion *pver,
+                              void **ploader)
+{
+    mfxStatus sts;
+    mfxLoader loader = NULL;
+    mfxConfig cfg;
+    mfxVariant impl_value;
+
+    loader = MFXLoad();
+    if (!loader) {
+        av_log(avctx, AV_LOG_ERROR, "Error creating a MFX loader\n");
+        goto fail;
+    }
+
+    /* Create configurations for implementation */
+    cfg = MFXCreateConfig(loader);
+    if (!cfg) {
+        av_log(avctx, AV_LOG_ERROR, "Error creating a MFX configurations\n");
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U32;
+    impl_value.Data.U32 = (implementation == MFX_IMPL_SOFTWARE) ?
+        MFX_IMPL_TYPE_SOFTWARE : MFX_IMPL_TYPE_HARDWARE;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxImplDescription.Impl", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(avctx, AV_LOG_ERROR, "Error adding a MFX configuration "
+               "property: %d\n", sts);
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U32;
+    impl_value.Data.U32 = pver->Version;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxImplDescription.ApiVersion.Version",
+                                     impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(avctx, AV_LOG_ERROR, "Error adding a MFX configuration "
+               "property: %d\n", sts);
+        goto fail;
+    }
+
+    *ploader = loader;
+
+    return 0;
+
+fail:
+    if (loader)
+        MFXUnload(loader);
+
+    *ploader = NULL;
+    return AVERROR_UNKNOWN;
+}
+
+static int qsv_create_mfx_session_from_loader(void *ctx, mfxLoader loader, mfxSession *psession)
+{
+    mfxStatus sts;
+    mfxSession session = NULL;
+    uint32_t impl_idx = 0;
+
+    while (1) {
+        /* Enumerate all implementations */
+        mfxImplDescription *impl_desc;
+
+        sts = MFXEnumImplementations(loader, impl_idx,
+                                     MFX_IMPLCAPS_IMPLDESCSTRUCTURE,
+                                     (mfxHDL *)&impl_desc);
+        /* Failed to find an available implementation */
+        if (sts == MFX_ERR_NOT_FOUND)
+            break;
+        else if (sts != MFX_ERR_NONE) {
+            impl_idx++;
+            continue;
+        }
+
+        sts = MFXCreateSession(loader, impl_idx, &session);
+        MFXDispReleaseImplDescription(loader, impl_desc);
+        if (sts == MFX_ERR_NONE)
+            break;
+
+        impl_idx++;
+    }
+
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error creating a MFX session: %d.\n", sts);
+        goto fail;
+    }
+
+    *psession = session;
+
+    return 0;
+
+fail:
+    if (session)
+        MFXClose(session);
+
+    *psession = NULL;
+    return AVERROR_UNKNOWN;
+}
+
+static int qsv_create_mfx_session(AVCodecContext *avctx,
+                                  mfxIMPL implementation,
+                                  mfxVersion *pver,
+                                  int gpu_copy,
+                                  mfxSession *psession,
+                                  void **ploader)
+{
+    mfxLoader loader = NULL;
+
+    /* Don't create a new MFX loader if the input loader is valid */
+    if (*ploader == NULL) {
+        av_log(avctx, AV_LOG_VERBOSE,
+               "Use Intel(R) oneVPL to create MFX session, the required "
+               "implementation version is %d.%d\n",
+               pver->Major, pver->Minor);
+
+        if (qsv_new_mfx_loader(avctx, implementation, pver, (void **)&loader))
+            goto fail;
+
+        av_assert0(loader);
+    } else {
+        av_log(avctx, AV_LOG_VERBOSE,
+               "Use Intel(R) oneVPL to create MFX session with the specified MFX loader\n");
+
+        loader = *ploader;
+    }
+
+    if (qsv_create_mfx_session_from_loader(avctx, loader, psession))
+        goto fail;
+
+    if (!*ploader)
+        *ploader = loader;
+
+    return 0;
+
+fail:
+    if (!*ploader && loader)
+        MFXUnload(loader);
+
+    return AVERROR_UNKNOWN;
+}
+
+#else
+
+static int qsv_create_mfx_session(AVCodecContext *avctx,
+                                  mfxIMPL implementation,
+                                  mfxVersion *pver,
+                                  int gpu_copy,
+                                  mfxSession *psession,
+                                  void **ploader)
+{
+    mfxInitParam init_par = { MFX_IMPL_AUTO_ANY };
+    mfxSession session = NULL;
+    mfxStatus sts;
+
+    av_log(avctx, AV_LOG_VERBOSE,
+           "Use Intel(R) Media SDK to create MFX session, the required "
+           "implementation version is %d.%d\n",
+           pver->Major, pver->Minor);
+
+    *psession = NULL;
+    *ploader = NULL;
+
+    init_par.GPUCopy = gpu_copy;
+    init_par.Implementation = implementation;
+    init_par.Version = *pver;
+    sts = MFXInitEx(init_par, &session);
+    if (sts < 0)
+        return ff_qsv_print_error(avctx, sts,
+                                  "Error initializing a MFX session");
+    else if (sts > 0) {
+        ff_qsv_print_warning(avctx, sts,
+                             "Warning in MFX initialization");
+        return AVERROR_UNKNOWN;
+    }
+
+    *psession = session;
+
+    return 0;
+}
+
+#endif
+
 int ff_qsv_init_internal_session(AVCodecContext *avctx, QSVSession *qs,
                                  const char *load_plugins, int gpu_copy)
 {
@@ -413,18 +627,12 @@ int ff_qsv_init_internal_session(AVCodecContext *avctx, QSVSession *qs,
     mfxIMPL          impl = MFX_IMPL_AUTO_ANY;
 #endif
     mfxVersion        ver = { { QSV_VERSION_MINOR, QSV_VERSION_MAJOR } };
-    mfxInitParam init_par = { MFX_IMPL_AUTO_ANY };
 
     const char *desc;
-    int ret;
-
-    init_par.GPUCopy        = gpu_copy;
-    init_par.Implementation = impl;
-    init_par.Version        = ver;
-    ret = MFXInitEx(init_par, &qs->session);
-    if (ret < 0)
-        return ff_qsv_print_error(avctx, ret,
-                                  "Error initializing an internal MFX session");
+    int ret = qsv_create_mfx_session(avctx, impl, &ver, gpu_copy, &qs->session,
+                                     &qs->loader);
+    if (ret)
+        return ret;
 
 #ifdef AVCODEC_QSV_LINUX_SESSION_HANDLE
     ret = ff_qsv_set_display_handle(avctx, qs);
@@ -728,7 +936,7 @@ int ff_qsv_init_session_device(AVCodecContext *avctx, mfxSession *psession,
     AVHWDeviceContext    *device_ctx = (AVHWDeviceContext*)device_ref->data;
     AVQSVDeviceContext *device_hwctx = device_ctx->hwctx;
     mfxSession        parent_session = device_hwctx->session;
-    mfxInitParam            init_par = { MFX_IMPL_AUTO_ANY };
+    void                     *loader = device_hwctx->loader;
     mfxHDL                    handle = NULL;
     int          hw_handle_supported = 0;
 
@@ -769,13 +977,10 @@ int ff_qsv_init_session_device(AVCodecContext *avctx, mfxSession *psession,
                "from the session\n");
     }
 
-    init_par.GPUCopy        = gpu_copy;
-    init_par.Implementation = impl;
-    init_par.Version        = ver;
-    err = MFXInitEx(init_par, &session);
-    if (err != MFX_ERR_NONE)
-        return ff_qsv_print_error(avctx, err,
-                                  "Error initializing a child MFX session");
+    ret = qsv_create_mfx_session(avctx, impl, &ver, gpu_copy, &session,
+                                 &loader);
+    if (ret)
+        return ret;
 
     if (handle) {
         err = MFXVideoCORE_SetHandle(session, handle_type, handle);
@@ -854,6 +1059,12 @@ int ff_qsv_close_internal_session(QSVSession *qs)
         MFXClose(qs->session);
         qs->session = NULL;
     }
+
+    if (qs->loader) {
+        MFXUnload(qs->loader);
+        qs->loader = NULL;
+    }
+
 #ifdef AVCODEC_QSV_LINUX_SESSION_HANDLE
     av_buffer_unref(&qs->va_device_ref);
 #endif
diff --git a/libavcodec/qsv.h b/libavcodec/qsv.h
index b77158e..c156b08 100644
--- a/libavcodec/qsv.h
+++ b/libavcodec/qsv.h
@@ -21,7 +21,7 @@
 #ifndef AVCODEC_QSV_H
 #define AVCODEC_QSV_H
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/buffer.h"
 
@@ -61,6 +61,8 @@ typedef struct AVQSVContext {
      * required by the encoder and the user-provided value nb_opaque_surfaces.
      * The array of the opaque surfaces will be exported to the caller through
      * the opaque_surfaces field.
+     *
+     * The caller must set this field to zero for oneVPL (MFX_VERSION >= 2.0)
      */
     int opaque_alloc;
 
diff --git a/libavcodec/qsv_internal.h b/libavcodec/qsv_internal.h
index 8131acd..f914956 100644
--- a/libavcodec/qsv_internal.h
+++ b/libavcodec/qsv_internal.h
@@ -39,7 +39,7 @@
 #include "libavutil/hwcontext_vaapi.h"
 #endif
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/frame.h"
 
@@ -65,6 +65,9 @@
     ((MFX_VERSION.Major > (MAJOR)) ||                           \
     (MFX_VERSION.Major == (MAJOR) && MFX_VERSION.Minor >= (MINOR)))
 
+#define QSV_ONEVPL       QSV_VERSION_ATLEAST(2, 0)
+#define QSV_HAVE_OPAQUE  !QSV_ONEVPL
+
 typedef struct QSVMid {
     AVBufferRef *hw_frames_ref;
     mfxHDLPair *handle_pair;
@@ -100,6 +103,7 @@ typedef struct QSVSession {
     AVBufferRef *va_device_ref;
     AVHWDeviceContext *va_device_ctx;
 #endif
+    void *loader;
 } QSVSession;
 
 typedef struct QSVFramesContext {
diff --git a/libavcodec/qsvdec.c b/libavcodec/qsvdec.c
index 5fc5bed..89ec5dc 100644
--- a/libavcodec/qsvdec.c
+++ b/libavcodec/qsvdec.c
@@ -27,7 +27,7 @@
 #include <string.h>
 #include <sys/types.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/common.h"
 #include "libavutil/fifo.h"
@@ -50,6 +50,12 @@
 #include "qsv.h"
 #include "qsv_internal.h"
 
+#if QSV_ONEVPL
+#include <mfxdispatcher.h>
+#else
+#define MFXUnload(a) do { } while(0)
+#endif
+
 static const AVRational mfx_tb = { 1, 90000 };
 
 #define PTS_TO_MFX_PTS(pts, pts_tb) ((pts) == AV_NOPTS_VALUE ? \
@@ -187,7 +193,11 @@ static int qsv_init_session(AVCodecContext *avctx, QSVContext *q, mfxSession ses
 
         ret = ff_qsv_init_session_frames(avctx, &q->internal_qs.session,
                                          &q->frames_ctx, q->load_plugins,
+#if QSV_HAVE_OPAQUE
                                          q->iopattern == MFX_IOPATTERN_OUT_OPAQUE_MEMORY,
+#else
+                                         0,
+#endif
                                          q->gpu_copy);
         if (ret < 0) {
             av_buffer_unref(&q->frames_ctx.hw_frames_ctx);
@@ -227,6 +237,11 @@ static int qsv_init_session(AVCodecContext *avctx, QSVContext *q, mfxSession ses
             q->internal_qs.session = NULL;
         }
 
+        if (q->internal_qs.loader) {
+            MFXUnload(q->internal_qs.loader);
+            q->internal_qs.loader = NULL;
+        }
+
         return AVERROR_EXTERNAL;
     }
 
@@ -300,10 +315,15 @@ static int qsv_decode_preinit(AVCodecContext *avctx, QSVContext *q, enum AVPixel
         AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
 
         if (!iopattern) {
+#if QSV_HAVE_OPAQUE
             if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)
                 iopattern = MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
             else if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)
                 iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;
+#else
+            if (frames_hwctx->frame_type & MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET)
+                iopattern = MFX_IOPATTERN_OUT_VIDEO_MEMORY;
+#endif
         }
     }
 
@@ -1025,6 +1045,7 @@ const FFCodec ff_##x##_qsv_decoder = { \
                                                     AV_PIX_FMT_NONE }, \
     .hw_configs     = qsv_hw_configs, \
     .p.wrapper_name = "qsv", \
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE, \
 }; \
 
 #define DEFINE_QSV_DECODER(x, X, bsf_name) DEFINE_QSV_DECODER_WITH_OPTION(x, X, bsf_name, options)
diff --git a/libavcodec/qsvenc.c b/libavcodec/qsvenc.c
index 2382c2f..4831640 100644
--- a/libavcodec/qsvenc.c
+++ b/libavcodec/qsvenc.c
@@ -25,7 +25,7 @@
 
 #include <string.h>
 #include <sys/types.h>
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/common.h"
 #include "libavutil/hwcontext.h"
@@ -141,7 +141,9 @@ static const struct {
 #if QSV_HAVE_VCM
     { MFX_RATECONTROL_VCM,     "VCM" },
 #endif
+#if !QSV_ONEVPL
     { MFX_RATECONTROL_LA_EXT,  "LA_EXT" },
+#endif
     { MFX_RATECONTROL_LA_HRD,  "LA_HRD" },
     { MFX_RATECONTROL_QVBR,    "QVBR" },
 };
@@ -182,6 +184,7 @@ static void dump_video_param(AVCodecContext *avctx, QSVEncContext *q,
     mfxExtCodingOption2 *co2 = NULL;
     mfxExtCodingOption3 *co3 = NULL;
     mfxExtHEVCTiles *exthevctiles = NULL;
+    const char *tmp_str = NULL;
 
     if (q->co2_idx > 0)
         co2 = (mfxExtCodingOption2*)coding_opts[q->co2_idx];
@@ -195,13 +198,12 @@ static void dump_video_param(AVCodecContext *avctx, QSVEncContext *q,
     av_log(avctx, AV_LOG_VERBOSE, "profile: %s; level: %"PRIu16"\n",
            print_profile(avctx->codec_id, info->CodecProfile), info->CodecLevel);
 
-    av_log(avctx, AV_LOG_VERBOSE, "GopPicSize: %"PRIu16"; GopRefDist: %"PRIu16"; GopOptFlag: ",
-           info->GopPicSize, info->GopRefDist);
-    if (info->GopOptFlag & MFX_GOP_CLOSED)
-        av_log(avctx, AV_LOG_VERBOSE, "closed ");
-    if (info->GopOptFlag & MFX_GOP_STRICT)
-        av_log(avctx, AV_LOG_VERBOSE, "strict ");
-    av_log(avctx, AV_LOG_VERBOSE, "; IdrInterval: %"PRIu16"\n", info->IdrInterval);
+    av_log(avctx, AV_LOG_VERBOSE,
+           "GopPicSize: %"PRIu16"; GopRefDist: %"PRIu16"; GopOptFlag:%s%s; IdrInterval: %"PRIu16"\n",
+           info->GopPicSize, info->GopRefDist,
+           info->GopOptFlag & MFX_GOP_CLOSED ? " closed" : "",
+           info->GopOptFlag & MFX_GOP_STRICT ? " strict" : "",
+           info->IdrInterval);
 
     av_log(avctx, AV_LOG_VERBOSE, "TargetUsage: %"PRIu16"; RateControlMethod: %s\n",
            info->TargetUsage, print_ratecontrol(info->RateControlMethod));
@@ -269,45 +271,46 @@ static void dump_video_param(AVCodecContext *avctx, QSVEncContext *q,
         av_log(avctx, AV_LOG_VERBOSE, "IntRefType: %"PRIu16"; IntRefCycleSize: %"PRIu16"; IntRefQPDelta: %"PRId16"\n",
                co2->IntRefType, co2->IntRefCycleSize, co2->IntRefQPDelta);
 
-        av_log(avctx, AV_LOG_VERBOSE, "MaxFrameSize: %d; ", co2->MaxFrameSize);
-        av_log(avctx, AV_LOG_VERBOSE, "MaxSliceSize: %d; ", co2->MaxSliceSize);
-        av_log(avctx, AV_LOG_VERBOSE, "\n");
+        av_log(avctx, AV_LOG_VERBOSE, "MaxFrameSize: %d; MaxSliceSize: %d\n",
+               co2->MaxFrameSize, co2->MaxSliceSize);
 
         av_log(avctx, AV_LOG_VERBOSE,
                "BitrateLimit: %s; MBBRC: %s; ExtBRC: %s\n",
                print_threestate(co2->BitrateLimit), print_threestate(co2->MBBRC),
                print_threestate(co2->ExtBRC));
 
-        av_log(avctx, AV_LOG_VERBOSE, "Trellis: ");
         if (co2->Trellis & MFX_TRELLIS_OFF) {
-            av_log(avctx, AV_LOG_VERBOSE, "off");
+            av_log(avctx, AV_LOG_VERBOSE, "Trellis: off\n");
         } else if (!co2->Trellis) {
-            av_log(avctx, AV_LOG_VERBOSE, "auto");
+            av_log(avctx, AV_LOG_VERBOSE, "Trellis: auto\n");
         } else {
-            if (co2->Trellis & MFX_TRELLIS_I) av_log(avctx, AV_LOG_VERBOSE, "I");
-            if (co2->Trellis & MFX_TRELLIS_P) av_log(avctx, AV_LOG_VERBOSE, "P");
-            if (co2->Trellis & MFX_TRELLIS_B) av_log(avctx, AV_LOG_VERBOSE, "B");
+            char trellis_type[4];
+            int i = 0;
+            if (co2->Trellis & MFX_TRELLIS_I) trellis_type[i++] = 'I';
+            if (co2->Trellis & MFX_TRELLIS_P) trellis_type[i++] = 'P';
+            if (co2->Trellis & MFX_TRELLIS_B) trellis_type[i++] = 'B';
+            trellis_type[i] = 0;
+            av_log(avctx, AV_LOG_VERBOSE, "Trellis: %s\n", trellis_type);
         }
-        av_log(avctx, AV_LOG_VERBOSE, "\n");
 
-        av_log(avctx, AV_LOG_VERBOSE,
-               "RepeatPPS: %s; NumMbPerSlice: %"PRIu16"; LookAheadDS: ",
-               print_threestate(co2->RepeatPPS), co2->NumMbPerSlice);
         switch (co2->LookAheadDS) {
-        case MFX_LOOKAHEAD_DS_OFF: av_log(avctx, AV_LOG_VERBOSE, "off");     break;
-        case MFX_LOOKAHEAD_DS_2x:  av_log(avctx, AV_LOG_VERBOSE, "2x");      break;
-        case MFX_LOOKAHEAD_DS_4x:  av_log(avctx, AV_LOG_VERBOSE, "4x");      break;
-        default:                   av_log(avctx, AV_LOG_VERBOSE, "unknown"); break;
+        case MFX_LOOKAHEAD_DS_OFF: tmp_str = "off";     break;
+        case MFX_LOOKAHEAD_DS_2x:  tmp_str = "2x";      break;
+        case MFX_LOOKAHEAD_DS_4x:  tmp_str = "4x";      break;
+        default:                   tmp_str = "unknown"; break;
         }
-        av_log(avctx, AV_LOG_VERBOSE, "\n");
+        av_log(avctx, AV_LOG_VERBOSE,
+               "RepeatPPS: %s; NumMbPerSlice: %"PRIu16"; LookAheadDS: %s\n",
+               print_threestate(co2->RepeatPPS), co2->NumMbPerSlice, tmp_str);
 
-        av_log(avctx, AV_LOG_VERBOSE, "AdaptiveI: %s; AdaptiveB: %s; BRefType: ",
-               print_threestate(co2->AdaptiveI), print_threestate(co2->AdaptiveB));
         switch (co2->BRefType) {
-        case MFX_B_REF_OFF:     av_log(avctx, AV_LOG_VERBOSE, "off");       break;
-        case MFX_B_REF_PYRAMID: av_log(avctx, AV_LOG_VERBOSE, "pyramid");   break;
-        default:                av_log(avctx, AV_LOG_VERBOSE, "auto");      break;
+        case MFX_B_REF_OFF:     tmp_str = "off";       break;
+        case MFX_B_REF_PYRAMID: tmp_str = "pyramid";   break;
+        default:                tmp_str = "auto";      break;
         }
+        av_log(avctx, AV_LOG_VERBOSE,
+               "AdaptiveI: %s; AdaptiveB: %s; BRefType:%s\n",
+               print_threestate(co2->AdaptiveI), print_threestate(co2->AdaptiveB), tmp_str);
 
         av_log(avctx, AV_LOG_VERBOSE,
                "MinQPI: %"PRIu8"; MaxQPI: %"PRIu8"; MinQPP: %"PRIu8"; MaxQPP: %"PRIu8"; MinQPB: %"PRIu8"; MaxQPB: %"PRIu8"\n",
@@ -319,14 +322,12 @@ static void dump_video_param(AVCodecContext *avctx, QSVEncContext *q,
         if (info->RateControlMethod == MFX_RATECONTROL_QVBR)
             av_log(avctx, AV_LOG_VERBOSE, "QVBRQuality: %"PRIu16"\n", co3->QVBRQuality);
 
-        av_log(avctx, AV_LOG_VERBOSE, "PRefType: ");
         switch (co3->PRefType) {
-        case MFX_P_REF_DEFAULT: av_log(avctx, AV_LOG_VERBOSE, "default");   break;
-        case MFX_P_REF_SIMPLE:  av_log(avctx, AV_LOG_VERBOSE, "simple");    break;
-        case MFX_P_REF_PYRAMID: av_log(avctx, AV_LOG_VERBOSE, "pyramid");   break;
-        default:                av_log(avctx, AV_LOG_VERBOSE, "unknown");   break;
+        case MFX_P_REF_DEFAULT: av_log(avctx, AV_LOG_VERBOSE, "PRefType: default\n");   break;
+        case MFX_P_REF_SIMPLE:  av_log(avctx, AV_LOG_VERBOSE, "PRefType: simple\n");    break;
+        case MFX_P_REF_PYRAMID: av_log(avctx, AV_LOG_VERBOSE, "PRefType: pyramid\n");   break;
+        default:                av_log(avctx, AV_LOG_VERBOSE, "PRefType: unknown\n");   break;
         }
-        av_log(avctx, AV_LOG_VERBOSE, "\n");
 
         if (avctx->codec_id == AV_CODEC_ID_HEVC)
             av_log(avctx, AV_LOG_VERBOSE,"GPB: %s\n", print_threestate(co3->GPB));
@@ -360,13 +361,12 @@ static void dump_video_vp9_param(AVCodecContext *avctx, QSVEncContext *q,
     av_log(avctx, AV_LOG_VERBOSE, "profile: %s \n",
            print_profile(avctx->codec_id, info->CodecProfile));
 
-    av_log(avctx, AV_LOG_VERBOSE, "GopPicSize: %"PRIu16"; GopRefDist: %"PRIu16"; GopOptFlag: ",
-           info->GopPicSize, info->GopRefDist);
-    if (info->GopOptFlag & MFX_GOP_CLOSED)
-        av_log(avctx, AV_LOG_VERBOSE, "closed ");
-    if (info->GopOptFlag & MFX_GOP_STRICT)
-        av_log(avctx, AV_LOG_VERBOSE, "strict ");
-    av_log(avctx, AV_LOG_VERBOSE, "; IdrInterval: %"PRIu16"\n", info->IdrInterval);
+    av_log(avctx, AV_LOG_VERBOSE,
+           "GopPicSize: %"PRIu16"; GopRefDist: %"PRIu16"; GopOptFlag:%s%s; IdrInterval: %"PRIu16"\n",
+           info->GopPicSize, info->GopRefDist,
+           info->GopOptFlag & MFX_GOP_CLOSED ? " closed" : "",
+           info->GopOptFlag & MFX_GOP_STRICT ? " strict" : "",
+           info->IdrInterval);
 
     av_log(avctx, AV_LOG_VERBOSE, "TargetUsage: %"PRIu16"; RateControlMethod: %s\n",
            info->TargetUsage, print_ratecontrol(info->RateControlMethod));
@@ -396,8 +396,7 @@ static void dump_video_vp9_param(AVCodecContext *avctx, QSVEncContext *q,
                "IntRefType: %"PRIu16"; IntRefCycleSize: %"PRIu16"; IntRefQPDelta: %"PRId16"\n",
                co2->IntRefType, co2->IntRefCycleSize, co2->IntRefQPDelta);
 
-        av_log(avctx, AV_LOG_VERBOSE, "MaxFrameSize: %d; ", co2->MaxFrameSize);
-        av_log(avctx, AV_LOG_VERBOSE, "\n");
+        av_log(avctx, AV_LOG_VERBOSE, "MaxFrameSize: %d\n", co2->MaxFrameSize);
 
         av_log(avctx, AV_LOG_VERBOSE,
                "BitrateLimit: %s; MBBRC: %s; ExtBRC: %s\n",
@@ -738,6 +737,11 @@ static int init_video_param(AVCodecContext *avctx, QSVEncContext *q)
         q->param.mfx.QPI = av_clip(quant * fabs(avctx->i_quant_factor) + avctx->i_quant_offset, 0, 51);
         q->param.mfx.QPP = av_clip(quant, 0, 51);
         q->param.mfx.QPB = av_clip(quant * fabs(avctx->b_quant_factor) + avctx->b_quant_offset, 0, 51);
+        q->old_global_quality = avctx->global_quality;
+        q->old_i_quant_factor = avctx->i_quant_factor;
+        q->old_i_quant_offset = avctx->i_quant_offset;
+        q->old_b_quant_factor = avctx->b_quant_factor;
+        q->old_b_quant_offset = avctx->b_quant_offset;
 
         break;
 #if QSV_HAVE_AVBR
@@ -1172,6 +1176,7 @@ static int qsv_retrieve_enc_params(AVCodecContext *avctx, QSVEncContext *q)
     return 0;
 }
 
+#if QSV_HAVE_OPAQUE
 static int qsv_init_opaque_alloc(AVCodecContext *avctx, QSVEncContext *q)
 {
     AVQSVContext *qsv = avctx->hwaccel_context;
@@ -1208,6 +1213,7 @@ static int qsv_init_opaque_alloc(AVCodecContext *avctx, QSVEncContext *q)
 
     return 0;
 }
+#endif
 
 static int qsvenc_init_session(AVCodecContext *avctx, QSVEncContext *q)
 {
@@ -1223,7 +1229,11 @@ static int qsvenc_init_session(AVCodecContext *avctx, QSVEncContext *q)
 
         ret = ff_qsv_init_session_frames(avctx, &q->internal_qs.session,
                                          &q->frames_ctx, q->load_plugins,
+#if QSV_HAVE_OPAQUE
                                          q->param.IOPattern == MFX_IOPATTERN_IN_OPAQUE_MEMORY,
+#else
+                                         0,
+#endif
                                          MFX_GPUCOPY_OFF);
         if (ret < 0) {
             av_buffer_unref(&q->frames_ctx.hw_frames_ctx);
@@ -1275,11 +1285,17 @@ int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q)
         AVQSVFramesContext *frames_hwctx = frames_ctx->hwctx;
 
         if (!iopattern) {
+#if QSV_HAVE_OPAQUE
             if (frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)
                 iopattern = MFX_IOPATTERN_IN_OPAQUE_MEMORY;
             else if (frames_hwctx->frame_type &
                      (MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET | MFX_MEMTYPE_VIDEO_MEMORY_PROCESSOR_TARGET))
                 iopattern = MFX_IOPATTERN_IN_VIDEO_MEMORY;
+#else
+            if (frames_hwctx->frame_type &
+                (MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET | MFX_MEMTYPE_VIDEO_MEMORY_PROCESSOR_TARGET))
+                iopattern = MFX_IOPATTERN_IN_VIDEO_MEMORY;
+#endif
         }
     }
 
@@ -1353,9 +1369,16 @@ int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q)
                                   "Error querying (IOSurf) the encoding parameters");
 
     if (opaque_alloc) {
+#if QSV_HAVE_OPAQUE
         ret = qsv_init_opaque_alloc(avctx, q);
         if (ret < 0)
             return ret;
+#else
+        av_log(avctx, AV_LOG_ERROR, "User is requesting to allocate OPAQUE surface, "
+               "however libmfx %d.%d doesn't support OPAQUE memory.\n",
+               q->ver.Major, q->ver.Minor);
+        return AVERROR_UNKNOWN;
+#endif
     }
 
     ret = MFXVideoENCODE_Init(q->session, &q->param);
@@ -1621,38 +1644,31 @@ static int set_roi_encode_ctrl(AVCodecContext *avctx, const AVFrame *frame,
     return 0;
 }
 
-static int update_qp(AVCodecContext *avctx, QSVEncContext *q,
-                     const AVFrame *frame)
+static int update_qp(AVCodecContext *avctx, QSVEncContext *q)
 {
-    int updated = 0, qp = 0, new_qp;
-    char *tail;
-    AVDictionaryEntry *entry = NULL;
+    int updated = 0, new_qp = 0;
 
     if (avctx->codec_id != AV_CODEC_ID_H264 && avctx->codec_id != AV_CODEC_ID_HEVC)
         return 0;
 
-    entry = av_dict_get(frame->metadata, "qsv_config_qp", NULL, 0);
-    if (entry && q->param.mfx.RateControlMethod == MFX_RATECONTROL_CQP) {
-        qp = strtol(entry->value, &tail, 10);
-        if (*tail) {
-            av_log(avctx, AV_LOG_WARNING, "Invalid qsv_config_qp string. Ignore this metadata\n");
+    if (q->param.mfx.RateControlMethod == MFX_RATECONTROL_CQP) {
+        UPDATE_PARAM(q->old_global_quality, avctx->global_quality);
+        UPDATE_PARAM(q->old_i_quant_factor, avctx->i_quant_factor);
+        UPDATE_PARAM(q->old_i_quant_offset, avctx->i_quant_offset);
+        UPDATE_PARAM(q->old_b_quant_factor, avctx->b_quant_factor);
+        UPDATE_PARAM(q->old_b_quant_offset, avctx->b_quant_offset);
+        if (!updated)
             return 0;
-        }
-        if (qp < 0 || qp > 51) {
-            av_log(avctx, AV_LOG_WARNING, "Invalid qp, clip to 0 ~ 51\n");
-            qp = av_clip(qp, 0, 51);
-        }
-        av_log(avctx, AV_LOG_DEBUG, "Configure qp: %d\n",qp);
-        UPDATE_PARAM(q->param.mfx.QPP, qp);
-        new_qp = av_clip(qp * fabs(avctx->i_quant_factor) +
-                            avctx->i_quant_offset, 0, 51);
-        UPDATE_PARAM(q->param.mfx.QPI, new_qp);
-        new_qp = av_clip(qp * fabs(avctx->b_quant_factor) +
-                            avctx->b_quant_offset, 0, 51);
-        UPDATE_PARAM(q->param.mfx.QPB, new_qp);
+
+        new_qp = avctx->global_quality / FF_QP2LAMBDA;
+        q->param.mfx.QPI = av_clip(new_qp * fabs(avctx->i_quant_factor) +
+                                    avctx->i_quant_offset, 0, 51);
+        q->param.mfx.QPP = av_clip(new_qp, 0, 51);
+        q->param.mfx.QPB = av_clip(new_qp * fabs(avctx->b_quant_factor) +
+                                    avctx->b_quant_offset, 0, 51);
         av_log(avctx, AV_LOG_DEBUG,
-                "using fixed qp = %d/%d/%d for idr/p/b frames\n",
-                q->param.mfx.QPI, q->param.mfx.QPP, q->param.mfx.QPB);
+               "Reset qp = %d/%d/%d for idr/p/b frames\n",
+               q->param.mfx.QPI, q->param.mfx.QPP, q->param.mfx.QPB);
     }
     return updated;
 }
@@ -1665,7 +1681,7 @@ static int update_parameters(AVCodecContext *avctx, QSVEncContext *q,
     if (!frame)
         return 0;
 
-    needReset = update_qp(avctx, q, frame);
+    needReset = update_qp(avctx, q);
     if (!needReset)
         return 0;
 
@@ -1916,8 +1932,10 @@ int ff_qsv_enc_close(AVCodecContext *avctx, QSVEncContext *q)
         av_fifo_freep2(&q->async_fifo);
     }
 
+#if QSV_HAVE_OPAQUE
     av_freep(&q->opaque_surfaces);
     av_buffer_unref(&q->opaque_alloc_buf);
+#endif
 
     av_freep(&q->extparam);
 
diff --git a/libavcodec/qsvenc.h b/libavcodec/qsvenc.h
index b754ac4..d35a131 100644
--- a/libavcodec/qsvenc.h
+++ b/libavcodec/qsvenc.h
@@ -26,8 +26,11 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
+#include "libavutil/common.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_qsv.h"
 #include "libavutil/avutil.h"
 #include "libavutil/fifo.h"
 
@@ -44,7 +47,7 @@
 #else
 #define QSV_HAVE_AVBR   0
 #define QSV_HAVE_VCM    0
-#define QSV_HAVE_MF     1
+#define QSV_HAVE_MF     !QSV_ONEVPL
 #endif
 
 #define QSV_COMMON_OPTS \
@@ -137,9 +140,11 @@ typedef struct QSVEncContext {
     mfxExtHEVCTiles exthevctiles;
     mfxExtVP9Param  extvp9param;
 
+#if QSV_HAVE_OPAQUE
     mfxExtOpaqueSurfaceAlloc opaque_alloc;
     mfxFrameSurface1       **opaque_surfaces;
     AVBufferRef             *opaque_alloc_buf;
+#endif
 
     mfxExtVideoSignalInfo extvsi;
 
@@ -224,6 +229,12 @@ typedef struct QSVEncContext {
     int min_qp_p;
     int max_qp_b;
     int min_qp_b;
+    // These are used for qp reset
+    int old_global_quality;
+    float old_i_quant_factor;
+    float old_i_quant_offset;
+    float old_b_quant_factor;
+    float old_b_quant_offset;
 } QSVEncContext;
 
 int ff_qsv_enc_init(AVCodecContext *avctx, QSVEncContext *q);
diff --git a/libavcodec/qsvenc_h264.c b/libavcodec/qsvenc_h264.c
index 87b0936..ad9cf62 100644
--- a/libavcodec/qsvenc_h264.c
+++ b/libavcodec/qsvenc_h264.c
@@ -24,7 +24,7 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
@@ -32,7 +32,6 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "qsv.h"
-#include "qsv_internal.h"
 #include "qsvenc.h"
 #include "atsc_a53.h"
 
@@ -200,7 +199,8 @@ const FFCodec ff_h264_qsv_encoder = {
                                                     AV_PIX_FMT_NONE },
     .p.priv_class   = &class,
     .defaults       = qsv_enc_defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name = "qsv",
     .hw_configs     = ff_qsv_enc_hw_configs,
 };
diff --git a/libavcodec/qsvenc_hevc.c b/libavcodec/qsvenc_hevc.c
index f6027f6..e11f5de 100644
--- a/libavcodec/qsvenc_hevc.c
+++ b/libavcodec/qsvenc_hevc.c
@@ -22,7 +22,7 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
@@ -35,7 +35,6 @@
 #include "hevcdec.h"
 #include "h2645_parse.h"
 #include "qsv.h"
-#include "qsv_internal.h"
 #include "qsvenc.h"
 
 enum LoadPlugin {
@@ -315,7 +314,8 @@ const FFCodec ff_hevc_qsv_encoder = {
                                                     AV_PIX_FMT_NONE },
     .p.priv_class   = &class,
     .defaults       = qsv_enc_defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name = "qsv",
     .hw_configs     = ff_qsv_enc_hw_configs,
 };
diff --git a/libavcodec/qsvenc_jpeg.c b/libavcodec/qsvenc_jpeg.c
index 825eb8d..6d17d89 100644
--- a/libavcodec/qsvenc_jpeg.c
+++ b/libavcodec/qsvenc_jpeg.c
@@ -22,7 +22,7 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
@@ -30,7 +30,6 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "qsv.h"
-#include "qsv_internal.h"
 #include "qsvenc.h"
 
 typedef struct QSVMJPEGEncContext {
@@ -96,4 +95,5 @@ const FFCodec ff_mjpeg_qsv_encoder = {
     .defaults       = qsv_enc_defaults,
     .p.wrapper_name = "qsv",
     .hw_configs     = ff_qsv_enc_hw_configs,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE,
 };
diff --git a/libavcodec/qsvenc_mpeg2.c b/libavcodec/qsvenc_mpeg2.c
index 5cb12a2..5666b3e 100644
--- a/libavcodec/qsvenc_mpeg2.c
+++ b/libavcodec/qsvenc_mpeg2.c
@@ -22,7 +22,7 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
@@ -30,7 +30,6 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "qsv.h"
-#include "qsv_internal.h"
 #include "qsvenc.h"
 
 typedef struct QSVMpeg2EncContext {
@@ -108,7 +107,8 @@ const FFCodec ff_mpeg2_qsv_encoder = {
                                                     AV_PIX_FMT_NONE },
     .p.priv_class   = &class,
     .defaults       = qsv_enc_defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name = "qsv",
     .hw_configs     = ff_qsv_enc_hw_configs,
 };
diff --git a/libavcodec/qsvenc_vp9.c b/libavcodec/qsvenc_vp9.c
index 4b2a6ce..c738da3 100644
--- a/libavcodec/qsvenc_vp9.c
+++ b/libavcodec/qsvenc_vp9.c
@@ -22,7 +22,7 @@
 #include <stdint.h>
 #include <sys/types.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "libavutil/common.h"
 #include "libavutil/opt.h"
@@ -30,7 +30,6 @@
 #include "avcodec.h"
 #include "codec_internal.h"
 #include "qsv.h"
-#include "qsv_internal.h"
 #include "qsvenc.h"
 
 typedef struct QSVVP9EncContext {
@@ -118,7 +117,8 @@ const FFCodec ff_vp9_qsv_encoder = {
                                                     AV_PIX_FMT_NONE },
     .p.priv_class   = &class,
     .defaults       = qsv_enc_defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name = "qsv",
     .hw_configs     = ff_qsv_enc_hw_configs,
 };
diff --git a/libavcodec/qtrle.c b/libavcodec/qtrle.c
index 5e2139c..2c070c0 100644
--- a/libavcodec/qtrle.c
+++ b/libavcodec/qtrle.c
@@ -592,5 +592,4 @@ const FFCodec ff_qtrle_decoder = {
     FF_CODEC_DECODE_CB(qtrle_decode_frame),
     .flush          = qtrle_decode_flush,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/qtrleenc.c b/libavcodec/qtrleenc.c
index 21c19ed..e0b1ecb 100644
--- a/libavcodec/qtrleenc.c
+++ b/libavcodec/qtrleenc.c
@@ -411,5 +411,5 @@ const FFCodec ff_qtrle_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]){
         AV_PIX_FMT_RGB24, AV_PIX_FMT_RGB555BE, AV_PIX_FMT_ARGB, AV_PIX_FMT_GRAY8, AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/r210dec.c b/libavcodec/r210dec.c
index b95f663..5ac285f 100644
--- a/libavcodec/r210dec.c
+++ b/libavcodec/r210dec.c
@@ -111,7 +111,6 @@ const FFCodec ff_r210_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_R10K_DECODER
@@ -123,7 +122,6 @@ const FFCodec ff_r10k_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_AVRP_DECODER
@@ -135,6 +133,5 @@ const FFCodec ff_avrp_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/r210enc.c b/libavcodec/r210enc.c
index cfff21c..139e5b7 100644
--- a/libavcodec/r210enc.c
+++ b/libavcodec/r210enc.c
@@ -47,7 +47,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     int aligned_width = FFALIGN(avctx->width,
                                 avctx->codec_id == AV_CODEC_ID_R10K ? 1 : 64);
     int pad = (aligned_width - avctx->width) * 4;
-    uint8_t *srcr_line, *srcg_line, *srcb_line;
+    const uint8_t *srcr_line, *srcg_line, *srcb_line;
     uint8_t *dst;
 
     ret = ff_get_encode_buffer(avctx, pkt, 4 * aligned_width * avctx->height, 0);
@@ -60,9 +60,9 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     dst = pkt->data;
 
     for (i = 0; i < avctx->height; i++) {
-        uint16_t *srcr = (uint16_t *)srcr_line;
-        uint16_t *srcg = (uint16_t *)srcg_line;
-        uint16_t *srcb = (uint16_t *)srcb_line;
+        const uint16_t *srcr = (const uint16_t *)srcr_line;
+        const uint16_t *srcg = (const uint16_t *)srcg_line;
+        const uint16_t *srcb = (const uint16_t *)srcb_line;
         for (j = 0; j < avctx->width; j++) {
             uint32_t pixel;
             unsigned r = *srcr++;
@@ -100,7 +100,6 @@ const FFCodec ff_r210_encoder = {
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = pix_fmt,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_R10K_ENCODER
@@ -113,7 +112,6 @@ const FFCodec ff_r10k_encoder = {
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = pix_fmt,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_AVRP_ENCODER
@@ -126,6 +124,5 @@ const FFCodec ff_avrp_encoder = {
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = pix_fmt,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/ra144dec.c b/libavcodec/ra144dec.c
index bef6389..a56d4f7 100644
--- a/libavcodec/ra144dec.c
+++ b/libavcodec/ra144dec.c
@@ -135,5 +135,4 @@ const FFCodec ff_ra_144_decoder = {
     .init           = ra144_decode_init,
     FF_CODEC_DECODE_CB(ra144_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ra144enc.c b/libavcodec/ra144enc.c
index 66ac381..1608b94 100644
--- a/libavcodec/ra144enc.c
+++ b/libavcodec/ra144enc.c
@@ -553,5 +553,4 @@ const FFCodec ff_ra_144_encoder = {
     .p.channel_layouts = (const uint64_t[]) { AV_CH_LAYOUT_MONO, 0 },
 #endif
     .p.ch_layouts   = (const AVChannelLayout[]){ AV_CHANNEL_LAYOUT_MONO, { 0 } },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ra288.c b/libavcodec/ra288.c
index 24d976f..4b2cc18 100644
--- a/libavcodec/ra288.c
+++ b/libavcodec/ra288.c
@@ -246,5 +246,4 @@ const FFCodec ff_ra_288_decoder = {
     .init           = ra288_decode_init,
     FF_CODEC_DECODE_CB(ra288_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ralf.c b/libavcodec/ralf.c
index 16cb524..ff4556b 100644
--- a/libavcodec/ralf.c
+++ b/libavcodec/ralf.c
@@ -527,5 +527,5 @@ const FFCodec ff_ralf_decoder = {
                       AV_CODEC_CAP_DR1,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/rasc.c b/libavcodec/rasc.c
index bcb619f..805e293 100644
--- a/libavcodec/rasc.c
+++ b/libavcodec/rasc.c
@@ -808,7 +808,6 @@ const FFCodec ff_rasc_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .flush            = decode_flush,
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .p.priv_class     = &rasc_decoder_class,
 };
diff --git a/libavcodec/ratecontrol.c b/libavcodec/ratecontrol.c
index a7614d7..4829172 100644
--- a/libavcodec/ratecontrol.c
+++ b/libavcodec/ratecontrol.c
@@ -49,8 +49,8 @@ void ff_write_pass1_stats(MpegEncContext *s)
              s->misc_bits,
              s->f_code,
              s->b_code,
-             s->current_picture.mc_mb_var_sum,
-             s->current_picture.mb_var_sum,
+             s->mc_mb_var_sum,
+             s->mb_var_sum,
              s->i_count, s->skip_count,
              s->header_bits);
 }
@@ -751,15 +751,14 @@ static void adaptive_quantization(MpegEncContext *s, double q)
     float *bits_tab                  = s->bits_tab;
     const int qmin                   = s->avctx->mb_lmin;
     const int qmax                   = s->avctx->mb_lmax;
-    Picture *const pic               = &s->current_picture;
     const int mb_width               = s->mb_width;
     const int mb_height              = s->mb_height;
 
     for (i = 0; i < s->mb_num; i++) {
         const int mb_xy = s->mb_index2xy[i];
-        float temp_cplx = sqrt(pic->mc_mb_var[mb_xy]); // FIXME merge in pow()
-        float spat_cplx = sqrt(pic->mb_var[mb_xy]);
-        const int lumi  = pic->mb_mean[mb_xy];
+        float temp_cplx = sqrt(s->mc_mb_var[mb_xy]); // FIXME merge in pow()
+        float spat_cplx = sqrt(s->mb_var[mb_xy]);
+        const int lumi  = s->mb_mean[mb_xy];
         float bits, cplx, factor;
         int mb_x = mb_xy % s->mb_stride;
         int mb_y = mb_xy / s->mb_stride;
@@ -881,7 +880,6 @@ float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run)
     double rate_factor;
     int64_t var;
     const int pict_type = s->pict_type;
-    Picture * const pic = &s->current_picture;
     emms_c();
 
     get_qminmax(&qmin, &qmax, s, pict_type);
@@ -930,7 +928,7 @@ float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run)
     if (br_compensation <= 0.0)
         br_compensation = 0.001;
 
-    var = pict_type == AV_PICTURE_TYPE_I ? pic->mb_var_sum : pic->mc_mb_var_sum;
+    var = pict_type == AV_PICTURE_TYPE_I ? s->mb_var_sum : s->mc_mb_var_sum;
 
     short_term_q = 0; /* avoid warning */
     if (s->avctx->flags & AV_CODEC_FLAG_PASS2) {
@@ -943,8 +941,8 @@ float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run)
     } else {
         rce->pict_type     =
         rce->new_pict_type = pict_type;
-        rce->mc_mb_var_sum = pic->mc_mb_var_sum;
-        rce->mb_var_sum    = pic->mb_var_sum;
+        rce->mc_mb_var_sum = s->mc_mb_var_sum;
+        rce->mb_var_sum    = s->mb_var_sum;
         rce->qscale        = FF_QP2LAMBDA * 2;
         rce->f_code        = s->f_code;
         rce->b_code        = s->b_code;
@@ -1004,7 +1002,7 @@ float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run)
                qmin, q, qmax, picture_number,
                wanted_bits / 1000, s->total_bits / 1000,
                br_compensation, short_term_q, s->frame_bits,
-               pic->mb_var_sum, pic->mc_mb_var_sum,
+               s->mb_var_sum, s->mc_mb_var_sum,
                s->bit_rate / 1000, (int)fps);
     }
 
@@ -1020,8 +1018,8 @@ float ff_rate_estimate_qscale(MpegEncContext *s, int dry_run)
 
     if (!dry_run) {
         rcc->last_qscale        = q;
-        rcc->last_mc_mb_var_sum = pic->mc_mb_var_sum;
-        rcc->last_mb_var_sum    = pic->mb_var_sum;
+        rcc->last_mc_mb_var_sum = s->mc_mb_var_sum;
+        rcc->last_mb_var_sum    = s->mb_var_sum;
     }
     return q;
 }
diff --git a/libavcodec/raw.c b/libavcodec/raw.c
index a371bb3..1e5b48d 100644
--- a/libavcodec/raw.c
+++ b/libavcodec/raw.c
@@ -72,6 +72,7 @@ static const PixelFormatTag raw_pix_fmt_tags[] = {
     { AV_PIX_FMT_GRAY8,   MKTAG('G', 'R', 'E', 'Y') },
     { AV_PIX_FMT_NV12,    MKTAG('N', 'V', '1', '2') },
     { AV_PIX_FMT_NV21,    MKTAG('N', 'V', '2', '1') },
+    { AV_PIX_FMT_VUYA,    MKTAG('A', 'Y', 'U', 'V') }, /* MS 4:4:4:4 */
 
     /* nut */
     { AV_PIX_FMT_RGB555LE, MKTAG('R', 'G', 'B', 15) },
diff --git a/libavcodec/rawdec.c b/libavcodec/rawdec.c
index c10b20d..e1bb542 100644
--- a/libavcodec/rawdec.c
+++ b/libavcodec/rawdec.c
@@ -234,7 +234,7 @@ static int raw_decode(AVCodecContext *avctx, AVFrame *frame,
         return res;
 
     frame->pkt_pos      = avctx->internal->last_pkt_props->pos;
-    frame->pkt_duration = avctx->internal->last_pkt_props->duration;
+    frame->duration     = avctx->internal->last_pkt_props->duration;
 
     if (context->tff >= 0) {
         frame->interlaced_frame = 1;
@@ -491,5 +491,4 @@ const FFCodec ff_rawvideo_decoder = {
     FF_CODEC_DECODE_CB(raw_decode),
     .p.priv_class   = &rawdec_class,
     .p.capabilities = AV_CODEC_CAP_PARAM_CHANGE,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/rawenc.c b/libavcodec/rawenc.c
index 34d7a1b..826102e 100644
--- a/libavcodec/rawenc.c
+++ b/libavcodec/rawenc.c
@@ -89,5 +89,4 @@ const FFCodec ff_rawvideo_encoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
     .init           = raw_encode_init,
     FF_CODEC_ENCODE_CB(raw_encode),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/realtextdec.c b/libavcodec/realtextdec.c
index c3e138a..f78c822 100644
--- a/libavcodec/realtextdec.c
+++ b/libavcodec/realtextdec.c
@@ -83,5 +83,4 @@ const FFCodec ff_realtext_decoder = {
     .init           = ff_ass_subtitle_header_default,
     .flush          = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index d4f09f4..852f694 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -19,533 +19,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include <drm_fourcc.h>
-#include <pthread.h>
-#include <rockchip/mpp_buffer.h>
-#include <rockchip/rk_mpi.h>
-#include <time.h>
-#include <unistd.h>
+#include "libavrkmpp/avrkmpp.h"
 
-#include "avcodec.h"
 #include "codec_internal.h"
 #include "decode.h"
 #include "hwconfig.h"
-#include "libavutil/buffer.h"
-#include "libavutil/common.h"
-#include "libavutil/frame.h"
-#include "libavutil/hwcontext.h"
-#include "libavutil/hwcontext_drm.h"
-#include "libavutil/imgutils.h"
-#include "libavutil/log.h"
-
-#define RECEIVE_FRAME_TIMEOUT   100
-#define FRAMEGROUP_MAX_FRAMES   16
-#define INPUT_MAX_PACKETS       4
-
-typedef struct {
-    MppCtx ctx;
-    MppApi *mpi;
-    MppBufferGroup frame_group;
-
-    char first_packet;
-    char eos_reached;
-
-    AVBufferRef *frames_ref;
-    AVBufferRef *device_ref;
-} RKMPPDecoder;
-
-typedef struct {
-    AVClass *av_class;
-    AVBufferRef *decoder_ref;
-} RKMPPDecodeContext;
-
-typedef struct {
-    MppFrame frame;
-    AVBufferRef *decoder_ref;
-} RKMPPFrameContext;
-
-static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
-{
-    switch (avctx->codec_id) {
-    case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
-    case AV_CODEC_ID_HEVC:          return MPP_VIDEO_CodingHEVC;
-    case AV_CODEC_ID_VP8:           return MPP_VIDEO_CodingVP8;
-    case AV_CODEC_ID_VP9:           return MPP_VIDEO_CodingVP9;
-    default:                        return MPP_VIDEO_CodingUnused;
-    }
-}
-
-static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
-{
-    switch (mppformat) {
-    case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
-#ifdef DRM_FORMAT_NV12_10
-    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV12_10;
-#endif
-    default:                        return 0;
-    }
-}
-
-static int rkmpp_write_data(AVCodecContext *avctx, uint8_t *buffer, int size, int64_t pts)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
-    MppPacket packet;
-
-    // create the MPP packet
-    ret = mpp_packet_init(&packet, buffer, size);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
-        return AVERROR_UNKNOWN;
-    }
-
-    mpp_packet_set_pts(packet, pts);
-
-    if (!buffer)
-        mpp_packet_set_eos(packet);
-
-    ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
-    if (ret != MPP_OK) {
-        if (ret == MPP_ERR_BUFFER_FULL) {
-            av_log(avctx, AV_LOG_DEBUG, "Buffer full writing %d bytes to decoder\n", size);
-            ret = AVERROR(EAGAIN);
-        } else
-            ret = AVERROR_UNKNOWN;
-    }
-    else
-        av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", size);
-
-    mpp_packet_deinit(&packet);
-
-    return ret;
-}
-
-static int rkmpp_close_decoder(AVCodecContext *avctx)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    av_buffer_unref(&rk_context->decoder_ref);
-    return 0;
-}
-
-static void rkmpp_release_decoder(void *opaque, uint8_t *data)
-{
-    RKMPPDecoder *decoder = (RKMPPDecoder *)data;
-
-    if (decoder->mpi) {
-        decoder->mpi->reset(decoder->ctx);
-        mpp_destroy(decoder->ctx);
-        decoder->ctx = NULL;
-    }
-
-    if (decoder->frame_group) {
-        mpp_buffer_group_put(decoder->frame_group);
-        decoder->frame_group = NULL;
-    }
-
-    av_buffer_unref(&decoder->frames_ref);
-    av_buffer_unref(&decoder->device_ref);
-
-    av_free(decoder);
-}
-
-static int rkmpp_init_decoder(AVCodecContext *avctx)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = NULL;
-    MppCodingType codectype = MPP_VIDEO_CodingUnused;
-    int ret;
-    RK_S64 paramS64;
-    RK_S32 paramS32;
-
-    avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
-
-    // create a decoder and a ref to it
-    decoder = av_mallocz(sizeof(RKMPPDecoder));
-    if (!decoder) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
-    rk_context->decoder_ref = av_buffer_create((uint8_t *)decoder, sizeof(*decoder), rkmpp_release_decoder,
-                                               NULL, AV_BUFFER_FLAG_READONLY);
-    if (!rk_context->decoder_ref) {
-        av_free(decoder);
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-
-    av_log(avctx, AV_LOG_DEBUG, "Initializing RKMPP decoder.\n");
-
-    codectype = rkmpp_get_codingtype(avctx);
-    if (codectype == MPP_VIDEO_CodingUnused) {
-        av_log(avctx, AV_LOG_ERROR, "Unknown codec type (%d).\n", avctx->codec_id);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    ret = mpp_check_support_format(MPP_CTX_DEC, codectype);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Codec type (%d) unsupported by MPP\n", avctx->codec_id);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    // Create the MPP context
-    ret = mpp_create(&decoder->ctx, &decoder->mpi);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    // initialize mpp
-    ret = mpp_init(decoder->ctx, MPP_CTX_DEC, codectype);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to initialize MPP context (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    // make decode calls blocking with a timeout
-    paramS32 = MPP_POLL_BLOCK;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK, &paramS32);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set blocking mode on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    paramS64 = RECEIVE_FRAME_TIMEOUT;
-    ret = decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_BLOCK_TIMEOUT, &paramS64);
-    if (ret != MPP_OK) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set block timeout on MPI (code = %d).\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    ret = mpp_buffer_group_get_internal(&decoder->frame_group, MPP_BUFFER_TYPE_ION);
-    if (ret) {
-       av_log(avctx, AV_LOG_ERROR, "Failed to retrieve buffer group (code = %d)\n", ret);
-       ret = AVERROR_UNKNOWN;
-       goto fail;
-    }
-
-    ret = decoder->mpi->control(decoder->ctx, MPP_DEC_SET_EXT_BUF_GROUP, decoder->frame_group);
-    if (ret) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to assign buffer group (code = %d)\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    ret = mpp_buffer_group_limit_config(decoder->frame_group, 0, FRAMEGROUP_MAX_FRAMES);
-    if (ret) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to set buffer group limit (code = %d)\n", ret);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    decoder->first_packet = 1;
-
-    av_log(avctx, AV_LOG_DEBUG, "RKMPP decoder initialized successfully.\n");
-
-    decoder->device_ref = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_DRM);
-    if (!decoder->device_ref) {
-        ret = AVERROR(ENOMEM);
-        goto fail;
-    }
-    ret = av_hwdevice_ctx_init(decoder->device_ref);
-    if (ret < 0)
-        goto fail;
-
-    return 0;
-
-fail:
-    av_log(avctx, AV_LOG_ERROR, "Failed to initialize RKMPP decoder.\n");
-    rkmpp_close_decoder(avctx);
-    return ret;
-}
-
-static int rkmpp_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret;
-
-    // handle EOF
-    if (!avpkt->size) {
-        av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
-        decoder->eos_reached = 1;
-        ret = rkmpp_write_data(avctx, NULL, 0, 0);
-        if (ret)
-            av_log(avctx, AV_LOG_ERROR, "Failed to send EOS to decoder (code = %d)\n", ret);
-        return ret;
-    }
-
-    // on first packet, send extradata
-    if (decoder->first_packet) {
-        if (avctx->extradata_size) {
-            ret = rkmpp_write_data(avctx, avctx->extradata,
-                                            avctx->extradata_size,
-                                            avpkt->pts);
-            if (ret) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to write extradata to decoder (code = %d)\n", ret);
-                return ret;
-            }
-        }
-        decoder->first_packet = 0;
-    }
-
-    // now send packet
-    ret = rkmpp_write_data(avctx, avpkt->data, avpkt->size, avpkt->pts);
-    if (ret && ret!=AVERROR(EAGAIN))
-        av_log(avctx, AV_LOG_ERROR, "Failed to write data to decoder (code = %d)\n", ret);
-
-    return ret;
-}
-
-static void rkmpp_release_frame(void *opaque, uint8_t *data)
-{
-    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
-    AVBufferRef *framecontextref = (AVBufferRef *)opaque;
-    RKMPPFrameContext *framecontext = (RKMPPFrameContext *)framecontextref->data;
-
-    mpp_frame_deinit(&framecontext->frame);
-    av_buffer_unref(&framecontext->decoder_ref);
-    av_buffer_unref(&framecontextref);
-
-    av_free(desc);
-}
-
-static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    RKMPPFrameContext *framecontext = NULL;
-    AVBufferRef *framecontextref = NULL;
-    int ret;
-    MppFrame mppframe = NULL;
-    MppBuffer buffer = NULL;
-    AVDRMFrameDescriptor *desc = NULL;
-    AVDRMLayerDescriptor *layer = NULL;
-    int mode;
-    MppFrameFormat mppformat;
-    uint32_t drmformat;
-
-    ret = decoder->mpi->decode_get_frame(decoder->ctx, &mppframe);
-    if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_ERROR, "Failed to get a frame from MPP (code = %d)\n", ret);
-        goto fail;
-    }
-
-    if (mppframe) {
-        // Check whether we have a special frame or not
-        if (mpp_frame_get_info_change(mppframe)) {
-            AVHWFramesContext *hwframes;
-
-            av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), format=%d\n",
-                                        (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
-                                        (int)mpp_frame_get_fmt(mppframe));
-
-            avctx->width = mpp_frame_get_width(mppframe);
-            avctx->height = mpp_frame_get_height(mppframe);
-
-            decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
-
-            av_buffer_unref(&decoder->frames_ref);
-
-            decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
-            if (!decoder->frames_ref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
-
-            mppformat = mpp_frame_get_fmt(mppframe);
-            drmformat = rkmpp_get_frameformat(mppformat);
-
-            hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
-            hwframes->format    = AV_PIX_FMT_DRM_PRIME;
-            hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;
-            hwframes->width     = avctx->width;
-            hwframes->height    = avctx->height;
-            ret = av_hwframe_ctx_init(decoder->frames_ref);
-            if (ret < 0)
-                goto fail;
-
-            // here decoder is fully initialized, we need to feed it again with data
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_eos(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a EOS frame.\n");
-            decoder->eos_reached = 1;
-            ret = AVERROR_EOF;
-            goto fail;
-        } else if (mpp_frame_get_discard(mppframe)) {
-            av_log(avctx, AV_LOG_DEBUG, "Received a discard frame.\n");
-            ret = AVERROR(EAGAIN);
-            goto fail;
-        } else if (mpp_frame_get_errinfo(mppframe)) {
-            av_log(avctx, AV_LOG_ERROR, "Received a errinfo frame.\n");
-            ret = AVERROR_UNKNOWN;
-            goto fail;
-        }
-
-        // here we should have a valid frame
-        av_log(avctx, AV_LOG_DEBUG, "Received a frame.\n");
-
-        // setup general frame fields
-        frame->format           = AV_PIX_FMT_DRM_PRIME;
-        frame->width            = mpp_frame_get_width(mppframe);
-        frame->height           = mpp_frame_get_height(mppframe);
-        frame->pts              = mpp_frame_get_pts(mppframe);
-        frame->color_range      = mpp_frame_get_color_range(mppframe);
-        frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
-        frame->color_trc        = mpp_frame_get_color_trc(mppframe);
-        frame->colorspace       = mpp_frame_get_colorspace(mppframe);
-
-        mode = mpp_frame_get_mode(mppframe);
-        frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
-        frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
-
-        mppformat = mpp_frame_get_fmt(mppframe);
-        drmformat = rkmpp_get_frameformat(mppformat);
-
-        // now setup the frame buffer info
-        buffer = mpp_frame_get_buffer(mppframe);
-        if (buffer) {
-            desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
-            if (!desc) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
-
-            desc->nb_objects = 1;
-            desc->objects[0].fd = mpp_buffer_get_fd(buffer);
-            desc->objects[0].size = mpp_buffer_get_size(buffer);
-
-            desc->nb_layers = 1;
-            layer = &desc->layers[0];
-            layer->format = drmformat;
-            layer->nb_planes = 2;
-
-            layer->planes[0].object_index = 0;
-            layer->planes[0].offset = 0;
-            layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
-
-            layer->planes[1].object_index = 0;
-            layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
-            layer->planes[1].pitch = layer->planes[0].pitch;
-
-            // we also allocate a struct in buf[0] that will allow to hold additionnal information
-            // for releasing properly MPP frames and decoder
-            framecontextref = av_buffer_allocz(sizeof(*framecontext));
-            if (!framecontextref) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
-
-            // MPP decoder needs to be closed only when all frames have been released.
-            framecontext = (RKMPPFrameContext *)framecontextref->data;
-            framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
-            framecontext->frame = mppframe;
-
-            frame->data[0]  = (uint8_t *)desc;
-            frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
-                                               framecontextref, AV_BUFFER_FLAG_READONLY);
-
-            if (!frame->buf[0]) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
-
-            frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
-            if (!frame->hw_frames_ctx) {
-                ret = AVERROR(ENOMEM);
-                goto fail;
-            }
-
-            return 0;
-        } else {
-            av_log(avctx, AV_LOG_ERROR, "Failed to retrieve the frame buffer, frame is dropped (code = %d)\n", ret);
-            mpp_frame_deinit(&mppframe);
-        }
-    } else if (decoder->eos_reached) {
-        return AVERROR_EOF;
-    } else if (ret == MPP_ERR_TIMEOUT) {
-        av_log(avctx, AV_LOG_DEBUG, "Timeout when trying to get a frame from MPP\n");
-    }
-
-    return AVERROR(EAGAIN);
-
-fail:
-    if (mppframe)
-        mpp_frame_deinit(&mppframe);
-
-    if (framecontext)
-        av_buffer_unref(&framecontext->decoder_ref);
-
-    if (framecontextref)
-        av_buffer_unref(&framecontextref);
-
-    if (desc)
-        av_free(desc);
-
-    return ret;
-}
 
 static int rkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame)
 {
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
-    AVPacket pkt = {0};
-    RK_S32 usedslots, freeslots;
-
-    if (!decoder->eos_reached) {
-        // we get the available slots in decoder
-        ret = decoder->mpi->control(decoder->ctx, MPP_DEC_GET_STREAM_COUNT, &usedslots);
-        if (ret != MPP_OK) {
-            av_log(avctx, AV_LOG_ERROR, "Failed to get decoder used slots (code = %d).\n", ret);
-            return ret;
-        }
-
-        freeslots = INPUT_MAX_PACKETS - usedslots;
-        if (freeslots > 0) {
-            ret = ff_decode_get_packet(avctx, &pkt);
-            if (ret < 0 && ret != AVERROR_EOF) {
-                return ret;
-            }
-
-            ret = rkmpp_send_packet(avctx, &pkt);
-            av_packet_unref(&pkt);
-
-            if (ret < 0) {
-                av_log(avctx, AV_LOG_ERROR, "Failed to send packet to decoder (code = %d)\n", ret);
-                return ret;
-            }
-        }
-
-        // make sure we keep decoder full
-        if (freeslots > 1)
-            return AVERROR(EAGAIN);
-    }
-
-    return rkmpp_retrieve_frame(avctx, frame);
-}
-
-static void rkmpp_flush(AVCodecContext *avctx)
-{
-    RKMPPDecodeContext *rk_context = avctx->priv_data;
-    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
-    int ret = MPP_NOK;
-
-    av_log(avctx, AV_LOG_DEBUG, "Flush.\n");
-
-    ret = decoder->mpi->reset(decoder->ctx);
-    if (ret == MPP_OK) {
-        decoder->first_packet = 1;
-    } else
-        av_log(avctx, AV_LOG_ERROR, "Failed to reset MPI (code = %d)\n", ret);
+    return avrkmpp_receive_frame(avctx, frame, ff_decode_get_packet);
 }
 
 static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
@@ -567,20 +49,27 @@ static const AVCodecHWConfigInternal *const rkmpp_hw_configs[] = {
         .p.type         = AVMEDIA_TYPE_VIDEO, \
         .p.id           = ID, \
         .priv_data_size = sizeof(RKMPPDecodeContext), \
-        .init           = rkmpp_init_decoder, \
-        .close          = rkmpp_close_decoder, \
+        .init           = avrkmpp_init_decoder, \
+        .close          = avrkmpp_close_decoder, \
         FF_CODEC_RECEIVE_FRAME_CB(rkmpp_receive_frame), \
-        .flush          = rkmpp_flush, \
+        .flush          = avrkmpp_decoder_flush, \
         .p.priv_class   = &rkmpp_##NAME##_dec_class, \
         .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING | AV_CODEC_CAP_HARDWARE, \
+        .caps_internal  = FF_CODEC_CAP_CONTIGUOUS_BUFFERS, \
         .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
                                                          AV_PIX_FMT_NONE}, \
         .hw_configs     = rkmpp_hw_configs, \
         .bsfs           = BSFS, \
         .p.wrapper_name = "rkmpp", \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE, \
     };
 
+RKMPP_DEC(h263,  AV_CODEC_ID_H263,          NULL)
 RKMPP_DEC(h264,  AV_CODEC_ID_H264,          "h264_mp4toannexb")
 RKMPP_DEC(hevc,  AV_CODEC_ID_HEVC,          "hevc_mp4toannexb")
+RKMPP_DEC(av1,   AV_CODEC_ID_AV1,           NULL)
 RKMPP_DEC(vp8,   AV_CODEC_ID_VP8,           NULL)
 RKMPP_DEC(vp9,   AV_CODEC_ID_VP9,           NULL)
+RKMPP_DEC(mpeg1, AV_CODEC_ID_MPEG1VIDEO,    NULL)
+RKMPP_DEC(mpeg2, AV_CODEC_ID_MPEG2VIDEO,    NULL)
+RKMPP_DEC(mpeg4, AV_CODEC_ID_MPEG4,         "mpeg4_unpack_bframes")
diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
new file mode 100644
index 0000000..7b7542e
--- /dev/null
+++ b/libavcodec/rkmppenc.c
@@ -0,0 +1,76 @@
+/*
+ * RockChip MPP Video Encoder
+ * Copyright (c) 2018 hertz.wang@rock-chips.com
+ * Copyright (c) 2023 jjm2473 at gmail.com
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "libavrkmpp/avrkmpp.h"
+#include "libavutil/opt.h"
+
+#include "codec_internal.h"
+#include "hwconfig.h"
+
+#define OFFSET(x) offsetof(RKMPPEncodeContext, x)
+#define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
+static const AVOption options[] = {
+    { "profile",       "Set profile restrictions (h264_rkmpp)",    OFFSET(profile),       AV_OPT_TYPE_INT, { .i64=-1 }, 
+            -1, FF_PROFILE_H264_HIGH, VE, "profile"},
+        { "baseline",   NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_PROFILE_H264_BASELINE},  INT_MIN, INT_MAX, VE, "profile" },
+        { "main",       NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_PROFILE_H264_MAIN},      INT_MIN, INT_MAX, VE, "profile" },
+        { "high",       NULL, 0, AV_OPT_TYPE_CONST, {.i64 = FF_PROFILE_H264_HIGH},      INT_MIN, INT_MAX, VE, "profile" },
+    { "8x8dct",        "High profile 8x8 transform (h264_rkmpp)", OFFSET(dct8x8), AV_OPT_TYPE_BOOL,   { .i64 = -1 }, -1, 1, VE},
+    { NULL }
+};
+
+static const AVCodecHWConfigInternal *rkmpp_hw_configs[] = {
+    HW_CONFIG_ENCODER_FRAMES(DRM_PRIME, DRM),
+    NULL
+};
+
+#define RKMPP_ENC_CLASS(NAME) \
+    static const AVClass rkmpp_##NAME##_enc_class = { \
+        .class_name = "rkmpp_" #NAME "_enc", \
+        .item_name  = av_default_item_name,\
+        .option     = options, \
+        .version    = LIBAVUTIL_VERSION_INT, \
+    };
+
+// TODO: .send_frame .receive_packet
+#define RKMPP_ENC(NAME, ID, BSFS) \
+    RKMPP_ENC_CLASS(NAME) \
+    FFCodec ff_##NAME##_rkmpp_encoder = { \
+        .p.name           = #NAME "_rkmpp", \
+        .p.long_name      = NULL_IF_CONFIG_SMALL(#NAME " (rkmpp)"), \
+        .p.type           = AVMEDIA_TYPE_VIDEO, \
+        .p.id             = ID, \
+        .init           = avrkmpp_init_encoder, \
+        .close          = avrkmpp_close_encoder, \
+        FF_CODEC_ENCODE_CB(avrkmpp_encode_frame), \
+        .priv_data_size = sizeof(RKMPPEncodeContext), \
+        .p.priv_class     = &rkmpp_##NAME##_enc_class, \
+        .p.capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE, \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP, \
+        .p.pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
+                                                         AV_PIX_FMT_NONE }, \
+        .hw_configs     = rkmpp_hw_configs, \
+        .bsfs           = BSFS, \
+        .p.wrapper_name   = "rkmpp", \
+    };
+
+RKMPP_ENC(h264, AV_CODEC_ID_H264, NULL)
diff --git a/libavcodec/rl2.c b/libavcodec/rl2.c
index e76b068..fc022ff 100644
--- a/libavcodec/rl2.c
+++ b/libavcodec/rl2.c
@@ -227,5 +227,4 @@ const FFCodec ff_rl2_decoder = {
     .close          = rl2_decode_end,
     FF_CODEC_DECODE_CB(rl2_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/roqaudioenc.c b/libavcodec/roqaudioenc.c
index 18a5f23..e5bc902 100644
--- a/libavcodec/roqaudioenc.c
+++ b/libavcodec/roqaudioenc.c
@@ -199,5 +199,4 @@ const FFCodec ff_roq_dpcm_encoder = {
     .close          = roq_dpcm_encode_close,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/roqvideodec.c b/libavcodec/roqvideodec.c
index 3e796b1..4fbb0ca 100644
--- a/libavcodec/roqvideodec.c
+++ b/libavcodec/roqvideodec.c
@@ -243,5 +243,5 @@ const FFCodec ff_roq_decoder = {
     .close          = roq_decode_end,
     FF_CODEC_DECODE_CB(roq_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/roqvideoenc.c b/libavcodec/roqvideoenc.c
index c0c67db..ebbcb21 100644
--- a/libavcodec/roqvideoenc.c
+++ b/libavcodec/roqvideoenc.c
@@ -1130,5 +1130,5 @@ const FFCodec ff_roq_encoder = {
     .p.pix_fmts           = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUVJ444P,
                                                         AV_PIX_FMT_NONE },
     .p.priv_class   = &roq_class,
-    .caps_internal        = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal        = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/rpza.c b/libavcodec/rpza.c
index 703f05e..d5ece16 100644
--- a/libavcodec/rpza.c
+++ b/libavcodec/rpza.c
@@ -296,5 +296,4 @@ const FFCodec ff_rpza_decoder = {
     .close          = rpza_decode_end,
     FF_CODEC_DECODE_CB(rpza_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/rpzaenc.c b/libavcodec/rpzaenc.c
index 50b68bb..a470f5d 100644
--- a/libavcodec/rpzaenc.c
+++ b/libavcodec/rpzaenc.c
@@ -84,7 +84,7 @@ typedef struct BlockInfo {
     int total_blocks;
 } BlockInfo;
 
-static void get_colors(uint8_t *min, uint8_t *max, uint8_t color4[4][3])
+static void get_colors(const uint8_t *min, const uint8_t *max, uint8_t color4[4][3])
 {
     uint8_t step;
 
@@ -135,7 +135,7 @@ static int get_block_info(BlockInfo *bi, int block)
     return block ? (bi->col * 4) + (bi->row * bi->rowstride * 4) : 0;
 }
 
-static uint16_t rgb24_to_rgb555(uint8_t *rgb24)
+static uint16_t rgb24_to_rgb555(const uint8_t *rgb24)
 {
     uint16_t rgb555 = 0;
     uint32_t r, g, b;
@@ -154,7 +154,7 @@ static uint16_t rgb24_to_rgb555(uint8_t *rgb24)
 /*
  * Returns the total difference between two 24 bit color values
  */
-static int diff_colors(uint8_t *colorA, uint8_t *colorB)
+static int diff_colors(const uint8_t *colorA, const uint8_t *colorB)
 {
     int tot;
 
@@ -168,7 +168,7 @@ static int diff_colors(uint8_t *colorA, uint8_t *colorB)
 /*
  * Returns the maximum channel difference
  */
-static int max_component_diff(uint16_t *colorA, uint16_t *colorB)
+static int max_component_diff(const uint16_t *colorA, const uint16_t *colorB)
 {
     int diff, max = 0;
 
@@ -192,7 +192,7 @@ static int max_component_diff(uint16_t *colorA, uint16_t *colorB)
  * color values. Put the minimum value in min, maximum in max and the channel
  * in chan.
  */
-static void get_max_component_diff(BlockInfo *bi, uint16_t *block_ptr,
+static void get_max_component_diff(const BlockInfo *bi, const uint16_t *block_ptr,
                                    uint8_t *min, uint8_t *max, channel_offset *chan)
 {
     int x, y;
@@ -242,7 +242,8 @@ static void get_max_component_diff(BlockInfo *bi, uint16_t *block_ptr,
  * blocks is greater than the thresh parameter. Returns -1 if difference
  * exceeds threshold or zero otherwise.
  */
-static int compare_blocks(uint16_t *block1, uint16_t *block2, BlockInfo *bi, int thresh)
+static int compare_blocks(const uint16_t *block1, const uint16_t *block2,
+                          const BlockInfo *bi, int thresh)
 {
     int x, y, diff = 0;
     for (y = 0; y < bi->block_height; y++) {
@@ -262,7 +263,7 @@ static int compare_blocks(uint16_t *block1, uint16_t *block2, BlockInfo *bi, int
  * Determine the fit of one channel to another within a 4x4 block. This
  * is used to determine the best palette choices for 4-color encoding.
  */
-static int leastsquares(uint16_t *block_ptr, BlockInfo *bi,
+static int leastsquares(const uint16_t *block_ptr, const BlockInfo *bi,
                         channel_offset xchannel, channel_offset ychannel,
                         double *slope, double *y_intercept, double *correlation_coef)
 {
@@ -315,7 +316,7 @@ static int leastsquares(uint16_t *block_ptr, BlockInfo *bi,
 /*
  * Determine the amount of error in the leastsquares fit.
  */
-static int calc_lsq_max_fit_error(uint16_t *block_ptr, BlockInfo *bi,
+static int calc_lsq_max_fit_error(const uint16_t *block_ptr, const BlockInfo *bi,
                                   int min, int max, int tmp_min, int tmp_max,
                                   channel_offset xchannel, channel_offset ychannel)
 {
@@ -356,7 +357,7 @@ static int calc_lsq_max_fit_error(uint16_t *block_ptr, BlockInfo *bi,
 /*
  * Find the closest match to a color within the 4-color palette
  */
-static int match_color(uint16_t *color, uint8_t colors[4][3])
+static int match_color(const uint16_t *color, uint8_t colors[4][3])
 {
     int ret = 0;
     int smallest_variance = INT_MAX;
@@ -383,8 +384,8 @@ static int match_color(uint16_t *color, uint8_t colors[4][3])
  * blocks encoded (until we implement multi-block 4 color runs this will
  * always be 1)
  */
-static int encode_four_color_block(uint8_t *min_color, uint8_t *max_color,
-                                   PutBitContext *pb, uint16_t *block_ptr, BlockInfo *bi)
+static int encode_four_color_block(const uint8_t *min_color, const uint8_t *max_color,
+                                   PutBitContext *pb, const uint16_t *block_ptr, const BlockInfo *bi)
 {
     int x, y, idx;
     uint8_t color4[4][3];
@@ -441,7 +442,7 @@ static void update_block_in_prev_frame(const uint16_t *src_pixels,
  * the statistics of this block. Otherwise, the stats are unchanged
  * and don't include the current block.
  */
-static int update_block_stats(RpzaContext *s, BlockInfo *bi, uint16_t *block,
+static int update_block_stats(RpzaContext *s, const BlockInfo *bi, const uint16_t *block,
                               uint8_t min_color[3], uint8_t max_color[3],
                               int *total_rgb, int *total_pixels,
                               uint8_t avg_color[3], int first_block)
@@ -562,7 +563,7 @@ static void rpza_encode_stream(RpzaContext *s, const AVFrame *pict)
     int pixel_count;
     uint8_t min_color[3], max_color[3];
     double slope, y_intercept, correlation_coef;
-    uint16_t *src_pixels = (uint16_t *)pict->data[0];
+    const uint16_t *src_pixels = (const uint16_t *)pict->data[0];
     uint16_t *prev_pixels = (uint16_t *)s->prev_frame->data[0];
 
     /* Number of 4x4 blocks in frame. */
@@ -728,7 +729,7 @@ post_skip :
             }
 
             if (err > s->sixteen_color_thresh) { // DO SIXTEEN COLOR BLOCK
-                uint16_t *row_ptr;
+                const uint16_t *row_ptr;
                 int rgb555;
 
                 block_offset = get_block_info(&bi, block_counter);
@@ -853,7 +854,6 @@ const FFCodec ff_rpza_encoder = {
     .init           = rpza_encode_init,
     FF_CODEC_ENCODE_CB(rpza_encode_frame),
     .close          = rpza_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_RGB555,
                                                      AV_PIX_FMT_NONE},
 };
diff --git a/libavcodec/rscc.c b/libavcodec/rscc.c
index f4fa786..eff4f87 100644
--- a/libavcodec/rscc.c
+++ b/libavcodec/rscc.c
@@ -372,6 +372,5 @@ const FFCodec ff_rscc_decoder = {
     .close          = rscc_close,
     .priv_data_size = sizeof(RsccContext),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/rv10.c b/libavcodec/rv10.c
index e394a63..abf4261 100644
--- a/libavcodec/rv10.c
+++ b/libavcodec/rv10.c
@@ -531,7 +531,7 @@ static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf,
     /* decode each macroblock */
     for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) {
         int ret;
-        ff_update_block_index(s);
+        ff_update_block_index(s, 8, s->avctx->lowres, 1);
         ff_tlog(avctx, "**mb x=%d y=%d\n", s->mb_x, s->mb_y);
 
         s->mv_dir  = MV_DIR_FORWARD;
@@ -691,7 +691,6 @@ const FFCodec ff_rv10_decoder = {
     .close          = rv10_decode_end,
     FF_CODEC_DECODE_CB(rv10_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.max_lowres   = 3,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
@@ -709,7 +708,6 @@ const FFCodec ff_rv20_decoder = {
     .close          = rv10_decode_end,
     FF_CODEC_DECODE_CB(rv10_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .flush          = ff_mpeg_flush,
     .p.max_lowres   = 3,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
diff --git a/libavcodec/rv10enc.c b/libavcodec/rv10enc.c
index 7560e60..71cbb8d 100644
--- a/libavcodec/rv10enc.c
+++ b/libavcodec/rv10enc.c
@@ -75,6 +75,6 @@ const FFCodec ff_rv10_encoder = {
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
     .close          = ff_mpv_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
 };
diff --git a/libavcodec/rv20enc.c b/libavcodec/rv20enc.c
index 422188e..8978f3f 100644
--- a/libavcodec/rv20enc.c
+++ b/libavcodec/rv20enc.c
@@ -72,6 +72,6 @@ const FFCodec ff_rv20_encoder = {
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
     .close          = ff_mpv_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV420P, AV_PIX_FMT_NONE },
 };
diff --git a/libavcodec/rv30.c b/libavcodec/rv30.c
index 8fd8498..a06e928 100644
--- a/libavcodec/rv30.c
+++ b/libavcodec/rv30.c
@@ -308,6 +308,5 @@ const FFCodec ff_rv30_decoder = {
         AV_PIX_FMT_NONE
     },
     .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_rv34_decode_update_thread_context),
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE |
-                             FF_CODEC_CAP_ALLOCATE_PROGRESS,
+    .caps_internal         = FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
diff --git a/libavcodec/rv34.c b/libavcodec/rv34.c
index 5f3b7d3..61d1e4c 100644
--- a/libavcodec/rv34.c
+++ b/libavcodec/rv34.c
@@ -703,7 +703,7 @@ static inline void rv34_mc(RV34DecContext *r, const int block_type,
     if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) {
         /* wait for the referenced mb row to be finished */
         int mb_row = s->mb_y + ((yoff + my + 5 + 8 * height) >> 4);
-        ThreadFrame *f = dir ? &s->next_picture_ptr->tf : &s->last_picture_ptr->tf;
+        const ThreadFrame *f = dir ? &s->next_picture_ptr->tf : &s->last_picture_ptr->tf;
         ff_thread_await_progress(f, mb_row, 0);
     }
 
@@ -1445,7 +1445,7 @@ static int rv34_decode_slice(RV34DecContext *r, int end, const uint8_t* buf, int
 
     ff_init_block_index(s);
     while(!check_slice_end(r, s)) {
-        ff_update_block_index(s);
+        ff_update_block_index(s, 8, 0, 1);
 
         if(r->si.type)
             res = rv34_decode_inter_macroblock(r, r->intra_types + s->mb_x * 4 + 4);
diff --git a/libavcodec/rv40.c b/libavcodec/rv40.c
index b946981..1ddc04e 100644
--- a/libavcodec/rv40.c
+++ b/libavcodec/rv40.c
@@ -591,6 +591,5 @@ const FFCodec ff_rv40_decoder = {
         AV_PIX_FMT_NONE
     },
     .update_thread_context = ONLY_IF_THREADS_ENABLED(ff_rv34_decode_update_thread_context),
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE |
-                             FF_CODEC_CAP_ALLOCATE_PROGRESS,
+    .caps_internal         = FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
diff --git a/libavcodec/rv40dsp.c b/libavcodec/rv40dsp.c
index a09179a..f0208b1 100644
--- a/libavcodec/rv40dsp.c
+++ b/libavcodec/rv40dsp.c
@@ -292,7 +292,7 @@ static const int rv40_bias[4][4] = {
 
 #define RV40_CHROMA_MC(OPNAME, OP)\
 static void OPNAME ## rv40_chroma_mc4_c(uint8_t *dst /*align 8*/,\
-                                        uint8_t *src /*align 1*/,\
+                                        const uint8_t *src /*align 1*/,\
                                         ptrdiff_t stride, int h, int x, int y)\
 {\
     const int A = (8-x) * (8-y);\
@@ -328,7 +328,7 @@ static void OPNAME ## rv40_chroma_mc4_c(uint8_t *dst /*align 8*/,\
 }\
 \
 static void OPNAME ## rv40_chroma_mc8_c(uint8_t *dst/*align 8*/,\
-                                        uint8_t *src/*align 1*/,\
+                                        const uint8_t *src/*align 1*/,\
                                         ptrdiff_t stride, int h, int x, int y)\
 {\
     const int A = (8-x) * (8-y);\
diff --git a/libavcodec/s302menc.c b/libavcodec/s302menc.c
index b6f9501..123ce13 100644
--- a/libavcodec/s302menc.c
+++ b/libavcodec/s302menc.c
@@ -189,5 +189,4 @@ const FFCodec ff_s302m_encoder = {
                                                   AV_CH_LAYOUT_5POINT1_BACK,
                                                   AV_CH_LAYOUT_5POINT1_BACK | AV_CH_LAYOUT_STEREO_DOWNMIX,
                                                   0 }, */
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/samidec.c b/libavcodec/samidec.c
index cf5dec9..d3d77cb 100644
--- a/libavcodec/samidec.c
+++ b/libavcodec/samidec.c
@@ -190,5 +190,4 @@ const FFCodec ff_sami_decoder = {
     .close          = sami_close,
     FF_CODEC_DECODE_SUB_CB(sami_decode_frame),
     .flush          = sami_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/sanm.c b/libavcodec/sanm.c
index 7f094c8..775768b 100644
--- a/libavcodec/sanm.c
+++ b/libavcodec/sanm.c
@@ -1526,5 +1526,4 @@ const FFCodec ff_sanm_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/sbcdec.c b/libavcodec/sbcdec.c
index 99af7e1..b7e59d7 100644
--- a/libavcodec/sbcdec.c
+++ b/libavcodec/sbcdec.c
@@ -374,7 +374,6 @@ const FFCodec ff_sbc_decoder = {
     .init                  = sbc_decode_init,
     FF_CODEC_DECODE_CB(sbc_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
                                                   AV_CH_LAYOUT_STEREO, 0},
diff --git a/libavcodec/sbcenc.c b/libavcodec/sbcenc.c
index 18ac4fb..863899c 100644
--- a/libavcodec/sbcenc.c
+++ b/libavcodec/sbcenc.c
@@ -352,7 +352,6 @@ const FFCodec ff_sbc_encoder = {
     .priv_data_size        = sizeof(SBCEncContext),
     .init                  = sbc_encode_init,
     FF_CODEC_ENCODE_CB(sbc_encode_frame),
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts     = (const uint64_t[]) { AV_CH_LAYOUT_MONO,
                                                   AV_CH_LAYOUT_STEREO, 0},
diff --git a/libavcodec/sbrdsp.c b/libavcodec/sbrdsp.c
index a93b5f9..8d6ffdf 100644
--- a/libavcodec/sbrdsp.c
+++ b/libavcodec/sbrdsp.c
@@ -23,7 +23,6 @@
 #define USE_FIXED 0
 
 #include "aac.h"
-#include "config.h"
 #include "libavutil/attributes.h"
 #include "libavutil/intfloat.h"
 #include "sbrdsp.h"
diff --git a/libavcodec/sbrdsp.h b/libavcodec/sbrdsp.h
index e6fd76d..8513c42 100644
--- a/libavcodec/sbrdsp.h
+++ b/libavcodec/sbrdsp.h
@@ -23,7 +23,6 @@
 
 #include <stdint.h>
 #include "aac_defines.h"
-#include "libavutil/softfloat.h"
 
 typedef struct SBRDSPContext {
     void (*sum64x5)(INTFLOAT *z);
diff --git a/libavcodec/sbrdsp_fixed.c b/libavcodec/sbrdsp_fixed.c
index 0d34a2a..f5784f8 100644
--- a/libavcodec/sbrdsp_fixed.c
+++ b/libavcodec/sbrdsp_fixed.c
@@ -26,7 +26,6 @@
 #define USE_FIXED 1
 
 #include "aac.h"
-#include "config.h"
 #include "libavutil/attributes.h"
 #include "libavutil/intfloat.h"
 #include "sbrdsp.h"
diff --git a/libavcodec/scpr.c b/libavcodec/scpr.c
index 0623b73..ed129a5 100644
--- a/libavcodec/scpr.c
+++ b/libavcodec/scpr.c
@@ -677,6 +677,5 @@ const FFCodec ff_scpr_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/screenpresso.c b/libavcodec/screenpresso.c
index 8a4a8cd..f5bc46f 100644
--- a/libavcodec/screenpresso.c
+++ b/libavcodec/screenpresso.c
@@ -193,6 +193,5 @@ const FFCodec ff_screenpresso_decoder = {
     .close          = screenpresso_close,
     .priv_data_size = sizeof(ScreenpressoContext),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/sga.c b/libavcodec/sga.c
index cdd37fe..27918ee 100644
--- a/libavcodec/sga.c
+++ b/libavcodec/sga.c
@@ -529,5 +529,4 @@ const FFCodec ff_sga_decoder = {
     FF_CODEC_DECODE_CB(sga_decode_frame),
     .close          = sga_decode_end,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/sgidec.c b/libavcodec/sgidec.c
index b23e205..965461d 100644
--- a/libavcodec/sgidec.c
+++ b/libavcodec/sgidec.c
@@ -295,5 +295,4 @@ const FFCodec ff_sgi_decoder = {
     FF_CODEC_DECODE_CB(decode_frame),
     .init           = sgi_decode_init,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/sgienc.c b/libavcodec/sgienc.c
index 93cb95f..7edc7cc 100644
--- a/libavcodec/sgienc.c
+++ b/libavcodec/sgienc.c
@@ -96,7 +96,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     SgiContext *s = avctx->priv_data;
     const AVFrame * const p = frame;
     PutByteContext pbc;
-    uint8_t *in_buf, *encode_buf;
+    uint8_t *encode_buf;
     int x, y, z, length, tablesize, ret, i;
     unsigned int width, height, depth, dimension;
     unsigned int bytes_per_channel, pixmax, put_be;
@@ -200,7 +200,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
             return AVERROR(ENOMEM);
 
         for (z = 0; z < depth; z++) {
-            in_buf = p->data[0] + p->linesize[0] * (height - 1) + z * bytes_per_channel;
+            const uint8_t *in_buf = p->data[0] + p->linesize[0] * (height - 1) + z * bytes_per_channel;
 
             for (y = 0; y < height; y++) {
                 bytestream2_put_be32(&taboff_pcb, bytestream2_tell_p(&pbc));
@@ -231,7 +231,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         av_free(encode_buf);
     } else {
         for (z = 0; z < depth; z++) {
-            in_buf = p->data[0] + p->linesize[0] * (height - 1) + z * bytes_per_channel;
+            const uint8_t *in_buf = p->data[0] + p->linesize[0] * (height - 1) + z * bytes_per_channel;
 
             for (y = 0; y < height; y++) {
                 for (x = 0; x < width * depth; x += depth)
@@ -286,5 +286,4 @@ const FFCodec ff_sgi_encoder = {
         AV_PIX_FMT_GRAY16LE, AV_PIX_FMT_GRAY16BE, AV_PIX_FMT_GRAY8,
         AV_PIX_FMT_NONE
     },
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/sgirledec.c b/libavcodec/sgirledec.c
index e04b9b1..a9fd24c 100644
--- a/libavcodec/sgirledec.c
+++ b/libavcodec/sgirledec.c
@@ -139,5 +139,4 @@ const FFCodec ff_sgirle_decoder = {
     .init           = sgirle_decode_init,
     FF_CODEC_DECODE_CB(sgirle_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/shorten.c b/libavcodec/shorten.c
index 27074e9..39aa147 100644
--- a/libavcodec/shorten.c
+++ b/libavcodec/shorten.c
@@ -819,5 +819,4 @@ const FFCodec ff_shorten_decoder = {
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_U8P,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/sipr.c b/libavcodec/sipr.c
index 9d11f2c..bf8d627 100644
--- a/libavcodec/sipr.c
+++ b/libavcodec/sipr.c
@@ -571,5 +571,4 @@ const FFCodec ff_sipr_decoder = {
     .init           = sipr_decoder_init,
     FF_CODEC_DECODE_CB(sipr_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/siren.c b/libavcodec/siren.c
index b613ee1..e7a5a33 100644
--- a/libavcodec/siren.c
+++ b/libavcodec/siren.c
@@ -853,8 +853,7 @@ const FFCodec ff_siren_decoder = {
     .flush          = siren_flush,
     .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_msnsiren_decoder = {
@@ -869,6 +868,5 @@ const FFCodec ff_msnsiren_decoder = {
     .flush          = siren_flush,
     .p.capabilities = AV_CODEC_CAP_CHANNEL_CONF |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/smacker.c b/libavcodec/smacker.c
index 9d02968..06af0fb 100644
--- a/libavcodec/smacker.c
+++ b/libavcodec/smacker.c
@@ -752,7 +752,7 @@ const FFCodec ff_smacker_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_smackaud_decoder = {
@@ -763,5 +763,4 @@ const FFCodec ff_smackaud_decoder = {
     .init           = smka_decode_init,
     FF_CODEC_DECODE_CB(smka_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/smc.c b/libavcodec/smc.c
index 313d8ed..28dc2b4 100644
--- a/libavcodec/smc.c
+++ b/libavcodec/smc.c
@@ -478,5 +478,4 @@ const FFCodec ff_smc_decoder = {
     .close          = smc_decode_end,
     FF_CODEC_DECODE_CB(smc_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/smcenc.c b/libavcodec/smcenc.c
index e113709..0b7b030 100644
--- a/libavcodec/smcenc.c
+++ b/libavcodec/smcenc.c
@@ -557,7 +557,6 @@ const FFCodec ff_smc_encoder = {
     .init           = smc_encode_init,
     FF_CODEC_ENCODE_CB(smc_encode_frame),
     .close          = smc_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_PAL8,
                                                      AV_PIX_FMT_NONE},
 };
diff --git a/libavcodec/snow.c b/libavcodec/snow.c
index 293a0eb..5e00330 100644
--- a/libavcodec/snow.c
+++ b/libavcodec/snow.c
@@ -359,7 +359,7 @@ void ff_snow_pred_block(SnowContext *s, uint8_t *dst, uint8_t *tmp, ptrdiff_t st
             }
         }
     }else{
-        uint8_t *src= s->last_picture[block->ref]->data[plane_index];
+        const uint8_t *src = s->last_picture[block->ref]->data[plane_index];
         const int scale= plane_index ?  (2*s->mv_scale)>>s->chroma_h_shift : 2*s->mv_scale;
         int mx= block->mx*scale;
         int my= block->my*scale;
@@ -587,72 +587,12 @@ int ff_snow_common_init_after_header(AVCodecContext *avctx) {
     return 0;
 }
 
-#define USE_HALFPEL_PLANE 0
-
-static int halfpel_interpol(SnowContext *s, uint8_t *halfpel[4][4], AVFrame *frame){
-    int p,x,y;
-
-    for(p=0; p < s->nb_planes; p++){
-        int is_chroma= !!p;
-        int w= is_chroma ? AV_CEIL_RSHIFT(s->avctx->width,  s->chroma_h_shift) : s->avctx->width;
-        int h= is_chroma ? AV_CEIL_RSHIFT(s->avctx->height, s->chroma_v_shift) : s->avctx->height;
-        int ls= frame->linesize[p];
-        uint8_t *src= frame->data[p];
-
-        halfpel[1][p] = av_malloc_array(ls, (h + 2 * EDGE_WIDTH));
-        halfpel[2][p] = av_malloc_array(ls, (h + 2 * EDGE_WIDTH));
-        halfpel[3][p] = av_malloc_array(ls, (h + 2 * EDGE_WIDTH));
-        if (!halfpel[1][p] || !halfpel[2][p] || !halfpel[3][p]) {
-            av_freep(&halfpel[1][p]);
-            av_freep(&halfpel[2][p]);
-            av_freep(&halfpel[3][p]);
-            return AVERROR(ENOMEM);
-        }
-        halfpel[1][p] += EDGE_WIDTH * (1 + ls);
-        halfpel[2][p] += EDGE_WIDTH * (1 + ls);
-        halfpel[3][p] += EDGE_WIDTH * (1 + ls);
-
-        halfpel[0][p]= src;
-        for(y=0; y<h; y++){
-            for(x=0; x<w; x++){
-                int i= y*ls + x;
-
-                halfpel[1][p][i]= (20*(src[i] + src[i+1]) - 5*(src[i-1] + src[i+2]) + (src[i-2] + src[i+3]) + 16 )>>5;
-            }
-        }
-        for(y=0; y<h; y++){
-            for(x=0; x<w; x++){
-                int i= y*ls + x;
-
-                halfpel[2][p][i]= (20*(src[i] + src[i+ls]) - 5*(src[i-ls] + src[i+2*ls]) + (src[i-2*ls] + src[i+3*ls]) + 16 )>>5;
-            }
-        }
-        src= halfpel[1][p];
-        for(y=0; y<h; y++){
-            for(x=0; x<w; x++){
-                int i= y*ls + x;
-
-                halfpel[3][p][i]= (20*(src[i] + src[i+ls]) - 5*(src[i-ls] + src[i+2*ls]) + (src[i-2*ls] + src[i+3*ls]) + 16 )>>5;
-            }
-        }
-
-//FIXME border!
-    }
-    return 0;
-}
-
 void ff_snow_release_buffer(AVCodecContext *avctx)
 {
     SnowContext *s = avctx->priv_data;
-    int i;
 
     if(s->last_picture[s->max_ref_frames-1]->data[0]){
         av_frame_unref(s->last_picture[s->max_ref_frames-1]);
-        for(i=0; i<9; i++)
-            if(s->halfpel_plane[s->max_ref_frames-1][1+i/3][i%3]) {
-                av_free(s->halfpel_plane[s->max_ref_frames-1][1+i/3][i%3] - EDGE_WIDTH*(1+s->current_picture->linesize[i%3]));
-                s->halfpel_plane[s->max_ref_frames-1][1+i/3][i%3] = NULL;
-            }
     }
 }
 
@@ -665,11 +605,6 @@ int ff_snow_frame_start(SnowContext *s){
     tmp= s->last_picture[s->max_ref_frames-1];
     for(i=s->max_ref_frames-1; i>0; i--)
         s->last_picture[i] = s->last_picture[i-1];
-    memmove(s->halfpel_plane+1, s->halfpel_plane, (s->max_ref_frames-1)*sizeof(void*)*4*4);
-    if(USE_HALFPEL_PLANE && s->current_picture->data[0]) {
-        if((ret = halfpel_interpol(s, s->halfpel_plane[0], s->current_picture)) < 0)
-            return ret;
-    }
     s->last_picture[0] = s->current_picture;
     s->current_picture = tmp;
 
diff --git a/libavcodec/snow.h b/libavcodec/snow.h
index f5beca6..ed0f9ab 100644
--- a/libavcodec/snow.h
+++ b/libavcodec/snow.h
@@ -127,7 +127,6 @@ typedef struct SnowContext{
     AVFrame *input_picture;              ///< new_picture with the internal linesizes
     AVFrame *current_picture;
     AVFrame *last_picture[MAX_REF_FRAMES];
-    uint8_t *halfpel_plane[MAX_REF_FRAMES][4][4];
     AVFrame *mconly_picture;
 //     uint8_t q_context[16];
     uint8_t header_state[32];
@@ -487,7 +486,7 @@ static inline void set_blocks(SnowContext *s, int level, int x, int y, int l, in
     }
 }
 
-static inline void init_ref(MotionEstContext *c, uint8_t *src[3], uint8_t *ref[3], uint8_t *ref2[3], int x, int y, int ref_index){
+static inline void init_ref(MotionEstContext *c, const uint8_t *const src[3], uint8_t *const ref[3], uint8_t *const ref2[3], int x, int y, int ref_index){
     SnowContext *s = c->avctx->priv_data;
     const int offset[3]= {
           y*c->  stride + x,
diff --git a/libavcodec/snow_dwt.c b/libavcodec/snow_dwt.c
index e196fef..18b315e 100644
--- a/libavcodec/snow_dwt.c
+++ b/libavcodec/snow_dwt.c
@@ -740,7 +740,7 @@ void ff_spatial_idwt(IDWTELEM *buffer, IDWTELEM *temp, int width, int height,
                               decomposition_count, y);
 }
 
-static inline int w_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size,
+static inline int w_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size,
                       int w, int h, int type)
 {
     int s, i, j;
@@ -809,32 +809,32 @@ static inline int w_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, pt
     return s >> 9;
 }
 
-static int w53_8_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h)
+static int w53_8_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h)
 {
     return w_c(v, pix1, pix2, line_size, 8, h, 1);
 }
 
-static int w97_8_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h)
+static int w97_8_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h)
 {
     return w_c(v, pix1, pix2, line_size, 8, h, 0);
 }
 
-static int w53_16_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h)
+static int w53_16_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h)
 {
     return w_c(v, pix1, pix2, line_size, 16, h, 1);
 }
 
-static int w97_16_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h)
+static int w97_16_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h)
 {
     return w_c(v, pix1, pix2, line_size, 16, h, 0);
 }
 
-int ff_w53_32_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h)
+int ff_w53_32_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h)
 {
     return w_c(v, pix1, pix2, line_size, 32, h, 1);
 }
 
-int ff_w97_32_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h)
+int ff_w97_32_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h)
 {
     return w_c(v, pix1, pix2, line_size, 32, h, 0);
 }
diff --git a/libavcodec/snow_dwt.h b/libavcodec/snow_dwt.h
index 390bc57..15b8a30 100644
--- a/libavcodec/snow_dwt.h
+++ b/libavcodec/snow_dwt.h
@@ -104,8 +104,8 @@ void ff_snow_inner_add_yblock(const uint8_t *obmc, const int obmc_stride,
                               int src_y, int src_stride, slice_buffer *sb,
                               int add, uint8_t *dst8);
 
-int ff_w53_32_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h);
-int ff_w97_32_c(struct MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t line_size, int h);
+int ff_w53_32_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h);
+int ff_w97_32_c(struct MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t line_size, int h);
 
 void ff_spatial_dwt(int *buffer, int *temp, int width, int height, int stride,
                     int type, int decomposition_count);
diff --git a/libavcodec/snowdec.c b/libavcodec/snowdec.c
index 92ff877..3a7fda0 100644
--- a/libavcodec/snowdec.c
+++ b/libavcodec/snowdec.c
@@ -663,6 +663,5 @@ const FFCodec ff_snow_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 /*| AV_CODEC_CAP_DRAW_HORIZ_BAND*/,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/snowenc.c b/libavcodec/snowenc.c
index 2079486..a295ff8 100644
--- a/libavcodec/snowenc.c
+++ b/libavcodec/snowenc.c
@@ -151,7 +151,7 @@ static av_cold int encode_init(AVCodecContext *avctx)
 }
 
 //near copy & paste from dsputil, FIXME
-static int pix_sum(uint8_t * pix, int line_size, int w, int h)
+static int pix_sum(const uint8_t * pix, int line_size, int w, int h)
 {
     int s, i, j;
 
@@ -167,7 +167,7 @@ static int pix_sum(uint8_t * pix, int line_size, int w, int h)
 }
 
 //near copy & paste from dsputil, FIXME
-static int pix_norm1(uint8_t * pix, int line_size, int w)
+static int pix_norm1(const uint8_t * pix, int line_size, int w)
 {
     int s, i, j;
     const uint32_t *sq = ff_square_tab + 256;
@@ -245,7 +245,7 @@ static int encode_q_branch(SnowContext *s, int level, int x, int y){
     int l,cr,cb;
     const int stride= s->current_picture->linesize[0];
     const int uvstride= s->current_picture->linesize[1];
-    uint8_t *current_data[3]= { s->input_picture->data[0] + (x + y*  stride)*block_w,
+    const uint8_t *const current_data[3] = { s->input_picture->data[0] + (x + y*  stride)*block_w,
                                 s->input_picture->data[1] + ((x*block_w)>>s->chroma_h_shift) + ((y*uvstride*block_w)>>s->chroma_v_shift),
                                 s->input_picture->data[2] + ((x*block_w)>>s->chroma_h_shift) + ((y*uvstride*block_w)>>s->chroma_v_shift)};
     int P[10][2];
@@ -508,7 +508,7 @@ static int get_dc(SnowContext *s, int mb_x, int mb_y, int plane_index){
     const uint8_t *obmc  = plane_index ? ff_obmc_tab[s->block_max_depth+s->chroma_h_shift] : ff_obmc_tab[s->block_max_depth];
     const int obmc_stride= plane_index ? (2*block_size)>>s->chroma_h_shift : 2*block_size;
     const int ref_stride= s->current_picture->linesize[plane_index];
-    uint8_t *src= s-> input_picture->data[plane_index];
+    const uint8_t *src = s->input_picture->data[plane_index];
     IDWTELEM *dst= (IDWTELEM*)s->m.sc.obmc_scratchpad + plane_index*block_size*block_size*4; //FIXME change to unsigned
     const int b_stride = s->b_width << s->block_max_depth;
     const int w= p->width;
@@ -603,7 +603,7 @@ static int get_block_rd(SnowContext *s, int mb_x, int mb_y, int plane_index, uin
     const int obmc_stride= plane_index ? (2*block_size)>>s->chroma_h_shift : 2*block_size;
     const int ref_stride= s->current_picture->linesize[plane_index];
     uint8_t *dst= s->current_picture->data[plane_index];
-    uint8_t *src= s->  input_picture->data[plane_index];
+    const uint8_t *src = s->input_picture->data[plane_index];
     IDWTELEM *pred= (IDWTELEM*)s->m.sc.obmc_scratchpad + plane_index*block_size*block_size*4;
     uint8_t *cur = s->scratchbuf;
     uint8_t *tmp = s->emu_edge_buffer;
@@ -706,7 +706,7 @@ static int get_4block_rd(SnowContext *s, int mb_x, int mb_y, int plane_index){
     const int obmc_stride= plane_index ? (2*block_size)>>s->chroma_h_shift : 2*block_size;
     const int ref_stride= s->current_picture->linesize[plane_index];
     uint8_t *dst= s->current_picture->data[plane_index];
-    uint8_t *src= s-> input_picture->data[plane_index];
+    const uint8_t *src = s->input_picture->data[plane_index];
     //FIXME zero_dst is const but add_yblock changes dst if add is 0 (this is never the case for dst=zero_dst
     // const has only been removed from zero_dst to suppress a warning
     static IDWTELEM zero_dst[4096]; //FIXME
@@ -892,34 +892,23 @@ static int encode_subband(SnowContext *s, SubBand *b, const IDWTELEM *src, const
 //    encode_subband_dzr(s, b, src, parent, stride, orientation);
 }
 
-static av_always_inline int check_block(SnowContext *s, int mb_x, int mb_y, int p[3], int intra, uint8_t (*obmc_edged)[MB_SIZE * 2], int *best_rd){
+static av_always_inline int check_block_intra(SnowContext *s, int mb_x, int mb_y, int p[3],
+                                              uint8_t (*obmc_edged)[MB_SIZE * 2], int *best_rd)
+{
     const int b_stride= s->b_width << s->block_max_depth;
     BlockNode *block= &s->block[mb_x + mb_y * b_stride];
     BlockNode backup= *block;
-    unsigned value;
-    int rd, index;
+    int rd;
 
     av_assert2(mb_x>=0 && mb_y>=0);
     av_assert2(mb_x<b_stride);
 
-    if(intra){
-        block->color[0] = p[0];
-        block->color[1] = p[1];
-        block->color[2] = p[2];
-        block->type |= BLOCK_INTRA;
-    }else{
-        index= (p[0] + 31*p[1]) & (ME_CACHE_SIZE-1);
-        value= s->me_cache_generation + (p[0]>>10) + (p[1]<<6) + (block->ref<<12);
-        if(s->me_cache[index] == value)
-            return 0;
-        s->me_cache[index]= value;
-
-        block->mx= p[0];
-        block->my= p[1];
-        block->type &= ~BLOCK_INTRA;
-    }
+    block->color[0] = p[0];
+    block->color[1] = p[1];
+    block->color[2] = p[2];
+    block->type |= BLOCK_INTRA;
 
-    rd= get_block_rd(s, mb_x, mb_y, 0, obmc_edged) + s->intra_penalty * !!intra;
+    rd = get_block_rd(s, mb_x, mb_y, 0, obmc_edged) + s->intra_penalty;
 
 //FIXME chroma
     if(rd < *best_rd){
@@ -934,8 +923,35 @@ static av_always_inline int check_block(SnowContext *s, int mb_x, int mb_y, int
 /* special case for int[2] args we discard afterwards,
  * fixes compilation problem with gcc 2.95 */
 static av_always_inline int check_block_inter(SnowContext *s, int mb_x, int mb_y, int p0, int p1, uint8_t (*obmc_edged)[MB_SIZE * 2], int *best_rd){
-    int p[2] = {p0, p1};
-    return check_block(s, mb_x, mb_y, p, 0, obmc_edged, best_rd);
+    const int b_stride = s->b_width << s->block_max_depth;
+    BlockNode *block = &s->block[mb_x + mb_y * b_stride];
+    BlockNode backup = *block;
+    unsigned value;
+    int rd, index;
+
+    av_assert2(mb_x >= 0 && mb_y >= 0);
+    av_assert2(mb_x < b_stride);
+
+    index = (p0 + 31 * p1) & (ME_CACHE_SIZE-1);
+    value = s->me_cache_generation + (p0 >> 10) + (p1 << 6) + (block->ref << 12);
+    if (s->me_cache[index] == value)
+        return 0;
+    s->me_cache[index] = value;
+
+    block->mx = p0;
+    block->my = p1;
+    block->type &= ~BLOCK_INTRA;
+
+    rd = get_block_rd(s, mb_x, mb_y, 0, obmc_edged);
+
+//FIXME chroma
+    if (rd < *best_rd) {
+        *best_rd = rd;
+        return 1;
+    } else {
+        *block   = backup;
+        return 0;
+    }
 }
 
 static av_always_inline int check_4block_inter(SnowContext *s, int mb_x, int mb_y, int p0, int p1, int ref, int *best_rd){
@@ -1060,7 +1076,7 @@ static void iterative_me(SnowContext *s){
 
                 //skip stuff outside the picture
                 if(mb_x==0 || mb_y==0 || mb_x==b_width-1 || mb_y==b_height-1){
-                    uint8_t *src= s->  input_picture->data[0];
+                    const uint8_t *src = s->input_picture->data[0];
                     uint8_t *dst= s->current_picture->data[0];
                     const int stride= s->current_picture->linesize[0];
                     const int block_w= MB_SIZE >> s->block_max_depth;
@@ -1092,7 +1108,7 @@ static void iterative_me(SnowContext *s){
                 // get previous score (cannot be cached due to OBMC)
                 if(pass > 0 && (block->type&BLOCK_INTRA)){
                     int color0[3]= {block->color[0], block->color[1], block->color[2]};
-                    check_block(s, mb_x, mb_y, color0, 1, obmc_edged, &best_rd);
+                    check_block_intra(s, mb_x, mb_y, color0, obmc_edged, &best_rd);
                 }else
                     check_block_inter(s, mb_x, mb_y, block->mx, block->my, obmc_edged, &best_rd);
 
@@ -1150,7 +1166,7 @@ static void iterative_me(SnowContext *s){
                 }
                 best_rd= ref_rd;
                 *block= ref_b;
-                check_block(s, mb_x, mb_y, color, 1, obmc_edged, &best_rd);
+                check_block_intra(s, mb_x, mb_y, color, obmc_edged, &best_rd);
                 //FIXME RD style color selection
                 if(!same_block(block, &backup)){
                     if(tb ) tb ->type &= ~BLOCK_OPT;
@@ -1511,11 +1527,11 @@ static int ratecontrol_1pass(SnowContext *s, AVFrame *pict)
     coef_sum = (uint64_t)coef_sum * coef_sum >> 16;
 
     if(pict->pict_type == AV_PICTURE_TYPE_I){
-        s->m.current_picture.mb_var_sum= coef_sum;
-        s->m.current_picture.mc_mb_var_sum= 0;
+        s->m.mb_var_sum    = coef_sum;
+        s->m.mc_mb_var_sum = 0;
     }else{
-        s->m.current_picture.mc_mb_var_sum= coef_sum;
-        s->m.current_picture.mb_var_sum= 0;
+        s->m.mc_mb_var_sum = coef_sum;
+        s->m.mb_var_sum    = 0;
     }
 
     pict->quality= ff_rate_estimate_qscale(&s->m, 1);
@@ -1927,6 +1943,5 @@ const FFCodec ff_snow_encoder = {
         AV_PIX_FMT_NONE
     },
     .p.priv_class   = &snowenc_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/sonic.c b/libavcodec/sonic.c
index dfb055d..c635831 100644
--- a/libavcodec/sonic.c
+++ b/libavcodec/sonic.c
@@ -1086,7 +1086,7 @@ const FFCodec ff_sonic_decoder = {
     .close          = sonic_decode_close,
     FF_CODEC_DECODE_CB(sonic_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_EXPERIMENTAL | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif /* CONFIG_SONIC_DECODER */
 
@@ -1101,7 +1101,7 @@ const FFCodec ff_sonic_encoder = {
     FF_CODEC_ENCODE_CB(sonic_encode_frame),
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },
     .p.capabilities = AV_CODEC_CAP_EXPERIMENTAL,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .close          = sonic_encode_close,
 };
 #endif
@@ -1117,7 +1117,7 @@ const FFCodec ff_sonic_ls_encoder = {
     FF_CODEC_ENCODE_CB(sonic_encode_frame),
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_S16, AV_SAMPLE_FMT_NONE },
     .p.capabilities = AV_CODEC_CAP_EXPERIMENTAL,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .close          = sonic_encode_close,
 };
 #endif
diff --git a/libavcodec/sp5xdec.c b/libavcodec/sp5xdec.c
index aa4d3d7..1d8316f 100644
--- a/libavcodec/sp5xdec.c
+++ b/libavcodec/sp5xdec.c
@@ -103,7 +103,7 @@ const FFCodec ff_sp5x_decoder = {
     FF_CODEC_RECEIVE_FRAME_CB(ff_mjpeg_receive_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .p.max_lowres   = 3,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_SETS_PKT_DTS,
 };
 #endif
@@ -119,7 +119,7 @@ const FFCodec ff_amv_decoder = {
     FF_CODEC_RECEIVE_FRAME_CB(ff_mjpeg_receive_frame),
     .p.max_lowres   = 3,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_SETS_PKT_DTS,
 };
 #endif
diff --git a/libavcodec/speedhq.c b/libavcodec/speedhq.c
index e158061..c43de4f 100644
--- a/libavcodec/speedhq.c
+++ b/libavcodec/speedhq.c
@@ -499,7 +499,7 @@ static int speedhq_decode_frame(AVCodecContext *avctx, AVFrame *frame,
     uint32_t second_field_offset;
     int ret;
 
-    if (buf_size < 4 || avctx->width < 8 || avctx->width % 8 != 0)
+    if (buf_size < 4 || avctx->width < 8)
         return AVERROR_INVALIDDATA;
 
     quality = buf[0];
@@ -733,6 +733,5 @@ const FFCodec ff_speedhq_decoder = {
     .init           = speedhq_decode_init,
     FF_CODEC_DECODE_CB(speedhq_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif /* CONFIG_SPEEDHQ_DECODER */
diff --git a/libavcodec/speedhqenc.c b/libavcodec/speedhqenc.c
index 7a53d86..73c70c2 100644
--- a/libavcodec/speedhqenc.c
+++ b/libavcodec/speedhqenc.c
@@ -287,7 +287,7 @@ const FFCodec ff_speedhq_encoder = {
     .init           = ff_mpv_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
     .close          = ff_mpv_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV422P, AV_PIX_FMT_YUV444P,
         AV_PIX_FMT_NONE
diff --git a/libavcodec/speexdec.c b/libavcodec/speexdec.c
index 3251eda..92a4f39 100644
--- a/libavcodec/speexdec.c
+++ b/libavcodec/speexdec.c
@@ -1586,5 +1586,5 @@ const FFCodec ff_speex_decoder = {
     .close          = speex_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .priv_data_size = sizeof(SpeexContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/srtdec.c b/libavcodec/srtdec.c
index b2df344..3a1ddfc 100644
--- a/libavcodec/srtdec.c
+++ b/libavcodec/srtdec.c
@@ -99,7 +99,6 @@ const FFCodec ff_srt_decoder = {
     FF_CODEC_DECODE_SUB_CB(srt_decode_frame),
     .flush        = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -113,6 +112,5 @@ const FFCodec ff_subrip_decoder = {
     FF_CODEC_DECODE_SUB_CB(srt_decode_frame),
     .flush        = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/srtenc.c b/libavcodec/srtenc.c
index 51456c8..f6b2f16 100644
--- a/libavcodec/srtenc.c
+++ b/libavcodec/srtenc.c
@@ -302,7 +302,6 @@ const FFCodec ff_srt_encoder = {
     .init           = srt_encode_init,
     FF_CODEC_ENCODE_SUB_CB(srt_encode_frame),
     .close          = srt_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -316,7 +315,6 @@ const FFCodec ff_subrip_encoder = {
     .init           = srt_encode_init,
     FF_CODEC_ENCODE_SUB_CB(srt_encode_frame),
     .close          = srt_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -330,6 +328,5 @@ const FFCodec ff_text_encoder = {
     .init           = srt_encode_init,
     FF_CODEC_ENCODE_SUB_CB(text_encode_frame),
     .close          = srt_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/subviewerdec.c b/libavcodec/subviewerdec.c
index 2bda5fa..3a293b0 100644
--- a/libavcodec/subviewerdec.c
+++ b/libavcodec/subviewerdec.c
@@ -74,5 +74,4 @@ const FFCodec ff_subviewer_decoder = {
     .init           = ff_ass_subtitle_header_default,
     .flush          = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/sunrastenc.c b/libavcodec/sunrastenc.c
index 6245e59..4fcc0e3 100644
--- a/libavcodec/sunrastenc.c
+++ b/libavcodec/sunrastenc.c
@@ -222,5 +222,4 @@ const FFCodec ff_sunrast_encoder = {
                                                   AV_PIX_FMT_GRAY8,
                                                   AV_PIX_FMT_MONOWHITE,
                                                   AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/svq1dec.c b/libavcodec/svq1dec.c
index 6fb5057..27feac3 100644
--- a/libavcodec/svq1dec.c
+++ b/libavcodec/svq1dec.c
@@ -856,5 +856,4 @@ const FFCodec ff_svq1_decoder = {
     .flush          = svq1_flush,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV410P,
                                                      AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/svq1enc.c b/libavcodec/svq1enc.c
index 3c2d594..36bc214 100644
--- a/libavcodec/svq1enc.c
+++ b/libavcodec/svq1enc.c
@@ -91,7 +91,7 @@ static int ssd_int8_vs_int16_c(const int8_t *pix1, const int16_t *pix2,
 }
 
 static int encode_block(SVQ1EncContext *s, uint8_t *src, uint8_t *ref,
-                        uint8_t *decoded, int stride, int level,
+                        uint8_t *decoded, int stride, unsigned level,
                         int threshold, int lambda, int intra)
 {
     int count, y, x, i, j, split, best_mean, best_score, best_count;
@@ -248,7 +248,7 @@ static void init_block_index(MpegEncContext *s){
 }
 
 static int svq1_encode_plane(SVQ1EncContext *s, int plane,
-                             unsigned char *src_plane,
+                             const unsigned char *src_plane,
                              unsigned char *ref_plane,
                              unsigned char *decoded_plane,
                              int width, int height, int src_stride, int stride)
@@ -313,9 +313,9 @@ static int svq1_encode_plane(SVQ1EncContext *s, int plane,
         s->m.mb_type = s->mb_type;
 
         // dummies, to avoid segfaults
-        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;
-        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;
-        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;
+        s->m.mb_mean   = (uint8_t *)s->dummy;
+        s->m.mb_var    = (uint16_t *)s->dummy;
+        s->m.mc_mb_var = (uint16_t *)s->dummy;
         s->m.current_picture.mb_type = s->dummy;
 
         s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;
@@ -371,7 +371,7 @@ static int svq1_encode_plane(SVQ1EncContext *s, int plane,
             int count[2][6];
             int offset       = y * 16 * stride + x * 16;
             uint8_t *decoded = decoded_plane + offset;
-            uint8_t *ref     = ref_plane + offset;
+            const uint8_t *ref = ref_plane + offset;
             int score[4]     = { 0, 0, 0, 0 }, best;
             uint8_t *temp    = s->scratchbuf;
 
@@ -689,5 +689,5 @@ const FFCodec ff_svq1_encoder = {
     .close          = svq1_encode_end,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV410P,
                                                      AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/svq3.c b/libavcodec/svq3.c
index f038466..1c3ed3c 100644
--- a/libavcodec/svq3.c
+++ b/libavcodec/svq3.c
@@ -1602,5 +1602,5 @@ const FFCodec ff_svq3_decoder = {
                       AV_CODEC_CAP_DELAY,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUVJ420P,
                                                      AV_PIX_FMT_NONE},
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/takdec.c b/libavcodec/takdec.c
index 47978fc..3e53401 100644
--- a/libavcodec/takdec.c
+++ b/libavcodec/takdec.c
@@ -956,5 +956,4 @@ const FFCodec ff_tak_decoder = {
                                                         AV_SAMPLE_FMT_S16P,
                                                         AV_SAMPLE_FMT_S32P,
                                                         AV_SAMPLE_FMT_NONE },
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/targa_y216dec.c b/libavcodec/targa_y216dec.c
index bf33dc8..1c19857 100644
--- a/libavcodec/targa_y216dec.c
+++ b/libavcodec/targa_y216dec.c
@@ -81,5 +81,4 @@ const FFCodec ff_targa_y216_decoder = {
     .init         = y216_decode_init,
     FF_CODEC_DECODE_CB(y216_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/targaenc.c b/libavcodec/targaenc.c
index 84e2086..7fb8e28 100644
--- a/libavcodec/targaenc.c
+++ b/libavcodec/targaenc.c
@@ -72,7 +72,7 @@ static int targa_encode_normal(uint8_t *outbuf, const AVFrame *pic, int bpp, int
 {
     int i, n = bpp * w;
     uint8_t *out = outbuf;
-    uint8_t *ptr = pic->data[0];
+    const uint8_t *ptr = pic->data[0];
 
     for(i=0; i < h; i++) {
         memcpy(out, ptr, n);
@@ -215,5 +215,4 @@ const FFCodec ff_targa_encoder = {
         AV_PIX_FMT_BGR24, AV_PIX_FMT_BGRA, AV_PIX_FMT_RGB555LE, AV_PIX_FMT_GRAY8, AV_PIX_FMT_PAL8,
         AV_PIX_FMT_NONE
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/tdsc.c b/libavcodec/tdsc.c
index 0cf17d7..7e16a32 100644
--- a/libavcodec/tdsc.c
+++ b/libavcodec/tdsc.c
@@ -631,6 +631,5 @@ const FFCodec ff_tdsc_decoder = {
     .close          = tdsc_close,
     .priv_data_size = sizeof(TDSCContext),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/textdec.c b/libavcodec/textdec.c
index d509452..4856ecd 100644
--- a/libavcodec/textdec.c
+++ b/libavcodec/textdec.c
@@ -90,7 +90,6 @@ const FFCodec ff_text_decoder = {
     .init           = ff_ass_subtitle_header_default,
     .p.priv_class   = &textsub_decoder_class,
     .flush          = text_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -114,7 +113,6 @@ const FFCodec ff_vplayer_decoder = {
     .init           = linebreak_init,
     .p.priv_class   = &textsub_decoder_class,
     .flush          = text_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -129,7 +127,6 @@ const FFCodec ff_stl_decoder = {
     .init           = linebreak_init,
     .p.priv_class   = &textsub_decoder_class,
     .flush          = text_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -144,7 +141,6 @@ const FFCodec ff_pjs_decoder = {
     .init           = linebreak_init,
     .p.priv_class   = &textsub_decoder_class,
     .flush          = text_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
@@ -159,7 +155,6 @@ const FFCodec ff_subviewer1_decoder = {
     .init           = linebreak_init,
     .p.priv_class   = &textsub_decoder_class,
     .flush          = text_flush,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 
diff --git a/libavcodec/thread.h b/libavcodec/thread.h
index 92cbd92..d5673f2 100644
--- a/libavcodec/thread.h
+++ b/libavcodec/thread.h
@@ -104,8 +104,7 @@ int ff_slice_thread_execute_with_mainfunc(AVCodecContext *avctx,
         int (*action_func2)(AVCodecContext *c, void *arg, int jobnr, int threadnr),
         int (*main_func)(AVCodecContext *c), void *arg, int *ret, int job_count);
 void ff_thread_free(AVCodecContext *s);
-int ff_alloc_entries(AVCodecContext *avctx, int count);
-void ff_reset_entries(AVCodecContext *avctx);
+int ff_slice_thread_allocz_entries(AVCodecContext *avctx, int count);
 int ff_slice_thread_init_progress(AVCodecContext *avctx);
 void ff_thread_report_progress2(AVCodecContext *avctx, int field, int thread, int n);
 void ff_thread_await_progress2(AVCodecContext *avctx,  int field, int thread, int shift);
diff --git a/libavcodec/threadframe.h b/libavcodec/threadframe.h
index dea4dad..d2f93c5 100644
--- a/libavcodec/threadframe.h
+++ b/libavcodec/threadframe.h
@@ -56,7 +56,7 @@ void ff_thread_report_progress(ThreadFrame *f, int progress, int field);
  * @param field The field being referenced, for field-picture codecs.
  * 0 for top field or frame pictures, 1 for bottom field.
  */
-void ff_thread_await_progress(ThreadFrame *f, int progress, int field);
+void ff_thread_await_progress(const ThreadFrame *f, int progress, int field);
 
 /**
  * Wrapper around ff_get_buffer() for frame-multithreaded codecs.
@@ -84,4 +84,6 @@ void ff_thread_release_ext_buffer(AVCodecContext *avctx, ThreadFrame *f);
 
 int ff_thread_ref_frame(ThreadFrame *dst, const ThreadFrame *src);
 
+int ff_thread_can_start_frame(AVCodecContext *avctx);
+
 #endif
diff --git a/libavcodec/tiertexseqv.c b/libavcodec/tiertexseqv.c
index 618275a..26711a3 100644
--- a/libavcodec/tiertexseqv.c
+++ b/libavcodec/tiertexseqv.c
@@ -271,5 +271,4 @@ const FFCodec ff_tiertexseqvideo_decoder = {
     .close          = seqvideo_decode_end,
     FF_CODEC_DECODE_CB(seqvideo_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/tiff.c b/libavcodec/tiff.c
index e7a2576..043ff79 100644
--- a/libavcodec/tiff.c
+++ b/libavcodec/tiff.c
@@ -1750,7 +1750,7 @@ static int decode_frame(AVCodecContext *avctx, AVFrame *p,
                         int *got_frame, AVPacket *avpkt)
 {
     TiffContext *const s = avctx->priv_data;
-    unsigned off, last_off = 0;
+    unsigned off, last_off;
     int le, ret, plane, planes;
     int i, j, entries, stride;
     unsigned soff, ssize;
@@ -1815,6 +1815,7 @@ again:
     /** whether we should process this multi-page IFD's next page */
     retry_for_page = s->get_page && s->cur_page + 1 < s->get_page;  // get_page is 1-indexed
 
+    last_off = off;
     if (retry_for_page) {
         // set offset to the next IFD
         off = ff_tget_long(&s->gb, le);
@@ -1832,7 +1833,6 @@ again:
             avpriv_request_sample(s->avctx, "non increasing IFD offset");
             return AVERROR_INVALIDDATA;
         }
-        last_off = off;
         if (off >= UINT_MAX - 14 || avpkt->size < off + 14) {
             av_log(avctx, AV_LOG_ERROR, "IFD offset is greater than image size\n");
             return AVERROR_INVALIDDATA;
@@ -2193,6 +2193,6 @@ const FFCodec ff_tiff_decoder = {
     .close          = tiff_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_ICC_PROFILES,
     .p.priv_class   = &tiff_decoder_class,
 };
diff --git a/libavcodec/tiffenc.c b/libavcodec/tiffenc.c
index 2f2742e..dba0e89 100644
--- a/libavcodec/tiffenc.c
+++ b/libavcodec/tiffenc.c
@@ -207,8 +207,8 @@ static void pack_yuv(TiffEncoderContext *s, const AVFrame *p,
 {
     int i, j, k;
     int w       = (s->width - 1) / s->subsampling[0] + 1;
-    uint8_t *pu = &p->data[1][lnum / s->subsampling[1] * p->linesize[1]];
-    uint8_t *pv = &p->data[2][lnum / s->subsampling[1] * p->linesize[2]];
+    const uint8_t *pu = &p->data[1][lnum / s->subsampling[1] * p->linesize[1]];
+    const uint8_t *pv = &p->data[2][lnum / s->subsampling[1] * p->linesize[2]];
     if (s->width % s->subsampling[0] || s->height % s->subsampling[1]) {
         for (i = 0; i < w; i++) {
             for (j = 0; j < s->subsampling[1]; j++)
@@ -589,5 +589,4 @@ const FFCodec ff_tiff_encoder = {
         AV_PIX_FMT_NONE
     },
     .p.priv_class   = &tiffenc_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/tmv.c b/libavcodec/tmv.c
index d1685a0..22329f2 100644
--- a/libavcodec/tmv.c
+++ b/libavcodec/tmv.c
@@ -94,5 +94,4 @@ const FFCodec ff_tmv_decoder = {
     .init           = tmv_decode_init,
     FF_CODEC_DECODE_CB(tmv_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/truemotion1.c b/libavcodec/truemotion1.c
index 64d9b8f..fc9f811 100644
--- a/libavcodec/truemotion1.c
+++ b/libavcodec/truemotion1.c
@@ -920,5 +920,5 @@ const FFCodec ff_truemotion1_decoder = {
     .close          = truemotion1_decode_end,
     FF_CODEC_DECODE_CB(truemotion1_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/truemotion2.c b/libavcodec/truemotion2.c
index 3fd956e..ec3f0d0 100644
--- a/libavcodec/truemotion2.c
+++ b/libavcodec/truemotion2.c
@@ -1018,5 +1018,5 @@ const FFCodec ff_truemotion2_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/truemotion2rt.c b/libavcodec/truemotion2rt.c
index a3686fc..46452a7 100644
--- a/libavcodec/truemotion2rt.c
+++ b/libavcodec/truemotion2rt.c
@@ -228,5 +228,4 @@ const FFCodec ff_truemotion2rt_decoder = {
     .init           = truemotion2rt_decode_init,
     FF_CODEC_DECODE_CB(truemotion2rt_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/truespeech.c b/libavcodec/truespeech.c
index e472cb8..f0cfada 100644
--- a/libavcodec/truespeech.c
+++ b/libavcodec/truespeech.c
@@ -365,5 +365,4 @@ const FFCodec ff_truespeech_decoder = {
     .init           = truespeech_decode_init,
     FF_CODEC_DECODE_CB(truespeech_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/tscc.c b/libavcodec/tscc.c
index 7343d7a..601ee19 100644
--- a/libavcodec/tscc.c
+++ b/libavcodec/tscc.c
@@ -180,5 +180,5 @@ const FFCodec ff_tscc_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/tscc2.c b/libavcodec/tscc2.c
index f6950fb..a50a8da 100644
--- a/libavcodec/tscc2.c
+++ b/libavcodec/tscc2.c
@@ -366,5 +366,5 @@ const FFCodec ff_tscc2_decoder = {
     .close          = tscc2_decode_end,
     FF_CODEC_DECODE_CB(tscc2_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/tta.c b/libavcodec/tta.c
index 0fc639b..4bc6016 100644
--- a/libavcodec/tta.c
+++ b/libavcodec/tta.c
@@ -377,15 +377,8 @@ static int tta_decode_frame(AVCodecContext *avctx, AVFrame *frame,
     case 3: {
         // shift samples for 24-bit sample format
         int32_t *samples = (int32_t *)frame->data[0];
-        int overflow = 0;
-
-        for (i = 0; i < framelen * s->channels; i++) {
-            int scaled = *samples * 256U;
-            overflow += (scaled >> 8 != *samples);
-            *samples++ = scaled;
-        }
-        if (overflow)
-            av_log(avctx, AV_LOG_WARNING, "%d overflows occurred on 24bit upscale\n", overflow);
+        for (i = 0; i < framelen * s->channels; i++)
+            *samples++ *= 256;
         // reset decode buffer
         s->decode_buffer = NULL;
         break;
@@ -438,5 +431,5 @@ const FFCodec ff_tta_decoder = {
     FF_CODEC_DECODE_CB(tta_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_CHANNEL_CONF,
     .p.priv_class   = &tta_decoder_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/ttaenc.c b/libavcodec/ttaenc.c
index b7d4aaf..25113d4 100644
--- a/libavcodec/ttaenc.c
+++ b/libavcodec/ttaenc.c
@@ -216,5 +216,4 @@ const FFCodec ff_tta_encoder = {
                                                      AV_SAMPLE_FMT_S16,
                                                      AV_SAMPLE_FMT_S32,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ttmlenc.c b/libavcodec/ttmlenc.c
index be1d8fb..7a09c8f 100644
--- a/libavcodec/ttmlenc.c
+++ b/libavcodec/ttmlenc.c
@@ -315,7 +315,7 @@ static int ttml_write_header_content(AVCodecContext *avctx)
     }
 
     // write the first string in extradata, attributes in the base "tt" element.
-    av_bprintf(&s->buffer, ttml_default_namespacing);
+    av_bprintf(&s->buffer, TTML_DEFAULT_NAMESPACING);
     // the cell resolution is in character cells, so not exactly 1:1 against
     // a pixel based resolution, but as the tts:extent in the root
     // "tt" element is frowned upon (and disallowed in the EBU-TT profile),
@@ -392,5 +392,5 @@ const FFCodec ff_ttml_encoder = {
     .init           = ttml_encode_init,
     FF_CODEC_ENCODE_SUB_CB(ttml_encode_frame),
     .close          = ttml_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/ttmlenc.h b/libavcodec/ttmlenc.h
index 467f35c..cbed6f6 100644
--- a/libavcodec/ttmlenc.h
+++ b/libavcodec/ttmlenc.h
@@ -25,10 +25,10 @@
 #define TTMLENC_EXTRADATA_SIGNATURE "lavc-ttmlenc"
 #define TTMLENC_EXTRADATA_SIGNATURE_SIZE (sizeof(TTMLENC_EXTRADATA_SIGNATURE) - 1)
 
-static const char ttml_default_namespacing[] =
-"  xmlns=\"http://www.w3.org/ns/ttml\"\n"
-"  xmlns:ttm=\"http://www.w3.org/ns/ttml#metadata\"\n"
-"  xmlns:tts=\"http://www.w3.org/ns/ttml#styling\"\n"
-"  xmlns:ttp=\"http://www.w3.org/ns/ttml#parameter\"\n";
+#define TTML_DEFAULT_NAMESPACING                        \
+"  xmlns=\"http://www.w3.org/ns/ttml\"\n"               \
+"  xmlns:ttm=\"http://www.w3.org/ns/ttml#metadata\"\n"  \
+"  xmlns:tts=\"http://www.w3.org/ns/ttml#styling\"\n"   \
+"  xmlns:ttp=\"http://www.w3.org/ns/ttml#parameter\"\n"
 
 #endif /* AVCODEC_TTMLENC_H */
diff --git a/libavcodec/twinvqdec.c b/libavcodec/twinvqdec.c
index 6dfa57f..7732957 100644
--- a/libavcodec/twinvqdec.c
+++ b/libavcodec/twinvqdec.c
@@ -426,5 +426,5 @@ const FFCodec ff_twinvq_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/ulti.c b/libavcodec/ulti.c
index a8bec9c..b9d17da 100644
--- a/libavcodec/ulti.c
+++ b/libavcodec/ulti.c
@@ -428,5 +428,4 @@ const FFCodec ff_ulti_decoder = {
     .close          = ulti_decode_end,
     FF_CODEC_DECODE_CB(ulti_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index f78475d..e73e3a7 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -949,7 +949,7 @@ void ff_thread_report_progress(ThreadFrame *f, int progress, int field)
 {
 }
 
-void ff_thread_await_progress(ThreadFrame *f, int progress, int field)
+void ff_thread_await_progress(const ThreadFrame *f, int progress, int field)
 {
 }
 
@@ -963,15 +963,11 @@ int ff_slice_thread_init_progress(AVCodecContext *avctx)
     return 0;
 }
 
-int ff_alloc_entries(AVCodecContext *avctx, int count)
+int ff_slice_thread_allocz_entries(AVCodecContext *avctx, int count)
 {
     return 0;
 }
 
-void ff_reset_entries(AVCodecContext *avctx)
-{
-}
-
 void ff_thread_await_progress2(AVCodecContext *avctx, int field, int thread, int shift)
 {
 }
diff --git a/libavcodec/utvideodec.c b/libavcodec/utvideodec.c
index 03ee8f0..fd16c3f 100644
--- a/libavcodec/utvideodec.c
+++ b/libavcodec/utvideodec.c
@@ -1060,5 +1060,4 @@ const FFCodec ff_utvideo_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/utvideoenc.c b/libavcodec/utvideoenc.c
index 15a53a6..f38db96 100644
--- a/libavcodec/utvideoenc.c
+++ b/libavcodec/utvideoenc.c
@@ -277,7 +277,7 @@ static void mangle_rgb_planes(uint8_t *dst[4], ptrdiff_t dst_stride,
 #undef B
 
 /* Write data to a plane with median prediction */
-static void median_predict(UtvideoContext *c, uint8_t *src, uint8_t *dst,
+static void median_predict(UtvideoContext *c, const uint8_t *src, uint8_t *dst,
                            ptrdiff_t stride, int width, int height)
 {
     int i, j;
@@ -376,7 +376,7 @@ static int write_huff_codes(uint8_t *src, uint8_t *dst, int dst_size,
     return put_bytes_output(&pb);
 }
 
-static int encode_plane(AVCodecContext *avctx, uint8_t *src,
+static int encode_plane(AVCodecContext *avctx, const uint8_t *src,
                         uint8_t *dst, ptrdiff_t stride, int plane_no,
                         int width, int height, PutByteContext *pb)
 {
@@ -658,5 +658,5 @@ const FFCodec ff_utvideo_encoder = {
                           AV_PIX_FMT_GBRP, AV_PIX_FMT_GBRAP, AV_PIX_FMT_YUV422P,
                           AV_PIX_FMT_YUV420P, AV_PIX_FMT_YUV444P, AV_PIX_FMT_NONE
                       },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/v210dec.c b/libavcodec/v210dec.c
index bf84cd4..f546379 100644
--- a/libavcodec/v210dec.c
+++ b/libavcodec/v210dec.c
@@ -243,5 +243,4 @@ const FFCodec ff_v210_decoder = {
                       AV_CODEC_CAP_SLICE_THREADS |
                       AV_CODEC_CAP_FRAME_THREADS,
     .p.priv_class   = &v210dec_class,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/v210enc.c b/libavcodec/v210enc.c
index de2e405..f466df8 100644
--- a/libavcodec/v210enc.c
+++ b/libavcodec/v210enc.c
@@ -117,5 +117,4 @@ const FFCodec ff_v210_encoder = {
     .init           = encode_init,
     FF_CODEC_ENCODE_CB(encode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV422P10, AV_PIX_FMT_YUV422P, AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/v210x.c b/libavcodec/v210x.c
index 18d3e63..f388a1c 100644
--- a/libavcodec/v210x.c
+++ b/libavcodec/v210x.c
@@ -127,5 +127,4 @@ const FFCodec ff_v210x_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/v308dec.c b/libavcodec/v308dec.c
index 5f8cbc6..a6a699c 100644
--- a/libavcodec/v308dec.c
+++ b/libavcodec/v308dec.c
@@ -80,5 +80,4 @@ const FFCodec ff_v308_decoder = {
     .init         = v308_decode_init,
     FF_CODEC_DECODE_CB(v308_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/v308enc.c b/libavcodec/v308enc.c
index c4f07a1..c6a270a 100644
--- a/libavcodec/v308enc.c
+++ b/libavcodec/v308enc.c
@@ -43,7 +43,7 @@ static int v308_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                              const AVFrame *pic, int *got_packet)
 {
     uint8_t *dst;
-    uint8_t *y, *u, *v;
+    const uint8_t *y, *u, *v;
     int i, j, ret;
 
     ret = ff_get_encode_buffer(avctx, pkt, avctx->width * avctx->height * 3, 0);
@@ -79,5 +79,4 @@ const FFCodec ff_v308_encoder = {
     .init         = v308_encode_init,
     FF_CODEC_ENCODE_CB(v308_encode_frame),
     .p.pix_fmts   = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV444P, AV_PIX_FMT_NONE },
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/v408dec.c b/libavcodec/v408dec.c
index 0202495..88fa777 100644
--- a/libavcodec/v408dec.c
+++ b/libavcodec/v408dec.c
@@ -90,7 +90,6 @@ const FFCodec ff_ayuv_decoder = {
     .init         = v408_decode_init,
     FF_CODEC_DECODE_CB(v408_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_V408_DECODER
@@ -102,6 +101,5 @@ const FFCodec ff_v408_decoder = {
     .init         = v408_decode_init,
     FF_CODEC_DECODE_CB(v408_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/v408enc.c b/libavcodec/v408enc.c
index 157ed85..77d2b02 100644
--- a/libavcodec/v408enc.c
+++ b/libavcodec/v408enc.c
@@ -40,7 +40,7 @@ static int v408_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                              const AVFrame *pic, int *got_packet)
 {
     uint8_t *dst;
-    uint8_t *y, *u, *v, *a;
+    const uint8_t *y, *u, *v, *a;
     int i, j, ret;
 
     ret = ff_get_encode_buffer(avctx, pkt, avctx->width * avctx->height * 4, 0);
@@ -89,7 +89,6 @@ const FFCodec ff_ayuv_encoder = {
     .init         = v408_encode_init,
     FF_CODEC_ENCODE_CB(v408_encode_frame),
     .p.pix_fmts   = pix_fmt,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
 #if CONFIG_V408_ENCODER
@@ -102,6 +101,5 @@ const FFCodec ff_v408_encoder = {
     .init         = v408_encode_init,
     FF_CODEC_ENCODE_CB(v408_encode_frame),
     .p.pix_fmts   = pix_fmt,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 #endif
diff --git a/libavcodec/v410dec.c b/libavcodec/v410dec.c
index e67cb82..4844e12 100644
--- a/libavcodec/v410dec.c
+++ b/libavcodec/v410dec.c
@@ -123,5 +123,4 @@ const FFCodec ff_v410_decoder = {
     FF_CODEC_DECODE_CB(v410_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS |
                     AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/v410enc.c b/libavcodec/v410enc.c
index 88a2ce3..f08ccb2 100644
--- a/libavcodec/v410enc.c
+++ b/libavcodec/v410enc.c
@@ -44,7 +44,7 @@ static int v410_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                              const AVFrame *pic, int *got_packet)
 {
     uint8_t *dst;
-    uint16_t *y, *u, *v;
+    const uint16_t *y, *u, *v;
     uint32_t val;
     int i, j, ret;
 
@@ -83,5 +83,4 @@ const FFCodec ff_v410_encoder = {
     .init         = v410_encode_init,
     FF_CODEC_ENCODE_CB(v410_encode_frame),
     .p.pix_fmts   = (const enum AVPixelFormat[]){ AV_PIX_FMT_YUV444P10, AV_PIX_FMT_NONE },
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/v4l2_m2m_dec.c b/libavcodec/v4l2_m2m_dec.c
index 8a51dec..81729e2 100644
--- a/libavcodec/v4l2_m2m_dec.c
+++ b/libavcodec/v4l2_m2m_dec.c
@@ -252,7 +252,8 @@ static const AVOption options[] = {
         .close          = v4l2_decode_close, \
         .bsfs           = bsf_name, \
         .p.capabilities = AV_CODEC_CAP_HARDWARE | AV_CODEC_CAP_DELAY | AV_CODEC_CAP_AVOID_PROBING, \
-        .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_INIT_CLEANUP, \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
+                          FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_INIT_CLEANUP, \
         .p.wrapper_name = "v4l2m2m", \
     }
 
diff --git a/libavcodec/v4l2_m2m_enc.c b/libavcodec/v4l2_m2m_enc.c
index 20f81df..0342567 100644
--- a/libavcodec/v4l2_m2m_enc.c
+++ b/libavcodec/v4l2_m2m_enc.c
@@ -433,7 +433,8 @@ static const FFCodecDefault v4l2_m2m_defaults[] = {
         .close          = v4l2_encode_close, \
         .defaults       = v4l2_m2m_defaults, \
         .p.capabilities = AV_CODEC_CAP_HARDWARE | AV_CODEC_CAP_DELAY, \
-        .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP, \
+        .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE | \
+                          FF_CODEC_CAP_INIT_CLEANUP, \
         .p.wrapper_name = "v4l2m2m", \
     }
 
diff --git a/libavcodec/vaapi_decode.c b/libavcodec/vaapi_decode.c
index a7abddb..bc2d3ed 100644
--- a/libavcodec/vaapi_decode.c
+++ b/libavcodec/vaapi_decode.c
@@ -267,6 +267,7 @@ static const struct {
     MAP(422V, YUV440P),
     // 4:4:4
     MAP(444P, YUV444P),
+    MAP(AYUV, VUYA),
     // 4:2:0 10-bit
 #ifdef VA_FOURCC_P010
     MAP(P010, P010),
@@ -357,6 +358,8 @@ static int vaapi_decode_find_best_format(AVCodecContext *avctx,
 
         ctx->pixel_format_attribute = (VASurfaceAttrib) {
             .type          = VASurfaceAttribPixelFormat,
+            .flags         = VA_SURFACE_ATTRIB_SETTABLE,
+            .value.type    = VAGenericValueTypeInteger,
             .value.value.i = best_fourcc,
         };
 
@@ -410,6 +413,7 @@ static const struct {
     MAP(VP9,         VP9_0,           VP9Profile0 ),
 #endif
 #if VA_CHECK_VERSION(0, 39, 0)
+    MAP(VP9,         VP9_1,           VP9Profile1 ),
     MAP(VP9,         VP9_2,           VP9Profile2 ),
 #endif
 #if VA_CHECK_VERSION(1, 8, 0)
diff --git a/libavcodec/vaapi_encode.c b/libavcodec/vaapi_encode.c
index 284ce29..f13daa5 100644
--- a/libavcodec/vaapi_encode.c
+++ b/libavcodec/vaapi_encode.c
@@ -1308,6 +1308,7 @@ static const VAAPIEncodeRTFormat vaapi_encode_rt_formats[] = {
     { "YUV422_10", VA_RT_FORMAT_YUV422_10,    10, 3, 1, 0 },
 #endif
     { "YUV444",    VA_RT_FORMAT_YUV444,        8, 3, 0, 0 },
+    { "AYUV",      VA_RT_FORMAT_YUV444,        8, 4, 0, 0 },
     { "YUV411",    VA_RT_FORMAT_YUV411,        8, 3, 2, 0 },
 #if VA_CHECK_VERSION(0, 38, 1)
     { "YUV420_10", VA_RT_FORMAT_YUV420_10BPP, 10, 3, 1, 1 },
diff --git a/libavcodec/vaapi_encode_h264.c b/libavcodec/vaapi_encode_h264.c
index 7a6b54a..f1f6694 100644
--- a/libavcodec/vaapi_encode_h264.c
+++ b/libavcodec/vaapi_encode_h264.c
@@ -1337,7 +1337,8 @@ const FFCodec ff_h264_vaapi_encoder = {
     .p.priv_class   = &vaapi_encode_h264_class,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .defaults       = vaapi_encode_h264_defaults,
     .p.pix_fmts = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_VAAPI,
diff --git a/libavcodec/vaapi_encode_h265.c b/libavcodec/vaapi_encode_h265.c
index 456307d..1de323a 100644
--- a/libavcodec/vaapi_encode_h265.c
+++ b/libavcodec/vaapi_encode_h265.c
@@ -1278,6 +1278,8 @@ static const VAAPIEncodeProfile vaapi_encode_h265_profiles[] = {
 #if VA_CHECK_VERSION(1, 2, 0)
     { FF_PROFILE_HEVC_REXT,     8, 3, 1, 0, VAProfileHEVCMain422_10 },
     { FF_PROFILE_HEVC_REXT,    10, 3, 1, 0, VAProfileHEVCMain422_10 },
+    // Four channels because this uses the AYUV format which has Alpha
+    { FF_PROFILE_HEVC_REXT,     8, 4, 0, 0, VAProfileHEVCMain444 },
 #endif
     { FF_PROFILE_UNKNOWN }
 };
@@ -1456,7 +1458,8 @@ const FFCodec ff_hevc_vaapi_encoder = {
     .p.priv_class   = &vaapi_encode_h265_class,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .defaults       = vaapi_encode_h265_defaults,
     .p.pix_fmts = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_VAAPI,
diff --git a/libavcodec/vaapi_encode_mjpeg.c b/libavcodec/vaapi_encode_mjpeg.c
index 9296014..cf1497a 100644
--- a/libavcodec/vaapi_encode_mjpeg.c
+++ b/libavcodec/vaapi_encode_mjpeg.c
@@ -575,7 +575,8 @@ const FFCodec ff_mjpeg_vaapi_encoder = {
     .close          = &vaapi_encode_mjpeg_close,
     .p.priv_class   = &vaapi_encode_mjpeg_class,
     .p.capabilities = AV_CODEC_CAP_HARDWARE | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .defaults       = vaapi_encode_mjpeg_defaults,
     .p.pix_fmts = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_VAAPI,
diff --git a/libavcodec/vaapi_encode_mpeg2.c b/libavcodec/vaapi_encode_mpeg2.c
index 01d1b24..f592043 100644
--- a/libavcodec/vaapi_encode_mpeg2.c
+++ b/libavcodec/vaapi_encode_mpeg2.c
@@ -699,7 +699,8 @@ const FFCodec ff_mpeg2_vaapi_encoder = {
     .p.priv_class   = &vaapi_encode_mpeg2_class,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .defaults       = vaapi_encode_mpeg2_defaults,
     .p.pix_fmts = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_VAAPI,
diff --git a/libavcodec/vaapi_encode_vp8.c b/libavcodec/vaapi_encode_vp8.c
index e1d7379..1cb2446 100644
--- a/libavcodec/vaapi_encode_vp8.c
+++ b/libavcodec/vaapi_encode_vp8.c
@@ -254,7 +254,8 @@ const FFCodec ff_vp8_vaapi_encoder = {
     .p.priv_class   = &vaapi_encode_vp8_class,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .defaults       = vaapi_encode_vp8_defaults,
     .p.pix_fmts = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_VAAPI,
diff --git a/libavcodec/vaapi_encode_vp9.c b/libavcodec/vaapi_encode_vp9.c
index 5237354..9b455e1 100644
--- a/libavcodec/vaapi_encode_vp9.c
+++ b/libavcodec/vaapi_encode_vp9.c
@@ -228,6 +228,8 @@ static av_cold int vaapi_encode_vp9_configure(AVCodecContext *avctx)
 
 static const VAAPIEncodeProfile vaapi_encode_vp9_profiles[] = {
     { FF_PROFILE_VP9_0,  8, 3, 1, 1, VAProfileVP9Profile0 },
+    // Four channels because this uses the AYUV format which has Alpha
+    { FF_PROFILE_VP9_1,  8, 4, 0, 0, VAProfileVP9Profile1 },
     { FF_PROFILE_VP9_2, 10, 3, 1, 1, VAProfileVP9Profile2 },
     { FF_PROFILE_UNKNOWN }
 };
@@ -307,7 +309,8 @@ const FFCodec ff_vp9_vaapi_encoder = {
     .p.priv_class   = &vaapi_encode_vp9_class,
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE |
                       AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_NOT_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
     .defaults       = vaapi_encode_vp9_defaults,
     .p.pix_fmts = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_VAAPI,
diff --git a/libavcodec/vaapi_vp8.c b/libavcodec/vaapi_vp8.c
index 06c23e7..5b18bf8 100644
--- a/libavcodec/vaapi_vp8.c
+++ b/libavcodec/vaapi_vp8.c
@@ -36,21 +36,21 @@ static int vaapi_vp8_start_frame(AVCodecContext          *avctx,
                                  av_unused uint32_t       size)
 {
     const VP8Context *s = avctx->priv_data;
-    VAAPIDecodePicture *pic = s->framep[VP56_FRAME_CURRENT]->hwaccel_picture_private;
+    VAAPIDecodePicture *pic = s->framep[VP8_FRAME_CURRENT]->hwaccel_picture_private;
     VAPictureParameterBufferVP8 pp;
     VAProbabilityDataBufferVP8 prob;
     VAIQMatrixBufferVP8 quant;
     int err, i, j, k;
 
-    pic->output_surface = vaapi_vp8_surface_id(s->framep[VP56_FRAME_CURRENT]);
+    pic->output_surface = vaapi_vp8_surface_id(s->framep[VP8_FRAME_CURRENT]);
 
     pp = (VAPictureParameterBufferVP8) {
         .frame_width                     = avctx->width,
         .frame_height                    = avctx->height,
 
-        .last_ref_frame                  = vaapi_vp8_surface_id(s->framep[VP56_FRAME_PREVIOUS]),
-        .golden_ref_frame                = vaapi_vp8_surface_id(s->framep[VP56_FRAME_GOLDEN]),
-        .alt_ref_frame                   = vaapi_vp8_surface_id(s->framep[VP56_FRAME_GOLDEN2]),
+        .last_ref_frame                  = vaapi_vp8_surface_id(s->framep[VP8_FRAME_PREVIOUS]),
+        .golden_ref_frame                = vaapi_vp8_surface_id(s->framep[VP8_FRAME_GOLDEN]),
+        .alt_ref_frame                   = vaapi_vp8_surface_id(s->framep[VP8_FRAME_ALTREF]),
         .out_of_loop_frame               = VA_INVALID_SURFACE,
 
         .pic_fields.bits = {
@@ -67,8 +67,8 @@ static int vaapi_vp8_start_frame(AVCodecContext          *avctx,
             .loop_filter_adj_enable      = s->lf_delta.enabled,
             .mode_ref_lf_delta_update    = s->lf_delta.update,
 
-            .sign_bias_golden            = s->sign_bias[VP56_FRAME_GOLDEN],
-            .sign_bias_alternate         = s->sign_bias[VP56_FRAME_GOLDEN2],
+            .sign_bias_golden            = s->sign_bias[VP8_FRAME_GOLDEN],
+            .sign_bias_alternate         = s->sign_bias[VP8_FRAME_ALTREF],
 
             .mb_no_coeff_skip            = s->mbskip_enabled,
             .loop_filter_disable         = s->filter.level == 0,
@@ -177,7 +177,7 @@ fail:
 static int vaapi_vp8_end_frame(AVCodecContext *avctx)
 {
     const VP8Context *s = avctx->priv_data;
-    VAAPIDecodePicture *pic = s->framep[VP56_FRAME_CURRENT]->hwaccel_picture_private;
+    VAAPIDecodePicture *pic = s->framep[VP8_FRAME_CURRENT]->hwaccel_picture_private;
 
     return ff_vaapi_decode_issue(avctx, pic);
 }
@@ -187,7 +187,7 @@ static int vaapi_vp8_decode_slice(AVCodecContext *avctx,
                                   uint32_t        size)
 {
     const VP8Context *s = avctx->priv_data;
-    VAAPIDecodePicture *pic = s->framep[VP56_FRAME_CURRENT]->hwaccel_picture_private;
+    VAAPIDecodePicture *pic = s->framep[VP8_FRAME_CURRENT]->hwaccel_picture_private;
     VASliceParameterBufferVP8 sp;
     int err, i;
 
diff --git a/libavcodec/vb.c b/libavcodec/vb.c
index 82b4ea8..0bd2cb6 100644
--- a/libavcodec/vb.c
+++ b/libavcodec/vb.c
@@ -288,5 +288,5 @@ const FFCodec ff_vb_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/vble.c b/libavcodec/vble.c
index f7ab17d..48a0c13 100644
--- a/libavcodec/vble.c
+++ b/libavcodec/vble.c
@@ -211,5 +211,4 @@ const FFCodec ff_vble_decoder = {
     .close          = vble_decode_close,
     FF_CODEC_DECODE_CB(vble_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/vbndec.c b/libavcodec/vbndec.c
index a6046c7..8be625c 100644
--- a/libavcodec/vbndec.c
+++ b/libavcodec/vbndec.c
@@ -182,5 +182,4 @@ const FFCodec ff_vbn_decoder = {
     FF_CODEC_DECODE_CB(vbn_decode_frame),
     .priv_data_size = sizeof(VBNContext),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE
 };
diff --git a/libavcodec/vbnenc.c b/libavcodec/vbnenc.c
index de35a44..c93b4e3 100644
--- a/libavcodec/vbnenc.c
+++ b/libavcodec/vbnenc.c
@@ -116,7 +116,7 @@ static int vbn_encode(AVCodecContext *avctx, AVPacket *pkt,
         ctx->enc.tex_data.out = pkt->data + VBN_HEADER_SIZE;
         avctx->execute2(avctx, ff_texturedsp_compress_thread, &ctx->enc, NULL, ctx->enc.slice_count);
     } else {
-        uint8_t *flipped = frame->data[0] + frame->linesize[0] * (frame->height - 1);
+        const uint8_t *flipped = frame->data[0] + frame->linesize[0] * (frame->height - 1);
         av_image_copy_plane(pkt->data + VBN_HEADER_SIZE, linesize, flipped, -frame->linesize[0], linesize, frame->height);
     }
 
@@ -161,6 +161,5 @@ const FFCodec ff_vbn_encoder = {
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_RGBA, AV_PIX_FMT_RGB24, AV_PIX_FMT_NONE,
     },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/vc1_block.c b/libavcodec/vc1_block.c
index 119df40..3267fc2 100644
--- a/libavcodec/vc1_block.c
+++ b/libavcodec/vc1_block.c
@@ -68,6 +68,13 @@ static inline void init_block_index(VC1Context *v)
     }
 }
 
+static inline void update_block_index(MpegEncContext *s)
+{
+    /* VC1 is always 420 except when using AV_CODEC_FLAG_GRAY
+     * (or a HWAccel). Shall we inline this value? */
+    ff_update_block_index(s, 8, 0, s->chroma_x_shift);
+}
+
 /** @} */ //Bitplane group
 
 static void vc1_put_blocks_clamped(VC1Context *v, int put_signed)
@@ -2570,7 +2577,7 @@ static void vc1_decode_i_blocks(VC1Context *v)
         s->mb_x = 0;
         init_block_index(v);
         for (; s->mb_x < v->end_mb_x; s->mb_x++) {
-            ff_update_block_index(s);
+            update_block_index(s);
             s->bdsp.clear_blocks(v->block[v->cur_blk_idx][0]);
             mb_pos = s->mb_x + s->mb_y * s->mb_width;
             s->current_picture.mb_type[mb_pos]                     = MB_TYPE_INTRA;
@@ -2705,7 +2712,7 @@ static int vc1_decode_i_blocks_adv(VC1Context *v)
         init_block_index(v);
         for (;s->mb_x < s->mb_width; s->mb_x++) {
             mquant = v->pq;
-            ff_update_block_index(s);
+            update_block_index(s);
             s->bdsp.clear_blocks(v->block[v->cur_blk_idx][0]);
             mb_pos = s->mb_x + s->mb_y * s->mb_stride;
             s->current_picture.mb_type[mb_pos + v->mb_off]                         = MB_TYPE_INTRA;
@@ -2830,7 +2837,7 @@ static void vc1_decode_p_blocks(VC1Context *v)
         s->mb_x = 0;
         init_block_index(v);
         for (; s->mb_x < s->mb_width; s->mb_x++) {
-            ff_update_block_index(s);
+            update_block_index(s);
 
             if (v->fcm == ILACE_FIELD || (v->fcm == PROGRESSIVE && v->mv_type_is_raw) || v->skip_is_raw)
                 if (get_bits_left(&v->s.gb) <= 1) {
@@ -2919,7 +2926,7 @@ static void vc1_decode_b_blocks(VC1Context *v)
         s->mb_x = 0;
         init_block_index(v);
         for (; s->mb_x < s->mb_width; s->mb_x++) {
-            ff_update_block_index(s);
+            update_block_index(s);
 
             if (v->fcm == ILACE_FIELD || v->skip_is_raw || v->dmb_is_raw)
                 if (get_bits_left(&v->s.gb) <= 1) {
@@ -2981,7 +2988,7 @@ static void vc1_decode_skip_blocks(VC1Context *v)
     for (s->mb_y = s->start_mb_y; s->mb_y < s->end_mb_y; s->mb_y++) {
         s->mb_x = 0;
         init_block_index(v);
-        ff_update_block_index(s);
+        update_block_index(s);
         memcpy(s->dest[0], s->last_picture.f->data[0] + s->mb_y * 16 * s->linesize,   s->linesize   * 16);
         memcpy(s->dest[1], s->last_picture.f->data[1] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);
         memcpy(s->dest[2], s->last_picture.f->data[2] + s->mb_y *  8 * s->uvlinesize, s->uvlinesize *  8);
diff --git a/libavcodec/vc1dec.c b/libavcodec/vc1dec.c
index a7d556c..b53490b 100644
--- a/libavcodec/vc1dec.c
+++ b/libavcodec/vc1dec.c
@@ -391,7 +391,7 @@ av_cold int ff_vc1_decode_init_alloc_tables(VC1Context *v)
                 goto error;
     }
 
-    ret = ff_intrax8_common_init(s->avctx, &v->x8, &s->idsp,
+    ret = ff_intrax8_common_init(s->avctx, &v->x8,
                                  s->block, s->block_last_index,
                                  s->mb_width, s->mb_height);
     if (ret < 0)
@@ -1212,7 +1212,6 @@ const FFCodec ff_vc1_decoder = {
     FF_CODEC_DECODE_CB(vc1_decode_frame),
     .flush          = ff_mpeg_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.pix_fmts     = vc1_hwaccel_pixfmt_list_420,
     .hw_configs     = (const AVCodecHWConfigInternal *const []) {
 #if CONFIG_VC1_DXVA2_HWACCEL
@@ -1250,7 +1249,6 @@ const FFCodec ff_wmv3_decoder = {
     FF_CODEC_DECODE_CB(vc1_decode_frame),
     .flush          = ff_mpeg_flush,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .p.pix_fmts     = vc1_hwaccel_pixfmt_list_420,
     .hw_configs     = (const AVCodecHWConfigInternal *const []) {
 #if CONFIG_WMV3_DXVA2_HWACCEL
@@ -1288,7 +1286,6 @@ const FFCodec ff_wmv3image_decoder = {
     .close          = ff_vc1_decode_end,
     FF_CODEC_DECODE_CB(vc1_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .flush          = vc1_sprite_flush,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
@@ -1308,7 +1305,6 @@ const FFCodec ff_vc1image_decoder = {
     .close          = ff_vc1_decode_end,
     FF_CODEC_DECODE_CB(vc1_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
     .flush          = vc1_sprite_flush,
     .p.pix_fmts     = (const enum AVPixelFormat[]) {
         AV_PIX_FMT_YUV420P,
diff --git a/libavcodec/vc1dsp.c b/libavcodec/vc1dsp.c
index 62c553b..62c8eb2 100644
--- a/libavcodec/vc1dsp.c
+++ b/libavcodec/vc1dsp.c
@@ -787,7 +787,7 @@ PUT_VC1_MSPEL(3, 3)
     ((A * src[a] + B * src[a + 1] + \
       C * src[stride + a] + D * src[stride + a + 1] + 32 - 4) >> 6)
 static void put_no_rnd_vc1_chroma_mc8_c(uint8_t *dst /* align 8 */,
-                                        uint8_t *src /* align 1 */,
+                                        const uint8_t *src /* align 1 */,
                                         ptrdiff_t stride, int h, int x, int y)
 {
     const int A = (8 - x) * (8 - y);
@@ -812,7 +812,7 @@ static void put_no_rnd_vc1_chroma_mc8_c(uint8_t *dst /* align 8 */,
     }
 }
 
-static void put_no_rnd_vc1_chroma_mc4_c(uint8_t *dst, uint8_t *src,
+static void put_no_rnd_vc1_chroma_mc4_c(uint8_t *dst, const uint8_t *src,
                                         ptrdiff_t stride, int h, int x, int y)
 {
     const int A = (8 - x) * (8 - y);
@@ -835,7 +835,7 @@ static void put_no_rnd_vc1_chroma_mc4_c(uint8_t *dst, uint8_t *src,
 
 #define avg2(a, b) (((a) + (b) + 1) >> 1)
 static void avg_no_rnd_vc1_chroma_mc8_c(uint8_t *dst /* align 8 */,
-                                        uint8_t *src /* align 1 */,
+                                        const uint8_t *src /* align 1 */,
                                         ptrdiff_t stride, int h, int x, int y)
 {
     const int A = (8 - x) * (8 - y);
@@ -861,7 +861,7 @@ static void avg_no_rnd_vc1_chroma_mc8_c(uint8_t *dst /* align 8 */,
 }
 
 static void avg_no_rnd_vc1_chroma_mc4_c(uint8_t *dst /* align 8 */,
-                                        uint8_t *src /* align 1 */,
+                                        const uint8_t *src /* align 1 */,
                                         ptrdiff_t stride, int h, int x, int y)
 {
     const int A = (8 - x) * (8 - y);
diff --git a/libavcodec/vc2enc.c b/libavcodec/vc2enc.c
index 1e3127f..e1fd5fa 100644
--- a/libavcodec/vc2enc.c
+++ b/libavcodec/vc2enc.c
@@ -117,7 +117,7 @@ typedef struct SliceArgs {
 typedef struct TransformArgs {
     void *ctx;
     Plane *plane;
-    void *idata;
+    const void *idata;
     ptrdiff_t istride;
     int field;
     VC2TransformContext t;
@@ -1230,7 +1230,7 @@ const FFCodec ff_vc2_encoder = {
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_DIRAC,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .priv_data_size = sizeof(VC2EncContext),
     .init           = vc2_encode_init,
     .close          = vc2_encode_end,
diff --git a/libavcodec/vcr1.c b/libavcodec/vcr1.c
index 4aed1ee..b149c9f 100644
--- a/libavcodec/vcr1.c
+++ b/libavcodec/vcr1.c
@@ -130,5 +130,4 @@ const FFCodec ff_vcr1_decoder = {
     .init           = vcr1_decode_init,
     FF_CODEC_DECODE_CB(vcr1_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/version.h b/libavcodec/version.h
index 376388c..777be76 100644
--- a/libavcodec/version.h
+++ b/libavcodec/version.h
@@ -29,8 +29,8 @@
 
 #include "version_major.h"
 
-#define LIBAVCODEC_VERSION_MINOR  37
-#define LIBAVCODEC_VERSION_MICRO 100
+#define LIBAVCODEC_VERSION_MINOR  42
+#define LIBAVCODEC_VERSION_MICRO 101
 
 #define LIBAVCODEC_VERSION_INT  AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, \
                                                LIBAVCODEC_VERSION_MINOR, \
diff --git a/libavcodec/videodsp.c b/libavcodec/videodsp.c
index 90dc1aa..bdff2e7 100644
--- a/libavcodec/videodsp.c
+++ b/libavcodec/videodsp.c
@@ -32,7 +32,7 @@
 #include "videodsp_template.c"
 #undef BIT_DEPTH
 
-static void just_return(uint8_t *buf, ptrdiff_t stride, int h)
+static void just_return(const uint8_t *buf, ptrdiff_t stride, int h)
 {
 }
 
diff --git a/libavcodec/videodsp.h b/libavcodec/videodsp.h
index b5219d2..e8960b6 100644
--- a/libavcodec/videodsp.h
+++ b/libavcodec/videodsp.h
@@ -72,7 +72,7 @@ typedef struct VideoDSPContext {
      * @param stride distance between two lines of buf (in bytes)
      * @param h      number of lines to prefetch
      */
-    void (*prefetch)(uint8_t *buf, ptrdiff_t stride, int h);
+    void (*prefetch)(const uint8_t *buf, ptrdiff_t stride, int h);
 } VideoDSPContext;
 
 void ff_videodsp_init(VideoDSPContext *ctx, int bpc);
diff --git a/libavcodec/videotoolbox.c b/libavcodec/videotoolbox.c
index d61d310..ce83c25 100644
--- a/libavcodec/videotoolbox.c
+++ b/libavcodec/videotoolbox.c
@@ -690,7 +690,8 @@ static void videotoolbox_decoder_callback(void *opaque,
                                           CMTime pts,
                                           CMTime duration)
 {
-    VTContext *vtctx = opaque;
+    AVCodecContext *avctx = opaque;
+    VTContext *vtctx = avctx->internal->hwaccel_priv_data;
 
     if (vtctx->frame) {
         CVPixelBufferRelease(vtctx->frame);
@@ -698,8 +699,7 @@ static void videotoolbox_decoder_callback(void *opaque,
     }
 
     if (!image_buffer) {
-        av_log(vtctx->logctx, status ? AV_LOG_WARNING : AV_LOG_DEBUG,
-               "vt decoder cb: output image buffer is null: %i\n", status);
+        av_log(avctx, status ? AV_LOG_WARNING : AV_LOG_DEBUG, "vt decoder cb: output image buffer is null: %i\n", status);
         return;
     }
 
@@ -949,7 +949,7 @@ static int videotoolbox_start(AVCodecContext *avctx)
                                                      videotoolbox->cv_pix_fmt_type);
 
     decoder_cb.decompressionOutputCallback = videotoolbox_decoder_callback;
-    decoder_cb.decompressionOutputRefCon   = avctx->internal->hwaccel_priv_data;
+    decoder_cb.decompressionOutputRefCon   = avctx;
 
     status = VTDecompressionSessionCreate(NULL,                      // allocator
                                           videotoolbox->cm_fmt_desc, // videoFormatDescription
@@ -1179,8 +1179,6 @@ int ff_videotoolbox_common_init(AVCodecContext *avctx)
     AVHWFramesContext *hw_frames;
     int err;
 
-    vtctx->logctx = avctx;
-
     // Old API - do nothing.
     if (avctx->hwaccel_context)
         return 0;
diff --git a/libavcodec/videotoolboxenc.c b/libavcodec/videotoolboxenc.c
index 69d9fe7..823e5ad 100644
--- a/libavcodec/videotoolboxenc.c
+++ b/libavcodec/videotoolboxenc.c
@@ -2750,8 +2750,7 @@ const FFCodec ff_h264_videotoolbox_encoder = {
     FF_CODEC_ENCODE_CB(vtenc_frame),
     .close            = vtenc_close,
     .p.priv_class     = &h264_videotoolbox_class,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 static const AVOption hevc_options[] = {
@@ -2785,8 +2784,7 @@ const FFCodec ff_hevc_videotoolbox_encoder = {
     FF_CODEC_ENCODE_CB(vtenc_frame),
     .close            = vtenc_close,
     .p.priv_class     = &hevc_videotoolbox_class,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name   = "videotoolbox",
 };
 
@@ -2824,7 +2822,6 @@ const FFCodec ff_prores_videotoolbox_encoder = {
     FF_CODEC_ENCODE_CB(vtenc_frame),
     .close            = vtenc_close,
     .p.priv_class     = &prores_videotoolbox_class,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .p.wrapper_name   = "videotoolbox",
 };
diff --git a/libavcodec/vima.c b/libavcodec/vima.c
index 7327605..9a77261 100644
--- a/libavcodec/vima.c
+++ b/libavcodec/vima.c
@@ -215,5 +215,4 @@ const FFCodec ff_adpcm_vima_decoder = {
     .init         = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/vmdaudio.c b/libavcodec/vmdaudio.c
index 2e6e358..e54e341 100644
--- a/libavcodec/vmdaudio.c
+++ b/libavcodec/vmdaudio.c
@@ -237,5 +237,4 @@ const FFCodec ff_vmdaudio_decoder = {
     .init           = vmdaudio_decode_init,
     FF_CODEC_DECODE_CB(vmdaudio_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/vmdvideo.c b/libavcodec/vmdvideo.c
index 947f09b..131e013 100644
--- a/libavcodec/vmdvideo.c
+++ b/libavcodec/vmdvideo.c
@@ -474,5 +474,5 @@ const FFCodec ff_vmdvideo_decoder = {
     .close          = vmdvideo_decode_end,
     FF_CODEC_DECODE_CB(vmdvideo_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/vmnc.c b/libavcodec/vmnc.c
index cc79098..e6e5442 100644
--- a/libavcodec/vmnc.c
+++ b/libavcodec/vmnc.c
@@ -583,5 +583,4 @@ const FFCodec ff_vmnc_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/vorbisdec.c b/libavcodec/vorbisdec.c
index 6ba0e1d..b94b4a3 100644
--- a/libavcodec/vorbisdec.c
+++ b/libavcodec/vorbisdec.c
@@ -1895,7 +1895,7 @@ const FFCodec ff_vorbis_decoder = {
     FF_CODEC_DECODE_CB(vorbis_decode_frame),
     .flush           = vorbis_decode_flush,
     .p.capabilities  = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal   = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal   = FF_CODEC_CAP_INIT_CLEANUP,
 #if FF_API_OLD_CHANNEL_LAYOUT
     .p.channel_layouts = ff_vorbis_channel_layouts,
 #endif
diff --git a/libavcodec/vorbisenc.c b/libavcodec/vorbisenc.c
index 0db8aeb..c8bbbf0 100644
--- a/libavcodec/vorbisenc.c
+++ b/libavcodec/vorbisenc.c
@@ -1307,5 +1307,5 @@ const FFCodec ff_vorbis_encoder = {
     .p.capabilities = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_EXPERIMENTAL,
     .p.sample_fmts  = (const enum AVSampleFormat[]){ AV_SAMPLE_FMT_FLTP,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/vp3.c b/libavcodec/vp3.c
index 8ca1b0d..3f6b010 100644
--- a/libavcodec/vp3.c
+++ b/libavcodec/vp3.c
@@ -1950,7 +1950,7 @@ static void vp3_draw_horiz_band(Vp3DecodeContext *s, int y)
 static void await_reference_row(Vp3DecodeContext *s, Vp3Fragment *fragment,
                                 int motion_y, int y)
 {
-    ThreadFrame *ref_frame;
+    const ThreadFrame *ref_frame;
     int ref_row;
     int border = motion_y & 1;
 
@@ -3181,7 +3181,7 @@ const FFCodec ff_theora_decoder = {
                              AV_CODEC_CAP_FRAME_THREADS,
     .flush                 = vp3_decode_flush,
     .update_thread_context = ONLY_IF_THREADS_ENABLED(vp3_update_thread_context),
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP |
                              FF_CODEC_CAP_EXPORTS_CROPPING | FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
 #endif
@@ -3199,7 +3199,7 @@ const FFCodec ff_vp3_decoder = {
                              AV_CODEC_CAP_FRAME_THREADS,
     .flush                 = vp3_decode_flush,
     .update_thread_context = ONLY_IF_THREADS_ENABLED(vp3_update_thread_context),
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP |
                              FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
 
@@ -3217,7 +3217,7 @@ const FFCodec ff_vp4_decoder = {
                              AV_CODEC_CAP_FRAME_THREADS,
     .flush                 = vp3_decode_flush,
     .update_thread_context = ONLY_IF_THREADS_ENABLED(vp3_update_thread_context),
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP |
                              FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
 #endif
diff --git a/libavcodec/vp5.c b/libavcodec/vp5.c
index 7ec381b..8ba4de7 100644
--- a/libavcodec/vp5.c
+++ b/libavcodec/vp5.c
@@ -33,19 +33,20 @@
 #include "vp56.h"
 #include "vp56data.h"
 #include "vp5data.h"
+#include "vpx_rac.h"
 
 
 static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int rows, cols;
     int ret;
 
-    ret = ff_vp56_init_range_decoder(&s->c, buf, buf_size);
+    ret = ff_vpx_init_range_decoder(&s->c, buf, buf_size);
     if (ret < 0)
         return ret;
-    s->frames[VP56_FRAME_CURRENT]->key_frame = !vp56_rac_get(c);
-    vp56_rac_get(c);
+    s->frames[VP56_FRAME_CURRENT]->key_frame = !vpx_rac_get(c);
+    vpx_rac_get(c);
     ff_vp56_init_dequant(s, vp56_rac_gets(c, 6));
     if (s->frames[VP56_FRAME_CURRENT]->key_frame)
     {
@@ -55,7 +56,7 @@ static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
         if(vp56_rac_gets(c, 5) > 5)
             return AVERROR_INVALIDDATA;
         vp56_rac_gets(c, 2);
-        if (vp56_rac_get(c)) {
+        if (vpx_rac_get(c)) {
             avpriv_report_missing_feature(s->avctx, "Interlacing");
             return AVERROR_PATCHWELCOME;
         }
@@ -87,16 +88,16 @@ static int vp5_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
 
 static void vp5_parse_vector_adjustment(VP56Context *s, VP56mv *vect)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     int comp, di;
 
     for (comp=0; comp<2; comp++) {
         int delta = 0;
-        if (vp56_rac_get_prob_branchy(c, model->vector_dct[comp])) {
-            int sign = vp56_rac_get_prob(c, model->vector_sig[comp]);
-            di  = vp56_rac_get_prob(c, model->vector_pdi[comp][0]);
-            di |= vp56_rac_get_prob(c, model->vector_pdi[comp][1]) << 1;
+        if (vpx_rac_get_prob_branchy(c, model->vector_dct[comp])) {
+            int sign = vpx_rac_get_prob(c, model->vector_sig[comp]);
+            di  = vpx_rac_get_prob(c, model->vector_pdi[comp][0]);
+            di |= vpx_rac_get_prob(c, model->vector_pdi[comp][1]) << 1;
             delta = vp56_rac_get_tree(c, ff_vp56_pva_tree,
                                       model->vector_pdv[comp]);
             delta = di | (delta << 2);
@@ -111,30 +112,30 @@ static void vp5_parse_vector_adjustment(VP56Context *s, VP56mv *vect)
 
 static void vp5_parse_vector_models(VP56Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     int comp, node;
 
     for (comp=0; comp<2; comp++) {
-        if (vp56_rac_get_prob_branchy(c, vp5_vmc_pct[comp][0]))
+        if (vpx_rac_get_prob_branchy(c, vp5_vmc_pct[comp][0]))
             model->vector_dct[comp] = vp56_rac_gets_nn(c, 7);
-        if (vp56_rac_get_prob_branchy(c, vp5_vmc_pct[comp][1]))
+        if (vpx_rac_get_prob_branchy(c, vp5_vmc_pct[comp][1]))
             model->vector_sig[comp] = vp56_rac_gets_nn(c, 7);
-        if (vp56_rac_get_prob_branchy(c, vp5_vmc_pct[comp][2]))
+        if (vpx_rac_get_prob_branchy(c, vp5_vmc_pct[comp][2]))
             model->vector_pdi[comp][0] = vp56_rac_gets_nn(c, 7);
-        if (vp56_rac_get_prob_branchy(c, vp5_vmc_pct[comp][3]))
+        if (vpx_rac_get_prob_branchy(c, vp5_vmc_pct[comp][3]))
             model->vector_pdi[comp][1] = vp56_rac_gets_nn(c, 7);
     }
 
     for (comp=0; comp<2; comp++)
         for (node=0; node<7; node++)
-            if (vp56_rac_get_prob_branchy(c, vp5_vmc_pct[comp][4 + node]))
+            if (vpx_rac_get_prob_branchy(c, vp5_vmc_pct[comp][4 + node]))
                 model->vector_pdv[comp][node] = vp56_rac_gets_nn(c, 7);
 }
 
 static int vp5_parse_coeff_models(VP56Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     uint8_t def_prob[11];
     int node, cg, ctx;
@@ -145,7 +146,7 @@ static int vp5_parse_coeff_models(VP56Context *s)
 
     for (pt=0; pt<2; pt++)
         for (node=0; node<11; node++)
-            if (vp56_rac_get_prob_branchy(c, vp5_dccv_pct[pt][node])) {
+            if (vpx_rac_get_prob_branchy(c, vp5_dccv_pct[pt][node])) {
                 def_prob[node] = vp56_rac_gets_nn(c, 7);
                 model->coeff_dccv[pt][node] = def_prob[node];
             } else if (s->frames[VP56_FRAME_CURRENT]->key_frame) {
@@ -156,7 +157,7 @@ static int vp5_parse_coeff_models(VP56Context *s)
         for (pt=0; pt<2; pt++)
             for (cg=0; cg<6; cg++)
                 for (node=0; node<11; node++)
-                    if (vp56_rac_get_prob_branchy(c, vp5_ract_pct[ct][pt][cg][node])) {
+                    if (vpx_rac_get_prob_branchy(c, vp5_ract_pct[ct][pt][cg][node])) {
                         def_prob[node] = vp56_rac_gets_nn(c, 7);
                         model->coeff_ract[pt][ct][cg][node] = def_prob[node];
                     } else if (s->frames[VP56_FRAME_CURRENT]->key_frame) {
@@ -181,7 +182,7 @@ static int vp5_parse_coeff_models(VP56Context *s)
 
 static int vp5_parse_coeff(VP56Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     uint8_t *permute = s->idct_scantable;
     uint8_t *model1, *model2;
@@ -189,7 +190,7 @@ static int vp5_parse_coeff(VP56Context *s)
     int b, i, cg, idx, ctx, ctx_last;
     int pt = 0;    /* plane type (0 for Y, 1 for U or V) */
 
-    if (vpX_rac_is_end(c)) {
+    if (vpx_rac_is_end(c)) {
         av_log(s->avctx, AV_LOG_ERROR, "End of AC stream reached in vp5_parse_coeff\n");
         return AVERROR_INVALIDDATA;
     }
@@ -206,30 +207,30 @@ static int vp5_parse_coeff(VP56Context *s)
 
         coeff_idx = 0;
         for (;;) {
-            if (vp56_rac_get_prob_branchy(c, model2[0])) {
-                if (vp56_rac_get_prob_branchy(c, model2[2])) {
-                    if (vp56_rac_get_prob_branchy(c, model2[3])) {
+            if (vpx_rac_get_prob_branchy(c, model2[0])) {
+                if (vpx_rac_get_prob_branchy(c, model2[2])) {
+                    if (vpx_rac_get_prob_branchy(c, model2[3])) {
                         s->coeff_ctx[ff_vp56_b6to4[b]][coeff_idx] = 4;
                         idx = vp56_rac_get_tree(c, ff_vp56_pc_tree, model1);
-                        sign = vp56_rac_get(c);
+                        sign = vpx_rac_get(c);
                         coeff = ff_vp56_coeff_bias[idx+5];
                         for (i=ff_vp56_coeff_bit_length[idx]; i>=0; i--)
-                            coeff += vp56_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;
+                            coeff += vpx_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;
                     } else {
-                        if (vp56_rac_get_prob_branchy(c, model2[4])) {
-                            coeff = 3 + vp56_rac_get_prob(c, model1[5]);
+                        if (vpx_rac_get_prob_branchy(c, model2[4])) {
+                            coeff = 3 + vpx_rac_get_prob(c, model1[5]);
                             s->coeff_ctx[ff_vp56_b6to4[b]][coeff_idx] = 3;
                         } else {
                             coeff = 2;
                             s->coeff_ctx[ff_vp56_b6to4[b]][coeff_idx] = 2;
                         }
-                        sign = vp56_rac_get(c);
+                        sign = vpx_rac_get(c);
                     }
                     ct = 2;
                 } else {
                     ct = 1;
                     s->coeff_ctx[ff_vp56_b6to4[b]][coeff_idx] = 1;
-                    sign = vp56_rac_get(c);
+                    sign = vpx_rac_get(c);
                     coeff = 1;
                 }
                 coeff = (coeff ^ -sign) + sign;
@@ -237,7 +238,7 @@ static int vp5_parse_coeff(VP56Context *s)
                     coeff *= s->dequant_ac;
                 s->block_coeff[b][permute[coeff_idx]] = coeff;
             } else {
-                if (ct && !vp56_rac_get_prob_branchy(c, model2[1]))
+                if (ct && !vpx_rac_get_prob_branchy(c, model2[1]))
                     break;
                 ct = 0;
                 s->coeff_ctx[ff_vp56_b6to4[b]][coeff_idx] = 0;
@@ -313,5 +314,5 @@ const FFCodec ff_vp5_decoder = {
     .close          = vp56_free,
     FF_CODEC_DECODE_CB(ff_vp56_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/vp56.c b/libavcodec/vp56.c
index a2efca1..3863af1 100644
--- a/libavcodec/vp56.c
+++ b/libavcodec/vp56.c
@@ -29,6 +29,7 @@
 #include "h264chroma.h"
 #include "vp56.h"
 #include "vp56data.h"
+#include "vpx_rac.h"
 
 
 void ff_vp56_init_dequant(VP56Context *s, int quantizer)
@@ -80,22 +81,22 @@ static int vp56_get_vectors_predictors(VP56Context *s, int row, int col,
 
 static void vp56_parse_mb_type_models(VP56Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     int i, ctx, type;
 
     for (ctx=0; ctx<3; ctx++) {
-        if (vp56_rac_get_prob_branchy(c, 174)) {
+        if (vpx_rac_get_prob_branchy(c, 174)) {
             int idx = vp56_rac_gets(c, 4);
             memcpy(model->mb_types_stats[ctx],
                    ff_vp56_pre_def_mb_type_stats[idx][ctx],
                    sizeof(model->mb_types_stats[ctx]));
         }
-        if (vp56_rac_get_prob_branchy(c, 254)) {
+        if (vpx_rac_get_prob_branchy(c, 254)) {
             for (type=0; type<10; type++) {
                 for(i=0; i<2; i++) {
-                    if (vp56_rac_get_prob_branchy(c, 205)) {
-                        int delta, sign = vp56_rac_get(c);
+                    if (vpx_rac_get_prob_branchy(c, 205)) {
+                        int delta, sign = vpx_rac_get(c);
 
                         delta = vp56_rac_get_tree(c, ff_vp56_pmbtm_tree,
                                                   ff_vp56_mb_type_model_model);
@@ -153,9 +154,9 @@ static VP56mb vp56_parse_mb_type(VP56Context *s,
                                  VP56mb prev_type, int ctx)
 {
     uint8_t *mb_type_model = s->modelp->mb_type[ctx][prev_type];
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
-    if (vp56_rac_get_prob_branchy(c, mb_type_model[0]))
+    if (vpx_rac_get_prob_branchy(c, mb_type_model[0]))
         return prev_type;
     else
         return vp56_rac_get_tree(c, ff_vp56_pmbt_tree, mb_type_model);
diff --git a/libavcodec/vp56.h b/libavcodec/vp56.h
index d2e6ad3..9dc0b9c 100644
--- a/libavcodec/vp56.h
+++ b/libavcodec/vp56.h
@@ -31,11 +31,11 @@
 #include "avcodec.h"
 #include "get_bits.h"
 #include "hpeldsp.h"
-#include "bytestream.h"
 #include "h264chroma.h"
 #include "videodsp.h"
 #include "vp3dsp.h"
 #include "vp56dsp.h"
+#include "vpx_rac.h"
 
 typedef struct vp56_context VP56Context;
 
@@ -44,7 +44,6 @@ typedef enum {
     VP56_FRAME_CURRENT  = 0,
     VP56_FRAME_PREVIOUS = 1,
     VP56_FRAME_GOLDEN   = 2,
-    VP56_FRAME_GOLDEN2  = 3,
 } VP56Frame;
 
 typedef enum {
@@ -84,16 +83,6 @@ typedef int  (*VP56ParseCoeffModels)(VP56Context *s);
 typedef int  (*VP56ParseHeader)(VP56Context *s, const uint8_t *buf,
                                 int buf_size);
 
-typedef struct VP56RangeCoder {
-    int high;
-    int bits; /* stored negated (i.e. negative "bits" is a positive number of
-                 bits left) in order to eliminate a negate in cache refilling */
-    const uint8_t *buffer;
-    const uint8_t *end;
-    unsigned int code_word;
-    int end_reached;
-} VP56RangeCoder;
-
 typedef struct VP56RefDc {
     uint8_t not_null_dc;
     VP56Frame ref_frame;
@@ -134,9 +123,9 @@ struct vp56_context {
     AVFrame *frames[4];
     uint8_t *edge_emu_buffer_alloc;
     uint8_t *edge_emu_buffer;
-    VP56RangeCoder c;
-    VP56RangeCoder cc;
-    VP56RangeCoder *ccp;
+    VPXRangeCoder c;
+    VPXRangeCoder cc;
+    VPXRangeCoder *ccp;
     int sub_version;
 
     /* frame info */
@@ -232,160 +221,31 @@ int ff_vp56_decode_frame(AVCodecContext *avctx, AVFrame *frame,
  * vp56 specific range coder implementation
  */
 
-extern const uint8_t ff_vp56_norm_shift[256];
-int ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size);
-
-/**
- * vp5689 returns 1 if the end of the stream has been reached, 0 otherwise.
- */
-static av_always_inline int vpX_rac_is_end(VP56RangeCoder *c)
-{
-    if (c->end <= c->buffer && c->bits >= 0)
-        c->end_reached ++;
-    return c->end_reached > 10;
-}
-
-static av_always_inline unsigned int vp56_rac_renorm(VP56RangeCoder *c)
-{
-    int shift = ff_vp56_norm_shift[c->high];
-    int bits = c->bits;
-    unsigned int code_word = c->code_word;
-
-    c->high   <<= shift;
-    code_word <<= shift;
-    bits       += shift;
-    if(bits >= 0 && c->buffer < c->end) {
-        code_word |= bytestream_get_be16(&c->buffer) << bits;
-        bits -= 16;
-    }
-    c->bits = bits;
-    return code_word;
-}
-
-#if   ARCH_ARM
-#include "arm/vp56_arith.h"
-#elif ARCH_X86
-#include "x86/vp56_arith.h"
-#endif
-
-#ifndef vp56_rac_get_prob
-#define vp56_rac_get_prob vp56_rac_get_prob
-static av_always_inline int vp56_rac_get_prob(VP56RangeCoder *c, uint8_t prob)
-{
-    unsigned int code_word = vp56_rac_renorm(c);
-    unsigned int low = 1 + (((c->high - 1) * prob) >> 8);
-    unsigned int low_shift = low << 16;
-    int bit = code_word >= low_shift;
-
-    c->high = bit ? c->high - low : low;
-    c->code_word = bit ? code_word - low_shift : code_word;
-
-    return bit;
-}
-#endif
-
-#ifndef vp56_rac_get_prob_branchy
-// branchy variant, to be used where there's a branch based on the bit decoded
-static av_always_inline int vp56_rac_get_prob_branchy(VP56RangeCoder *c, int prob)
-{
-    unsigned long code_word = vp56_rac_renorm(c);
-    unsigned low = 1 + (((c->high - 1) * prob) >> 8);
-    unsigned low_shift = low << 16;
-
-    if (code_word >= low_shift) {
-        c->high     -= low;
-        c->code_word = code_word - low_shift;
-        return 1;
-    }
-
-    c->high = low;
-    c->code_word = code_word;
-    return 0;
-}
-#endif
-
-static av_always_inline int vp56_rac_get(VP56RangeCoder *c)
-{
-    unsigned int code_word = vp56_rac_renorm(c);
-    /* equiprobable */
-    int low = (c->high + 1) >> 1;
-    unsigned int low_shift = low << 16;
-    int bit = code_word >= low_shift;
-    if (bit) {
-        c->high   -= low;
-        code_word -= low_shift;
-    } else {
-        c->high = low;
-    }
-
-    c->code_word = code_word;
-    return bit;
-}
-
-// rounding is different than vp56_rac_get, is vp56_rac_get wrong?
-static av_always_inline int vp8_rac_get(VP56RangeCoder *c)
-{
-    return vp56_rac_get_prob(c, 128);
-}
-
-static int vp56_rac_gets(VP56RangeCoder *c, int bits)
+static int vp56_rac_gets(VPXRangeCoder *c, int bits)
 {
     int value = 0;
 
     while (bits--) {
-        value = (value << 1) | vp56_rac_get(c);
+        value = (value << 1) | vpx_rac_get(c);
     }
 
     return value;
 }
 
-static int vp8_rac_get_uint(VP56RangeCoder *c, int bits)
-{
-    int value = 0;
-
-    while (bits--) {
-        value = (value << 1) | vp8_rac_get(c);
-    }
-
-    return value;
-}
-
-// fixme: add 1 bit to all the calls to this?
-static av_unused int vp8_rac_get_sint(VP56RangeCoder *c, int bits)
-{
-    int v;
-
-    if (!vp8_rac_get(c))
-        return 0;
-
-    v = vp8_rac_get_uint(c, bits);
-
-    if (vp8_rac_get(c))
-        v = -v;
-
-    return v;
-}
-
 // P(7)
-static av_unused int vp56_rac_gets_nn(VP56RangeCoder *c, int bits)
+static av_unused int vp56_rac_gets_nn(VPXRangeCoder *c, int bits)
 {
     int v = vp56_rac_gets(c, 7) << 1;
     return v + !v;
 }
 
-static av_unused int vp8_rac_get_nn(VP56RangeCoder *c)
-{
-    int v = vp8_rac_get_uint(c, 7) << 1;
-    return v + !v;
-}
-
 static av_always_inline
-int vp56_rac_get_tree(VP56RangeCoder *c,
+int vp56_rac_get_tree(VPXRangeCoder *c,
                       const VP56Tree *tree,
                       const uint8_t *probs)
 {
     while (tree->val > 0) {
-        if (vp56_rac_get_prob_branchy(c, probs[tree->prob_idx]))
+        if (vpx_rac_get_prob_branchy(c, probs[tree->prob_idx]))
             tree += tree->val;
         else
             tree++;
@@ -393,30 +253,4 @@ int vp56_rac_get_tree(VP56RangeCoder *c,
     return -tree->val;
 }
 
-// how probabilities are associated with decisions is different I think
-// well, the new scheme fits in the old but this way has one fewer branches per decision
-static av_always_inline int vp8_rac_get_tree(VP56RangeCoder *c, const int8_t (*tree)[2],
-                                   const uint8_t *probs)
-{
-    int i = 0;
-
-    do {
-        i = tree[i][vp56_rac_get_prob(c, probs[i])];
-    } while (i > 0);
-
-    return -i;
-}
-
-// DCTextra
-static av_always_inline int vp8_rac_get_coeff(VP56RangeCoder *c, const uint8_t *prob)
-{
-    int v = 0;
-
-    do {
-        v = (v<<1) + vp56_rac_get_prob(c, *prob++);
-    } while (*prob);
-
-    return v;
-}
-
 #endif /* AVCODEC_VP56_H */
diff --git a/libavcodec/vp6.c b/libavcodec/vp6.c
index 19dc754..ad81060 100644
--- a/libavcodec/vp6.c
+++ b/libavcodec/vp6.c
@@ -38,6 +38,7 @@
 #include "vp56.h"
 #include "vp56data.h"
 #include "vp6data.h"
+#include "vpx_rac.h"
 
 #define VP6_MAX_HUFF_SIZE 12
 
@@ -46,7 +47,7 @@ static int vp6_parse_coeff_huffman(VP56Context *s);
 
 static int vp6_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int parse_filter_info = 0;
     int coeff_offset = 0;
     int vrt_shift = 0;
@@ -107,7 +108,7 @@ static int vp6_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
             res = VP56_SIZE_CHANGE;
         }
 
-        ret = ff_vp56_init_range_decoder(c, buf+6, buf_size-6);
+        ret = ff_vpx_init_range_decoder(c, buf+6, buf_size-6);
         if (ret < 0)
             goto fail;
         vp56_rac_gets(c, 2);
@@ -126,26 +127,26 @@ static int vp6_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
             buf += 2;
             buf_size -= 2;
         }
-        ret = ff_vp56_init_range_decoder(c, buf+1, buf_size-1);
+        ret = ff_vpx_init_range_decoder(c, buf+1, buf_size-1);
         if (ret < 0)
             return ret;
 
-        s->golden_frame = vp56_rac_get(c);
+        s->golden_frame = vpx_rac_get(c);
         if (s->filter_header) {
-            s->deblock_filtering = vp56_rac_get(c);
+            s->deblock_filtering = vpx_rac_get(c);
             if (s->deblock_filtering)
-                vp56_rac_get(c);
+                vpx_rac_get(c);
             if (s->sub_version > 7)
-                parse_filter_info = vp56_rac_get(c);
+                parse_filter_info = vpx_rac_get(c);
         }
     }
 
     if (parse_filter_info) {
-        if (vp56_rac_get(c)) {
+        if (vpx_rac_get(c)) {
             s->filter_mode = 2;
             s->sample_variance_threshold = vp56_rac_gets(c, 5) << vrt_shift;
             s->max_vector_length = 2 << vp56_rac_gets(c, 3);
-        } else if (vp56_rac_get(c)) {
+        } else if (vpx_rac_get(c)) {
             s->filter_mode = 1;
         } else {
             s->filter_mode = 0;
@@ -156,7 +157,7 @@ static int vp6_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
             s->filter_selection = 16;
     }
 
-    s->use_huffman = vp56_rac_get(c);
+    s->use_huffman = vpx_rac_get(c);
 
     s->parse_coeff = vp6_parse_coeff;
     if (coeff_offset) {
@@ -172,7 +173,7 @@ static int vp6_parse_header(VP56Context *s, const uint8_t *buf, int buf_size)
             if (ret < 0)
                 return ret;
         } else {
-            ret = ff_vp56_init_range_decoder(&s->cc, buf, buf_size);
+            ret = ff_vpx_init_range_decoder(&s->cc, buf, buf_size);
             if (ret < 0)
                 goto fail;
             s->ccp = &s->cc;
@@ -231,25 +232,25 @@ static void vp6_default_models_init(VP56Context *s)
 
 static void vp6_parse_vector_models(VP56Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     int comp, node;
 
     for (comp=0; comp<2; comp++) {
-        if (vp56_rac_get_prob_branchy(c, vp6_sig_dct_pct[comp][0]))
+        if (vpx_rac_get_prob_branchy(c, vp6_sig_dct_pct[comp][0]))
             model->vector_dct[comp] = vp56_rac_gets_nn(c, 7);
-        if (vp56_rac_get_prob_branchy(c, vp6_sig_dct_pct[comp][1]))
+        if (vpx_rac_get_prob_branchy(c, vp6_sig_dct_pct[comp][1]))
             model->vector_sig[comp] = vp56_rac_gets_nn(c, 7);
     }
 
     for (comp=0; comp<2; comp++)
         for (node=0; node<7; node++)
-            if (vp56_rac_get_prob_branchy(c, vp6_pdv_pct[comp][node]))
+            if (vpx_rac_get_prob_branchy(c, vp6_pdv_pct[comp][node]))
                 model->vector_pdv[comp][node] = vp56_rac_gets_nn(c, 7);
 
     for (comp=0; comp<2; comp++)
         for (node=0; node<8; node++)
-            if (vp56_rac_get_prob_branchy(c, vp6_fdv_pct[comp][node]))
+            if (vpx_rac_get_prob_branchy(c, vp6_fdv_pct[comp][node]))
                 model->vector_fdv[comp][node] = vp56_rac_gets_nn(c, 7);
 }
 
@@ -284,7 +285,7 @@ static int vp6_build_huff_tree(VP56Context *s, uint8_t coeff_model[],
 
 static int vp6_parse_coeff_models(VP56Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     int def_prob[11];
     int node, cg, ctx, pos;
@@ -295,30 +296,30 @@ static int vp6_parse_coeff_models(VP56Context *s)
 
     for (pt=0; pt<2; pt++)
         for (node=0; node<11; node++)
-            if (vp56_rac_get_prob_branchy(c, vp6_dccv_pct[pt][node])) {
+            if (vpx_rac_get_prob_branchy(c, vp6_dccv_pct[pt][node])) {
                 def_prob[node] = vp56_rac_gets_nn(c, 7);
                 model->coeff_dccv[pt][node] = def_prob[node];
             } else if (s->frames[VP56_FRAME_CURRENT]->key_frame) {
                 model->coeff_dccv[pt][node] = def_prob[node];
             }
 
-    if (vp56_rac_get(c)) {
+    if (vpx_rac_get(c)) {
         for (pos=1; pos<64; pos++)
-            if (vp56_rac_get_prob_branchy(c, vp6_coeff_reorder_pct[pos]))
+            if (vpx_rac_get_prob_branchy(c, vp6_coeff_reorder_pct[pos]))
                 model->coeff_reorder[pos] = vp56_rac_gets(c, 4);
         vp6_coeff_order_table_init(s);
     }
 
     for (cg=0; cg<2; cg++)
         for (node=0; node<14; node++)
-            if (vp56_rac_get_prob_branchy(c, vp6_runv_pct[cg][node]))
+            if (vpx_rac_get_prob_branchy(c, vp6_runv_pct[cg][node]))
                 model->coeff_runv[cg][node] = vp56_rac_gets_nn(c, 7);
 
     for (ct=0; ct<3; ct++)
         for (pt=0; pt<2; pt++)
             for (cg=0; cg<6; cg++)
                 for (node=0; node<11; node++)
-                    if (vp56_rac_get_prob_branchy(c, vp6_ract_pct[ct][pt][cg][node])) {
+                    if (vpx_rac_get_prob_branchy(c, vp6_ract_pct[ct][pt][cg][node])) {
                         def_prob[node] = vp56_rac_gets_nn(c, 7);
                         model->coeff_ract[pt][ct][cg][node] = def_prob[node];
                     } else if (s->frames[VP56_FRAME_CURRENT]->key_frame) {
@@ -353,7 +354,7 @@ static int vp6_parse_coeff_models(VP56Context *s)
 
 static void vp6_parse_vector_adjustment(VP56Context *s, VP56mv *vect)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     VP56Model *model = s->modelp;
     int comp;
 
@@ -364,14 +365,14 @@ static void vp6_parse_vector_adjustment(VP56Context *s, VP56mv *vect)
     for (comp=0; comp<2; comp++) {
         int i, delta = 0;
 
-        if (vp56_rac_get_prob_branchy(c, model->vector_dct[comp])) {
+        if (vpx_rac_get_prob_branchy(c, model->vector_dct[comp])) {
             static const uint8_t prob_order[] = {0, 1, 2, 7, 6, 5, 4};
             for (i=0; i<sizeof(prob_order); i++) {
                 int j = prob_order[i];
-                delta |= vp56_rac_get_prob(c, model->vector_fdv[comp][j])<<j;
+                delta |= vpx_rac_get_prob(c, model->vector_fdv[comp][j])<<j;
             }
             if (delta & 0xF0)
-                delta |= vp56_rac_get_prob(c, model->vector_fdv[comp][3])<<3;
+                delta |= vpx_rac_get_prob(c, model->vector_fdv[comp][3])<<3;
             else
                 delta |= 8;
         } else {
@@ -379,7 +380,7 @@ static void vp6_parse_vector_adjustment(VP56Context *s, VP56mv *vect)
                                       model->vector_pdv[comp]);
         }
 
-        if (delta && vp56_rac_get_prob_branchy(c, model->vector_sig[comp]))
+        if (delta && vpx_rac_get_prob_branchy(c, model->vector_sig[comp]))
             delta = -delta;
 
         if (!comp)
@@ -468,7 +469,7 @@ static int vp6_parse_coeff_huffman(VP56Context *s)
 
 static int vp6_parse_coeff(VP56Context *s)
 {
-    VP56RangeCoder *c = s->ccp;
+    VPXRangeCoder *c = s->ccp;
     VP56Model *model = s->modelp;
     uint8_t *permute = s->idct_scantable;
     uint8_t *model1, *model2, *model3;
@@ -476,7 +477,7 @@ static int vp6_parse_coeff(VP56Context *s)
     int b, i, cg, idx, ctx;
     int pt = 0;    /* plane type (0 for Y, 1 for U or V) */
 
-    if (vpX_rac_is_end(c)) {
+    if (vpx_rac_is_end(c)) {
         av_log(s->avctx, AV_LOG_ERROR, "End of AC stream reached in vp6_parse_coeff\n");
         return AVERROR_INVALIDDATA;
     }
@@ -494,17 +495,17 @@ static int vp6_parse_coeff(VP56Context *s)
 
         coeff_idx = 0;
         for (;;) {
-            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {
+            if ((coeff_idx>1 && ct==0) || vpx_rac_get_prob_branchy(c, model2[0])) {
                 /* parse a coeff */
-                if (vp56_rac_get_prob_branchy(c, model2[2])) {
-                    if (vp56_rac_get_prob_branchy(c, model2[3])) {
+                if (vpx_rac_get_prob_branchy(c, model2[2])) {
+                    if (vpx_rac_get_prob_branchy(c, model2[3])) {
                         idx = vp56_rac_get_tree(c, ff_vp56_pc_tree, model1);
                         coeff = ff_vp56_coeff_bias[idx+5];
                         for (i=ff_vp56_coeff_bit_length[idx]; i>=0; i--)
-                            coeff += vp56_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;
+                            coeff += vpx_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;
                     } else {
-                        if (vp56_rac_get_prob_branchy(c, model2[4]))
-                            coeff = 3 + vp56_rac_get_prob(c, model1[5]);
+                        if (vpx_rac_get_prob_branchy(c, model2[4]))
+                            coeff = 3 + vpx_rac_get_prob(c, model1[5]);
                         else
                             coeff = 2;
                     }
@@ -513,7 +514,7 @@ static int vp6_parse_coeff(VP56Context *s)
                     ct = 1;
                     coeff = 1;
                 }
-                sign = vp56_rac_get(c);
+                sign = vpx_rac_get(c);
                 coeff = (coeff ^ -sign) + sign;
                 if (coeff_idx)
                     coeff *= s->dequant_ac;
@@ -524,14 +525,14 @@ static int vp6_parse_coeff(VP56Context *s)
                 /* parse a run */
                 ct = 0;
                 if (coeff_idx > 0) {
-                    if (!vp56_rac_get_prob_branchy(c, model2[1]))
+                    if (!vpx_rac_get_prob_branchy(c, model2[1]))
                         break;
 
                     model3 = model->coeff_runv[coeff_idx >= 6];
                     run = vp56_rac_get_tree(c, vp6_pcr_tree, model3);
                     if (!run)
                         for (run=9, i=0; i<6; i++)
-                            run += vp56_rac_get_prob(c, model3[i+8]) << i;
+                            run += vpx_rac_get_prob(c, model3[i+8]) << i;
                 }
             }
             coeff_idx += run;
@@ -722,7 +723,7 @@ const FFCodec ff_vp6_decoder = {
     .close          = vp6_decode_free,
     FF_CODEC_DECODE_CB(ff_vp56_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 /* flash version, not flipped upside-down */
@@ -736,7 +737,7 @@ const FFCodec ff_vp6f_decoder = {
     .close          = vp6_decode_free,
     FF_CODEC_DECODE_CB(ff_vp56_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 /* flash version, not flipped upside-down, with alpha channel */
@@ -750,5 +751,5 @@ const FFCodec ff_vp6a_decoder = {
     .close          = vp6_decode_free,
     FF_CODEC_DECODE_CB(ff_vp56_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/vp8.c b/libavcodec/vp8.c
index f521f2c..7a151fe 100644
--- a/libavcodec/vp8.c
+++ b/libavcodec/vp8.c
@@ -38,7 +38,9 @@
 #include "thread.h"
 #include "threadframe.h"
 #include "vp8.h"
+#include "vp89_rac.h"
 #include "vp8data.h"
+#include "vpx_rac.h"
 
 #if ARCH_ARM
 #   include "arm/vp8.h"
@@ -52,6 +54,40 @@
 #define VPX(vp7, f) vp8_ ## f
 #endif
 
+// fixme: add 1 bit to all the calls to this?
+static int vp8_rac_get_sint(VPXRangeCoder *c, int bits)
+{
+    int v;
+
+    if (!vp89_rac_get(c))
+        return 0;
+
+    v = vp89_rac_get_uint(c, bits);
+
+    if (vp89_rac_get(c))
+        v = -v;
+
+    return v;
+}
+
+static int vp8_rac_get_nn(VPXRangeCoder *c)
+{
+    int v = vp89_rac_get_uint(c, 7) << 1;
+    return v + !v;
+}
+
+// DCTextra
+static int vp8_rac_get_coeff(VPXRangeCoder *c, const uint8_t *prob)
+{
+    int v = 0;
+
+    do {
+        v = (v<<1) + vpx_rac_get_prob(c, *prob++);
+    } while (*prob);
+
+    return v;
+}
+
 static void free_buffers(VP8Context *s)
 {
     int i;
@@ -155,10 +191,10 @@ static VP8Frame *vp8_find_free_buffer(VP8Context *s)
 
     // find a free buffer
     for (i = 0; i < 5; i++)
-        if (&s->frames[i] != s->framep[VP56_FRAME_CURRENT]  &&
-            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2]) {
+        if (&s->frames[i] != s->framep[VP8_FRAME_CURRENT]  &&
+            &s->frames[i] != s->framep[VP8_FRAME_PREVIOUS] &&
+            &s->frames[i] != s->framep[VP8_FRAME_GOLDEN]   &&
+            &s->frames[i] != s->framep[VP8_FRAME_ALTREF]) {
             frame = &s->frames[i];
             break;
         }
@@ -266,14 +302,14 @@ static int vp8_update_dimensions(VP8Context *s, int width, int height)
 
 static void parse_segment_info(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i;
 
-    s->segmentation.update_map = vp8_rac_get(c);
-    s->segmentation.update_feature_data = vp8_rac_get(c);
+    s->segmentation.update_map = vp89_rac_get(c);
+    s->segmentation.update_feature_data = vp89_rac_get(c);
 
     if (s->segmentation.update_feature_data) {
-        s->segmentation.absolute_vals = vp8_rac_get(c);
+        s->segmentation.absolute_vals = vp89_rac_get(c);
 
         for (i = 0; i < 4; i++)
             s->segmentation.base_quant[i]   = vp8_rac_get_sint(c, 7);
@@ -283,28 +319,28 @@ static void parse_segment_info(VP8Context *s)
     }
     if (s->segmentation.update_map)
         for (i = 0; i < 3; i++)
-            s->prob->segmentid[i] = vp8_rac_get(c) ? vp8_rac_get_uint(c, 8) : 255;
+            s->prob->segmentid[i] = vp89_rac_get(c) ? vp89_rac_get_uint(c, 8) : 255;
 }
 
 static void update_lf_deltas(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i;
 
     for (i = 0; i < 4; i++) {
-        if (vp8_rac_get(c)) {
-            s->lf_delta.ref[i] = vp8_rac_get_uint(c, 6);
+        if (vp89_rac_get(c)) {
+            s->lf_delta.ref[i] = vp89_rac_get_uint(c, 6);
 
-            if (vp8_rac_get(c))
+            if (vp89_rac_get(c))
                 s->lf_delta.ref[i] = -s->lf_delta.ref[i];
         }
     }
 
     for (i = MODE_I4x4; i <= VP8_MVMODE_SPLIT; i++) {
-        if (vp8_rac_get(c)) {
-            s->lf_delta.mode[i] = vp8_rac_get_uint(c, 6);
+        if (vp89_rac_get(c)) {
+            s->lf_delta.mode[i] = vp89_rac_get_uint(c, 6);
 
-            if (vp8_rac_get(c))
+            if (vp89_rac_get(c))
                 s->lf_delta.mode[i] = -s->lf_delta.mode[i];
         }
     }
@@ -316,7 +352,7 @@ static int setup_partitions(VP8Context *s, const uint8_t *buf, int buf_size)
     int i;
     int ret;
 
-    s->num_coeff_partitions = 1 << vp8_rac_get_uint(&s->c, 2);
+    s->num_coeff_partitions = 1 << vp89_rac_get_uint(&s->c, 2);
 
     buf      += 3 * (s->num_coeff_partitions - 1);
     buf_size -= 3 * (s->num_coeff_partitions - 1);
@@ -329,7 +365,7 @@ static int setup_partitions(VP8Context *s, const uint8_t *buf, int buf_size)
             return -1;
         s->coeff_partition_size[i] = size;
 
-        ret = ff_vp56_init_range_decoder(&s->coeff_partition[i], buf, size);
+        ret = ff_vpx_init_range_decoder(&s->coeff_partition[i], buf, size);
         if (ret < 0)
             return ret;
         buf      += size;
@@ -337,21 +373,21 @@ static int setup_partitions(VP8Context *s, const uint8_t *buf, int buf_size)
     }
 
     s->coeff_partition_size[i] = buf_size;
-    ff_vp56_init_range_decoder(&s->coeff_partition[i], buf, buf_size);
+    ff_vpx_init_range_decoder(&s->coeff_partition[i], buf, buf_size);
 
     return 0;
 }
 
 static void vp7_get_quants(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
-    int yac_qi  = vp8_rac_get_uint(c, 7);
-    int ydc_qi  = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int y2dc_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int y2ac_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int uvdc_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
-    int uvac_qi = vp8_rac_get(c) ? vp8_rac_get_uint(c, 7) : yac_qi;
+    int yac_qi  = vp89_rac_get_uint(c, 7);
+    int ydc_qi  = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int y2dc_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int y2ac_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int uvdc_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
+    int uvac_qi = vp89_rac_get(c) ? vp89_rac_get_uint(c, 7) : yac_qi;
 
     s->qmat[0].luma_qmul[0]    =       vp7_ydc_qlookup[ydc_qi];
     s->qmat[0].luma_qmul[1]    =       vp7_yac_qlookup[yac_qi];
@@ -363,10 +399,10 @@ static void vp7_get_quants(VP8Context *s)
 
 static void vp8_get_quants(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i, base_qi;
 
-    s->quant.yac_qi     = vp8_rac_get_uint(c, 7);
+    s->quant.yac_qi     = vp89_rac_get_uint(c, 7);
     s->quant.ydc_delta  = vp8_rac_get_sint(c, 4);
     s->quant.y2dc_delta = vp8_rac_get_sint(c, 4);
     s->quant.y2ac_delta = vp8_rac_get_sint(c, 4);
@@ -399,28 +435,28 @@ static void vp8_get_quants(VP8Context *s)
  * The spec isn't clear here, so I'm going by my understanding of what libvpx does
  *
  * Intra frames update all 3 references
- * Inter frames update VP56_FRAME_PREVIOUS if the update_last flag is set
+ * Inter frames update VP8_FRAME_PREVIOUS if the update_last flag is set
  * If the update (golden|altref) flag is set, it's updated with the current frame
- *      if update_last is set, and VP56_FRAME_PREVIOUS otherwise.
+ *      if update_last is set, and VP8_FRAME_PREVIOUS otherwise.
  * If the flag is not set, the number read means:
  *      0: no update
- *      1: VP56_FRAME_PREVIOUS
+ *      1: VP8_FRAME_PREVIOUS
  *      2: update golden with altref, or update altref with golden
  */
-static VP56Frame ref_to_update(VP8Context *s, int update, VP56Frame ref)
+static VP8FrameType ref_to_update(VP8Context *s, int update, VP8FrameType ref)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
     if (update)
-        return VP56_FRAME_CURRENT;
+        return VP8_FRAME_CURRENT;
 
-    switch (vp8_rac_get_uint(c, 2)) {
+    switch (vp89_rac_get_uint(c, 2)) {
     case 1:
-        return VP56_FRAME_PREVIOUS;
+        return VP8_FRAME_PREVIOUS;
     case 2:
-        return (ref == VP56_FRAME_GOLDEN) ? VP56_FRAME_GOLDEN2 : VP56_FRAME_GOLDEN;
+        return (ref == VP8_FRAME_GOLDEN) ? VP8_FRAME_ALTREF : VP8_FRAME_GOLDEN;
     }
-    return VP56_FRAME_NONE;
+    return VP8_FRAME_NONE;
 }
 
 static void vp78_reset_probability_tables(VP8Context *s)
@@ -434,15 +470,15 @@ static void vp78_reset_probability_tables(VP8Context *s)
 
 static void vp78_update_probability_tables(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i, j, k, l, m;
 
     for (i = 0; i < 4; i++)
         for (j = 0; j < 8; j++)
             for (k = 0; k < 3; k++)
                 for (l = 0; l < NUM_DCT_TOKENS-1; l++)
-                    if (vp56_rac_get_prob_branchy(c, vp8_token_update_probs[i][j][k][l])) {
-                        int prob = vp8_rac_get_uint(c, 8);
+                    if (vpx_rac_get_prob_branchy(c, vp8_token_update_probs[i][j][k][l])) {
+                        int prob = vp89_rac_get_uint(c, 8);
                         for (m = 0; vp8_coeff_band_indexes[j][m] >= 0; m++)
                             s->prob->token[i][vp8_coeff_band_indexes[j][m]][k][l] = prob;
                     }
@@ -454,32 +490,32 @@ static void vp78_update_probability_tables(VP8Context *s)
 static void vp78_update_pred16x16_pred8x8_mvc_probabilities(VP8Context *s,
                                                             int mvc_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i, j;
 
-    if (vp8_rac_get(c))
+    if (vp89_rac_get(c))
         for (i = 0; i < 4; i++)
-            s->prob->pred16x16[i] = vp8_rac_get_uint(c, 8);
-    if (vp8_rac_get(c))
+            s->prob->pred16x16[i] = vp89_rac_get_uint(c, 8);
+    if (vp89_rac_get(c))
         for (i = 0; i < 3; i++)
-            s->prob->pred8x8c[i]  = vp8_rac_get_uint(c, 8);
+            s->prob->pred8x8c[i]  = vp89_rac_get_uint(c, 8);
 
     // 17.2 MV probability update
     for (i = 0; i < 2; i++)
         for (j = 0; j < mvc_size; j++)
-            if (vp56_rac_get_prob_branchy(c, vp8_mv_update_prob[i][j]))
+            if (vpx_rac_get_prob_branchy(c, vp8_mv_update_prob[i][j]))
                 s->prob->mvc[i][j] = vp8_rac_get_nn(c);
 }
 
 static void update_refs(VP8Context *s)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
-    int update_golden = vp8_rac_get(c);
-    int update_altref = vp8_rac_get(c);
+    int update_golden = vp89_rac_get(c);
+    int update_altref = vp89_rac_get(c);
 
-    s->update_golden = ref_to_update(s, update_golden, VP56_FRAME_GOLDEN);
-    s->update_altref = ref_to_update(s, update_altref, VP56_FRAME_GOLDEN2);
+    s->update_golden = ref_to_update(s, update_golden, VP8_FRAME_GOLDEN);
+    s->update_altref = ref_to_update(s, update_altref, VP8_FRAME_ALTREF);
 }
 
 static void copy_chroma(AVFrame *dst, AVFrame *src, int width, int height)
@@ -518,22 +554,22 @@ static int vp7_fade_frame(VP8Context *s, int alpha, int beta)
         int height = s->mb_height * 16;
         AVFrame *src, *dst;
 
-        if (!s->framep[VP56_FRAME_PREVIOUS] ||
-            !s->framep[VP56_FRAME_GOLDEN]) {
+        if (!s->framep[VP8_FRAME_PREVIOUS] ||
+            !s->framep[VP8_FRAME_GOLDEN]) {
             av_log(s->avctx, AV_LOG_WARNING, "Discarding interframe without a prior keyframe!\n");
             return AVERROR_INVALIDDATA;
         }
 
         dst =
-        src = s->framep[VP56_FRAME_PREVIOUS]->tf.f;
+        src = s->framep[VP8_FRAME_PREVIOUS]->tf.f;
 
         /* preserve the golden frame, write a new previous frame */
-        if (s->framep[VP56_FRAME_GOLDEN] == s->framep[VP56_FRAME_PREVIOUS]) {
-            s->framep[VP56_FRAME_PREVIOUS] = vp8_find_free_buffer(s);
-            if ((ret = vp8_alloc_frame(s, s->framep[VP56_FRAME_PREVIOUS], 1)) < 0)
+        if (s->framep[VP8_FRAME_GOLDEN] == s->framep[VP8_FRAME_PREVIOUS]) {
+            s->framep[VP8_FRAME_PREVIOUS] = vp8_find_free_buffer(s);
+            if ((ret = vp8_alloc_frame(s, s->framep[VP8_FRAME_PREVIOUS], 1)) < 0)
                 return ret;
 
-            dst = s->framep[VP56_FRAME_PREVIOUS]->tf.f;
+            dst = s->framep[VP8_FRAME_PREVIOUS]->tf.f;
 
             copy_chroma(dst, src, width, height);
         }
@@ -548,7 +584,7 @@ static int vp7_fade_frame(VP8Context *s, int alpha, int beta)
 
 static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int part1_size, hscale, vscale, i, j, ret;
     int width  = s->avctx->width;
     int height = s->avctx->height;
@@ -579,7 +615,7 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 
     memcpy(s->put_pixels_tab, s->vp8dsp.put_vp8_epel_pixels_tab, sizeof(s->put_pixels_tab));
 
-    ret = ff_vp56_init_range_decoder(c, buf, part1_size);
+    ret = ff_vpx_init_range_decoder(c, buf, part1_size);
     if (ret < 0)
         return ret;
     buf      += part1_size;
@@ -587,14 +623,14 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 
     /* A. Dimension information (keyframes only) */
     if (s->keyframe) {
-        width  = vp8_rac_get_uint(c, 12);
-        height = vp8_rac_get_uint(c, 12);
-        hscale = vp8_rac_get_uint(c, 2);
-        vscale = vp8_rac_get_uint(c, 2);
+        width  = vp89_rac_get_uint(c, 12);
+        height = vp89_rac_get_uint(c, 12);
+        hscale = vp89_rac_get_uint(c, 2);
+        vscale = vp89_rac_get_uint(c, 2);
         if (hscale || vscale)
             avpriv_request_sample(s->avctx, "Upscaling");
 
-        s->update_golden = s->update_altref = VP56_FRAME_CURRENT;
+        s->update_golden = s->update_altref = VP8_FRAME_CURRENT;
         vp78_reset_probability_tables(s);
         memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter,
                sizeof(s->prob->pred16x16));
@@ -613,18 +649,18 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 
     /* B. Decoding information for all four macroblock-level features */
     for (i = 0; i < 4; i++) {
-        s->feature_enabled[i] = vp8_rac_get(c);
+        s->feature_enabled[i] = vp89_rac_get(c);
         if (s->feature_enabled[i]) {
-             s->feature_present_prob[i] = vp8_rac_get_uint(c, 8);
+             s->feature_present_prob[i] = vp89_rac_get_uint(c, 8);
 
              for (j = 0; j < 3; j++)
                  s->feature_index_prob[i][j] =
-                     vp8_rac_get(c) ? vp8_rac_get_uint(c, 8) : 255;
+                     vp89_rac_get(c) ? vp89_rac_get_uint(c, 8) : 255;
 
              if (vp7_feature_value_size[s->profile][i])
                  for (j = 0; j < 4; j++)
                      s->feature_value[i][j] =
-                        vp8_rac_get(c) ? vp8_rac_get_uint(c, vp7_feature_value_size[s->profile][i]) : 0;
+                        vp89_rac_get(c) ? vp89_rac_get_uint(c, vp7_feature_value_size[s->profile][i]) : 0;
         }
     }
 
@@ -633,7 +669,7 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
     s->lf_delta.enabled        = 0;
 
     s->num_coeff_partitions = 1;
-    ret = ff_vp56_init_range_decoder(&s->coeff_partition[0], buf, buf_size);
+    ret = ff_vpx_init_range_decoder(&s->coeff_partition[0], buf, buf_size);
     if (ret < 0)
         return ret;
 
@@ -649,8 +685,8 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 
     /* D. Golden frame update flag (a Flag) for interframes only */
     if (!s->keyframe) {
-        s->update_golden = vp8_rac_get(c) ? VP56_FRAME_CURRENT : VP56_FRAME_NONE;
-        s->sign_bias[VP56_FRAME_GOLDEN] = 0;
+        s->update_golden = vp89_rac_get(c) ? VP8_FRAME_CURRENT : VP8_FRAME_NONE;
+        s->sign_bias[VP8_FRAME_GOLDEN] = 0;
     }
 
     s->update_last          = 1;
@@ -658,36 +694,36 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
     s->fade_present         = 1;
 
     if (s->profile > 0) {
-        s->update_probabilities = vp8_rac_get(c);
+        s->update_probabilities = vp89_rac_get(c);
         if (!s->update_probabilities)
             s->prob[1] = s->prob[0];
 
         if (!s->keyframe)
-            s->fade_present = vp8_rac_get(c);
+            s->fade_present = vp89_rac_get(c);
     }
 
-    if (vpX_rac_is_end(c))
+    if (vpx_rac_is_end(c))
         return AVERROR_INVALIDDATA;
     /* E. Fading information for previous frame */
-    if (s->fade_present && vp8_rac_get(c)) {
-        alpha = (int8_t) vp8_rac_get_uint(c, 8);
-        beta  = (int8_t) vp8_rac_get_uint(c, 8);
+    if (s->fade_present && vp89_rac_get(c)) {
+        alpha = (int8_t) vp89_rac_get_uint(c, 8);
+        beta  = (int8_t) vp89_rac_get_uint(c, 8);
     }
 
     /* F. Loop filter type */
     if (!s->profile)
-        s->filter.simple = vp8_rac_get(c);
+        s->filter.simple = vp89_rac_get(c);
 
     /* G. DCT coefficient ordering specification */
-    if (vp8_rac_get(c))
+    if (vp89_rac_get(c))
         for (i = 1; i < 16; i++)
-            s->prob[0].scan[i] = ff_zigzag_scan[vp8_rac_get_uint(c, 4)];
+            s->prob[0].scan[i] = ff_zigzag_scan[vp89_rac_get_uint(c, 4)];
 
     /* H. Loop filter levels  */
     if (s->profile > 0)
-        s->filter.simple = vp8_rac_get(c);
-    s->filter.level     = vp8_rac_get_uint(c, 6);
-    s->filter.sharpness = vp8_rac_get_uint(c, 3);
+        s->filter.simple = vp89_rac_get(c);
+    s->filter.level     = vp89_rac_get_uint(c, 6);
+    s->filter.sharpness = vp89_rac_get_uint(c, 3);
 
     /* I. DCT coefficient probability update; 13.3 Token Probability Updates */
     vp78_update_probability_tables(s);
@@ -696,12 +732,12 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 
     /* J. The remaining frame header data occurs ONLY FOR INTERFRAMES */
     if (!s->keyframe) {
-        s->prob->intra  = vp8_rac_get_uint(c, 8);
-        s->prob->last   = vp8_rac_get_uint(c, 8);
+        s->prob->intra  = vp89_rac_get_uint(c, 8);
+        s->prob->last   = vp89_rac_get_uint(c, 8);
         vp78_update_pred16x16_pred8x8_mvc_probabilities(s, VP7_MVC_SIZE);
     }
 
-    if (vpX_rac_is_end(c))
+    if (vpx_rac_is_end(c))
         return AVERROR_INVALIDDATA;
 
     if ((ret = vp7_fade_frame(s, alpha, beta)) < 0)
@@ -712,7 +748,7 @@ static int vp7_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 
 static int vp8_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_size)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int header_size, hscale, vscale, ret;
     int width  = s->avctx->width;
     int height = s->avctx->height;
@@ -762,7 +798,7 @@ static int vp8_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
         if (hscale || vscale)
             avpriv_request_sample(s->avctx, "Upscaling");
 
-        s->update_golden = s->update_altref = VP56_FRAME_CURRENT;
+        s->update_golden = s->update_altref = VP8_FRAME_CURRENT;
         vp78_reset_probability_tables(s);
         memcpy(s->prob->pred16x16, vp8_pred16x16_prob_inter,
                sizeof(s->prob->pred16x16));
@@ -774,30 +810,30 @@ static int vp8_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
         memset(&s->lf_delta, 0, sizeof(s->lf_delta));
     }
 
-    ret = ff_vp56_init_range_decoder(c, buf, header_size);
+    ret = ff_vpx_init_range_decoder(c, buf, header_size);
     if (ret < 0)
         return ret;
     buf      += header_size;
     buf_size -= header_size;
 
     if (s->keyframe) {
-        s->colorspace = vp8_rac_get(c);
+        s->colorspace = vp89_rac_get(c);
         if (s->colorspace)
             av_log(s->avctx, AV_LOG_WARNING, "Unspecified colorspace\n");
-        s->fullrange = vp8_rac_get(c);
+        s->fullrange = vp89_rac_get(c);
     }
 
-    if ((s->segmentation.enabled = vp8_rac_get(c)))
+    if ((s->segmentation.enabled = vp89_rac_get(c)))
         parse_segment_info(s);
     else
         s->segmentation.update_map = 0; // FIXME: move this to some init function?
 
-    s->filter.simple    = vp8_rac_get(c);
-    s->filter.level     = vp8_rac_get_uint(c, 6);
-    s->filter.sharpness = vp8_rac_get_uint(c, 3);
+    s->filter.simple    = vp89_rac_get(c);
+    s->filter.level     = vp89_rac_get_uint(c, 6);
+    s->filter.sharpness = vp89_rac_get_uint(c, 3);
 
-    if ((s->lf_delta.enabled = vp8_rac_get(c))) {
-        s->lf_delta.update = vp8_rac_get(c);
+    if ((s->lf_delta.enabled = vp89_rac_get(c))) {
+        s->lf_delta.update = vp89_rac_get(c);
         if (s->lf_delta.update)
             update_lf_deltas(s);
     }
@@ -817,31 +853,31 @@ static int vp8_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 
     if (!s->keyframe) {
         update_refs(s);
-        s->sign_bias[VP56_FRAME_GOLDEN]               = vp8_rac_get(c);
-        s->sign_bias[VP56_FRAME_GOLDEN2 /* altref */] = vp8_rac_get(c);
+        s->sign_bias[VP8_FRAME_GOLDEN] = vp89_rac_get(c);
+        s->sign_bias[VP8_FRAME_ALTREF] = vp89_rac_get(c);
     }
 
     // if we aren't saving this frame's probabilities for future frames,
     // make a copy of the current probabilities
-    if (!(s->update_probabilities = vp8_rac_get(c)))
+    if (!(s->update_probabilities = vp89_rac_get(c)))
         s->prob[1] = s->prob[0];
 
-    s->update_last = s->keyframe || vp8_rac_get(c);
+    s->update_last = s->keyframe || vp89_rac_get(c);
 
     vp78_update_probability_tables(s);
 
-    if ((s->mbskip_enabled = vp8_rac_get(c)))
-        s->prob->mbskip = vp8_rac_get_uint(c, 8);
+    if ((s->mbskip_enabled = vp89_rac_get(c)))
+        s->prob->mbskip = vp89_rac_get_uint(c, 8);
 
     if (!s->keyframe) {
-        s->prob->intra  = vp8_rac_get_uint(c, 8);
-        s->prob->last   = vp8_rac_get_uint(c, 8);
-        s->prob->golden = vp8_rac_get_uint(c, 8);
+        s->prob->intra  = vp89_rac_get_uint(c, 8);
+        s->prob->last   = vp89_rac_get_uint(c, 8);
+        s->prob->golden = vp89_rac_get_uint(c, 8);
         vp78_update_pred16x16_pred8x8_mvc_probabilities(s, VP8_MVC_SIZE);
     }
 
     // Record the entropy coder state here so that hwaccels can use it.
-    s->c.code_word = vp56_rac_renorm(&s->c);
+    s->c.code_word = vpx_rac_renorm(&s->c);
     s->coder_state_at_header_end.input     = s->c.buffer - (-s->c.bits / 8);
     s->coder_state_at_header_end.range     = s->c.high;
     s->coder_state_at_header_end.value     = s->c.code_word >> 16;
@@ -851,7 +887,7 @@ static int vp8_decode_frame_header(VP8Context *s, const uint8_t *buf, int buf_si
 }
 
 static av_always_inline
-void clamp_mv(VP8mvbounds *s, VP56mv *dst, const VP56mv *src)
+void clamp_mv(VP8mvbounds *s, VP8mv *dst, const VP8mv *src)
 {
     dst->x = av_clip(src->x, av_clip(s->mv_min.x, INT16_MIN, INT16_MAX),
                              av_clip(s->mv_max.x, INT16_MIN, INT16_MAX));
@@ -862,40 +898,40 @@ void clamp_mv(VP8mvbounds *s, VP56mv *dst, const VP56mv *src)
 /**
  * Motion vector coding, 17.1.
  */
-static av_always_inline int read_mv_component(VP56RangeCoder *c, const uint8_t *p, int vp7)
+static av_always_inline int read_mv_component(VPXRangeCoder *c, const uint8_t *p, int vp7)
 {
     int bit, x = 0;
 
-    if (vp56_rac_get_prob_branchy(c, p[0])) {
+    if (vpx_rac_get_prob_branchy(c, p[0])) {
         int i;
 
         for (i = 0; i < 3; i++)
-            x += vp56_rac_get_prob(c, p[9 + i]) << i;
+            x += vpx_rac_get_prob(c, p[9 + i]) << i;
         for (i = (vp7 ? 7 : 9); i > 3; i--)
-            x += vp56_rac_get_prob(c, p[9 + i]) << i;
-        if (!(x & (vp7 ? 0xF0 : 0xFFF0)) || vp56_rac_get_prob(c, p[12]))
+            x += vpx_rac_get_prob(c, p[9 + i]) << i;
+        if (!(x & (vp7 ? 0xF0 : 0xFFF0)) || vpx_rac_get_prob(c, p[12]))
             x += 8;
     } else {
         // small_mvtree
         const uint8_t *ps = p + 2;
-        bit = vp56_rac_get_prob(c, *ps);
+        bit = vpx_rac_get_prob(c, *ps);
         ps += 1 + 3 * bit;
         x  += 4 * bit;
-        bit = vp56_rac_get_prob(c, *ps);
+        bit = vpx_rac_get_prob(c, *ps);
         ps += 1 + bit;
         x  += 2 * bit;
-        x  += vp56_rac_get_prob(c, *ps);
+        x  += vpx_rac_get_prob(c, *ps);
     }
 
-    return (x && vp56_rac_get_prob(c, p[1])) ? -x : x;
+    return (x && vpx_rac_get_prob(c, p[1])) ? -x : x;
 }
 
-static int vp7_read_mv_component(VP56RangeCoder *c, const uint8_t *p)
+static int vp7_read_mv_component(VPXRangeCoder *c, const uint8_t *p)
 {
     return read_mv_component(c, p, 1);
 }
 
-static int vp8_read_mv_component(VP56RangeCoder *c, const uint8_t *p)
+static int vp8_read_mv_component(VPXRangeCoder *c, const uint8_t *p)
 {
     return read_mv_component(c, p, 0);
 }
@@ -918,7 +954,7 @@ const uint8_t *get_submv_prob(uint32_t left, uint32_t top, int is_vp7)
  * @returns the number of motion vectors parsed (2, 4 or 16)
  */
 static av_always_inline
-int decode_splitmvs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
+int decode_splitmvs(VP8Context *s, VPXRangeCoder *c, VP8Macroblock *mb,
                     int layout, int is_vp7)
 {
     int part_idx;
@@ -927,9 +963,9 @@ int decode_splitmvs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
     VP8Macroblock *left_mb = &mb[-1];
     const uint8_t *mbsplits_left = vp8_mbsplits[left_mb->partitioning];
     const uint8_t *mbsplits_top, *mbsplits_cur, *firstidx;
-    VP56mv *top_mv;
-    VP56mv *left_mv = left_mb->bmv;
-    VP56mv *cur_mv  = mb->bmv;
+    VP8mv *top_mv;
+    VP8mv *left_mv = left_mb->bmv;
+    VP8mv *cur_mv  = mb->bmv;
 
     if (!layout) // layout is inlined, s->mb_layout is not
         top_mb = &mb[2];
@@ -938,9 +974,9 @@ int decode_splitmvs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
     mbsplits_top = vp8_mbsplits[top_mb->partitioning];
     top_mv       = top_mb->bmv;
 
-    if (vp56_rac_get_prob_branchy(c, vp8_mbsplit_prob[0])) {
-        if (vp56_rac_get_prob_branchy(c, vp8_mbsplit_prob[1]))
-            part_idx = VP8_SPLITMVMODE_16x8 + vp56_rac_get_prob(c, vp8_mbsplit_prob[2]);
+    if (vpx_rac_get_prob_branchy(c, vp8_mbsplit_prob[0])) {
+        if (vpx_rac_get_prob_branchy(c, vp8_mbsplit_prob[1]))
+            part_idx = VP8_SPLITMVMODE_16x8 + vpx_rac_get_prob(c, vp8_mbsplit_prob[2]);
         else
             part_idx = VP8_SPLITMVMODE_8x8;
     } else {
@@ -968,9 +1004,9 @@ int decode_splitmvs(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
 
         submv_prob = get_submv_prob(left, above, is_vp7);
 
-        if (vp56_rac_get_prob_branchy(c, submv_prob[0])) {
-            if (vp56_rac_get_prob_branchy(c, submv_prob[1])) {
-                if (vp56_rac_get_prob_branchy(c, submv_prob[2])) {
+        if (vpx_rac_get_prob_branchy(c, submv_prob[0])) {
+            if (vpx_rac_get_prob_branchy(c, submv_prob[1])) {
+                if (vpx_rac_get_prob_branchy(c, submv_prob[2])) {
                     mb->bmv[n].y = mb->mv.y +
                                    read_mv_component(c, s->prob->mvc[0], is_vp7);
                     mb->bmv[n].x = mb->mv.x +
@@ -1013,7 +1049,7 @@ static int vp7_calculate_mb_offset(int mb_x, int mb_y, int mb_width,
     return 1;
 }
 
-static const VP56mv *get_bmv_ptr(const VP8Macroblock *mb, int subblock)
+static const VP8mv *get_bmv_ptr(const VP8Macroblock *mb, int subblock)
 {
     return &mb->bmv[mb->mode == VP8_MVMODE_SPLIT ? vp8_mbsplits[mb->partitioning][subblock] : 0];
 }
@@ -1026,9 +1062,9 @@ void vp7_decode_mvs(VP8Context *s, VP8Macroblock *mb,
     enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR };
     enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };
     int idx = CNT_ZERO;
-    VP56mv near_mv[3];
+    VP8mv near_mv[3];
     uint8_t cnt[3] = { 0 };
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     int i;
 
     AV_ZERO32(&near_mv[0]);
@@ -1074,19 +1110,19 @@ void vp7_decode_mvs(VP8Context *s, VP8Macroblock *mb,
 
     mb->partitioning = VP8_SPLITMVMODE_NONE;
 
-    if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_ZERO]][0])) {
+    if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_ZERO]][0])) {
         mb->mode = VP8_MVMODE_MV;
 
-        if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAREST]][1])) {
+        if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAREST]][1])) {
 
-            if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][2])) {
+            if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][2])) {
 
                 if (cnt[CNT_NEAREST] > cnt[CNT_NEAR])
                     AV_WN32A(&mb->mv, cnt[CNT_ZERO] > cnt[CNT_NEAREST] ? 0 : AV_RN32A(&near_mv[CNT_NEAREST]));
                 else
                     AV_WN32A(&mb->mv, cnt[CNT_ZERO] > cnt[CNT_NEAR]    ? 0 : AV_RN32A(&near_mv[CNT_NEAR]));
 
-                if (vp56_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][3])) {
+                if (vpx_rac_get_prob_branchy(c, vp7_mode_contexts[cnt[CNT_NEAR]][3])) {
                     mb->mode = VP8_MVMODE_SPLIT;
                     mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP7) - 1];
                 } else {
@@ -1121,9 +1157,9 @@ void vp8_decode_mvs(VP8Context *s, VP8mvbounds *mv_bounds, VP8Macroblock *mb,
     int idx = CNT_ZERO;
     int cur_sign_bias = s->sign_bias[mb->ref_frame];
     int8_t *sign_bias = s->sign_bias;
-    VP56mv near_mv[4];
+    VP8mv near_mv[4];
     uint8_t cnt[4] = { 0 };
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
 
     if (!layout) { // layout is inlined (s->mb_layout is not)
         mb_edge[0] = mb + 2;
@@ -1142,7 +1178,7 @@ void vp8_decode_mvs(VP8Context *s, VP8mvbounds *mv_bounds, VP8Macroblock *mb,
     {                                                                         \
         VP8Macroblock *edge = mb_edge[n];                                     \
         int edge_ref = edge->ref_frame;                                       \
-        if (edge_ref != VP56_FRAME_CURRENT) {                                 \
+        if (edge_ref != VP8_FRAME_CURRENT) {                                 \
             uint32_t mv = AV_RN32A(&edge->mv);                                \
             if (mv) {                                                         \
                 if (cur_sign_bias != sign_bias[edge_ref]) {                   \
@@ -1164,7 +1200,7 @@ void vp8_decode_mvs(VP8Context *s, VP8mvbounds *mv_bounds, VP8Macroblock *mb,
     MV_EDGE_CHECK(2)
 
     mb->partitioning = VP8_SPLITMVMODE_NONE;
-    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {
+    if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {
         mb->mode = VP8_MVMODE_MV;
 
         /* If we have three distinct MVs, merge first and last if they're the same */
@@ -1175,18 +1211,18 @@ void vp8_decode_mvs(VP8Context *s, VP8mvbounds *mv_bounds, VP8Macroblock *mb,
         /* Swap near and nearest if necessary */
         if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {
             FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);
-            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);
+            FFSWAP(VP8mv,   near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);
         }
 
-        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {
-            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {
+        if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {
+            if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {
                 /* Choose the best mv out of 0,0 and the nearest mv */
                 clamp_mv(mv_bounds, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);
                 cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +
                                     (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +
                                     (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);
 
-                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {
+                if (vpx_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {
                     mb->mode = VP8_MVMODE_SPLIT;
                     mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];
                 } else {
@@ -1210,7 +1246,7 @@ void vp8_decode_mvs(VP8Context *s, VP8mvbounds *mv_bounds, VP8Macroblock *mb,
 }
 
 static av_always_inline
-void decode_intra4x4_modes(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
+void decode_intra4x4_modes(VP8Context *s, VPXRangeCoder *c, VP8Macroblock *mb,
                            int mb_x, int keyframe, int layout)
 {
     uint8_t *intra4x4 = mb->intra4x4_pred_mode_mb;
@@ -1231,7 +1267,7 @@ void decode_intra4x4_modes(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
             for (x = 0; x < 4; x++) {
                 const uint8_t *ctx;
                 ctx       = vp8_pred4x4_prob_intra[top[x]][left[y]];
-                *intra4x4 = vp8_rac_get_tree(c, vp8_pred4x4_tree, ctx);
+                *intra4x4 = vp89_rac_get_tree(c, vp8_pred4x4_tree, ctx);
                 left[y]   = top[x] = *intra4x4;
                 intra4x4++;
             }
@@ -1239,17 +1275,17 @@ void decode_intra4x4_modes(VP8Context *s, VP56RangeCoder *c, VP8Macroblock *mb,
     } else {
         int i;
         for (i = 0; i < 16; i++)
-            intra4x4[i] = vp8_rac_get_tree(c, vp8_pred4x4_tree,
-                                           vp8_pred4x4_prob_inter);
+            intra4x4[i] = vp89_rac_get_tree(c, vp8_pred4x4_tree,
+                                            vp8_pred4x4_prob_inter);
     }
 }
 
 static av_always_inline
 void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
                     VP8Macroblock *mb, int mb_x, int mb_y,
-                    uint8_t *segment, uint8_t *ref, int layout, int is_vp7)
+                    uint8_t *segment, const uint8_t *ref, int layout, int is_vp7)
 {
-    VP56RangeCoder *c = &s->c;
+    VPXRangeCoder *c = &s->c;
     static const char * const vp7_feature_name[] = { "q-index",
                                                      "lf-delta",
                                                      "partial-golden-update",
@@ -1259,9 +1295,9 @@ void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
         *segment = 0;
         for (i = 0; i < 4; i++) {
             if (s->feature_enabled[i]) {
-                if (vp56_rac_get_prob_branchy(c, s->feature_present_prob[i])) {
-                      int index = vp8_rac_get_tree(c, vp7_feature_index_tree,
-                                                   s->feature_index_prob[i]);
+                if (vpx_rac_get_prob_branchy(c, s->feature_present_prob[i])) {
+                      int index = vp89_rac_get_tree(c, vp7_feature_index_tree,
+                                                    s->feature_index_prob[i]);
                       av_log(s->avctx, AV_LOG_WARNING,
                              "Feature %s present in macroblock (value 0x%x)\n",
                              vp7_feature_name[i], s->feature_value[i][index]);
@@ -1269,17 +1305,17 @@ void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
            }
         }
     } else if (s->segmentation.update_map) {
-        int bit  = vp56_rac_get_prob(c, s->prob->segmentid[0]);
-        *segment = vp56_rac_get_prob(c, s->prob->segmentid[1+bit]) + 2*bit;
+        int bit  = vpx_rac_get_prob(c, s->prob->segmentid[0]);
+        *segment = vpx_rac_get_prob(c, s->prob->segmentid[1+bit]) + 2*bit;
     } else if (s->segmentation.enabled)
         *segment = ref ? *ref : *segment;
     mb->segment = *segment;
 
-    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;
+    mb->skip = s->mbskip_enabled ? vpx_rac_get_prob(c, s->prob->mbskip) : 0;
 
     if (s->keyframe) {
-        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,
-                                    vp8_pred16x16_prob_intra);
+        mb->mode = vp89_rac_get_tree(c, vp8_pred16x16_tree_intra,
+                                     vp8_pred16x16_prob_intra);
 
         if (mb->mode == MODE_I4x4) {
             decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);
@@ -1293,17 +1329,17 @@ void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
             AV_WN32A(s->intra4x4_pred_mode_left, modes);
         }
 
-        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,
-                                                vp8_pred8x8c_prob_intra);
-        mb->ref_frame        = VP56_FRAME_CURRENT;
-    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {
+        mb->chroma_pred_mode = vp89_rac_get_tree(c, vp8_pred8x8c_tree,
+                                                 vp8_pred8x8c_prob_intra);
+        mb->ref_frame        = VP8_FRAME_CURRENT;
+    } else if (vpx_rac_get_prob_branchy(c, s->prob->intra)) {
         // inter MB, 16.2
-        if (vp56_rac_get_prob_branchy(c, s->prob->last))
+        if (vpx_rac_get_prob_branchy(c, s->prob->last))
             mb->ref_frame =
-                (!is_vp7 && vp56_rac_get_prob(c, s->prob->golden)) ? VP56_FRAME_GOLDEN2 /* altref */
-                                                                   : VP56_FRAME_GOLDEN;
+                (!is_vp7 && vpx_rac_get_prob(c, s->prob->golden)) ? VP8_FRAME_ALTREF
+                                                                  : VP8_FRAME_GOLDEN;
         else
-            mb->ref_frame = VP56_FRAME_PREVIOUS;
+            mb->ref_frame = VP8_FRAME_PREVIOUS;
         s->ref_count[mb->ref_frame - 1]++;
 
         // motion vectors, 16.3
@@ -1313,14 +1349,15 @@ void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
             vp8_decode_mvs(s, mv_bounds, mb, mb_x, mb_y, layout);
     } else {
         // intra MB, 16.1
-        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);
+        mb->mode = vp89_rac_get_tree(c, vp8_pred16x16_tree_inter,
+                                     s->prob->pred16x16);
 
         if (mb->mode == MODE_I4x4)
             decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);
 
-        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,
-                                                s->prob->pred8x8c);
-        mb->ref_frame        = VP56_FRAME_CURRENT;
+        mb->chroma_pred_mode = vp89_rac_get_tree(c, vp8_pred8x8c_tree,
+                                                 s->prob->pred8x8c);
+        mb->ref_frame        = VP8_FRAME_CURRENT;
         mb->partitioning     = VP8_SPLITMVMODE_NONE;
         AV_ZERO32(&mb->bmv[0]);
     }
@@ -1337,21 +1374,21 @@ void decode_mb_mode(VP8Context *s, VP8mvbounds *mv_bounds,
  *         otherwise, the index of the last coeff decoded plus one
  */
 static av_always_inline
-int decode_block_coeffs_internal(VP56RangeCoder *r, int16_t block[16],
+int decode_block_coeffs_internal(VPXRangeCoder *r, int16_t block[16],
                                  uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                                  int i, uint8_t *token_prob, int16_t qmul[2],
                                  const uint8_t scan[16], int vp7)
 {
-    VP56RangeCoder c = *r;
+    VPXRangeCoder c = *r;
     goto skip_eob;
     do {
         int coeff;
 restart:
-        if (!vp56_rac_get_prob_branchy(&c, token_prob[0]))   // DCT_EOB
+        if (!vpx_rac_get_prob_branchy(&c, token_prob[0]))   // DCT_EOB
             break;
 
 skip_eob:
-        if (!vp56_rac_get_prob_branchy(&c, token_prob[1])) { // DCT_0
+        if (!vpx_rac_get_prob_branchy(&c, token_prob[1])) { // DCT_0
             if (++i == 16)
                 break; // invalid input; blocks should end with EOB
             token_prob = probs[i][0];
@@ -1360,28 +1397,28 @@ skip_eob:
             goto skip_eob;
         }
 
-        if (!vp56_rac_get_prob_branchy(&c, token_prob[2])) { // DCT_1
+        if (!vpx_rac_get_prob_branchy(&c, token_prob[2])) { // DCT_1
             coeff = 1;
             token_prob = probs[i + 1][1];
         } else {
-            if (!vp56_rac_get_prob_branchy(&c, token_prob[3])) { // DCT 2,3,4
-                coeff = vp56_rac_get_prob_branchy(&c, token_prob[4]);
+            if (!vpx_rac_get_prob_branchy(&c, token_prob[3])) { // DCT 2,3,4
+                coeff = vpx_rac_get_prob_branchy(&c, token_prob[4]);
                 if (coeff)
-                    coeff += vp56_rac_get_prob(&c, token_prob[5]);
+                    coeff += vpx_rac_get_prob(&c, token_prob[5]);
                 coeff += 2;
             } else {
                 // DCT_CAT*
-                if (!vp56_rac_get_prob_branchy(&c, token_prob[6])) {
-                    if (!vp56_rac_get_prob_branchy(&c, token_prob[7])) { // DCT_CAT1
-                        coeff = 5 + vp56_rac_get_prob(&c, vp8_dct_cat1_prob[0]);
+                if (!vpx_rac_get_prob_branchy(&c, token_prob[6])) {
+                    if (!vpx_rac_get_prob_branchy(&c, token_prob[7])) { // DCT_CAT1
+                        coeff = 5 + vpx_rac_get_prob(&c, vp8_dct_cat1_prob[0]);
                     } else {                                    // DCT_CAT2
                         coeff  = 7;
-                        coeff += vp56_rac_get_prob(&c, vp8_dct_cat2_prob[0]) << 1;
-                        coeff += vp56_rac_get_prob(&c, vp8_dct_cat2_prob[1]);
+                        coeff += vpx_rac_get_prob(&c, vp8_dct_cat2_prob[0]) << 1;
+                        coeff += vpx_rac_get_prob(&c, vp8_dct_cat2_prob[1]);
                     }
                 } else {    // DCT_CAT3 and up
-                    int a   = vp56_rac_get_prob(&c, token_prob[8]);
-                    int b   = vp56_rac_get_prob(&c, token_prob[9 + a]);
+                    int a   = vpx_rac_get_prob(&c, token_prob[8]);
+                    int b   = vpx_rac_get_prob(&c, token_prob[9 + a]);
                     int cat = (a << 1) + b;
                     coeff  = 3 + (8 << cat);
                     coeff += vp8_rac_get_coeff(&c, ff_vp8_dct_cat_prob[cat]);
@@ -1389,7 +1426,7 @@ skip_eob:
             }
             token_prob = probs[i + 1][2];
         }
-        block[scan[i]] = (vp8_rac_get(&c) ? -coeff : coeff) * qmul[!!i];
+        block[scan[i]] = (vp89_rac_get(&c) ? -coeff : coeff) * qmul[!!i];
     } while (++i < 16);
 
     *r = c;
@@ -1419,7 +1456,7 @@ int inter_predict_dc(int16_t block[16], int16_t pred[2])
     return ret;
 }
 
-static int vp7_decode_block_coeffs_internal(VP56RangeCoder *r,
+static int vp7_decode_block_coeffs_internal(VPXRangeCoder *r,
                                             int16_t block[16],
                                             uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                                             int i, uint8_t *token_prob,
@@ -1431,7 +1468,7 @@ static int vp7_decode_block_coeffs_internal(VP56RangeCoder *r,
 }
 
 #ifndef vp8_decode_block_coeffs_internal
-static int vp8_decode_block_coeffs_internal(VP56RangeCoder *r,
+static int vp8_decode_block_coeffs_internal(VPXRangeCoder *r,
                                             int16_t block[16],
                                             uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                                             int i, uint8_t *token_prob,
@@ -1456,13 +1493,13 @@ static int vp8_decode_block_coeffs_internal(VP56RangeCoder *r,
  *         otherwise, the index of the last coeff decoded plus one
  */
 static av_always_inline
-int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
+int decode_block_coeffs(VPXRangeCoder *c, int16_t block[16],
                         uint8_t probs[16][3][NUM_DCT_TOKENS - 1],
                         int i, int zero_nhood, int16_t qmul[2],
                         const uint8_t scan[16], int vp7)
 {
     uint8_t *token_prob = probs[i][zero_nhood];
-    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
+    if (!vpx_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB
         return 0;
     return vp7 ? vp7_decode_block_coeffs_internal(c, block, probs, i,
                                                   token_prob, qmul, scan)
@@ -1471,7 +1508,7 @@ int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],
 }
 
 static av_always_inline
-void decode_mb_coeffs(VP8Context *s, VP8ThreadData *td, VP56RangeCoder *c,
+void decode_mb_coeffs(VP8Context *s, VP8ThreadData *td, VPXRangeCoder *c,
                       VP8Macroblock *mb, uint8_t t_nnz[9], uint8_t l_nnz[9],
                       int is_vp7)
 {
@@ -1811,7 +1848,7 @@ static const uint8_t subpel_idx[3][8] = {
  */
 static av_always_inline
 void vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst,
-                 ThreadFrame *ref, const VP56mv *mv,
+                 const ThreadFrame *ref, const VP8mv *mv,
                  int x_off, int y_off, int block_w, int block_h,
                  int width, int height, ptrdiff_t linesize,
                  vp8_mc_func mc_func[3][3])
@@ -1869,7 +1906,7 @@ void vp8_mc_luma(VP8Context *s, VP8ThreadData *td, uint8_t *dst,
  */
 static av_always_inline
 void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1,
-                   uint8_t *dst2, ThreadFrame *ref, const VP56mv *mv,
+                   uint8_t *dst2, const ThreadFrame *ref, const VP8mv *mv,
                    int x_off, int y_off, int block_w, int block_h,
                    int width, int height, ptrdiff_t linesize,
                    vp8_mc_func mc_func[3][3])
@@ -1921,9 +1958,9 @@ static av_always_inline
 void vp8_mc_part(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
                  ThreadFrame *ref_frame, int x_off, int y_off,
                  int bx_off, int by_off, int block_w, int block_h,
-                 int width, int height, VP56mv *mv)
+                 int width, int height, VP8mv *mv)
 {
-    VP56mv uvmv = *mv;
+    VP8mv uvmv = *mv;
 
     /* Y */
     vp8_mc_luma(s, td, dst[0] + by_off * s->linesize + bx_off,
@@ -1985,7 +2022,7 @@ void inter_predict(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
     int x_off = mb_x << 4, y_off = mb_y << 4;
     int width = 16 * s->mb_width, height = 16 * s->mb_height;
     ThreadFrame *ref = &s->framep[mb->ref_frame]->tf;
-    VP56mv *bmv = mb->bmv;
+    VP8mv *bmv = mb->bmv;
 
     switch (mb->partitioning) {
     case VP8_SPLITMVMODE_NONE:
@@ -1994,7 +2031,7 @@ void inter_predict(VP8Context *s, VP8ThreadData *td, uint8_t *dst[3],
         break;
     case VP8_SPLITMVMODE_4x4: {
         int x, y;
-        VP56mv uvmv;
+        VP8mv uvmv;
 
         /* Y */
         for (y = 0; y < 4; y++) {
@@ -2298,7 +2335,7 @@ int vp78_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *curframe,
         s->mv_bounds.mv_max.x = ((s->mb_width - 1) << 6) + MARGIN;
 
         for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {
-            if (vpX_rac_is_end(&s->c)) {
+            if (vpx_rac_is_end(&s->c)) {
                 return AVERROR_INVALIDDATA;
             }
             if (mb_y == 0)
@@ -2374,8 +2411,9 @@ static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void
     int mb_y = atomic_load(&td->thread_mb_pos) >> 16;
     int mb_x, mb_xy = mb_y * s->mb_width;
     int num_jobs = s->num_jobs;
-    VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame;
-    VP56RangeCoder *c  = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)];
+    const VP8Frame *prev_frame = s->prev_frame;
+    VP8Frame *curframe = s->curframe;
+    VPXRangeCoder *c  = &s->coeff_partition[mb_y & (s->num_coeff_partitions - 1)];
     VP8Macroblock *mb;
     uint8_t *dst[3] = {
         curframe->tf.f->data[0] + 16 * mb_y * s->linesize,
@@ -2383,7 +2421,7 @@ static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void
         curframe->tf.f->data[2] +  8 * mb_y * s->uvlinesize
     };
 
-    if (vpX_rac_is_end(c))
+    if (vpx_rac_is_end(c))
          return AVERROR_INVALIDDATA;
 
     if (mb_y == 0)
@@ -2414,7 +2452,7 @@ static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void
     td->mv_bounds.mv_max.x = ((s->mb_width - 1) << 6) + MARGIN;
 
     for (mb_x = 0; mb_x < s->mb_width; mb_x++, mb_xy++, mb++) {
-        if (vpX_rac_is_end(c))
+        if (vpx_rac_is_end(c))
             return AVERROR_INVALIDDATA;
         // Wait for previous thread to read mb_x+2, and reach mb_y-1.
         if (prev_td != td) {
@@ -2439,7 +2477,7 @@ static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void
                            prev_frame && prev_frame->seg_map ?
                            prev_frame->seg_map->data + mb_xy : NULL, 0, is_vp7);
 
-        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_PREVIOUS);
+        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP8_FRAME_PREVIOUS);
 
         if (!mb->skip)
             decode_mb_coeffs(s, td, c, mb, s->top_nnz[mb_x], td->left_nnz, is_vp7);
@@ -2449,7 +2487,7 @@ static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void
         else
             inter_predict(s, td, dst, mb, mb_x, mb_y);
 
-        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN);
+        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP8_FRAME_GOLDEN);
 
         if (!mb->skip) {
             idct_mb(s, td, dst, mb);
@@ -2477,7 +2515,7 @@ static av_always_inline int decode_mb_row_no_filter(AVCodecContext *avctx, void
                                  dst[1], dst[2], s->linesize, s->uvlinesize, 0);
         }
 
-        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP56_FRAME_GOLDEN2);
+        prefetch_motion(s, mb, mb_x, mb_y, mb_xy, VP8_FRAME_ALTREF);
 
         dst[0]      += 16;
         dst[1]      += 8;
@@ -2581,7 +2619,7 @@ static av_always_inline
 int vp78_decode_mb_row_sliced(AVCodecContext *avctx, void *tdata, int jobnr,
                               int threadnr, int is_vp7)
 {
-    VP8Context *s = avctx->priv_data;
+    const VP8Context *s = avctx->priv_data;
     VP8ThreadData *td = &s->thread_data[jobnr];
     VP8ThreadData *next_td = NULL, *prev_td = NULL;
     VP8Frame *curframe = s->curframe;
@@ -2652,10 +2690,10 @@ int vp78_decode_frame(AVCodecContext *avctx, AVFrame *rframe, int *got_frame,
         avctx->pix_fmt = s->pix_fmt;
     }
 
-    prev_frame = s->framep[VP56_FRAME_CURRENT];
+    prev_frame = s->framep[VP8_FRAME_CURRENT];
 
-    referenced = s->update_last || s->update_golden == VP56_FRAME_CURRENT ||
-                 s->update_altref == VP56_FRAME_CURRENT;
+    referenced = s->update_last || s->update_golden == VP8_FRAME_CURRENT ||
+                 s->update_altref == VP8_FRAME_CURRENT;
 
     skip_thresh = !referenced ? AVDISCARD_NONREF
                               : !s->keyframe ? AVDISCARD_NONKEY
@@ -2672,12 +2710,12 @@ int vp78_decode_frame(AVCodecContext *avctx, AVFrame *rframe, int *got_frame,
     for (i = 0; i < 5; i++)
         if (s->frames[i].tf.f->buf[0] &&
             &s->frames[i] != prev_frame &&
-            &s->frames[i] != s->framep[VP56_FRAME_PREVIOUS] &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN]   &&
-            &s->frames[i] != s->framep[VP56_FRAME_GOLDEN2])
+            &s->frames[i] != s->framep[VP8_FRAME_PREVIOUS] &&
+            &s->frames[i] != s->framep[VP8_FRAME_GOLDEN]   &&
+            &s->frames[i] != s->framep[VP8_FRAME_ALTREF])
             vp8_release_frame(s, &s->frames[i]);
 
-    curframe = s->framep[VP56_FRAME_CURRENT] = vp8_find_free_buffer(s);
+    curframe = s->framep[VP8_FRAME_CURRENT] = vp8_find_free_buffer(s);
 
     if (!s->colorspace)
         avctx->colorspace = AVCOL_SPC_BT470BG;
@@ -2690,9 +2728,9 @@ int vp78_decode_frame(AVCodecContext *avctx, AVFrame *rframe, int *got_frame,
      * likely that the values we have on a random interframe are complete
      * junk if we didn't start decode on a keyframe. So just don't display
      * anything rather than junk. */
-    if (!s->keyframe && (!s->framep[VP56_FRAME_PREVIOUS] ||
-                         !s->framep[VP56_FRAME_GOLDEN]   ||
-                         !s->framep[VP56_FRAME_GOLDEN2])) {
+    if (!s->keyframe && (!s->framep[VP8_FRAME_PREVIOUS] ||
+                         !s->framep[VP8_FRAME_GOLDEN]   ||
+                         !s->framep[VP8_FRAME_ALTREF])) {
         av_log(avctx, AV_LOG_WARNING,
                "Discarding interframe without a prior keyframe!\n");
         ret = AVERROR_INVALIDDATA;
@@ -2706,22 +2744,22 @@ int vp78_decode_frame(AVCodecContext *avctx, AVFrame *rframe, int *got_frame,
         goto err;
 
     // check if golden and altref are swapped
-    if (s->update_altref != VP56_FRAME_NONE)
-        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[s->update_altref];
+    if (s->update_altref != VP8_FRAME_NONE)
+        s->next_framep[VP8_FRAME_ALTREF] = s->framep[s->update_altref];
     else
-        s->next_framep[VP56_FRAME_GOLDEN2] = s->framep[VP56_FRAME_GOLDEN2];
+        s->next_framep[VP8_FRAME_ALTREF] = s->framep[VP8_FRAME_ALTREF];
 
-    if (s->update_golden != VP56_FRAME_NONE)
-        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[s->update_golden];
+    if (s->update_golden != VP8_FRAME_NONE)
+        s->next_framep[VP8_FRAME_GOLDEN] = s->framep[s->update_golden];
     else
-        s->next_framep[VP56_FRAME_GOLDEN] = s->framep[VP56_FRAME_GOLDEN];
+        s->next_framep[VP8_FRAME_GOLDEN] = s->framep[VP8_FRAME_GOLDEN];
 
     if (s->update_last)
-        s->next_framep[VP56_FRAME_PREVIOUS] = curframe;
+        s->next_framep[VP8_FRAME_PREVIOUS] = curframe;
     else
-        s->next_framep[VP56_FRAME_PREVIOUS] = s->framep[VP56_FRAME_PREVIOUS];
+        s->next_framep[VP8_FRAME_PREVIOUS] = s->framep[VP8_FRAME_PREVIOUS];
 
-    s->next_framep[VP56_FRAME_CURRENT] = curframe;
+    s->next_framep[VP8_FRAME_CURRENT] = curframe;
 
     if (ffcodec(avctx->codec)->update_thread_context)
         ff_thread_finish_setup(avctx);
@@ -2949,7 +2987,6 @@ const FFCodec ff_vp7_decoder = {
     .close                 = ff_vp8_decode_free,
     FF_CODEC_DECODE_CB(vp7_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE,
     .flush                 = vp8_decode_flush,
 };
 #endif /* CONFIG_VP7_DECODER */
@@ -2966,8 +3003,7 @@ const FFCodec ff_vp8_decoder = {
     FF_CODEC_DECODE_CB(ff_vp8_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
                              AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE |
-                             FF_CODEC_CAP_ALLOCATE_PROGRESS,
+    .caps_internal         = FF_CODEC_CAP_ALLOCATE_PROGRESS,
     .flush                 = vp8_decode_flush,
     .update_thread_context = ONLY_IF_THREADS_ENABLED(vp8_decode_update_thread_context),
     .hw_configs            = (const AVCodecHWConfigInternal *const []) {
diff --git a/libavcodec/vp8.h b/libavcodec/vp8.h
index 8fe4557..30aeb4c 100644
--- a/libavcodec/vp8.h
+++ b/libavcodec/vp8.h
@@ -34,11 +34,20 @@
 
 #include "h264pred.h"
 #include "threadframe.h"
-#include "vp56.h"
+#include "videodsp.h"
 #include "vp8dsp.h"
+#include "vpx_rac.h"
 
 #define VP8_MAX_QUANT 127
 
+typedef enum {
+    VP8_FRAME_NONE     = -1,
+    VP8_FRAME_CURRENT  =  0,
+    VP8_FRAME_PREVIOUS =  1,
+    VP8_FRAME_GOLDEN   =  2,
+    VP8_FRAME_ALTREF   =  3,
+} VP8FrameType;
+
 enum dct_token {
     DCT_0,
     DCT_1,
@@ -73,6 +82,11 @@ enum inter_splitmvmode {
     VP8_SPLITMVMODE_NONE,        ///< (only used in prediction) no split MVs
 };
 
+typedef struct VP8mv {
+    DECLARE_ALIGNED(4, int16_t, x);
+    int16_t y;
+} VP8mv;
+
 typedef struct VP8FilterStrength {
     uint8_t filter_level;
     uint8_t inner_limit;
@@ -90,8 +104,8 @@ typedef struct VP8Macroblock {
     uint8_t segment;
     uint8_t intra4x4_pred_mode_mb[16];
     DECLARE_ALIGNED(4, uint8_t, intra4x4_pred_mode_top)[4];
-    VP56mv mv;
-    VP56mv bmv[16];
+    VP8mv mv;
+    VP8mv bmv[16];
 } VP8Macroblock;
 
 typedef struct VP8intmv {
@@ -234,10 +248,10 @@ typedef struct VP8Context {
 
         /**
          * filter strength adjustment for macroblocks that reference:
-         * [0] - intra / VP56_FRAME_CURRENT
-         * [1] - VP56_FRAME_PREVIOUS
-         * [2] - VP56_FRAME_GOLDEN
-         * [3] - altref / VP56_FRAME_GOLDEN2
+         * [0] - intra / VP8_FRAME_CURRENT
+         * [1] - VP8_FRAME_PREVIOUS
+         * [2] - VP8_FRAME_GOLDEN
+         * [3] - altref / VP8_FRAME_ALTREF
          */
         int8_t ref[4];
     } lf_delta;
@@ -245,7 +259,7 @@ typedef struct VP8Context {
     uint8_t (*top_border)[16 + 8 + 8];
     uint8_t (*top_nnz)[9];
 
-    VP56RangeCoder c;   ///< header context, includes mb modes and motion vectors
+    VPXRangeCoder c;   ///< header context, includes mb modes and motion vectors
 
     /* This contains the entropy coder state at the end of the header
      * block, in the form specified by the standard.  For use by
@@ -282,8 +296,8 @@ typedef struct VP8Context {
 
     VP8Macroblock *macroblocks_base;
     int invisible;
-    int update_last;    ///< update VP56_FRAME_PREVIOUS with the current one
-    int update_golden;  ///< VP56_FRAME_NONE if not updated, or which frame to copy if so
+    int update_last;    ///< update VP8_FRAME_PREVIOUS with the current one
+    int update_golden;  ///< VP8_FRAME_NONE if not updated, or which frame to copy if so
     int update_altref;
 
     /**
@@ -297,7 +311,7 @@ typedef struct VP8Context {
      * There can be 1, 2, 4, or 8 of these after the header context.
      */
     int num_coeff_partitions;
-    VP56RangeCoder coeff_partition[8];
+    VPXRangeCoder coeff_partition[8];
     int coeff_partition_size[8];
     VideoDSPContext vdsp;
     VP8DSPContext vp8dsp;
@@ -328,8 +342,8 @@ typedef struct VP8Context {
 
     /**
      * Interframe DC prediction (VP7)
-     * [0] VP56_FRAME_PREVIOUS
-     * [1] VP56_FRAME_GOLDEN
+     * [0] VP8_FRAME_PREVIOUS
+     * [1] VP8_FRAME_GOLDEN
      */
     uint16_t inter_dc_pred[2][2];
 
diff --git a/libavcodec/vp89_rac.h b/libavcodec/vp89_rac.h
new file mode 100644
index 0000000..bc0924c
--- /dev/null
+++ b/libavcodec/vp89_rac.h
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Range decoder functions common to VP8 and VP9
+ */
+
+#ifndef AVCODEC_VP89_RAC_H
+#define AVCODEC_VP89_RAC_H
+
+#include <stdint.h>
+
+#include "libavutil/attributes.h"
+
+#include "vpx_rac.h"
+
+// rounding is different than vpx_rac_get, is vpx_rac_get wrong?
+static av_always_inline int vp89_rac_get(VPXRangeCoder *c)
+{
+    return vpx_rac_get_prob(c, 128);
+}
+
+static av_unused int vp89_rac_get_uint(VPXRangeCoder *c, int bits)
+{
+    int value = 0;
+
+    while (bits--) {
+        value = (value << 1) | vp89_rac_get(c);
+    }
+
+    return value;
+}
+
+// how probabilities are associated with decisions is different I think
+// well, the new scheme fits in the old but this way has one fewer branches per decision
+static av_always_inline int vp89_rac_get_tree(VPXRangeCoder *c, const int8_t (*tree)[2],
+                                              const uint8_t *probs)
+{
+    int i = 0;
+
+    do {
+        i = tree[i][vpx_rac_get_prob(c, probs[i])];
+    } while (i > 0);
+
+    return -i;
+}
+
+#endif /* AVCODEC_VP89_RAC_H */
diff --git a/libavcodec/vp9.c b/libavcodec/vp9.c
index fee79fb..621627d 100644
--- a/libavcodec/vp9.c
+++ b/libavcodec/vp9.c
@@ -34,10 +34,11 @@
 #include "pthread_internal.h"
 
 #include "videodsp.h"
-#include "vp56.h"
+#include "vp89_rac.h"
 #include "vp9.h"
 #include "vp9data.h"
 #include "vp9dec.h"
+#include "vpx_rac.h"
 #include "libavutil/avassert.h"
 #include "libavutil/pixdesc.h"
 #include "libavutil/video_enc_params.h"
@@ -231,6 +232,11 @@ static int update_size(AVCodecContext *avctx, int w, int h)
 #endif
 #if CONFIG_VP9_VDPAU_HWACCEL
             *fmtp++ = AV_PIX_FMT_VDPAU;
+#endif
+            break;
+        case AV_PIX_FMT_YUV444P:
+#if CONFIG_VP9_VAAPI_HWACCEL
+            *fmtp++ = AV_PIX_FMT_VAAPI;
 #endif
             break;
         }
@@ -274,7 +280,7 @@ static int update_size(AVCodecContext *avctx, int w, int h)
     assign(s->intra_pred_data[2],  uint8_t *,             64 * bytesperpixel);
     assign(s->above_y_nnz_ctx,     uint8_t *,             16);
     assign(s->above_mode_ctx,      uint8_t *,             16);
-    assign(s->above_mv_ctx,        VP56mv(*)[2],          16);
+    assign(s->above_mv_ctx,        VP9mv(*)[2],           16);
     assign(s->above_uv_nnz_ctx[0], uint8_t *,             16);
     assign(s->above_uv_nnz_ctx[1], uint8_t *,             16);
     assign(s->above_partition_ctx, uint8_t *,              8);
@@ -379,7 +385,7 @@ static av_always_inline int inv_recenter_nonneg(int v, int m)
 }
 
 // differential forward probability updates
-static int update_prob(VP56RangeCoder *c, int p)
+static int update_prob(VPXRangeCoder *c, int p)
 {
     static const uint8_t inv_map_table[255] = {
           7,  20,  33,  46,  59,  72,  85,  98, 111, 124, 137, 150, 163, 176,
@@ -419,16 +425,16 @@ static int update_prob(VP56RangeCoder *c, int p)
      * updates vs. the 'fine, exact' updates further down the range, which
      * adds one extra dimension to this differential update model. */
 
-    if (!vp8_rac_get(c)) {
-        d = vp8_rac_get_uint(c, 4) + 0;
-    } else if (!vp8_rac_get(c)) {
-        d = vp8_rac_get_uint(c, 4) + 16;
-    } else if (!vp8_rac_get(c)) {
-        d = vp8_rac_get_uint(c, 5) + 32;
+    if (!vp89_rac_get(c)) {
+        d = vp89_rac_get_uint(c, 4) + 0;
+    } else if (!vp89_rac_get(c)) {
+        d = vp89_rac_get_uint(c, 4) + 16;
+    } else if (!vp89_rac_get(c)) {
+        d = vp89_rac_get_uint(c, 5) + 32;
     } else {
-        d = vp8_rac_get_uint(c, 7);
+        d = vp89_rac_get_uint(c, 7);
         if (d >= 65)
-            d = (d << 1) - 65 + vp8_rac_get(c);
+            d = (d << 1) - 65 + vp89_rac_get(c);
         d += 64;
         av_assert2(d < FF_ARRAY_ELEMS(inv_map_table));
     }
@@ -784,7 +790,7 @@ static int decode_frame_header(AVCodecContext *avctx,
     s->s.h.tiling.tile_rows = 1 << s->s.h.tiling.log2_tile_rows;
     if (s->s.h.tiling.tile_cols != (1 << s->s.h.tiling.log2_tile_cols)) {
         int n_range_coders;
-        VP56RangeCoder *rc;
+        VPXRangeCoder *rc;
 
         if (s->td) {
             for (i = 0; i < s->active_tile_cols; i++)
@@ -802,10 +808,10 @@ static int decode_frame_header(AVCodecContext *avctx,
             n_range_coders = s->s.h.tiling.tile_cols;
         }
         s->td = av_calloc(s->active_tile_cols, sizeof(VP9TileData) +
-                                 n_range_coders * sizeof(VP56RangeCoder));
+                                 n_range_coders * sizeof(VPXRangeCoder));
         if (!s->td)
             return AVERROR(ENOMEM);
-        rc = (VP56RangeCoder *) &s->td[s->active_tile_cols];
+        rc = (VPXRangeCoder *) &s->td[s->active_tile_cols];
         for (i = 0; i < s->active_tile_cols; i++) {
             s->td[i].s = s;
             s->td[i].c_b = rc;
@@ -877,11 +883,11 @@ static int decode_frame_header(AVCodecContext *avctx,
         av_log(avctx, AV_LOG_ERROR, "Invalid compressed header size\n");
         return AVERROR_INVALIDDATA;
     }
-    ret = ff_vp56_init_range_decoder(&s->c, data2, size2);
+    ret = ff_vpx_init_range_decoder(&s->c, data2, size2);
     if (ret < 0)
         return ret;
 
-    if (vp56_rac_get_prob_branchy(&s->c, 128)) { // marker bit
+    if (vpx_rac_get_prob_branchy(&s->c, 128)) { // marker bit
         av_log(avctx, AV_LOG_ERROR, "Marker bit was set\n");
         return AVERROR_INVALIDDATA;
     }
@@ -905,22 +911,22 @@ static int decode_frame_header(AVCodecContext *avctx,
     if (s->s.h.lossless) {
         s->s.h.txfmmode = TX_4X4;
     } else {
-        s->s.h.txfmmode = vp8_rac_get_uint(&s->c, 2);
+        s->s.h.txfmmode = vp89_rac_get_uint(&s->c, 2);
         if (s->s.h.txfmmode == 3)
-            s->s.h.txfmmode += vp8_rac_get(&s->c);
+            s->s.h.txfmmode += vp89_rac_get(&s->c);
 
         if (s->s.h.txfmmode == TX_SWITCHABLE) {
             for (i = 0; i < 2; i++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.tx8p[i] = update_prob(&s->c, s->prob.p.tx8p[i]);
             for (i = 0; i < 2; i++)
                 for (j = 0; j < 2; j++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.tx16p[i][j] =
                             update_prob(&s->c, s->prob.p.tx16p[i][j]);
             for (i = 0; i < 2; i++)
                 for (j = 0; j < 3; j++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.tx32p[i][j] =
                             update_prob(&s->c, s->prob.p.tx32p[i][j]);
         }
@@ -929,7 +935,7 @@ static int decode_frame_header(AVCodecContext *avctx,
     // coef updates
     for (i = 0; i < 4; i++) {
         uint8_t (*ref)[2][6][6][3] = s->prob_ctx[c].coef[i];
-        if (vp8_rac_get(&s->c)) {
+        if (vp89_rac_get(&s->c)) {
             for (j = 0; j < 2; j++)
                 for (k = 0; k < 2; k++)
                     for (l = 0; l < 6; l++)
@@ -939,7 +945,7 @@ static int decode_frame_header(AVCodecContext *avctx,
                             if (m >= 3 && l == 0) // dc only has 3 pt
                                 break;
                             for (n = 0; n < 3; n++) {
-                                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                                if (vpx_rac_get_prob_branchy(&s->c, 252))
                                     p[n] = update_prob(&s->c, r[n]);
                                 else
                                     p[n] = r[n];
@@ -965,33 +971,33 @@ static int decode_frame_header(AVCodecContext *avctx,
 
     // mode updates
     for (i = 0; i < 3; i++)
-        if (vp56_rac_get_prob_branchy(&s->c, 252))
+        if (vpx_rac_get_prob_branchy(&s->c, 252))
             s->prob.p.skip[i] = update_prob(&s->c, s->prob.p.skip[i]);
     if (!s->s.h.keyframe && !s->s.h.intraonly) {
         for (i = 0; i < 7; i++)
             for (j = 0; j < 3; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_mode[i][j] =
                         update_prob(&s->c, s->prob.p.mv_mode[i][j]);
 
         if (s->s.h.filtermode == FILTER_SWITCHABLE)
             for (i = 0; i < 4; i++)
                 for (j = 0; j < 2; j++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.filter[i][j] =
                             update_prob(&s->c, s->prob.p.filter[i][j]);
 
         for (i = 0; i < 4; i++)
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
                 s->prob.p.intra[i] = update_prob(&s->c, s->prob.p.intra[i]);
 
         if (s->s.h.allowcompinter) {
-            s->s.h.comppredmode = vp8_rac_get(&s->c);
+            s->s.h.comppredmode = vp89_rac_get(&s->c);
             if (s->s.h.comppredmode)
-                s->s.h.comppredmode += vp8_rac_get(&s->c);
+                s->s.h.comppredmode += vp89_rac_get(&s->c);
             if (s->s.h.comppredmode == PRED_SWITCHABLE)
                 for (i = 0; i < 5; i++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.comp[i] =
                             update_prob(&s->c, s->prob.p.comp[i]);
         } else {
@@ -1000,10 +1006,10 @@ static int decode_frame_header(AVCodecContext *avctx,
 
         if (s->s.h.comppredmode != PRED_COMPREF) {
             for (i = 0; i < 5; i++) {
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.single_ref[i][0] =
                         update_prob(&s->c, s->prob.p.single_ref[i][0]);
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.single_ref[i][1] =
                         update_prob(&s->c, s->prob.p.single_ref[i][1]);
             }
@@ -1011,72 +1017,72 @@ static int decode_frame_header(AVCodecContext *avctx,
 
         if (s->s.h.comppredmode != PRED_SINGLEREF) {
             for (i = 0; i < 5; i++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.comp_ref[i] =
                         update_prob(&s->c, s->prob.p.comp_ref[i]);
         }
 
         for (i = 0; i < 4; i++)
             for (j = 0; j < 9; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.y_mode[i][j] =
                         update_prob(&s->c, s->prob.p.y_mode[i][j]);
 
         for (i = 0; i < 4; i++)
             for (j = 0; j < 4; j++)
                 for (k = 0; k < 3; k++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.partition[3 - i][j][k] =
                             update_prob(&s->c,
                                         s->prob.p.partition[3 - i][j][k]);
 
         // mv fields don't use the update_prob subexp model for some reason
         for (i = 0; i < 3; i++)
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
-                s->prob.p.mv_joint[i] = (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
+                s->prob.p.mv_joint[i] = (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
         for (i = 0; i < 2; i++) {
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
                 s->prob.p.mv_comp[i].sign =
-                    (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                    (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
             for (j = 0; j < 10; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].classes[j] =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
-            if (vp56_rac_get_prob_branchy(&s->c, 252))
+            if (vpx_rac_get_prob_branchy(&s->c, 252))
                 s->prob.p.mv_comp[i].class0 =
-                    (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                    (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
             for (j = 0; j < 10; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].bits[j] =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
         }
 
         for (i = 0; i < 2; i++) {
             for (j = 0; j < 2; j++)
                 for (k = 0; k < 3; k++)
-                    if (vp56_rac_get_prob_branchy(&s->c, 252))
+                    if (vpx_rac_get_prob_branchy(&s->c, 252))
                         s->prob.p.mv_comp[i].class0_fp[j][k] =
-                            (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                            (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
             for (j = 0; j < 3; j++)
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].fp[j] =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
         }
 
         if (s->s.h.highprecisionmvs) {
             for (i = 0; i < 2; i++) {
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].class0_hp =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
 
-                if (vp56_rac_get_prob_branchy(&s->c, 252))
+                if (vpx_rac_get_prob_branchy(&s->c, 252))
                     s->prob.p.mv_comp[i].hp =
-                        (vp8_rac_get_uint(&s->c, 7) << 1) | 1;
+                        (vp89_rac_get_uint(&s->c, 7) << 1) | 1;
             }
         }
     }
@@ -1099,11 +1105,11 @@ static void decode_sb(VP9TileData *td, int row, int col, VP9Filter *lflvl,
     int bytesperpixel = s->bytesperpixel;
 
     if (bl == BL_8X8) {
-        bp = vp8_rac_get_tree(td->c, ff_vp9_partition_tree, p);
+        bp = vp89_rac_get_tree(td->c, ff_vp9_partition_tree, p);
         ff_vp9_decode_block(td, row, col, lflvl, yoff, uvoff, bl, bp);
     } else if (col + hbs < s->cols) { // FIXME why not <=?
         if (row + hbs < s->rows) { // FIXME why not <=?
-            bp = vp8_rac_get_tree(td->c, ff_vp9_partition_tree, p);
+            bp = vp89_rac_get_tree(td->c, ff_vp9_partition_tree, p);
             switch (bp) {
             case PARTITION_NONE:
                 ff_vp9_decode_block(td, row, col, lflvl, yoff, uvoff, bl, bp);
@@ -1135,7 +1141,7 @@ static void decode_sb(VP9TileData *td, int row, int col, VP9Filter *lflvl,
             default:
                 av_assert0(0);
             }
-        } else if (vp56_rac_get_prob_branchy(td->c, p[1])) {
+        } else if (vpx_rac_get_prob_branchy(td->c, p[1])) {
             bp = PARTITION_SPLIT;
             decode_sb(td, row, col, lflvl, yoff, uvoff, bl + 1);
             decode_sb(td, row, col + hbs, lflvl,
@@ -1146,7 +1152,7 @@ static void decode_sb(VP9TileData *td, int row, int col, VP9Filter *lflvl,
             ff_vp9_decode_block(td, row, col, lflvl, yoff, uvoff, bl, bp);
         }
     } else if (row + hbs < s->rows) { // FIXME why not <=?
-        if (vp56_rac_get_prob_branchy(td->c, p[2])) {
+        if (vpx_rac_get_prob_branchy(td->c, p[2])) {
             bp = PARTITION_SPLIT;
             decode_sb(td, row, col, lflvl, yoff, uvoff, bl + 1);
             yoff  += hbs * 8 * y_stride;
@@ -1287,17 +1293,13 @@ static int decode_tiles(AVCodecContext *avctx,
                 data += 4;
                 size -= 4;
             }
-            if (tile_size > size) {
-                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);
+            if (tile_size > size)
                 return AVERROR_INVALIDDATA;
-            }
-            ret = ff_vp56_init_range_decoder(&td->c_b[tile_col], data, tile_size);
+            ret = ff_vpx_init_range_decoder(&td->c_b[tile_col], data, tile_size);
             if (ret < 0)
                 return ret;
-            if (vp56_rac_get_prob_branchy(&td->c_b[tile_col], 128)) { // marker bit
-                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);
+            if (vpx_rac_get_prob_branchy(&td->c_b[tile_col], 128)) // marker bit
                 return AVERROR_INVALIDDATA;
-            }
             data += tile_size;
             size -= tile_size;
         }
@@ -1340,7 +1342,7 @@ static int decode_tiles(AVCodecContext *avctx,
                         decode_sb_mem(td, row, col, lflvl_ptr,
                                       yoff2, uvoff2, BL_64X64);
                     } else {
-                        if (vpX_rac_is_end(td->c)) {
+                        if (vpx_rac_is_end(td->c)) {
                             return AVERROR_INVALIDDATA;
                         }
                         decode_sb(td, row, col, lflvl_ptr,
@@ -1714,10 +1716,10 @@ static int vp9_decode_frame(AVCodecContext *avctx, AVFrame *frame,
                     }
                     if (tile_size > size)
                         return AVERROR_INVALIDDATA;
-                    ret = ff_vp56_init_range_decoder(&s->td[tile_col].c_b[tile_row], data, tile_size);
+                    ret = ff_vpx_init_range_decoder(&s->td[tile_col].c_b[tile_row], data, tile_size);
                     if (ret < 0)
                         return ret;
-                    if (vp56_rac_get_prob_branchy(&s->td[tile_col].c_b[tile_row], 128)) // marker bit
+                    if (vpx_rac_get_prob_branchy(&s->td[tile_col].c_b[tile_row], 128)) // marker bit
                         return AVERROR_INVALIDDATA;
                     data += tile_size;
                     size -= tile_size;
@@ -1876,7 +1878,7 @@ const FFCodec ff_vp9_decoder = {
     .close                 = vp9_decode_free,
     FF_CODEC_DECODE_CB(vp9_decode_frame),
     .p.capabilities        = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS | AV_CODEC_CAP_SLICE_THREADS,
-    .caps_internal         = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal         = FF_CODEC_CAP_INIT_CLEANUP |
                              FF_CODEC_CAP_SLICE_THREAD_HAS_MF |
                              FF_CODEC_CAP_ALLOCATE_PROGRESS,
     .flush                 = vp9_decode_flush,
diff --git a/libavcodec/vp9_mc_template.c b/libavcodec/vp9_mc_template.c
index 31e692f..e654c0e 100644
--- a/libavcodec/vp9_mc_template.c
+++ b/libavcodec/vp9_mc_template.c
@@ -22,9 +22,9 @@
  */
 
 #define ROUNDED_DIV_MVx2(a, b) \
-    (VP56mv) { .x = ROUNDED_DIV(a.x + b.x, 2), .y = ROUNDED_DIV(a.y + b.y, 2) }
+    (VP9mv) { .x = ROUNDED_DIV(a.x + b.x, 2), .y = ROUNDED_DIV(a.y + b.y, 2) }
 #define ROUNDED_DIV_MVx4(a, b, c, d) \
-    (VP56mv) { .x = ROUNDED_DIV(a.x + b.x + c.x + d.x, 4), \
+    (VP9mv) { .x = ROUNDED_DIV(a.x + b.x + c.x + d.x, 4), \
                .y = ROUNDED_DIV(a.y + b.y + c.y + d.y, 4) }
 
 static void FN(inter_pred)(VP9TileData *td)
@@ -33,11 +33,11 @@ static void FN(inter_pred)(VP9TileData *td)
         { 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4 },
         { 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4 },
     };
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
-    ThreadFrame *tref1 = &s->s.refs[s->s.h.refidx[b->ref[0]]], *tref2;
-    AVFrame *ref1 = tref1->f, *ref2;
+    const ThreadFrame *tref1 = &s->s.refs[s->s.h.refidx[b->ref[0]]], *tref2;
+    const AVFrame *ref1 = tref1->f, *ref2;
     int w1 = ref1->width, h1 = ref1->height, w2, h2;
     ptrdiff_t ls_y = td->y_stride, ls_uv = td->uv_stride;
     int bytesperpixel = BYTES_PER_PIXEL;
@@ -51,7 +51,7 @@ static void FN(inter_pred)(VP9TileData *td)
 
     // y inter pred
     if (b->bs > BS_8x8) {
-        VP56mv uvmv;
+        VP9mv uvmv;
 
 #if SCALED == 0
         if (b->bs == BS_8x4) {
diff --git a/libavcodec/vp9block.c b/libavcodec/vp9block.c
index 5fdda63..5743f04 100644
--- a/libavcodec/vp9block.c
+++ b/libavcodec/vp9block.c
@@ -24,10 +24,11 @@
 #include "libavutil/avassert.h"
 
 #include "threadframe.h"
-#include "vp56.h"
+#include "vp89_rac.h"
 #include "vp9.h"
 #include "vp9data.h"
 #include "vp9dec.h"
+#include "vpx_rac.h"
 
 static av_always_inline void setctx_2d(uint8_t *ptr, int w, int h,
                                        ptrdiff_t stride, int v)
@@ -87,7 +88,7 @@ static void decode_mode(VP9TileData *td)
         TX_32X32, TX_32X32, TX_32X32, TX_32X32, TX_16X16, TX_16X16,
         TX_16X16, TX_8X8,   TX_8X8,   TX_8X8,   TX_4X4,   TX_4X4,  TX_4X4
     };
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col, row7 = td->row7;
     enum TxfmMode max_tx = max_tx_for_bl_bp[b->bs];
@@ -100,10 +101,11 @@ static void decode_mode(VP9TileData *td)
         b->seg_id = 0;
     } else if (s->s.h.keyframe || s->s.h.intraonly) {
         b->seg_id = !s->s.h.segmentation.update_map ? 0 :
-                    vp8_rac_get_tree(td->c, ff_vp9_segmentation_tree, s->s.h.segmentation.prob);
+                    vp89_rac_get_tree(td->c, ff_vp9_segmentation_tree,
+                                      s->s.h.segmentation.prob);
     } else if (!s->s.h.segmentation.update_map ||
                (s->s.h.segmentation.temporal &&
-                vp56_rac_get_prob_branchy(td->c,
+                vpx_rac_get_prob_branchy(td->c,
                     s->s.h.segmentation.pred_prob[s->above_segpred_ctx[col] +
                                     td->left_segpred_ctx[row7]]))) {
         if (!s->s.h.errorres && s->s.frames[REF_FRAME_SEGMAP].segmentation_map) {
@@ -126,8 +128,8 @@ static void decode_mode(VP9TileData *td)
         memset(&s->above_segpred_ctx[col], 1, w4);
         memset(&td->left_segpred_ctx[row7], 1, h4);
     } else {
-        b->seg_id = vp8_rac_get_tree(td->c, ff_vp9_segmentation_tree,
-                                     s->s.h.segmentation.prob);
+        b->seg_id = vp89_rac_get_tree(td->c, ff_vp9_segmentation_tree,
+                                      s->s.h.segmentation.prob);
 
         memset(&s->above_segpred_ctx[col], 0, w4);
         memset(&td->left_segpred_ctx[row7], 0, h4);
@@ -142,7 +144,7 @@ static void decode_mode(VP9TileData *td)
         s->s.h.segmentation.feat[b->seg_id].skip_enabled;
     if (!b->skip) {
         int c = td->left_skip_ctx[row7] + s->above_skip_ctx[col];
-        b->skip = vp56_rac_get_prob(td->c, s->prob.p.skip[c]);
+        b->skip = vpx_rac_get_prob(td->c, s->prob.p.skip[c]);
         td->counts.skip[c][b->skip]++;
     }
 
@@ -160,7 +162,7 @@ static void decode_mode(VP9TileData *td)
             c = have_a ? 2 * s->above_intra_ctx[col] :
                 have_l ? 2 * td->left_intra_ctx[row7] : 0;
         }
-        bit = vp56_rac_get_prob(td->c, s->prob.p.intra[c]);
+        bit = vpx_rac_get_prob(td->c, s->prob.p.intra[c]);
         td->counts.intra[c][bit]++;
         b->intra = !bit;
     }
@@ -185,22 +187,22 @@ static void decode_mode(VP9TileData *td)
         }
         switch (max_tx) {
         case TX_32X32:
-            b->tx = vp56_rac_get_prob(td->c, s->prob.p.tx32p[c][0]);
+            b->tx = vpx_rac_get_prob(td->c, s->prob.p.tx32p[c][0]);
             if (b->tx) {
-                b->tx += vp56_rac_get_prob(td->c, s->prob.p.tx32p[c][1]);
+                b->tx += vpx_rac_get_prob(td->c, s->prob.p.tx32p[c][1]);
                 if (b->tx == 2)
-                    b->tx += vp56_rac_get_prob(td->c, s->prob.p.tx32p[c][2]);
+                    b->tx += vpx_rac_get_prob(td->c, s->prob.p.tx32p[c][2]);
             }
             td->counts.tx32p[c][b->tx]++;
             break;
         case TX_16X16:
-            b->tx = vp56_rac_get_prob(td->c, s->prob.p.tx16p[c][0]);
+            b->tx = vpx_rac_get_prob(td->c, s->prob.p.tx16p[c][0]);
             if (b->tx)
-                b->tx += vp56_rac_get_prob(td->c, s->prob.p.tx16p[c][1]);
+                b->tx += vpx_rac_get_prob(td->c, s->prob.p.tx16p[c][1]);
             td->counts.tx16p[c][b->tx]++;
             break;
         case TX_8X8:
-            b->tx = vp56_rac_get_prob(td->c, s->prob.p.tx8p[c]);
+            b->tx = vpx_rac_get_prob(td->c, s->prob.p.tx8p[c]);
             td->counts.tx8p[c][b->tx]++;
             break;
         case TX_4X4:
@@ -221,11 +223,11 @@ static void decode_mode(VP9TileData *td)
             // necessary, they're just there to make the code slightly
             // simpler for now
             b->mode[0] =
-            a[0]       = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          ff_vp9_default_kf_ymode_probs[a[0]][l[0]]);
+            a[0]       = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           ff_vp9_default_kf_ymode_probs[a[0]][l[0]]);
             if (b->bs != BS_8x4) {
-                b->mode[1] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              ff_vp9_default_kf_ymode_probs[a[1]][b->mode[0]]);
+                b->mode[1] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               ff_vp9_default_kf_ymode_probs[a[1]][b->mode[0]]);
                 l[0]       =
                 a[1]       = b->mode[1];
             } else {
@@ -235,11 +237,11 @@ static void decode_mode(VP9TileData *td)
             }
             if (b->bs != BS_4x8) {
                 b->mode[2] =
-                a[0]       = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              ff_vp9_default_kf_ymode_probs[a[0]][l[1]]);
+                a[0]       = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               ff_vp9_default_kf_ymode_probs[a[0]][l[1]]);
                 if (b->bs != BS_8x4) {
-                    b->mode[3] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                                  ff_vp9_default_kf_ymode_probs[a[1]][b->mode[2]]);
+                    b->mode[3] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                                   ff_vp9_default_kf_ymode_probs[a[1]][b->mode[2]]);
                     l[1]       =
                     a[1]       = b->mode[3];
                 } else {
@@ -254,8 +256,8 @@ static void decode_mode(VP9TileData *td)
                 b->mode[3] = b->mode[1];
             }
         } else {
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          ff_vp9_default_kf_ymode_probs[*a][*l]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           ff_vp9_default_kf_ymode_probs[*a][*l]);
             b->mode[3] =
             b->mode[2] =
             b->mode[1] = b->mode[0];
@@ -263,28 +265,28 @@ static void decode_mode(VP9TileData *td)
             memset(a, b->mode[0], ff_vp9_bwh_tab[0][b->bs][0]);
             memset(l, b->mode[0], ff_vp9_bwh_tab[0][b->bs][1]);
         }
-        b->uvmode = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                     ff_vp9_default_kf_uvmode_probs[b->mode[3]]);
+        b->uvmode = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                      ff_vp9_default_kf_uvmode_probs[b->mode[3]]);
     } else if (b->intra) {
         b->comp = 0;
         if (b->bs > BS_8x8) {
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          s->prob.p.y_mode[0]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           s->prob.p.y_mode[0]);
             td->counts.y_mode[0][b->mode[0]]++;
             if (b->bs != BS_8x4) {
-                b->mode[1] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              s->prob.p.y_mode[0]);
+                b->mode[1] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               s->prob.p.y_mode[0]);
                 td->counts.y_mode[0][b->mode[1]]++;
             } else {
                 b->mode[1] = b->mode[0];
             }
             if (b->bs != BS_4x8) {
-                b->mode[2] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                              s->prob.p.y_mode[0]);
+                b->mode[2] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                               s->prob.p.y_mode[0]);
                 td->counts.y_mode[0][b->mode[2]]++;
                 if (b->bs != BS_8x4) {
-                    b->mode[3] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                                  s->prob.p.y_mode[0]);
+                    b->mode[3] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                                   s->prob.p.y_mode[0]);
                     td->counts.y_mode[0][b->mode[3]]++;
                 } else {
                     b->mode[3] = b->mode[2];
@@ -299,15 +301,15 @@ static void decode_mode(VP9TileData *td)
             };
             int sz = size_group[b->bs];
 
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                          s->prob.p.y_mode[sz]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                           s->prob.p.y_mode[sz]);
             b->mode[1] =
             b->mode[2] =
             b->mode[3] = b->mode[0];
             td->counts.y_mode[sz][b->mode[3]]++;
         }
-        b->uvmode = vp8_rac_get_tree(td->c, ff_vp9_intramode_tree,
-                                     s->prob.p.uv_mode[b->mode[3]]);
+        b->uvmode = vp89_rac_get_tree(td->c, ff_vp9_intramode_tree,
+                                      s->prob.p.uv_mode[b->mode[3]]);
         td->counts.uv_mode[b->mode[3]][b->uvmode]++;
     } else {
         static const uint8_t inter_mode_ctx_lut[14][14] = {
@@ -365,7 +367,7 @@ static void decode_mode(VP9TileData *td)
                 } else {
                     c = 1;
                 }
-                b->comp = vp56_rac_get_prob(td->c, s->prob.p.comp[c]);
+                b->comp = vpx_rac_get_prob(td->c, s->prob.p.comp[c]);
                 td->counts.comp[c][b->comp]++;
             }
 
@@ -437,7 +439,7 @@ static void decode_mode(VP9TileData *td)
                 } else {
                     c = 2;
                 }
-                bit = vp56_rac_get_prob(td->c, s->prob.p.comp_ref[c]);
+                bit = vpx_rac_get_prob(td->c, s->prob.p.comp_ref[c]);
                 b->ref[var_idx] = s->s.h.varcompref[bit];
                 td->counts.comp_ref[c][bit]++;
             } else /* single reference */ {
@@ -477,7 +479,7 @@ static void decode_mode(VP9TileData *td)
                 } else {
                     c = 2;
                 }
-                bit = vp56_rac_get_prob(td->c, s->prob.p.single_ref[c][0]);
+                bit = vpx_rac_get_prob(td->c, s->prob.p.single_ref[c][0]);
                 td->counts.single_ref[c][0][bit]++;
                 if (!bit) {
                     b->ref[0] = 0;
@@ -564,7 +566,7 @@ static void decode_mode(VP9TileData *td)
                     } else {
                         c = 2;
                     }
-                    bit = vp56_rac_get_prob(td->c, s->prob.p.single_ref[c][1]);
+                    bit = vpx_rac_get_prob(td->c, s->prob.p.single_ref[c][1]);
                     td->counts.single_ref[c][1][bit]++;
                     b->ref[0] = 1 + bit;
                 }
@@ -587,8 +589,8 @@ static void decode_mode(VP9TileData *td)
                 int c = inter_mode_ctx_lut[s->above_mode_ctx[col + off[b->bs]]]
                                           [td->left_mode_ctx[row7 + off[b->bs]]];
 
-                b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                              s->prob.p.mv_mode[c]);
+                b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                               s->prob.p.mv_mode[c]);
                 b->mode[1] =
                 b->mode[2] =
                 b->mode[3] = b->mode[0];
@@ -612,8 +614,8 @@ static void decode_mode(VP9TileData *td)
                 c = 3;
             }
 
-            filter_id = vp8_rac_get_tree(td->c, ff_vp9_filter_tree,
-                                         s->prob.p.filter[c]);
+            filter_id = vp89_rac_get_tree(td->c, ff_vp9_filter_tree,
+                                          s->prob.p.filter[c]);
             td->counts.filter[c][filter_id]++;
             b->filter = ff_vp9_filter_lut[filter_id];
         } else {
@@ -623,14 +625,14 @@ static void decode_mode(VP9TileData *td)
         if (b->bs > BS_8x8) {
             int c = inter_mode_ctx_lut[s->above_mode_ctx[col]][td->left_mode_ctx[row7]];
 
-            b->mode[0] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                          s->prob.p.mv_mode[c]);
+            b->mode[0] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                           s->prob.p.mv_mode[c]);
             td->counts.mv_mode[c][b->mode[0] - 10]++;
             ff_vp9_fill_mv(td, b->mv[0], b->mode[0], 0);
 
             if (b->bs != BS_8x4) {
-                b->mode[1] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                              s->prob.p.mv_mode[c]);
+                b->mode[1] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                               s->prob.p.mv_mode[c]);
                 td->counts.mv_mode[c][b->mode[1] - 10]++;
                 ff_vp9_fill_mv(td, b->mv[1], b->mode[1], 1);
             } else {
@@ -640,14 +642,14 @@ static void decode_mode(VP9TileData *td)
             }
 
             if (b->bs != BS_4x8) {
-                b->mode[2] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                              s->prob.p.mv_mode[c]);
+                b->mode[2] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                               s->prob.p.mv_mode[c]);
                 td->counts.mv_mode[c][b->mode[2] - 10]++;
                 ff_vp9_fill_mv(td, b->mv[2], b->mode[2], 2);
 
                 if (b->bs != BS_8x4) {
-                    b->mode[3] = vp8_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
-                                                  s->prob.p.mv_mode[c]);
+                    b->mode[3] = vp89_rac_get_tree(td->c, ff_vp9_inter_mode_tree,
+                                                   s->prob.p.mv_mode[c]);
                     td->counts.mv_mode[c][b->mode[3] - 10]++;
                     ff_vp9_fill_mv(td, b->mv[3], b->mode[3], 3);
                 } else {
@@ -800,11 +802,11 @@ static void decode_mode(VP9TileData *td)
 
 // FIXME merge cnt/eob arguments?
 static av_always_inline int
-decode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs,
+decode_coeffs_b_generic(VPXRangeCoder *c, int16_t *coef, int n_coeffs,
                         int is_tx32x32, int is8bitsperpixel, int bpp, unsigned (*cnt)[6][3],
-                        unsigned (*eob)[6][2], uint8_t (*p)[6][11],
+                        unsigned (*eob)[6][2], const uint8_t (*p)[6][11],
                         int nnz, const int16_t *scan, const int16_t (*nb)[2],
-                        const int16_t *band_counts, int16_t *qmul)
+                        const int16_t *band_counts, const int16_t *qmul)
 {
     int i = 0, band = 0, band_left = band_counts[band];
     const uint8_t *tp = p[0][nnz];
@@ -813,13 +815,13 @@ decode_coeffs_b_generic(VP56RangeCoder *c, int16_t *coef, int n_coeffs,
     do {
         int val, rc;
 
-        val = vp56_rac_get_prob_branchy(c, tp[0]); // eob
+        val = vpx_rac_get_prob_branchy(c, tp[0]); // eob
         eob[band][nnz][val]++;
         if (!val)
             break;
 
 skip_eob:
-        if (!vp56_rac_get_prob_branchy(c, tp[1])) { // zero
+        if (!vpx_rac_get_prob_branchy(c, tp[1])) { // zero
             cnt[band][nnz][0]++;
             if (!--band_left)
                 band_left = band_counts[++band];
@@ -832,70 +834,70 @@ skip_eob:
         }
 
         rc = scan[i];
-        if (!vp56_rac_get_prob_branchy(c, tp[2])) { // one
+        if (!vpx_rac_get_prob_branchy(c, tp[2])) { // one
             cnt[band][nnz][1]++;
             val       = 1;
             cache[rc] = 1;
         } else {
             cnt[band][nnz][2]++;
-            if (!vp56_rac_get_prob_branchy(c, tp[3])) { // 2, 3, 4
-                if (!vp56_rac_get_prob_branchy(c, tp[4])) {
+            if (!vpx_rac_get_prob_branchy(c, tp[3])) { // 2, 3, 4
+                if (!vpx_rac_get_prob_branchy(c, tp[4])) {
                     cache[rc] = val = 2;
                 } else {
-                    val       = 3 + vp56_rac_get_prob(c, tp[5]);
+                    val       = 3 + vpx_rac_get_prob(c, tp[5]);
                     cache[rc] = 3;
                 }
-            } else if (!vp56_rac_get_prob_branchy(c, tp[6])) { // cat1/2
+            } else if (!vpx_rac_get_prob_branchy(c, tp[6])) { // cat1/2
                 cache[rc] = 4;
-                if (!vp56_rac_get_prob_branchy(c, tp[7])) {
-                    val  =  vp56_rac_get_prob(c, 159) + 5;
+                if (!vpx_rac_get_prob_branchy(c, tp[7])) {
+                    val  =  vpx_rac_get_prob(c, 159) + 5;
                 } else {
-                    val  = (vp56_rac_get_prob(c, 165) << 1) + 7;
-                    val +=  vp56_rac_get_prob(c, 145);
+                    val  = (vpx_rac_get_prob(c, 165) << 1) + 7;
+                    val +=  vpx_rac_get_prob(c, 145);
                 }
             } else { // cat 3-6
                 cache[rc] = 5;
-                if (!vp56_rac_get_prob_branchy(c, tp[8])) {
-                    if (!vp56_rac_get_prob_branchy(c, tp[9])) {
-                        val  = 11 + (vp56_rac_get_prob(c, 173) << 2);
-                        val +=      (vp56_rac_get_prob(c, 148) << 1);
-                        val +=       vp56_rac_get_prob(c, 140);
+                if (!vpx_rac_get_prob_branchy(c, tp[8])) {
+                    if (!vpx_rac_get_prob_branchy(c, tp[9])) {
+                        val  = 11 + (vpx_rac_get_prob(c, 173) << 2);
+                        val +=      (vpx_rac_get_prob(c, 148) << 1);
+                        val +=       vpx_rac_get_prob(c, 140);
                     } else {
-                        val  = 19 + (vp56_rac_get_prob(c, 176) << 3);
-                        val +=      (vp56_rac_get_prob(c, 155) << 2);
-                        val +=      (vp56_rac_get_prob(c, 140) << 1);
-                        val +=       vp56_rac_get_prob(c, 135);
+                        val  = 19 + (vpx_rac_get_prob(c, 176) << 3);
+                        val +=      (vpx_rac_get_prob(c, 155) << 2);
+                        val +=      (vpx_rac_get_prob(c, 140) << 1);
+                        val +=       vpx_rac_get_prob(c, 135);
                     }
-                } else if (!vp56_rac_get_prob_branchy(c, tp[10])) {
-                    val  = (vp56_rac_get_prob(c, 180) << 4) + 35;
-                    val += (vp56_rac_get_prob(c, 157) << 3);
-                    val += (vp56_rac_get_prob(c, 141) << 2);
-                    val += (vp56_rac_get_prob(c, 134) << 1);
-                    val +=  vp56_rac_get_prob(c, 130);
+                } else if (!vpx_rac_get_prob_branchy(c, tp[10])) {
+                    val  = (vpx_rac_get_prob(c, 180) << 4) + 35;
+                    val += (vpx_rac_get_prob(c, 157) << 3);
+                    val += (vpx_rac_get_prob(c, 141) << 2);
+                    val += (vpx_rac_get_prob(c, 134) << 1);
+                    val +=  vpx_rac_get_prob(c, 130);
                 } else {
                     val = 67;
                     if (!is8bitsperpixel) {
                         if (bpp == 12) {
-                            val += vp56_rac_get_prob(c, 255) << 17;
-                            val += vp56_rac_get_prob(c, 255) << 16;
+                            val += vpx_rac_get_prob(c, 255) << 17;
+                            val += vpx_rac_get_prob(c, 255) << 16;
                         }
-                        val +=  (vp56_rac_get_prob(c, 255) << 15);
-                        val +=  (vp56_rac_get_prob(c, 255) << 14);
+                        val +=  (vpx_rac_get_prob(c, 255) << 15);
+                        val +=  (vpx_rac_get_prob(c, 255) << 14);
                     }
-                    val += (vp56_rac_get_prob(c, 254) << 13);
-                    val += (vp56_rac_get_prob(c, 254) << 12);
-                    val += (vp56_rac_get_prob(c, 254) << 11);
-                    val += (vp56_rac_get_prob(c, 252) << 10);
-                    val += (vp56_rac_get_prob(c, 249) << 9);
-                    val += (vp56_rac_get_prob(c, 243) << 8);
-                    val += (vp56_rac_get_prob(c, 230) << 7);
-                    val += (vp56_rac_get_prob(c, 196) << 6);
-                    val += (vp56_rac_get_prob(c, 177) << 5);
-                    val += (vp56_rac_get_prob(c, 153) << 4);
-                    val += (vp56_rac_get_prob(c, 140) << 3);
-                    val += (vp56_rac_get_prob(c, 133) << 2);
-                    val += (vp56_rac_get_prob(c, 130) << 1);
-                    val +=  vp56_rac_get_prob(c, 129);
+                    val += (vpx_rac_get_prob(c, 254) << 13);
+                    val += (vpx_rac_get_prob(c, 254) << 12);
+                    val += (vpx_rac_get_prob(c, 254) << 11);
+                    val += (vpx_rac_get_prob(c, 252) << 10);
+                    val += (vpx_rac_get_prob(c, 249) << 9);
+                    val += (vpx_rac_get_prob(c, 243) << 8);
+                    val += (vpx_rac_get_prob(c, 230) << 7);
+                    val += (vpx_rac_get_prob(c, 196) << 6);
+                    val += (vpx_rac_get_prob(c, 177) << 5);
+                    val += (vpx_rac_get_prob(c, 153) << 4);
+                    val += (vpx_rac_get_prob(c, 140) << 3);
+                    val += (vpx_rac_get_prob(c, 133) << 2);
+                    val += (vpx_rac_get_prob(c, 130) << 1);
+                    val +=  vpx_rac_get_prob(c, 129);
                 }
             }
         }
@@ -909,9 +911,9 @@ skip_eob:
         if (!--band_left)
             band_left = band_counts[++band];
         if (is_tx32x32)
-            STORE_COEF(coef, rc, (int)((vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]) / 2);
+            STORE_COEF(coef, rc, (int)((vp89_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]) / 2);
         else
-            STORE_COEF(coef, rc, (vp8_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]);
+            STORE_COEF(coef, rc, (vp89_rac_get(c) ? -val : val) * (unsigned)qmul[!!i]);
         nnz = (1 + cache[nb[i][0]] + cache[nb[i][1]]) >> 1;
         tp = p[band][nnz];
     } while (++i < n_coeffs);
@@ -921,9 +923,9 @@ skip_eob:
 
 static int decode_coeffs_b_8bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                 unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                 const int16_t (*nb)[2], const int16_t *band_counts,
-                                int16_t *qmul)
+                                const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 0, 1, 8, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -931,9 +933,9 @@ static int decode_coeffs_b_8bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
 
 static int decode_coeffs_b32_8bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                   unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                  uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                  const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                   const int16_t (*nb)[2], const int16_t *band_counts,
-                                  int16_t *qmul)
+                                  const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 1, 1, 8, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -941,9 +943,9 @@ static int decode_coeffs_b32_8bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
 
 static int decode_coeffs_b_16bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                  unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                 uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                 const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                  const int16_t (*nb)[2], const int16_t *band_counts,
-                                 int16_t *qmul)
+                                 const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 0, 0, td->s->s.h.bpp, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -951,9 +953,9 @@ static int decode_coeffs_b_16bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
 
 static int decode_coeffs_b32_16bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
                                    unsigned (*cnt)[6][3], unsigned (*eob)[6][2],
-                                   uint8_t (*p)[6][11], int nnz, const int16_t *scan,
+                                   const uint8_t (*p)[6][11], int nnz, const int16_t *scan,
                                    const int16_t (*nb)[2], const int16_t *band_counts,
-                                   int16_t *qmul)
+                                   const int16_t *qmul)
 {
     return decode_coeffs_b_generic(td->c, coef, n_coeffs, 1, 0, td->s->s.h.bpp, cnt, eob, p,
                                    nnz, scan, nb, band_counts, qmul);
@@ -961,17 +963,17 @@ static int decode_coeffs_b32_16bpp(VP9TileData *td, int16_t *coef, int n_coeffs,
 
 static av_always_inline int decode_coeffs(VP9TileData *td, int is8bitsperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
-    uint8_t (*p)[6][11] = s->prob.coef[b->tx][0 /* y */][!b->intra];
+    const uint8_t (*p)[6][11] = s->prob.coef[b->tx][0 /* y */][!b->intra];
     unsigned (*c)[6][3] = td->counts.coef[b->tx][0 /* y */][!b->intra];
     unsigned (*e)[6][2] = td->counts.eob[b->tx][0 /* y */][!b->intra];
     int w4 = ff_vp9_bwh_tab[1][b->bs][0] << 1, h4 = ff_vp9_bwh_tab[1][b->bs][1] << 1;
     int end_x = FFMIN(2 * (s->cols - col), w4);
     int end_y = FFMIN(2 * (s->rows - row), h4);
     int n, pl, x, y, ret;
-    int16_t (*qmul)[2] = s->s.h.segmentation.feat[b->seg_id].qmul;
+    const int16_t (*qmul)[2] = s->s.h.segmentation.feat[b->seg_id].qmul;
     int tx = 4 * s->s.h.lossless + b->tx;
     const int16_t * const *yscans = ff_vp9_scans[tx];
     const int16_t (* const * ynbs)[2] = ff_vp9_scans_nb[tx];
@@ -1262,7 +1264,7 @@ void ff_vp9_decode_block(VP9TileData *td, int row, int col,
                          VP9Filter *lflvl, ptrdiff_t yoff, ptrdiff_t uvoff,
                          enum BlockLevel bl, enum BlockPartition bp)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     enum BlockSize bs = bl * 3 + bp;
     int bytesperpixel = s->bytesperpixel;
diff --git a/libavcodec/vp9dec.h b/libavcodec/vp9dec.h
index 9cbd583..de7aba0 100644
--- a/libavcodec/vp9dec.h
+++ b/libavcodec/vp9dec.h
@@ -33,9 +33,12 @@
 #include "libavutil/thread.h"
 #include "libavutil/internal.h"
 
+#include "get_bits.h"
+#include "videodsp.h"
 #include "vp9.h"
 #include "vp9dsp.h"
 #include "vp9shared.h"
+#include "vpx_rac.h"
 
 #define REF_INVALID_SCALE 0xFFFF
 
@@ -82,7 +85,7 @@ typedef struct VP9Filter {
 typedef struct VP9Block {
     uint8_t seg_id, intra, comp, ref[2], mode[4], uvmode, skip;
     enum FilterMode filter;
-    VP56mv mv[4 /* b_idx */][2 /* ref */];
+    VP9mv mv[4 /* b_idx */][2 /* ref */];
     enum BlockSize bs;
     enum TxfmMode tx, uvtx;
     enum BlockLevel bl;
@@ -98,7 +101,7 @@ typedef struct VP9Context {
     VP9DSPContext dsp;
     VideoDSPContext vdsp;
     GetBitContext gb;
-    VP56RangeCoder c;
+    VPXRangeCoder c;
     int pass, active_tile_cols;
 
 #if HAVE_THREADS
@@ -146,7 +149,7 @@ typedef struct VP9Context {
     uint8_t *above_comp_ctx; // 1bit
     uint8_t *above_ref_ctx; // 2bit
     uint8_t *above_filter_ctx;
-    VP56mv (*above_mv_ctx)[2];
+    VP9mv (*above_mv_ctx)[2];
 
     // whole-frame cache
     uint8_t *intra_pred_data[3];
@@ -163,11 +166,9 @@ typedef struct VP9Context {
 } VP9Context;
 
 struct VP9TileData {
-    //VP9Context should be const, but because of the threading API(generates
-    //a lot of warnings) it's not.
-    VP9Context *s;
-    VP56RangeCoder *c_b;
-    VP56RangeCoder *c;
+    const VP9Context *s;
+    VPXRangeCoder *c_b;
+    VPXRangeCoder *c;
     int row, row7, col, col7;
     uint8_t *dst[3];
     ptrdiff_t y_stride, uv_stride;
@@ -209,7 +210,7 @@ struct VP9TileData {
     // contextual (left) cache
     DECLARE_ALIGNED(16, uint8_t, left_y_nnz_ctx)[16];
     DECLARE_ALIGNED(16, uint8_t, left_mode_ctx)[16];
-    DECLARE_ALIGNED(16, VP56mv, left_mv_ctx)[16][2];
+    DECLARE_ALIGNED(16, VP9mv, left_mv_ctx)[16][2];
     DECLARE_ALIGNED(16, uint8_t, left_uv_nnz_ctx)[2][16];
     DECLARE_ALIGNED(8, uint8_t, left_partition_ctx)[8];
     DECLARE_ALIGNED(8, uint8_t, left_skip_ctx)[8];
@@ -237,7 +238,7 @@ struct VP9TileData {
     unsigned int nb_block_structure;
 };
 
-void ff_vp9_fill_mv(VP9TileData *td, VP56mv *mv, int mode, int sb);
+void ff_vp9_fill_mv(VP9TileData *td, VP9mv *mv, int mode, int sb);
 
 void ff_vp9_adapt_probs(VP9Context *s);
 
diff --git a/libavcodec/vp9mvs.c b/libavcodec/vp9mvs.c
index ddce9b6..b93d878 100644
--- a/libavcodec/vp9mvs.c
+++ b/libavcodec/vp9mvs.c
@@ -22,12 +22,12 @@
  */
 
 #include "threadframe.h"
-#include "vp56.h"
-#include "vp9.h"
+#include "vp89_rac.h"
 #include "vp9data.h"
 #include "vp9dec.h"
+#include "vpx_rac.h"
 
-static av_always_inline void clamp_mv(VP56mv *dst, const VP56mv *src,
+static av_always_inline void clamp_mv(VP9mv *dst, const VP9mv *src,
                                       VP9TileData *td)
 {
     dst->x = av_clip(src->x, td->min_mv.x, td->max_mv.x);
@@ -35,7 +35,7 @@ static av_always_inline void clamp_mv(VP56mv *dst, const VP56mv *src,
 }
 
 static void find_ref_mvs(VP9TileData *td,
-                         VP56mv *pmv, int ref, int z, int idx, int sb)
+                         VP9mv *pmv, int ref, int z, int idx, int sb)
 {
     static const int8_t mv_ref_blk_off[N_BS_SIZES][8][2] = {
         [BS_64x64] = { {  3, -1 }, { -1,  3 }, {  4, -1 }, { -1,  4 },
@@ -65,7 +65,7 @@ static void find_ref_mvs(VP9TileData *td,
         [BS_4x4]   = { {  0, -1 }, { -1,  0 }, { -1, -1 }, {  0, -2 },
                        { -2,  0 }, { -1, -2 }, { -2, -1 }, { -2, -2 } },
     };
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col, row7 = td->row7;
     const int8_t (*p)[2] = mv_ref_blk_off[b->bs];
@@ -99,7 +99,7 @@ static void find_ref_mvs(VP9TileData *td,
 #define RETURN_MV(mv)                                                  \
     do {                                                               \
         if (sb > 0) {                                                  \
-            VP56mv tmp;                                                \
+            VP9mv tmp;                                                 \
             uint32_t m;                                                \
             av_assert2(idx == 1);                                      \
             av_assert2(mem != INVALID_MV);                             \
@@ -185,7 +185,7 @@ static void find_ref_mvs(VP9TileData *td,
 #define RETURN_SCALE_MV(mv, scale)              \
     do {                                        \
         if (scale) {                            \
-            VP56mv mv_temp = { -mv.x, -mv.y };  \
+            VP9mv mv_temp = { -mv.x, -mv.y };   \
             RETURN_MV(mv_temp);                 \
         } else {                                \
             RETURN_MV(mv);                      \
@@ -235,10 +235,10 @@ static void find_ref_mvs(VP9TileData *td,
 
 static av_always_inline int read_mv_component(VP9TileData *td, int idx, int hp)
 {
-    VP9Context *s = td->s;
-    int bit, sign = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].sign);
-    int n, c = vp8_rac_get_tree(td->c, ff_vp9_mv_class_tree,
-                                s->prob.p.mv_comp[idx].classes);
+    const VP9Context *s = td->s;
+    int bit, sign = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].sign);
+    int n, c = vp89_rac_get_tree(td->c, ff_vp9_mv_class_tree,
+                                 s->prob.p.mv_comp[idx].classes);
 
     td->counts.mv_comp[idx].sign[sign]++;
     td->counts.mv_comp[idx].classes[c]++;
@@ -246,17 +246,17 @@ static av_always_inline int read_mv_component(VP9TileData *td, int idx, int hp)
         int m;
 
         for (n = 0, m = 0; m < c; m++) {
-            bit = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].bits[m]);
+            bit = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].bits[m]);
             n |= bit << m;
             td->counts.mv_comp[idx].bits[m][bit]++;
         }
         n <<= 3;
-        bit = vp8_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
-                               s->prob.p.mv_comp[idx].fp);
+        bit = vp89_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
+                                s->prob.p.mv_comp[idx].fp);
         n  |= bit << 1;
         td->counts.mv_comp[idx].fp[bit]++;
         if (hp) {
-            bit = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].hp);
+            bit = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].hp);
             td->counts.mv_comp[idx].hp[bit]++;
             n |= bit;
         } else {
@@ -267,14 +267,14 @@ static av_always_inline int read_mv_component(VP9TileData *td, int idx, int hp)
         }
         n += 8 << c;
     } else {
-        n = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0);
+        n = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0);
         td->counts.mv_comp[idx].class0[n]++;
-        bit = vp8_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
-                               s->prob.p.mv_comp[idx].class0_fp[n]);
+        bit = vp89_rac_get_tree(td->c, ff_vp9_mv_fp_tree,
+                                s->prob.p.mv_comp[idx].class0_fp[n]);
         td->counts.mv_comp[idx].class0_fp[n][bit]++;
         n = (n << 3) | (bit << 1);
         if (hp) {
-            bit = vp56_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0_hp);
+            bit = vpx_rac_get_prob(td->c, s->prob.p.mv_comp[idx].class0_hp);
             td->counts.mv_comp[idx].class0_hp[bit]++;
             n |= bit;
         } else {
@@ -288,9 +288,9 @@ static av_always_inline int read_mv_component(VP9TileData *td, int idx, int hp)
     return sign ? -(n + 1) : (n + 1);
 }
 
-void ff_vp9_fill_mv(VP9TileData *td, VP56mv *mv, int mode, int sb)
+void ff_vp9_fill_mv(VP9TileData *td, VP9mv *mv, int mode, int sb)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
 
     if (mode == ZEROMV) {
@@ -319,8 +319,8 @@ void ff_vp9_fill_mv(VP9TileData *td, VP56mv *mv, int mode, int sb)
             }
         }
         if (mode == NEWMV) {
-            enum MVJoint j = vp8_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
-                                              s->prob.p.mv_joint);
+            enum MVJoint j = vp89_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
+                                               s->prob.p.mv_joint);
 
             td->counts.mv_joint[j]++;
             if (j >= MV_JOINT_V)
@@ -350,8 +350,8 @@ void ff_vp9_fill_mv(VP9TileData *td, VP56mv *mv, int mode, int sb)
                 }
             }
             if (mode == NEWMV) {
-                enum MVJoint j = vp8_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
-                                                  s->prob.p.mv_joint);
+                enum MVJoint j = vp89_rac_get_tree(td->c, ff_vp9_mv_joint_tree,
+                                                   s->prob.p.mv_joint);
 
                 td->counts.mv_joint[j]++;
                 if (j >= MV_JOINT_V)
diff --git a/libavcodec/vp9prob.c b/libavcodec/vp9prob.c
index fb295b4..69a5180 100644
--- a/libavcodec/vp9prob.c
+++ b/libavcodec/vp9prob.c
@@ -21,9 +21,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "vp56.h"
 #include "vp9.h"
-#include "vp9data.h"
 #include "vp9dec.h"
 
 static av_always_inline void adapt_prob(uint8_t *p, unsigned ct0, unsigned ct1,
diff --git a/libavcodec/vp9recon.c b/libavcodec/vp9recon.c
index bfafde8..073c04b 100644
--- a/libavcodec/vp9recon.c
+++ b/libavcodec/vp9recon.c
@@ -36,7 +36,7 @@ static av_always_inline int check_intra_mode(VP9TileData *td, int mode, uint8_t
                                              int row, int y, enum TxfmMode tx,
                                              int p, int ss_h, int ss_v, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     int have_top = row > 0 || y > 0;
     int have_left = col > td->tile_col_start || x > 0;
     int have_right = x < w - 1;
@@ -218,7 +218,7 @@ static av_always_inline int check_intra_mode(VP9TileData *td, int mode, uint8_t
 static av_always_inline void intra_recon(VP9TileData *td, ptrdiff_t y_off,
                                          ptrdiff_t uv_off, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
     int w4 = ff_vp9_bwh_tab[1][b->bs][0] << 1, step1d = 1 << b->tx, n;
@@ -295,14 +295,14 @@ void ff_vp9_intra_recon_16bpp(VP9TileData *td, ptrdiff_t y_off, ptrdiff_t uv_off
     intra_recon(td, y_off, uv_off, 2);
 }
 
-static av_always_inline void mc_luma_unscaled(VP9TileData *td, vp9_mc_func (*mc)[2],
+static av_always_inline void mc_luma_unscaled(VP9TileData *td, const vp9_mc_func (*mc)[2],
                                               uint8_t *dst, ptrdiff_t dst_stride,
                                               const uint8_t *ref, ptrdiff_t ref_stride,
-                                              ThreadFrame *ref_frame,
-                                              ptrdiff_t y, ptrdiff_t x, const VP56mv *mv,
+                                              const ThreadFrame *ref_frame,
+                                              ptrdiff_t y, ptrdiff_t x, const VP9mv *mv,
                                               int bw, int bh, int w, int h, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     int mx = mv->x, my = mv->y, th;
 
     y += my >> 3;
@@ -331,16 +331,16 @@ static av_always_inline void mc_luma_unscaled(VP9TileData *td, vp9_mc_func (*mc)
     mc[!!mx][!!my](dst, dst_stride, ref, ref_stride, bh, mx << 1, my << 1);
 }
 
-static av_always_inline void mc_chroma_unscaled(VP9TileData *td, vp9_mc_func (*mc)[2],
+static av_always_inline void mc_chroma_unscaled(VP9TileData *td, const vp9_mc_func (*mc)[2],
                                                 uint8_t *dst_u, uint8_t *dst_v,
                                                 ptrdiff_t dst_stride,
                                                 const uint8_t *ref_u, ptrdiff_t src_stride_u,
                                                 const uint8_t *ref_v, ptrdiff_t src_stride_v,
-                                                ThreadFrame *ref_frame,
-                                                ptrdiff_t y, ptrdiff_t x, const VP56mv *mv,
+                                                const ThreadFrame *ref_frame,
+                                                ptrdiff_t y, ptrdiff_t x, const VP9mv *mv,
                                                 int bw, int bh, int w, int h, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     int mx = mv->x * (1 << !s->ss_h), my = mv->y * (1 << !s->ss_v), th;
 
     y += my >> 4;
@@ -404,16 +404,16 @@ static av_always_inline void mc_chroma_unscaled(VP9TileData *td, vp9_mc_func (*m
 #undef SCALED
 
 static av_always_inline void mc_luma_scaled(VP9TileData *td, vp9_scaled_mc_func smc,
-                                            vp9_mc_func (*mc)[2],
+                                            const vp9_mc_func (*mc)[2],
                                             uint8_t *dst, ptrdiff_t dst_stride,
                                             const uint8_t *ref, ptrdiff_t ref_stride,
-                                            ThreadFrame *ref_frame,
-                                            ptrdiff_t y, ptrdiff_t x, const VP56mv *in_mv,
+                                            const ThreadFrame *ref_frame,
+                                            ptrdiff_t y, ptrdiff_t x, const VP9mv *in_mv,
                                             int px, int py, int pw, int ph,
                                             int bw, int bh, int w, int h, int bytesperpixel,
                                             const uint16_t *scale, const uint8_t *step)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     if (s->s.frames[CUR_FRAME].tf.f->width == ref_frame->f->width &&
         s->s.frames[CUR_FRAME].tf.f->height == ref_frame->f->height) {
         mc_luma_unscaled(td, mc, dst, dst_stride, ref, ref_stride, ref_frame,
@@ -423,7 +423,7 @@ static av_always_inline void mc_luma_scaled(VP9TileData *td, vp9_scaled_mc_func
     int mx, my;
     int refbw_m1, refbh_m1;
     int th;
-    VP56mv mv;
+    VP9mv mv;
 
     mv.x = av_clip(in_mv->x, -(x + pw - px + 4) * 8, (s->cols * 8 - x + px + 3) * 8);
     mv.y = av_clip(in_mv->y, -(y + ph - py + 4) * 8, (s->rows * 8 - y + py + 3) * 8);
@@ -462,18 +462,18 @@ static av_always_inline void mc_luma_scaled(VP9TileData *td, vp9_scaled_mc_func
 }
 
 static av_always_inline void mc_chroma_scaled(VP9TileData *td, vp9_scaled_mc_func smc,
-                                              vp9_mc_func (*mc)[2],
+                                              const vp9_mc_func (*mc)[2],
                                               uint8_t *dst_u, uint8_t *dst_v,
                                               ptrdiff_t dst_stride,
                                               const uint8_t *ref_u, ptrdiff_t src_stride_u,
                                               const uint8_t *ref_v, ptrdiff_t src_stride_v,
-                                              ThreadFrame *ref_frame,
-                                              ptrdiff_t y, ptrdiff_t x, const VP56mv *in_mv,
+                                              const ThreadFrame *ref_frame,
+                                              ptrdiff_t y, ptrdiff_t x, const VP9mv *in_mv,
                                               int px, int py, int pw, int ph,
                                               int bw, int bh, int w, int h, int bytesperpixel,
                                               const uint16_t *scale, const uint8_t *step)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     if (s->s.frames[CUR_FRAME].tf.f->width == ref_frame->f->width &&
         s->s.frames[CUR_FRAME].tf.f->height == ref_frame->f->height) {
         mc_chroma_unscaled(td, mc, dst_u, dst_v, dst_stride, ref_u, src_stride_u,
@@ -483,7 +483,7 @@ static av_always_inline void mc_chroma_scaled(VP9TileData *td, vp9_scaled_mc_fun
     int mx, my;
     int refbw_m1, refbh_m1;
     int th;
-    VP56mv mv;
+    VP9mv mv;
 
     if (s->ss_h) {
         // BUG https://code.google.com/p/webm/issues/detail?id=820
@@ -568,7 +568,7 @@ static av_always_inline void mc_chroma_scaled(VP9TileData *td, vp9_scaled_mc_fun
 
 static av_always_inline void inter_recon(VP9TileData *td, int bytesperpixel)
 {
-    VP9Context *s = td->s;
+    const VP9Context *s = td->s;
     VP9Block *b = td->b;
     int row = td->row, col = td->col;
 
diff --git a/libavcodec/vp9shared.h b/libavcodec/vp9shared.h
index ebaa11d..543a496 100644
--- a/libavcodec/vp9shared.h
+++ b/libavcodec/vp9shared.h
@@ -27,9 +27,10 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "libavutil/mem_internal.h"
+
 #include "vp9.h"
 #include "threadframe.h"
-#include "vp56.h"
 
 enum BlockPartition {
     PARTITION_NONE,    // [ ] <-.
@@ -51,8 +52,13 @@ enum CompPredMode {
     PRED_SWITCHABLE,
 };
 
+typedef struct VP9mv {
+    DECLARE_ALIGNED(4, int16_t, x);
+    int16_t y;
+} VP9mv;
+
 typedef struct VP9mvrefPair {
-    VP56mv mv[2];
+    VP9mv mv[2];
     int8_t ref[2];
 } VP9mvrefPair;
 
diff --git a/libavcodec/vpx_rac.c b/libavcodec/vpx_rac.c
new file mode 100644
index 0000000..cf02e9a
--- /dev/null
+++ b/libavcodec/vpx_rac.c
@@ -0,0 +1,53 @@
+/*
+ * VP5/6/8 decoder
+ * Copyright (c) 2010 Fiona Glaser <fiona@x264.com>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <stdint.h>
+#include "libavutil/error.h"
+#include "bytestream.h"
+#include "vpx_rac.h"
+
+const uint8_t ff_vpx_norm_shift[256]= {
+ 8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,
+ 3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
+ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+ 2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+};
+
+int ff_vpx_init_range_decoder(VPXRangeCoder *c, const uint8_t *buf, int buf_size)
+{
+    c->high = 255;
+    c->bits = -16;
+    c->buffer = buf;
+    c->end = buf + buf_size;
+    c->end_reached = 0;
+    if (buf_size < 1)
+        return AVERROR_INVALIDDATA;
+    c->code_word = bytestream_get_be24(&c->buffer);
+    return 0;
+}
diff --git a/libavcodec/vpx_rac.h b/libavcodec/vpx_rac.h
new file mode 100644
index 0000000..b158cc0
--- /dev/null
+++ b/libavcodec/vpx_rac.h
@@ -0,0 +1,135 @@
+/*
+ * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Common VP5-VP9 range decoder stuff
+ */
+
+#ifndef AVCODEC_VPX_RAC_H
+#define AVCODEC_VPX_RAC_H
+
+#include <stdint.h>
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "bytestream.h"
+
+typedef struct VPXRangeCoder {
+    int high;
+    int bits; /* stored negated (i.e. negative "bits" is a positive number of
+                 bits left) in order to eliminate a negate in cache refilling */
+    const uint8_t *buffer;
+    const uint8_t *end;
+    unsigned int code_word;
+    int end_reached;
+} VPXRangeCoder;
+
+extern const uint8_t ff_vpx_norm_shift[256];
+int ff_vpx_init_range_decoder(VPXRangeCoder *c, const uint8_t *buf, int buf_size);
+
+/**
+ * returns 1 if the end of the stream has been reached, 0 otherwise.
+ */
+static av_always_inline int vpx_rac_is_end(VPXRangeCoder *c)
+{
+    if (c->end <= c->buffer && c->bits >= 0)
+        c->end_reached ++;
+    return c->end_reached > 10;
+}
+
+static av_always_inline unsigned int vpx_rac_renorm(VPXRangeCoder *c)
+{
+    int shift = ff_vpx_norm_shift[c->high];
+    int bits = c->bits;
+    unsigned int code_word = c->code_word;
+
+    c->high   <<= shift;
+    code_word <<= shift;
+    bits       += shift;
+    if(bits >= 0 && c->buffer < c->end) {
+        code_word |= bytestream_get_be16(&c->buffer) << bits;
+        bits -= 16;
+    }
+    c->bits = bits;
+    return code_word;
+}
+
+#if   ARCH_ARM
+#include "arm/vpx_arith.h"
+#elif ARCH_X86
+#include "x86/vpx_arith.h"
+#endif
+
+#ifndef vpx_rac_get_prob
+#define vpx_rac_get_prob vpx_rac_get_prob
+static av_always_inline int vpx_rac_get_prob(VPXRangeCoder *c, uint8_t prob)
+{
+    unsigned int code_word = vpx_rac_renorm(c);
+    unsigned int low = 1 + (((c->high - 1) * prob) >> 8);
+    unsigned int low_shift = low << 16;
+    int bit = code_word >= low_shift;
+
+    c->high = bit ? c->high - low : low;
+    c->code_word = bit ? code_word - low_shift : code_word;
+
+    return bit;
+}
+#endif
+
+#ifndef vpx_rac_get_prob_branchy
+// branchy variant, to be used where there's a branch based on the bit decoded
+static av_always_inline int vpx_rac_get_prob_branchy(VPXRangeCoder *c, int prob)
+{
+    unsigned long code_word = vpx_rac_renorm(c);
+    unsigned low = 1 + (((c->high - 1) * prob) >> 8);
+    unsigned low_shift = low << 16;
+
+    if (code_word >= low_shift) {
+        c->high     -= low;
+        c->code_word = code_word - low_shift;
+        return 1;
+    }
+
+    c->high = low;
+    c->code_word = code_word;
+    return 0;
+}
+#endif
+
+static av_always_inline int vpx_rac_get(VPXRangeCoder *c)
+{
+    unsigned int code_word = vpx_rac_renorm(c);
+    /* equiprobable */
+    int low = (c->high + 1) >> 1;
+    unsigned int low_shift = low << 16;
+    int bit = code_word >= low_shift;
+    if (bit) {
+        c->high   -= low;
+        code_word -= low_shift;
+    } else {
+        c->high = low;
+    }
+
+    c->code_word = code_word;
+    return bit;
+}
+
+#endif /* AVCODEC_VPX_RAC_H */
diff --git a/libavcodec/vqavideo.c b/libavcodec/vqavideo.c
index 62f930e..a195eae 100644
--- a/libavcodec/vqavideo.c
+++ b/libavcodec/vqavideo.c
@@ -857,5 +857,5 @@ const FFCodec ff_vqa_decoder = {
     FF_CODEC_DECODE_CB(vqa_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
     .defaults       = vqa_defaults,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/vt_internal.h b/libavcodec/vt_internal.h
index 9502d7c..54a11fd 100644
--- a/libavcodec/vt_internal.h
+++ b/libavcodec/vt_internal.h
@@ -45,8 +45,6 @@ typedef struct VTContext {
     // Current H264 parameters (used to trigger decoder restart on SPS changes).
     uint8_t                     sps[3];
     bool                        reconfig_needed;
-
-    void *logctx;
 } VTContext;
 
 int ff_videotoolbox_alloc_frame(AVCodecContext *avctx, AVFrame *frame);
diff --git a/libavcodec/wavpack.c b/libavcodec/wavpack.c
index 8bfbb65..c12e1d6 100644
--- a/libavcodec/wavpack.c
+++ b/libavcodec/wavpack.c
@@ -1616,7 +1616,7 @@ static void wavpack_decode_flush(AVCodecContext *avctx)
 
 static int dsd_channel(AVCodecContext *avctx, void *frmptr, int jobnr, int threadnr)
 {
-    WavpackContext *s  = avctx->priv_data;
+    const WavpackContext *s  = avctx->priv_data;
     AVFrame *frame = frmptr;
 
     ff_dsd2pcm_translate (&s->dsdctx [jobnr], s->samples, 0,
@@ -1714,6 +1714,6 @@ const FFCodec ff_wavpack_decoder = {
     .update_thread_context = ONLY_IF_THREADS_ENABLED(update_thread_context),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS |
                       AV_CODEC_CAP_SLICE_THREADS | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP |
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP |
                       FF_CODEC_CAP_ALLOCATE_PROGRESS,
 };
diff --git a/libavcodec/wavpackenc.c b/libavcodec/wavpackenc.c
index 1f95768..7f7ed80 100644
--- a/libavcodec/wavpackenc.c
+++ b/libavcodec/wavpackenc.c
@@ -2977,5 +2977,4 @@ const FFCodec ff_wavpack_encoder = {
                                                      AV_SAMPLE_FMT_S32P,
                                                      AV_SAMPLE_FMT_FLTP,
                                                      AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/wbmpdec.c b/libavcodec/wbmpdec.c
new file mode 100644
index 0000000..0d0e574
--- /dev/null
+++ b/libavcodec/wbmpdec.c
@@ -0,0 +1,92 @@
+/*
+ * WBMP (Wireless Application Protocol Bitmap) image
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "bytestream.h"
+#include "codec_internal.h"
+#include "internal.h"
+#include "thread.h"
+
+static unsigned int getv(GetByteContext * gb)
+{
+    int i;
+    unsigned int v = 0;
+
+    do {
+        i = bytestream2_get_byte(gb);
+        v = (v << 7) | (i & 0x7F);
+    } while (i & 0x80);
+    return v;
+}
+
+static void readbits(uint8_t * dst, int width, int height, int linesize, const uint8_t * src, int size)
+{
+    int wpad = (width + 7) / 8;
+    for (int j = 0; j < height && size > 0; j++) {
+        memcpy(dst, src, FFMIN(wpad, size));
+        src += wpad;
+        size -= wpad;
+        dst += linesize;
+    }
+}
+
+static int wbmp_decode_frame(AVCodecContext *avctx, AVFrame *p,
+                            int *got_frame, AVPacket *avpkt)
+{
+    const uint8_t *buf = avpkt->data;
+    int buf_size = avpkt->size, width, height, ret;
+    GetByteContext gb;
+
+    bytestream2_init(&gb, buf, buf_size);
+
+    if (getv(&gb))
+        return AVERROR_INVALIDDATA;
+    bytestream2_skip(&gb, 1);
+    width = getv(&gb);
+    height = getv(&gb);
+
+    if ((ret = ff_set_dimensions(avctx, width, height)) < 0)
+        return ret;
+
+    avctx->pix_fmt = AV_PIX_FMT_MONOBLACK;
+    if ((ret = ff_thread_get_buffer(avctx, p, 0)) < 0)
+        return ret;
+
+    if (p->linesize[0] == (width + 7) / 8)
+        bytestream2_get_buffer(&gb, p->data[0], height * ((width + 7) / 8));
+    else
+        readbits(p->data[0], width, height, p->linesize[0], gb.buffer, gb.buffer_end - gb.buffer_start);
+
+    p->key_frame = 1;
+    p->pict_type = AV_PICTURE_TYPE_I;
+
+    *got_frame   = 1;
+
+    return buf_size;
+}
+
+const FFCodec ff_wbmp_decoder = {
+    .p.name         = "wbmp",
+    .p.long_name    = NULL_IF_CONFIG_SMALL("WBMP (Wireless Application Protocol Bitmap) image"),
+    .p.type         = AVMEDIA_TYPE_VIDEO,
+    .p.id           = AV_CODEC_ID_WBMP,
+    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
+    FF_CODEC_DECODE_CB(wbmp_decode_frame),
+};
diff --git a/libavcodec/wbmpenc.c b/libavcodec/wbmpenc.c
new file mode 100644
index 0000000..c2dd5f5
--- /dev/null
+++ b/libavcodec/wbmpenc.c
@@ -0,0 +1,89 @@
+/*
+ * WBMP (Wireless Application Protocol Bitmap) image
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "avcodec.h"
+#include "bytestream.h"
+#include "codec_internal.h"
+#include "encode.h"
+
+static void putv(uint8_t ** bufp, unsigned int v)
+{
+    unsigned int vv = 0;
+    int n = 0;
+
+    while (vv != v)
+        vv += v & (0x7F << 7 * n++);
+
+    while (--n > 0)
+        bytestream_put_byte(bufp, 0x80 | (v & (0x7F << 7 * n)) >> 7 * n);
+
+    bytestream_put_byte(bufp, v & 0x7F);
+}
+
+static void writebits(uint8_t ** bufp, const uint8_t * src, int width, int height, int linesize)
+{
+    int wpad = (width + 7) / 8;
+    for (int j = 0; j < height; j++) {
+        memcpy(*bufp, src, wpad);
+        *bufp += wpad;
+        src += linesize;
+    }
+}
+
+static int wbmp_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
+                            const AVFrame *frame, int *got_packet)
+{
+    int64_t size = avctx->height * ((avctx->width + 7) / 8) + 32;
+    uint8_t *buf;
+    int ret;
+
+    if ((ret = ff_get_encode_buffer(avctx, pkt, size, 0)) < 0)
+        return ret;
+
+    buf = pkt->data;
+
+    putv(&buf, 0);
+    bytestream_put_byte(&buf, 0);
+    putv(&buf, avctx->width);
+    putv(&buf, avctx->height);
+
+    if (frame->linesize[0] == (avctx->width + 7) / 8)
+        bytestream_put_buffer(&buf, frame->data[0], avctx->height * ((avctx->width + 7) / 8));
+    else
+        writebits(&buf, frame->data[0], avctx->width, avctx->height, frame->linesize[0]);
+
+    av_shrink_packet(pkt, buf - pkt->data);
+
+    *got_packet = 1;
+    return 0;
+}
+
+const FFCodec ff_wbmp_encoder = {
+    .p.name         = "wbmp",
+    .p.long_name    = NULL_IF_CONFIG_SMALL("WBMP (Wireless Application Protocol Bitmap) image"),
+    .p.type         = AVMEDIA_TYPE_VIDEO,
+    .p.id           = AV_CODEC_ID_WBMP,
+    .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
+    FF_CODEC_ENCODE_CB(wbmp_encode_frame),
+    .p.pix_fmts     = (const enum AVPixelFormat[]){
+        AV_PIX_FMT_MONOBLACK,
+        AV_PIX_FMT_NONE
+    },
+};
diff --git a/libavcodec/wcmv.c b/libavcodec/wcmv.c
index ac135f6..d2fdb30 100644
--- a/libavcodec/wcmv.c
+++ b/libavcodec/wcmv.c
@@ -250,6 +250,5 @@ const FFCodec ff_wcmv_decoder = {
     .close            = decode_close,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities   = AV_CODEC_CAP_DR1,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE |
-                        FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/webp.c b/libavcodec/webp.c
index e57a5a2..fb5688f 100644
--- a/libavcodec/webp.c
+++ b/libavcodec/webp.c
@@ -1565,5 +1565,5 @@ const FFCodec ff_webp_decoder = {
     FF_CODEC_DECODE_CB(webp_decode_frame),
     .close          = webp_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_ICC_PROFILES,
 };
diff --git a/libavcodec/webvttdec.c b/libavcodec/webvttdec.c
index fcf1062..e245e83 100644
--- a/libavcodec/webvttdec.c
+++ b/libavcodec/webvttdec.c
@@ -107,5 +107,4 @@ const FFCodec ff_webvtt_decoder = {
     .init           = ff_ass_subtitle_header_default,
     .flush          = ff_ass_decoder_flush,
     .priv_data_size = sizeof(FFASSDecoderContext),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/webvttenc.c b/libavcodec/webvttenc.c
index e433bb4..f47a5c5 100644
--- a/libavcodec/webvttenc.c
+++ b/libavcodec/webvttenc.c
@@ -220,5 +220,4 @@ const FFCodec ff_webvtt_encoder = {
     .init           = webvtt_encode_init,
     FF_CODEC_ENCODE_SUB_CB(webvtt_encode_frame),
     .close          = webvtt_encode_close,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/wmadec.c b/libavcodec/wmadec.c
index 825bd6c..755fd39 100644
--- a/libavcodec/wmadec.c
+++ b/libavcodec/wmadec.c
@@ -1012,7 +1012,7 @@ const FFCodec ff_wmav1_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
 #if CONFIG_WMAV2_DECODER
@@ -1029,6 +1029,6 @@ const FFCodec ff_wmav2_decoder = {
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/wmaenc.c b/libavcodec/wmaenc.c
index 28a7546..03a5d78 100644
--- a/libavcodec/wmaenc.c
+++ b/libavcodec/wmaenc.c
@@ -110,7 +110,7 @@ static av_cold int encode_init(AVCodecContext *avctx)
 static int apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)
 {
     WMACodecContext *s = avctx->priv_data;
-    float **audio      = (float **) frame->extended_data;
+    const float *const *audio = (const float *const *) frame->extended_data;
     int len            = frame->nb_samples;
     int window_index   = s->frame_len_bits - s->block_len_bits;
     FFTContext *mdct   = &s->mdct_ctx[window_index];
@@ -444,7 +444,7 @@ const FFCodec ff_wmav1_encoder = {
     .close          = ff_wma_end,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
 #if CONFIG_WMAV2_ENCODER
@@ -459,6 +459,6 @@ const FFCodec ff_wmav2_encoder = {
     .close          = ff_wma_end,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 #endif
diff --git a/libavcodec/wmalosslessdec.c b/libavcodec/wmalosslessdec.c
index 16c6713..614b613 100644
--- a/libavcodec/wmalosslessdec.c
+++ b/libavcodec/wmalosslessdec.c
@@ -1338,7 +1338,7 @@ const FFCodec ff_wmalossless_decoder = {
     FF_CODEC_DECODE_CB(decode_packet),
     .flush          = flush,
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_S16P,
                                                       AV_SAMPLE_FMT_S32P,
                                                       AV_SAMPLE_FMT_NONE },
diff --git a/libavcodec/wmaprodec.c b/libavcodec/wmaprodec.c
index 9cf763a..136522b 100644
--- a/libavcodec/wmaprodec.c
+++ b/libavcodec/wmaprodec.c
@@ -2093,7 +2093,7 @@ const FFCodec ff_wmapro_decoder = {
     .flush          = wmapro_flush,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_xma1_decoder = {
@@ -2108,7 +2108,7 @@ const FFCodec ff_xma1_decoder = {
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
 
 const FFCodec ff_xma2_decoder = {
@@ -2124,5 +2124,5 @@ const FFCodec ff_xma2_decoder = {
     .p.capabilities = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
     .p.sample_fmts  = (const enum AVSampleFormat[]) { AV_SAMPLE_FMT_FLTP,
                                                       AV_SAMPLE_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/wmavoice.c b/libavcodec/wmavoice.c
index c52ab87..6f6cc94 100644
--- a/libavcodec/wmavoice.c
+++ b/libavcodec/wmavoice.c
@@ -2008,6 +2008,6 @@ const FFCodec ff_wmavoice_decoder = {
     .close            = wmavoice_decode_end,
     FF_CODEC_DECODE_CB(wmavoice_decode_packet),
     .p.capabilities   = AV_CODEC_CAP_SUBFRAMES | AV_CODEC_CAP_DR1 | AV_CODEC_CAP_DELAY,
-    .caps_internal    = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal    = FF_CODEC_CAP_INIT_CLEANUP,
     .flush            = wmavoice_flush,
 };
diff --git a/libavcodec/wmv2.c b/libavcodec/wmv2.c
index 8d1d117..5fea009 100644
--- a/libavcodec/wmv2.c
+++ b/libavcodec/wmv2.c
@@ -49,11 +49,11 @@ av_cold void ff_wmv2_common_init(MpegEncContext *s)
 
 void ff_mspel_motion(MpegEncContext *s, uint8_t *dest_y,
                      uint8_t *dest_cb, uint8_t *dest_cr,
-                     uint8_t **ref_picture, op_pixels_func (*pix_op)[4],
+                     uint8_t *const *ref_picture, op_pixels_func (*pix_op)[4],
                      int motion_x, int motion_y, int h)
 {
     WMV2Context *const w = s->private_ctx;
-    uint8_t *ptr;
+    const uint8_t *ptr;
     int dxy, mx, my, src_x, src_y, v_edge_pos;
     ptrdiff_t offset, linesize, uvlinesize;
     int emu = 0;
diff --git a/libavcodec/wmv2.h b/libavcodec/wmv2.h
index cdd58cf..e49b81c 100644
--- a/libavcodec/wmv2.h
+++ b/libavcodec/wmv2.h
@@ -39,7 +39,7 @@ void ff_wmv2_common_init(MpegEncContext *s);
 
 void ff_mspel_motion(MpegEncContext *s,
                      uint8_t *dest_y, uint8_t *dest_cb, uint8_t *dest_cr,
-                     uint8_t **ref_picture, op_pixels_func (*pix_op)[4],
+                     uint8_t *const *ref_picture, op_pixels_func (*pix_op)[4],
                      int motion_x, int motion_y, int h);
 
 
diff --git a/libavcodec/wmv2dec.c b/libavcodec/wmv2dec.c
index bf0e609..22eb012 100644
--- a/libavcodec/wmv2dec.c
+++ b/libavcodec/wmv2dec.c
@@ -242,6 +242,10 @@ int ff_wmv2_decode_secondary_picture_header(MpegEncContext *s)
     WMV2DecContext *const w = (WMV2DecContext *) s;
 
     if (s->pict_type == AV_PICTURE_TYPE_I) {
+        /* Is filling with zeroes really the right thing to do? */
+        memset(s->current_picture_ptr->mb_type, 0,
+               sizeof(*s->current_picture_ptr->mb_type) *
+               s->mb_height * s->mb_stride);
         if (w->j_type_bit)
             w->j_type = get_bits1(&s->gb);
         else
@@ -578,7 +582,7 @@ static av_cold int wmv2_decode_init(AVCodecContext *avctx)
     ff_init_scantable(s->idsp.idct_permutation, &w->abt_scantable[1],
                       ff_wmv2_scantableB);
 
-    return ff_intrax8_common_init(avctx, &w->x8, &w->s.idsp,
+    return ff_intrax8_common_init(avctx, &w->x8,
                                   w->s.block, w->s.block_last_index,
                                   w->s.mb_width, w->s.mb_height);
 }
@@ -601,7 +605,7 @@ const FFCodec ff_wmv2_decoder = {
     .close          = wmv2_decode_end,
     FF_CODEC_DECODE_CB(ff_h263_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DRAW_HORIZ_BAND | AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
 };
diff --git a/libavcodec/wmv2enc.c b/libavcodec/wmv2enc.c
index 88211ac..2f6c688 100644
--- a/libavcodec/wmv2enc.c
+++ b/libavcodec/wmv2enc.c
@@ -243,7 +243,7 @@ const FFCodec ff_wmv2_encoder = {
     .init           = wmv2_encode_init,
     FF_CODEC_ENCODE_CB(ff_mpv_encode_picture),
     .close          = ff_mpv_encode_end,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV420P,
                                                      AV_PIX_FMT_NONE },
 };
diff --git a/libavcodec/wnv1.c b/libavcodec/wnv1.c
index 6251c00..8e568e7 100644
--- a/libavcodec/wnv1.c
+++ b/libavcodec/wnv1.c
@@ -143,5 +143,4 @@ const FFCodec ff_wnv1_decoder = {
     .init           = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/wrapped_avframe.c b/libavcodec/wrapped_avframe.c
index 06c274e..def29a9 100644
--- a/libavcodec/wrapped_avframe.c
+++ b/libavcodec/wrapped_avframe.c
@@ -92,11 +92,13 @@ static int wrapped_avframe_decode(AVCodecContext *avctx, AVFrame *out,
 
     in  = (AVFrame*)pkt->data;
 
-    err = ff_decode_frame_props(avctx, out);
+    err = av_frame_ref(out, in);
     if (err < 0)
         return err;
 
-    av_frame_move_ref(out, in);
+    err = ff_decode_frame_props(avctx, out);
+    if (err < 0)
+        return err;
 
     *got_frame = 1;
     return 0;
@@ -108,7 +110,6 @@ const FFCodec ff_wrapped_avframe_encoder = {
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_WRAPPED_AVFRAME,
     FF_CODEC_ENCODE_CB(wrapped_avframe_encode),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
 
 const FFCodec ff_wrapped_avframe_decoder = {
@@ -117,5 +118,4 @@ const FFCodec ff_wrapped_avframe_decoder = {
     .p.type         = AVMEDIA_TYPE_VIDEO,
     .p.id           = AV_CODEC_ID_WRAPPED_AVFRAME,
     FF_CODEC_DECODE_CB(wrapped_avframe_decode),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ws-snd1.c b/libavcodec/ws-snd1.c
index 8d07229..ceda575 100644
--- a/libavcodec/ws-snd1.c
+++ b/libavcodec/ws-snd1.c
@@ -178,5 +178,4 @@ const FFCodec ff_ws_snd1_decoder = {
     .init           = ws_snd_decode_init,
     FF_CODEC_DECODE_CB(ws_snd_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_CHANNEL_CONF,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/x86/Makefile b/libavcodec/x86/Makefile
index 6361161..4e44862 100644
--- a/libavcodec/x86/Makefile
+++ b/libavcodec/x86/Makefile
@@ -10,7 +10,6 @@ OBJS-$(CONFIG_DIRAC_DECODER)           += x86/diracdsp_init.o           \
                                           x86/dirac_dwt_init.o
 OBJS-$(CONFIG_FDCTDSP)                 += x86/fdctdsp_init.o
 OBJS-$(CONFIG_FFT)                     += x86/fft_init.o
-OBJS-$(CONFIG_FLACDSP)                 += x86/flacdsp_init.o
 OBJS-$(CONFIG_FMTCONVERT)              += x86/fmtconvert_init.o
 OBJS-$(CONFIG_H263DSP)                 += x86/h263dsp_init.o
 OBJS-$(CONFIG_H264CHROMA)              += x86/h264chroma_init.o
@@ -55,6 +54,8 @@ OBJS-$(CONFIG_CFHD_ENCODER)            += x86/cfhdencdsp_init.o
 OBJS-$(CONFIG_DCA_DECODER)             += x86/dcadsp_init.o x86/synth_filter_init.o
 OBJS-$(CONFIG_DNXHD_ENCODER)           += x86/dnxhdenc_init.o
 OBJS-$(CONFIG_EXR_DECODER)             += x86/exrdsp_init.o
+OBJS-$(CONFIG_FLAC_DECODER)            += x86/flacdsp_init.o
+OBJS-$(CONFIG_FLAC_ENCODER)            += x86/flacencdsp_init.o
 OBJS-$(CONFIG_OPUS_DECODER)            += x86/opusdsp_init.o
 OBJS-$(CONFIG_OPUS_ENCODER)            += x86/celt_pvq_init.o
 OBJS-$(CONFIG_HEVC_DECODER)            += x86/hevcdsp_init.o
diff --git a/libavcodec/x86/cfhdencdsp_init.c b/libavcodec/x86/cfhdencdsp_init.c
index 1e3586e..5cea39a 100644
--- a/libavcodec/x86/cfhdencdsp_init.c
+++ b/libavcodec/x86/cfhdencdsp_init.c
@@ -27,11 +27,11 @@
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/cfhdencdsp.h"
 
-void ff_cfhdenc_horiz_filter_sse2(int16_t *input, int16_t *low, int16_t *high,
+void ff_cfhdenc_horiz_filter_sse2(const int16_t *input, int16_t *low, int16_t *high,
                                   ptrdiff_t in_stride, ptrdiff_t low_stride,
                                   ptrdiff_t high_stride,
                                   int width, int height);
-void ff_cfhdenc_vert_filter_sse2(int16_t *input, int16_t *low, int16_t *high,
+void ff_cfhdenc_vert_filter_sse2(const int16_t *input, int16_t *low, int16_t *high,
                                  ptrdiff_t in_stride, ptrdiff_t low_stride,
                                  ptrdiff_t high_stride,
                                  int width, int height);
diff --git a/libavcodec/x86/flacdsp_init.c b/libavcodec/x86/flacdsp_init.c
index ed2e5ed..2deaf31 100644
--- a/libavcodec/x86/flacdsp_init.c
+++ b/libavcodec/x86/flacdsp_init.c
@@ -22,15 +22,12 @@
 #include "libavcodec/flacdsp.h"
 #include "libavutil/x86/cpu.h"
 #include "config.h"
-#include "config_components.h"
 
 void ff_flac_lpc_32_sse4(int32_t *samples, const int coeffs[32], int order,
                          int qlevel, int len);
 void ff_flac_lpc_32_xop(int32_t *samples, const int coeffs[32], int order,
                         int qlevel, int len);
 
-void ff_flac_enc_lpc_16_sse4(int32_t *, const int32_t *, int, int, const int32_t *,int);
-
 #define DECORRELATE_FUNCS(fmt, opt)                                                      \
 void ff_flac_decorrelate_ls_##fmt##_##opt(uint8_t **out, int32_t **in, int channels,     \
                                           int len, int shift);                           \
@@ -52,13 +49,11 @@ DECORRELATE_FUNCS(16,  avx);
 DECORRELATE_FUNCS(32, sse2);
 DECORRELATE_FUNCS(32,  avx);
 
-av_cold void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels,
-                                 int bps)
+av_cold void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int channels)
 {
 #if HAVE_X86ASM
     int cpu_flags = av_get_cpu_flags();
 
-#if CONFIG_FLAC_DECODER
     if (EXTERNAL_SSE2(cpu_flags)) {
         if (fmt == AV_SAMPLE_FMT_S16) {
             if (channels == 2)
@@ -105,13 +100,5 @@ av_cold void ff_flacdsp_init_x86(FLACDSPContext *c, enum AVSampleFormat fmt, int
     if (EXTERNAL_XOP(cpu_flags)) {
         c->lpc32 = ff_flac_lpc_32_xop;
     }
-#endif
-
-#if CONFIG_FLAC_ENCODER
-    if (EXTERNAL_SSE4(cpu_flags)) {
-        if (CONFIG_GPL)
-            c->lpc16_encode = ff_flac_enc_lpc_16_sse4;
-    }
-#endif
 #endif /* HAVE_X86ASM */
 }
diff --git a/libavcodec/x86/flacencdsp_init.c b/libavcodec/x86/flacencdsp_init.c
new file mode 100644
index 0000000..5ab37e0
--- /dev/null
+++ b/libavcodec/x86/flacencdsp_init.c
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2014 James Almer
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+#include "libavutil/attributes.h"
+#include "libavutil/x86/cpu.h"
+#include "libavcodec/flacencdsp.h"
+
+void ff_flac_enc_lpc_16_sse4(int32_t *, const int32_t *, int, int, const int32_t *,int);
+
+av_cold void ff_flacencdsp_init_x86(FLACEncDSPContext *c)
+{
+#if HAVE_X86ASM && CONFIG_GPL
+    int cpu_flags = av_get_cpu_flags();
+
+    if (EXTERNAL_SSE4(cpu_flags)) {
+        if (CONFIG_GPL)
+            c->lpc16_encode = ff_flac_enc_lpc_16_sse4;
+    }
+#endif /* HAVE_X86ASM */
+}
diff --git a/libavcodec/x86/h264_chromamc.asm b/libavcodec/x86/h264_chromamc.asm
index e562efd..a5c5303 100644
--- a/libavcodec/x86/h264_chromamc.asm
+++ b/libavcodec/x86/h264_chromamc.asm
@@ -104,7 +104,7 @@ SECTION .text
 %define extra_regs 0
 %endif ; rv40
 ; void ff_put/avg_h264_chroma_mc8_*(uint8_t *dst /* align 8 */,
-;                                   uint8_t *src /* align 1 */,
+;                                   const uint8_t *src /* align 1 */,
 ;                                   ptrdiff_t stride, int h, int mx, int my)
 cglobal %1_%2_chroma_mc8%3, 6, 7 + extra_regs, 0
     mov          r6d, r5d
diff --git a/libavcodec/x86/h264_chromamc_10bit.asm b/libavcodec/x86/h264_chromamc_10bit.asm
index 34bc419..fdc4f40 100644
--- a/libavcodec/x86/h264_chromamc_10bit.asm
+++ b/libavcodec/x86/h264_chromamc_10bit.asm
@@ -57,7 +57,7 @@ SECTION .text
 %endmacro
 
 ;-----------------------------------------------------------------------------
-; void ff_put/avg_h264_chroma_mc8(pixel *dst, pixel *src, ptrdiff_t stride,
+; void ff_put/avg_h264_chroma_mc8(pixel *dst, const pixel *src, ptrdiff_t stride,
 ;                                 int h, int mx, int my)
 ;-----------------------------------------------------------------------------
 %macro CHROMA_MC8 1
@@ -198,7 +198,7 @@ cglobal %1_h264_chroma_mc4_10, 6,6,7
 %endmacro
 
 ;-----------------------------------------------------------------------------
-; void ff_put/avg_h264_chroma_mc2(pixel *dst, pixel *src, ptrdiff_t stride,
+; void ff_put/avg_h264_chroma_mc2(pixel *dst, const pixel *src, ptrdiff_t stride,
 ;                                 int h, int mx, int my)
 ;-----------------------------------------------------------------------------
 %macro CHROMA_MC2 1
diff --git a/libavcodec/x86/h264chroma_init.c b/libavcodec/x86/h264chroma_init.c
index 7c0f492..34934b6 100644
--- a/libavcodec/x86/h264chroma_init.c
+++ b/libavcodec/x86/h264chroma_init.c
@@ -24,35 +24,35 @@
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/h264chroma.h"
 
-void ff_put_h264_chroma_mc8_rnd_mmx  (uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc8_rnd_mmx  (uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
-void ff_avg_h264_chroma_mc8_rnd_mmxext(uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc8_rnd_mmxext(uint8_t *dst, const uint8_t *src,
                                        ptrdiff_t stride, int h, int x, int y);
 
-void ff_put_h264_chroma_mc4_mmx      (uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc4_mmx      (uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
-void ff_avg_h264_chroma_mc4_mmxext   (uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc4_mmxext   (uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
 
-void ff_put_h264_chroma_mc2_mmxext   (uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc2_mmxext   (uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
-void ff_avg_h264_chroma_mc2_mmxext   (uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc2_mmxext   (uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
 
-void ff_put_h264_chroma_mc8_rnd_ssse3(uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc8_rnd_ssse3(uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
-void ff_put_h264_chroma_mc4_ssse3    (uint8_t *dst, uint8_t *src,
+void ff_put_h264_chroma_mc4_ssse3    (uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
 
-void ff_avg_h264_chroma_mc8_rnd_ssse3(uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc8_rnd_ssse3(uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
-void ff_avg_h264_chroma_mc4_ssse3    (uint8_t *dst, uint8_t *src,
+void ff_avg_h264_chroma_mc4_ssse3    (uint8_t *dst, const uint8_t *src,
                                       ptrdiff_t stride, int h, int x, int y);
 
 #define CHROMA_MC(OP, NUM, DEPTH, OPT)                                  \
 void ff_ ## OP ## _h264_chroma_mc ## NUM ## _ ## DEPTH ## _ ## OPT      \
-                                      (uint8_t *dst, uint8_t *src,      \
-                                       ptrdiff_t stride, int h, int x, int y);
+                                     (uint8_t *dst, const uint8_t *src, \
+                                      ptrdiff_t stride, int h, int x, int y);
 
 CHROMA_MC(put, 2, 10, mmxext)
 CHROMA_MC(avg, 2, 10, mmxext)
diff --git a/libavcodec/x86/hevc_add_res.asm b/libavcodec/x86/hevc_add_res.asm
index c6c4007..3ecbd42 100644
--- a/libavcodec/x86/hevc_add_res.asm
+++ b/libavcodec/x86/hevc_add_res.asm
@@ -47,7 +47,7 @@ cextern pw_1023
 
 
 INIT_MMX mmxext
-; void ff_hevc_add_residual_4_8_mmxext(uint8_t *dst, int16_t *res, ptrdiff_t stride)
+; void ff_hevc_add_residual_4_8_mmxext(uint8_t *dst, const int16_t *res, ptrdiff_t stride)
 cglobal hevc_add_residual_4_8, 3, 3, 6
     pxor              m4, m4
     ADD_RES_MMX_4_8
@@ -118,7 +118,7 @@ cglobal hevc_add_residual_4_8, 3, 3, 6
 
 
 %macro TRANSFORM_ADD_8 0
-; void ff_hevc_add_residual_8_8_<opt>(uint8_t *dst, int16_t *res, ptrdiff_t stride)
+; void ff_hevc_add_residual_8_8_<opt>(uint8_t *dst, const int16_t *res, ptrdiff_t stride)
 cglobal hevc_add_residual_8_8, 3, 4, 8
     pxor              m4, m4
     lea               r3, [r2*3]
@@ -128,7 +128,7 @@ cglobal hevc_add_residual_8_8, 3, 4, 8
     ADD_RES_SSE_8_8
     RET
 
-; void ff_hevc_add_residual_16_8_<opt>(uint8_t *dst, int16_t *res, ptrdiff_t stride)
+; void ff_hevc_add_residual_16_8_<opt>(uint8_t *dst, const int16_t *res, ptrdiff_t stride)
 cglobal hevc_add_residual_16_8, 3, 5, 7
     pxor                m0, m0
     lea                 r3, [r2*3]
@@ -142,7 +142,7 @@ cglobal hevc_add_residual_16_8, 3, 5, 7
     jg .loop
     RET
 
-; void ff_hevc_add_residual_32_8_<opt>(uint8_t *dst, int16_t *res, ptrdiff_t stride)
+; void ff_hevc_add_residual_32_8_<opt>(uint8_t *dst, const int16_t *res, ptrdiff_t stride)
 cglobal hevc_add_residual_32_8, 3, 5, 7
     pxor                m0, m0
     mov                r4d, 16
@@ -163,7 +163,7 @@ TRANSFORM_ADD_8
 
 %if HAVE_AVX2_EXTERNAL
 INIT_YMM avx2
-; void ff_hevc_add_residual_32_8_avx2(uint8_t *dst, int16_t *res, ptrdiff_t stride)
+; void ff_hevc_add_residual_32_8_avx2(uint8_t *dst, const int16_t *res, ptrdiff_t stride)
 cglobal hevc_add_residual_32_8, 3, 5, 7
     pxor                 m0, m0
     lea                  r3, [r2*3]
@@ -289,7 +289,7 @@ cglobal hevc_add_residual_32_8, 3, 5, 7
     mova      [%1+%2+32], m3
 %endmacro
 
-; void ff_hevc_add_residual_<4|8|16|32>_10(pixel *dst, int16_t *block, ptrdiff_t stride)
+; void ff_hevc_add_residual_<4|8|16|32>_10(pixel *dst, const int16_t *block, ptrdiff_t stride)
 INIT_MMX mmxext
 cglobal hevc_add_residual_4_10, 3, 3, 6
     pxor              m2, m2
diff --git a/libavcodec/x86/hevc_mc.asm b/libavcodec/x86/hevc_mc.asm
index e159adc..eb26745 100644
--- a/libavcodec/x86/hevc_mc.asm
+++ b/libavcodec/x86/hevc_mc.asm
@@ -711,7 +711,7 @@ SECTION .text
 
 ; ******************************
 ; void put_hevc_mc_pixels(int16_t *dst, ptrdiff_t dststride,
-;                         uint8_t *_src, ptrdiff_t _srcstride,
+;                         const uint8_t *_src, ptrdiff_t _srcstride,
 ;                         int height, int mx, int my)
 ; ******************************
 
@@ -765,7 +765,7 @@ cglobal hevc_put_hevc_bi_pel_pixels%1_%2, 6, 6, 6, dst, dststride, src, srcstrid
 
 ; ******************************
 ; void put_hevc_epel_hX(int16_t *dst, ptrdiff_t dststride,
-;                       uint8_t *_src, ptrdiff_t _srcstride,
+;                       const uint8_t *_src, ptrdiff_t _srcstride,
 ;                       int height, int mx, int my, int width);
 ; ******************************
 
@@ -820,7 +820,7 @@ cglobal hevc_put_hevc_bi_epel_h%1_%2, 7, 8, XMM_REGS, dst, dststride, src, srcst
 
 ; ******************************
 ; void put_hevc_epel_v(int16_t *dst, ptrdiff_t dststride,
-;                      uint8_t *_src, ptrdiff_t _srcstride,
+;                      const uint8_t *_src, ptrdiff_t _srcstride,
 ;                      int height, int mx, int my, int width)
 ; ******************************
 
@@ -877,7 +877,7 @@ cglobal hevc_put_hevc_bi_epel_v%1_%2, 6, 8, XMM_REGS, dst, dststride, src, srcst
 
 ; ******************************
 ; void put_hevc_epel_hv(int16_t *dst, ptrdiff_t dststride,
-;                       uint8_t *_src, ptrdiff_t _srcstride,
+;                       const uint8_t *_src, ptrdiff_t _srcstride,
 ;                       int height, int mx, int my, int width)
 ; ******************************
 
@@ -1088,7 +1088,7 @@ cglobal hevc_put_hevc_bi_epel_hv%1_%2, 8, 9, 16, dst, dststride, src, srcstride,
 
 ; ******************************
 ; void put_hevc_qpel_hX_X_X(int16_t *dst, ptrdiff_t dststride,
-;                       uint8_t *_src, ptrdiff_t _srcstride,
+;                           const uint8_t *_src, ptrdiff_t _srcstride,
 ;                       int height, int mx, int my, int width)
 ; ******************************
 
@@ -1144,7 +1144,7 @@ cglobal hevc_put_hevc_bi_qpel_h%1_%2, 7, 8, 16 , dst, dststride, src, srcstride,
 
 ; ******************************
 ; void put_hevc_qpel_vX_X_X(int16_t *dst, ptrdiff_t dststride,
-;                       uint8_t *_src, ptrdiff_t _srcstride,
+;                           const uint8_t *_src, ptrdiff_t _srcstride,
 ;                       int height, int mx, int my, int width)
 ; ******************************
 
@@ -1206,7 +1206,7 @@ cglobal hevc_put_hevc_bi_qpel_v%1_%2, 6, 10, 16, dst, dststride, src, srcstride,
 
 ; ******************************
 ; void put_hevc_qpel_hvX_X(int16_t *dst, ptrdiff_t dststride,
-;                       uint8_t *_src, ptrdiff_t _srcstride,
+;                          const uint8_t *_src, ptrdiff_t _srcstride,
 ;                       int height, int mx, int my)
 ; ******************************
 %macro HEVC_PUT_HEVC_QPEL_HV 2
diff --git a/libavcodec/x86/hevc_sao.asm b/libavcodec/x86/hevc_sao.asm
index 756adfe..2eb8924 100644
--- a/libavcodec/x86/hevc_sao.asm
+++ b/libavcodec/x86/hevc_sao.asm
@@ -119,7 +119,7 @@ DEFINE_ARGS dst, src, dststride, srcstride, offset, height
 %endif ; ARCH
 %endmacro
 
-;void ff_hevc_sao_band_filter_<width>_8_<opt>(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
+;void ff_hevc_sao_band_filter_<width>_8_<opt>(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
 ;                                             int16_t *sao_offset_val, int sao_left_class, int width, int height);
 %macro HEVC_SAO_BAND_FILTER 2
 cglobal hevc_sao_band_filter_%1_8, 6, 6, 15, 7*mmsize*ARCH_X86_32, dst, src, dststride, srcstride, offset, left
diff --git a/libavcodec/x86/hevc_sao_10bit.asm b/libavcodec/x86/hevc_sao_10bit.asm
index b30583d..3800574 100644
--- a/libavcodec/x86/hevc_sao_10bit.asm
+++ b/libavcodec/x86/hevc_sao_10bit.asm
@@ -92,7 +92,7 @@ DEFINE_ARGS dst, src, dststride, srcstride, offset, height
     mov          heightd, r7m
 %endmacro
 
-;void ff_hevc_sao_band_filter_<width>_<depth>_<opt>(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
+;void ff_hevc_sao_band_filter_<width>_<depth>_<opt>(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,
 ;                                                   int16_t *sao_offset_val, int sao_left_class, int width, int height);
 %macro HEVC_SAO_BAND_FILTER 3
 cglobal hevc_sao_band_filter_%2_%1, 6, 6, 15, 7*mmsize*ARCH_X86_32, dst, src, dststride, srcstride, offset, left
diff --git a/libavcodec/x86/hevcdsp.h b/libavcodec/x86/hevcdsp.h
index 24e35bc..037519f 100644
--- a/libavcodec/x86/hevcdsp.h
+++ b/libavcodec/x86/hevcdsp.h
@@ -38,11 +38,11 @@ dst ## _bi_w[idx1][idx2][idx3] = ff_hevc_put_hevc_bi_w_ ## name ## _ ## D ## _##
 
 
 #define PEL_PROTOTYPE(name, D, opt) \
-void ff_hevc_put_hevc_ ## name ## _ ## D ## _##opt(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width); \
-void ff_hevc_put_hevc_bi_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width); \
-void ff_hevc_put_hevc_uni_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width); \
-void ff_hevc_put_hevc_uni_w_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width); \
-void ff_hevc_put_hevc_bi_w_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, int denom, int wx0, int wx1, int ox0, int ox1, intptr_t mx, intptr_t my, int width)
+void ff_hevc_put_hevc_ ## name ## _ ## D ## _##opt(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width); \
+void ff_hevc_put_hevc_bi_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width); \
+void ff_hevc_put_hevc_uni_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width); \
+void ff_hevc_put_hevc_uni_w_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, int height, int denom, int wx, int ox, intptr_t mx, intptr_t my, int width); \
+void ff_hevc_put_hevc_bi_w_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, int denom, int wx0, int wx1, int ox0, int ox1, intptr_t mx, intptr_t my, int width)
 
 
 ///////////////////////////////////////////////////////////////////////////////
@@ -71,8 +71,8 @@ void ff_hevc_put_hevc_bi_w_ ## name ## _ ## D ## _##opt(uint8_t *_dst, ptrdiff_t
         PEL_PROTOTYPE(fname##64, bitd, opt)
 
 #define WEIGHTING_PROTOTYPE(width, bitd, opt) \
-void ff_hevc_put_hevc_uni_w##width##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dststride, int16_t *_src, int height, int denom,  int _wx, int _ox); \
-void ff_hevc_put_hevc_bi_w##width##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dststride, int16_t *_src, int16_t *_src2, int height, int denom,  int _wx0,  int _wx1, int _ox0, int _ox1)
+void ff_hevc_put_hevc_uni_w##width##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dststride, const int16_t *_src, int height, int denom,  int _wx, int _ox); \
+void ff_hevc_put_hevc_bi_w##width##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dststride, const int16_t *_src, const int16_t *_src2, int height, int denom,  int _wx0,  int _wx1, int _ox0, int _ox1)
 
 #define WEIGHTING_PROTOTYPES(bitd, opt) \
         WEIGHTING_PROTOTYPE(2, bitd, opt); \
@@ -94,38 +94,38 @@ EPEL_PROTOTYPES(pel_pixels ,  8, sse4);
 EPEL_PROTOTYPES(pel_pixels , 10, sse4);
 EPEL_PROTOTYPES(pel_pixels , 12, sse4);
 
-void ff_hevc_put_hevc_pel_pixels16_8_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels24_8_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels32_8_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels48_8_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels64_8_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels16_8_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels24_8_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels32_8_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels48_8_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels64_8_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
 
-void ff_hevc_put_hevc_pel_pixels16_10_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels24_10_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels32_10_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels48_10_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_pel_pixels64_10_avx2(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels16_10_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels24_10_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels32_10_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels48_10_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_pel_pixels64_10_avx2(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
 
 
 
-void ff_hevc_put_hevc_uni_pel_pixels32_8_avx2(uint8_t *dst, ptrdiff_t dststride,uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_uni_pel_pixels48_8_avx2(uint8_t *dst, ptrdiff_t dststride,uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_uni_pel_pixels64_8_avx2(uint8_t *dst, ptrdiff_t dststride,uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
-void ff_hevc_put_hevc_uni_pel_pixels96_8_avx2(uint8_t *dst, ptrdiff_t dststride,uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width); //used for 10bit
-void ff_hevc_put_hevc_uni_pel_pixels128_8_avx2(uint8_t *dst, ptrdiff_t dststride,uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);//used for 10bit
+void ff_hevc_put_hevc_uni_pel_pixels32_8_avx2(uint8_t *dst, ptrdiff_t dststride,const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_uni_pel_pixels48_8_avx2(uint8_t *dst, ptrdiff_t dststride,const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_uni_pel_pixels64_8_avx2(uint8_t *dst, ptrdiff_t dststride,const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);
+void ff_hevc_put_hevc_uni_pel_pixels96_8_avx2(uint8_t *dst, ptrdiff_t dststride,const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width); //used for 10bit
+void ff_hevc_put_hevc_uni_pel_pixels128_8_avx2(uint8_t *dst, ptrdiff_t dststride,const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my,int width);//used for 10bit
 
 
-void ff_hevc_put_hevc_bi_pel_pixels16_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels24_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels32_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels48_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels64_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels16_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels24_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels32_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels48_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels64_8_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
 
-void ff_hevc_put_hevc_bi_pel_pixels16_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels24_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels32_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels48_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_bi_pel_pixels64_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride, int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels16_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels24_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels32_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels48_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_bi_pel_pixels64_10_avx2(uint8_t *_dst, ptrdiff_t _dststride, const uint8_t *_src, ptrdiff_t _srcstride, const int16_t *src2, int height, intptr_t mx, intptr_t my, int width);
 
 ///////////////////////////////////////////////////////////////////////////////
 // EPEL
@@ -233,34 +233,34 @@ WEIGHTING_PROTOTYPES(8, sse4);
 WEIGHTING_PROTOTYPES(10, sse4);
 WEIGHTING_PROTOTYPES(12, sse4);
 
-void ff_hevc_put_hevc_qpel_h4_8_avx512icl(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_qpel_h8_8_avx512icl(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_qpel_h16_8_avx512icl(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_qpel_h32_8_avx512icl(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_qpel_h64_8_avx512icl(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
-void ff_hevc_put_hevc_qpel_hv8_8_avx512icl(int16_t *dst, uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h4_8_avx512icl(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h8_8_avx512icl(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h16_8_avx512icl(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h32_8_avx512icl(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_h64_8_avx512icl(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
+void ff_hevc_put_hevc_qpel_hv8_8_avx512icl(int16_t *dst, const uint8_t *_src, ptrdiff_t _srcstride, int height, intptr_t mx, intptr_t my, int width);
 
 ///////////////////////////////////////////////////////////////////////////////
 // TRANSFORM_ADD
 ///////////////////////////////////////////////////////////////////////////////
 
-void ff_hevc_add_residual_4_8_mmxext(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_8_8_sse2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_16_8_sse2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_32_8_sse2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_4_8_mmxext(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_8_8_sse2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_16_8_sse2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_32_8_sse2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
 
-void ff_hevc_add_residual_8_8_avx(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_16_8_avx(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_32_8_avx(uint8_t *dst, int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_8_8_avx(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_16_8_avx(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_32_8_avx(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
 
-void ff_hevc_add_residual_32_8_avx2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_32_8_avx2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
 
-void ff_hevc_add_residual_4_10_mmxext(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_8_10_sse2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_16_10_sse2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_32_10_sse2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_4_10_mmxext(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_8_10_sse2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_16_10_sse2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_32_10_sse2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
 
-void ff_hevc_add_residual_16_10_avx2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
-void ff_hevc_add_residual_32_10_avx2(uint8_t *dst, int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_16_10_avx2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
+void ff_hevc_add_residual_32_10_avx2(uint8_t *dst, const int16_t *res, ptrdiff_t stride);
 
 #endif // AVCODEC_X86_HEVCDSP_H
diff --git a/libavcodec/x86/hevcdsp_init.c b/libavcodec/x86/hevcdsp_init.c
index f7a5b28..6f45e5e 100644
--- a/libavcodec/x86/hevcdsp_init.c
+++ b/libavcodec/x86/hevcdsp_init.c
@@ -29,10 +29,10 @@
 #include "libavcodec/x86/hevcdsp.h"
 
 #define LFC_FUNC(DIR, DEPTH, OPT) \
-void ff_hevc_ ## DIR ## _loop_filter_chroma_ ## DEPTH ## _ ## OPT(uint8_t *pix, ptrdiff_t stride, int *tc, uint8_t *no_p, uint8_t *no_q);
+void ff_hevc_ ## DIR ## _loop_filter_chroma_ ## DEPTH ## _ ## OPT(uint8_t *pix, ptrdiff_t stride, const int *tc, const uint8_t *no_p, const uint8_t *no_q);
 
 #define LFL_FUNC(DIR, DEPTH, OPT) \
-void ff_hevc_ ## DIR ## _loop_filter_luma_ ## DEPTH ## _ ## OPT(uint8_t *pix, ptrdiff_t stride, int beta, int *tc, uint8_t *no_p, uint8_t *no_q);
+void ff_hevc_ ## DIR ## _loop_filter_luma_ ## DEPTH ## _ ## OPT(uint8_t *pix, ptrdiff_t stride, int beta, const int *tc, const uint8_t *no_p, const uint8_t *no_q);
 
 #define LFC_FUNCS(type, depth, opt) \
     LFC_FUNC(h, depth, opt)  \
@@ -85,46 +85,42 @@ IDCT_FUNCS(avx)
 
 #define mc_rep_func(name, bitd, step, W, opt) \
 void ff_hevc_put_hevc_##name##W##_##bitd##_##opt(int16_t *_dst,                                                 \
-                                                uint8_t *_src, ptrdiff_t _srcstride, int height,                \
+                                                 const uint8_t *_src, ptrdiff_t _srcstride, int height,         \
                                                 intptr_t mx, intptr_t my, int width)                            \
 {                                                                                                               \
     int i;                                                                                                      \
-    uint8_t *src;                                                                                               \
     int16_t *dst;                                                                                               \
     for (i = 0; i < W; i += step) {                                                                             \
-        src  = _src + (i * ((bitd + 7) / 8));                                                                   \
+        const uint8_t *src  = _src + (i * ((bitd + 7) / 8));                                                    \
         dst = _dst + i;                                                                                         \
         ff_hevc_put_hevc_##name##step##_##bitd##_##opt(dst, src, _srcstride, height, mx, my, width);            \
     }                                                                                                           \
 }
 #define mc_rep_uni_func(name, bitd, step, W, opt) \
 void ff_hevc_put_hevc_uni_##name##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dststride,                        \
-                                                    uint8_t *_src, ptrdiff_t _srcstride, int height,            \
+                                                     const uint8_t *_src, ptrdiff_t _srcstride, int height,     \
                                                     intptr_t mx, intptr_t my, int width)                        \
 {                                                                                                               \
     int i;                                                                                                      \
-    uint8_t *src;                                                                                               \
     uint8_t *dst;                                                                                               \
     for (i = 0; i < W; i += step) {                                                                             \
-        src = _src + (i * ((bitd + 7) / 8));                                                                    \
+        const uint8_t *src = _src + (i * ((bitd + 7) / 8));                                                     \
         dst = _dst + (i * ((bitd + 7) / 8));                                                                    \
         ff_hevc_put_hevc_uni_##name##step##_##bitd##_##opt(dst, dststride, src, _srcstride,                     \
                                                           height, mx, my, width);                               \
     }                                                                                                           \
 }
 #define mc_rep_bi_func(name, bitd, step, W, opt) \
-void ff_hevc_put_hevc_bi_##name##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dststride, uint8_t *_src,          \
-                                                   ptrdiff_t _srcstride, int16_t* _src2,                        \
+void ff_hevc_put_hevc_bi_##name##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dststride, const uint8_t *_src,    \
+                                                    ptrdiff_t _srcstride, const int16_t *_src2,                 \
                                                    int height, intptr_t mx, intptr_t my, int width)             \
 {                                                                                                               \
     int i;                                                                                                      \
-    uint8_t  *src;                                                                                              \
     uint8_t  *dst;                                                                                              \
-    int16_t  *src2;                                                                                             \
     for (i = 0; i < W ; i += step) {                                                                            \
-        src  = _src + (i * ((bitd + 7) / 8));                                                                   \
+        const uint8_t *src  = _src + (i * ((bitd + 7) / 8));                                                    \
+        const int16_t *src2 = _src2 + i;                                                                        \
         dst  = _dst + (i * ((bitd + 7) / 8));                                                                   \
-        src2 = _src2 + i;                                                                                       \
         ff_hevc_put_hevc_bi_##name##step##_##bitd##_##opt(dst, dststride, src, _srcstride, src2,                \
                                                           height, mx, my, width);                               \
     }                                                                                                           \
@@ -137,7 +133,7 @@ void ff_hevc_put_hevc_bi_##name##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dst
 
 #define mc_rep_func2(name, bitd, step1, step2, W, opt) \
 void ff_hevc_put_hevc_##name##W##_##bitd##_##opt(int16_t *dst,                                                  \
-                                                 uint8_t *src, ptrdiff_t _srcstride, int height,                \
+                                                 const uint8_t *src, ptrdiff_t _srcstride, int height,          \
                                                  intptr_t mx, intptr_t my, int width)                           \
 {                                                                                                               \
     ff_hevc_put_hevc_##name##step1##_##bitd##_##opt(dst, src, _srcstride, height, mx, my, width);               \
@@ -146,7 +142,7 @@ void ff_hevc_put_hevc_##name##W##_##bitd##_##opt(int16_t *dst,
 }
 #define mc_rep_uni_func2(name, bitd, step1, step2, W, opt) \
 void ff_hevc_put_hevc_uni_##name##W##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dststride,                         \
-                                                     uint8_t *src, ptrdiff_t _srcstride, int height,            \
+                                                     const uint8_t *src, ptrdiff_t _srcstride, int height,      \
                                                      intptr_t mx, intptr_t my, int width)                       \
 {                                                                                                               \
     ff_hevc_put_hevc_uni_##name##step1##_##bitd##_##opt(dst, dststride, src, _srcstride, height, mx, my, width);\
@@ -155,8 +151,8 @@ void ff_hevc_put_hevc_uni_##name##W##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dst
                                                         height, mx, my, width);                                 \
 }
 #define mc_rep_bi_func2(name, bitd, step1, step2, W, opt) \
-void ff_hevc_put_hevc_bi_##name##W##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dststride, uint8_t *src,            \
-                                                    ptrdiff_t _srcstride, int16_t* src2,                        \
+void ff_hevc_put_hevc_bi_##name##W##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dststride, const uint8_t *src,      \
+                                                    ptrdiff_t _srcstride, const int16_t *src2,                  \
                                                     int height, intptr_t mx, intptr_t my, int width)            \
 {                                                                                                               \
     ff_hevc_put_hevc_bi_##name##step1##_##bitd##_##opt(dst, dststride, src, _srcstride, src2, height, mx, my, width);\
@@ -173,7 +169,7 @@ void ff_hevc_put_hevc_bi_##name##W##_##bitd##_##opt(uint8_t *dst, ptrdiff_t dsts
 #if ARCH_X86_64 && HAVE_SSE4_EXTERNAL
 
 #define mc_rep_mix_10(name, width1, width2, width3, opt1, opt2, width4)                                       \
-void ff_hevc_put_hevc_##name##width1##_10_##opt1(int16_t *dst, uint8_t *src, ptrdiff_t _srcstride,            \
+void ff_hevc_put_hevc_##name##width1##_10_##opt1(int16_t *dst, const uint8_t *src, ptrdiff_t _srcstride,      \
                                                  int height, intptr_t mx, intptr_t my, int width)             \
                                                                                                               \
 {                                                                                                             \
@@ -182,8 +178,8 @@ void ff_hevc_put_hevc_##name##width1##_10_##opt1(int16_t *dst, uint8_t *src, ptr
 }
 
 #define mc_bi_rep_mix_10(name, width1, width2, width3, opt1, opt2, width4)                                    \
-void ff_hevc_put_hevc_bi_##name##width1##_10_##opt1(uint8_t *dst, ptrdiff_t dststride, uint8_t *src,          \
-                                                    ptrdiff_t _srcstride, int16_t *src2,                      \
+void ff_hevc_put_hevc_bi_##name##width1##_10_##opt1(uint8_t *dst, ptrdiff_t dststride, const uint8_t *src,    \
+                                                    ptrdiff_t _srcstride, const int16_t *src2,                \
                                                     int height, intptr_t mx, intptr_t my, int width)          \
 {                                                                                                             \
     ff_hevc_put_hevc_bi_##name##width2##_10_##opt1(dst, dststride, src, _srcstride, src2,                     \
@@ -194,7 +190,7 @@ void ff_hevc_put_hevc_bi_##name##width1##_10_##opt1(uint8_t *dst, ptrdiff_t dsts
 
 #define mc_uni_rep_mix_10(name, width1, width2, width3, opt1, opt2, width4)                                   \
 void ff_hevc_put_hevc_uni_##name##width1##_10_##opt1(uint8_t *dst, ptrdiff_t dststride,                       \
-                                                     uint8_t *src, ptrdiff_t _srcstride, int height,          \
+                                                     const uint8_t *src, ptrdiff_t _srcstride, int height,    \
                                                      intptr_t mx, intptr_t my, int width)                     \
 {                                                                                                             \
     ff_hevc_put_hevc_uni_##name##width2##_10_##opt1(dst, dststride, src, _srcstride,                          \
@@ -209,7 +205,7 @@ mc_bi_rep_mix_10(name, width1, width2, width3, opt1, opt2, width4)         \
 mc_uni_rep_mix_10(name, width1, width2, width3, opt1, opt2, width4)
 
 #define mc_rep_mix_8(name, width1, width2, width3, opt1, opt2)                                                \
-void ff_hevc_put_hevc_##name##width1##_8_##opt1(int16_t *dst, uint8_t *src, ptrdiff_t _srcstride,             \
+void ff_hevc_put_hevc_##name##width1##_8_##opt1(int16_t *dst, const uint8_t *src, ptrdiff_t _srcstride,       \
                                                 int height, intptr_t mx, intptr_t my, int width)              \
                                                                                                               \
 {                                                                                                             \
@@ -218,8 +214,8 @@ void ff_hevc_put_hevc_##name##width1##_8_##opt1(int16_t *dst, uint8_t *src, ptrd
 }
 
 #define mc_bi_rep_mix_8(name, width1, width2, width3, opt1, opt2)                                             \
-void ff_hevc_put_hevc_bi_##name##width1##_8_##opt1(uint8_t *dst, ptrdiff_t dststride, uint8_t *src,           \
-                                                   ptrdiff_t _srcstride, int16_t* src2,                       \
+void ff_hevc_put_hevc_bi_##name##width1##_8_##opt1(uint8_t *dst, ptrdiff_t dststride, const uint8_t *src,     \
+                                                   ptrdiff_t _srcstride, const int16_t *src2,                 \
                                                    int height, intptr_t mx, intptr_t my, int width)           \
 {                                                                                                             \
     ff_hevc_put_hevc_bi_##name##width2##_8_##opt1(dst, dststride, src, _srcstride,                            \
@@ -230,7 +226,7 @@ void ff_hevc_put_hevc_bi_##name##width1##_8_##opt1(uint8_t *dst, ptrdiff_t dstst
 
 #define mc_uni_rep_mix_8(name, width1, width2, width3, opt1, opt2)                                            \
 void ff_hevc_put_hevc_uni_##name##width1##_8_##opt1(uint8_t *dst, ptrdiff_t dststride,                        \
-                                                    uint8_t *src, ptrdiff_t _srcstride, int height,           \
+                                                    const uint8_t *src, ptrdiff_t _srcstride, int height,     \
                                                     intptr_t mx, intptr_t my, int width)                      \
 {                                                                                                             \
     ff_hevc_put_hevc_uni_##name##width2##_8_##opt1(dst, dststride, src, _srcstride,                           \
@@ -434,14 +430,13 @@ mc_rep_funcs(qpel_hv,12,  8, 16, sse4)
 mc_rep_funcs(qpel_hv,12,  4, 12, sse4)
 
 #define mc_rep_uni_w(bitd, step, W, opt) \
-void ff_hevc_put_hevc_uni_w##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dststride, int16_t *_src, \
+void ff_hevc_put_hevc_uni_w##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dststride, const int16_t *_src, \
                                                int height, int denom,  int _wx, int _ox)                                \
 {                                                                                                                       \
     int i;                                                                                                              \
-    int16_t *src;                                                                                                       \
     uint8_t *dst;                                                                                                       \
     for (i = 0; i < W; i += step) {                                                                                     \
-        src= _src + i;                                                                                                  \
+        const int16_t *src = _src + i;                                                                                  \
         dst= _dst + (i * ((bitd + 7) / 8));                                                                             \
         ff_hevc_put_hevc_uni_w##step##_##bitd##_##opt(dst, dststride, src,                                   \
                                                      height, denom, _wx, _ox);                                          \
@@ -470,17 +465,15 @@ mc_rep_uni_w(12, 8, 48, sse4)
 mc_rep_uni_w(12, 8, 64, sse4)
 
 #define mc_rep_bi_w(bitd, step, W, opt) \
-void ff_hevc_put_hevc_bi_w##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dststride, int16_t *_src, \
-                                              int16_t *_src2, int height,                                               \
+void ff_hevc_put_hevc_bi_w##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t dststride, const int16_t *_src, \
+                                               const int16_t *_src2, int height,                                        \
                                               int denom,  int _wx0,  int _wx1, int _ox0, int _ox1)                      \
 {                                                                                                                       \
     int i;                                                                                                              \
-    int16_t *src;                                                                                                       \
-    int16_t *src2;                                                                                                      \
     uint8_t *dst;                                                                                                       \
     for (i = 0; i < W; i += step) {                                                                                     \
-        src  = _src  + i;                                                                                               \
-        src2 = _src2 + i;                                                                                               \
+        const int16_t *src  = _src  + i;                                                                                \
+        const int16_t *src2 = _src2 + i;                                                                                \
         dst  = _dst  + (i * ((bitd + 7) / 8));                                                                          \
         ff_hevc_put_hevc_bi_w##step##_##bitd##_##opt(dst, dststride, src, src2,                             \
                                                      height, denom, _wx0, _wx1, _ox0, _ox1);                             \
@@ -510,7 +503,7 @@ mc_rep_bi_w(12, 8, 64, sse4)
 
 #define mc_uni_w_func(name, bitd, W, opt) \
 void ff_hevc_put_hevc_uni_w_##name##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t _dststride,         \
-                                                      uint8_t *_src, ptrdiff_t _srcstride,          \
+                                                       const uint8_t *_src, ptrdiff_t _srcstride,   \
                                                       int height, int denom,                        \
                                                       int _wx, int _ox,                             \
                                                       intptr_t mx, intptr_t my, int width)          \
@@ -568,8 +561,8 @@ mc_uni_w_funcs(qpel_hv, 12, sse4)
 
 #define mc_bi_w_func(name, bitd, W, opt) \
 void ff_hevc_put_hevc_bi_w_##name##W##_##bitd##_##opt(uint8_t *_dst, ptrdiff_t _dststride,           \
-                                                     uint8_t *_src, ptrdiff_t _srcstride,            \
-                                                     int16_t *_src2,                                 \
+                                                      const uint8_t *_src, ptrdiff_t _srcstride,     \
+                                                      const int16_t *_src2,                          \
                                                      int height, int denom,                          \
                                                      int _wx0, int _wx1, int _ox0, int _ox1,         \
                                                      intptr_t mx, intptr_t my, int width)            \
@@ -628,16 +621,16 @@ mc_bi_w_funcs(qpel_hv, 12, sse4)
 #endif //ARCH_X86_64 && HAVE_SSE4_EXTERNAL
 
 #define SAO_BAND_FILTER_FUNCS(bitd, opt)                                                                                   \
-void ff_hevc_sao_band_filter_8_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,  \
-                                            int16_t *sao_offset_val, int sao_left_class, int width, int height);           \
-void ff_hevc_sao_band_filter_16_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
-                                            int16_t *sao_offset_val, int sao_left_class, int width, int height);           \
-void ff_hevc_sao_band_filter_32_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
-                                            int16_t *sao_offset_val, int sao_left_class, int width, int height);           \
-void ff_hevc_sao_band_filter_48_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
-                                            int16_t *sao_offset_val, int sao_left_class, int width, int height);           \
-void ff_hevc_sao_band_filter_64_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
-                                             int16_t *sao_offset_val, int sao_left_class, int width, int height);
+void ff_hevc_sao_band_filter_8_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src,  \
+                                              const int16_t *sao_offset_val, int sao_left_class, int width, int height);         \
+void ff_hevc_sao_band_filter_16_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
+                                               const int16_t *sao_offset_val, int sao_left_class, int width, int height);        \
+void ff_hevc_sao_band_filter_32_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
+                                               const int16_t *sao_offset_val, int sao_left_class, int width, int height);        \
+void ff_hevc_sao_band_filter_48_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
+                                               const int16_t *sao_offset_val, int sao_left_class, int width, int height);        \
+void ff_hevc_sao_band_filter_64_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t _stride_dst, ptrdiff_t _stride_src, \
+                                               const int16_t *sao_offset_val, int sao_left_class, int width, int height);
 
 SAO_BAND_FILTER_FUNCS(8,  sse2)
 SAO_BAND_FILTER_FUNCS(10, sse2)
@@ -657,17 +650,17 @@ SAO_BAND_FILTER_FUNCS(12, avx2)
     c->sao_band_filter[4]      = ff_hevc_sao_band_filter_64_##bitd##_##opt; \
 } while (0)
 
-#define SAO_EDGE_FILTER_FUNCS(bitd, opt)                                                                                    \
-void ff_hevc_sao_edge_filter_8_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val,  \
-                                              int eo, int width, int height);                                               \
-void ff_hevc_sao_edge_filter_16_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val, \
-                                               int eo, int width, int height);                                              \
-void ff_hevc_sao_edge_filter_32_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val, \
-                                               int eo, int width, int height);                                              \
-void ff_hevc_sao_edge_filter_48_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val, \
-                                               int eo, int width, int height);                                              \
-void ff_hevc_sao_edge_filter_64_##bitd##_##opt(uint8_t *_dst, uint8_t *_src, ptrdiff_t stride_dst, int16_t *sao_offset_val, \
-                                               int eo, int width, int height);                                              \
+#define SAO_EDGE_FILTER_FUNCS(bitd, opt)                                                                      \
+void ff_hevc_sao_edge_filter_8_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst,       \
+                                              const int16_t *sao_offset_val, int eo, int width, int height);  \
+void ff_hevc_sao_edge_filter_16_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst,      \
+                                               const int16_t *sao_offset_val, int eo, int width, int height); \
+void ff_hevc_sao_edge_filter_32_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst,      \
+                                               const int16_t *sao_offset_val, int eo, int width, int height); \
+void ff_hevc_sao_edge_filter_48_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst,      \
+                                               const int16_t *sao_offset_val, int eo, int width, int height); \
+void ff_hevc_sao_edge_filter_64_##bitd##_##opt(uint8_t *_dst, const uint8_t *_src, ptrdiff_t stride_dst,      \
+                                               const int16_t *sao_offset_val, int eo, int width, int height); \
 
 SAO_EDGE_FILTER_FUNCS(8, ssse3)
 SAO_EDGE_FILTER_FUNCS(8, avx2)
diff --git a/libavcodec/x86/lossless_videoencdsp.asm b/libavcodec/x86/lossless_videoencdsp.asm
index 2e1d01b..c579891 100644
--- a/libavcodec/x86/lossless_videoencdsp.asm
+++ b/libavcodec/x86/lossless_videoencdsp.asm
@@ -145,7 +145,7 @@ DIFF_BYTES_PROLOGUE
 
 
 ;--------------------------------------------------------------------------------------------------
-;void sub_left_predict(uint8_t *dst, uint8_t *src, ptrdiff_t stride, ptrdiff_t width, int height)
+;void sub_left_predict(uint8_t *dst, const uint8_t *src, ptrdiff_t stride, ptrdiff_t width, int height)
 ;--------------------------------------------------------------------------------------------------
 
 INIT_XMM avx
diff --git a/libavcodec/x86/lossless_videoencdsp_init.c b/libavcodec/x86/lossless_videoencdsp_init.c
index b3efcfd..22a4014 100644
--- a/libavcodec/x86/lossless_videoencdsp_init.c
+++ b/libavcodec/x86/lossless_videoencdsp_init.c
@@ -34,7 +34,7 @@ void ff_diff_bytes_sse2(uint8_t *dst, const uint8_t *src1, const uint8_t *src2,
 void ff_diff_bytes_avx2(uint8_t *dst, const uint8_t *src1, const uint8_t *src2,
                         intptr_t w);
 
-void ff_sub_left_predict_avx(uint8_t *dst, uint8_t *src,
+void ff_sub_left_predict_avx(uint8_t *dst, const uint8_t *src,
                             ptrdiff_t stride, ptrdiff_t width, int height);
 
 #if HAVE_INLINE_ASM
diff --git a/libavcodec/x86/me_cmp.asm b/libavcodec/x86/me_cmp.asm
index 10809bb..eb036ee 100644
--- a/libavcodec/x86/me_cmp.asm
+++ b/libavcodec/x86/me_cmp.asm
@@ -38,7 +38,7 @@ SECTION .text
     psubw           %1, %2
 %endmacro
 
-; %1=uint8_t *pix1, %2=uint8_t *pix2, %3=static offset, %4=stride, %5=stride*3
+; %1=const uint8_t *pix1, %2=const uint8_t *pix2, %3=static offset, %4=stride, %5=stride*3
 ; %6=temporary storage location
 ; this macro requires $mmsize stack space (aligned) on %6 (except on SSE+x86-64)
 %macro DIFF_PIXELS_8 6
@@ -214,8 +214,8 @@ hadamard8x8_diff %+ SUFFIX:
 hadamard8_16_wrapper %1, 3
 %elif cpuflag(mmx)
 ALIGN 16
-; int ff_hadamard8_diff_ ## cpu(MpegEncContext *s, uint8_t *src1,
-;                               uint8_t *src2, ptrdiff_t stride, int h)
+; int ff_hadamard8_diff_ ## cpu(MpegEncContext *s, const uint8_t *src1,
+;                               const uint8_t *src2, ptrdiff_t stride, int h)
 ; r0 = void *s = unused, int h = unused (always 8)
 ; note how r1, r2 and r3 are not clobbered in this function, so 16x16
 ; can simply call this 2x2x (and that's why we access rsp+gprsize
@@ -278,7 +278,7 @@ INIT_XMM ssse3
 %define ABS_SUM_8x8 ABS_SUM_8x8_64
 HADAMARD8_DIFF 9
 
-; int ff_sse*_*(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+; int ff_sse*_*(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
 ;               ptrdiff_t line_size, int h)
 
 %macro SUM_SQUARED_ERRORS 1
@@ -357,7 +357,7 @@ INIT_XMM sse2
 SUM_SQUARED_ERRORS 16
 
 ;-----------------------------------------------
-;int ff_sum_abs_dctelem(int16_t *block)
+;int ff_sum_abs_dctelem(const int16_t *block)
 ;-----------------------------------------------
 ; %1 = number of xmm registers used
 ; %2 = number of inline loops
@@ -390,7 +390,7 @@ INIT_XMM ssse3
 SUM_ABS_DCTELEM 6, 2
 
 ;------------------------------------------------------------------------------
-; int ff_hf_noise*_mmx(uint8_t *pix1, ptrdiff_t lsize, int h)
+; int ff_hf_noise*_mmx(const uint8_t *pix1, ptrdiff_t lsize, int h)
 ;------------------------------------------------------------------------------
 ; %1 = 8/16. %2-5=m#
 %macro HF_NOISE_PART1 5
@@ -466,7 +466,7 @@ HF_NOISE 8
 HF_NOISE 16
 
 ;---------------------------------------------------------------------------------------
-;int ff_sad_<opt>(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t stride, int h);
+;int ff_sad_<opt>(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t stride, int h);
 ;---------------------------------------------------------------------------------------
 ;%1 = 8/16
 %macro SAD 1
@@ -521,7 +521,7 @@ INIT_XMM sse2
 SAD 16
 
 ;------------------------------------------------------------------------------------------
-;int ff_sad_x2_<opt>(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t stride, int h);
+;int ff_sad_x2_<opt>(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t stride, int h);
 ;------------------------------------------------------------------------------------------
 ;%1 = 8/16
 %macro SAD_X2 1
@@ -598,7 +598,7 @@ INIT_XMM sse2
 SAD_X2 16
 
 ;------------------------------------------------------------------------------------------
-;int ff_sad_y2_<opt>(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t stride, int h);
+;int ff_sad_y2_<opt>(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t stride, int h);
 ;------------------------------------------------------------------------------------------
 ;%1 = 8/16
 %macro SAD_Y2 1
@@ -668,7 +668,7 @@ INIT_XMM sse2
 SAD_Y2 16
 
 ;-------------------------------------------------------------------------------------------
-;int ff_sad_approx_xy2_<opt>(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2, ptrdiff_t stride, int h);
+;int ff_sad_approx_xy2_<opt>(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2, ptrdiff_t stride, int h);
 ;-------------------------------------------------------------------------------------------
 ;%1 = 8/16
 %macro SAD_APPROX_XY2 1
@@ -769,7 +769,7 @@ INIT_XMM sse2
 SAD_APPROX_XY2 16
 
 ;--------------------------------------------------------------------
-;int ff_vsad_intra(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+;int ff_vsad_intra(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
 ;                  ptrdiff_t line_size, int h);
 ;--------------------------------------------------------------------
 ; %1 = 8/16
@@ -830,7 +830,7 @@ INIT_XMM sse2
 VSAD_INTRA 16
 
 ;---------------------------------------------------------------------
-;int ff_vsad_approx(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+;int ff_vsad_approx(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
 ;                   ptrdiff_t line_size, int h);
 ;---------------------------------------------------------------------
 ; %1 = 8/16
diff --git a/libavcodec/x86/me_cmp_init.c b/libavcodec/x86/me_cmp_init.c
index 61e9396..bc1051c 100644
--- a/libavcodec/x86/me_cmp_init.c
+++ b/libavcodec/x86/me_cmp_init.c
@@ -30,65 +30,65 @@
 #include "libavcodec/me_cmp.h"
 #include "libavcodec/mpegvideo.h"
 
-int ff_sum_abs_dctelem_sse2(int16_t *block);
-int ff_sum_abs_dctelem_ssse3(int16_t *block);
-int ff_sse8_mmx(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sum_abs_dctelem_sse2(const int16_t *block);
+int ff_sum_abs_dctelem_ssse3(const int16_t *block);
+int ff_sse8_mmx(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                 ptrdiff_t stride, int h);
-int ff_sse16_mmx(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sse16_mmx(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                  ptrdiff_t stride, int h);
-int ff_sse16_sse2(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sse16_sse2(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                   ptrdiff_t stride, int h);
-int ff_hf_noise8_mmx(uint8_t *pix1, ptrdiff_t stride, int h);
-int ff_hf_noise16_mmx(uint8_t *pix1, ptrdiff_t stride, int h);
-int ff_sad8_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_hf_noise8_mmx(const uint8_t *pix1, ptrdiff_t stride, int h);
+int ff_hf_noise16_mmx(const uint8_t *pix1, ptrdiff_t stride, int h);
+int ff_sad8_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                    ptrdiff_t stride, int h);
-int ff_sad16_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                     ptrdiff_t stride, int h);
-int ff_sad16_sse2(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_sse2(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                   ptrdiff_t stride, int h);
-int ff_sad8_x2_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad8_x2_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                       ptrdiff_t stride, int h);
-int ff_sad16_x2_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_x2_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                        ptrdiff_t stride, int h);
-int ff_sad16_x2_sse2(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_x2_sse2(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                      ptrdiff_t stride, int h);
-int ff_sad8_y2_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad8_y2_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                       ptrdiff_t stride, int h);
-int ff_sad16_y2_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_y2_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                        ptrdiff_t stride, int h);
-int ff_sad16_y2_sse2(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_y2_sse2(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                      ptrdiff_t stride, int h);
-int ff_sad8_approx_xy2_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad8_approx_xy2_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                               ptrdiff_t stride, int h);
-int ff_sad16_approx_xy2_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_approx_xy2_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                                ptrdiff_t stride, int h);
-int ff_sad16_approx_xy2_sse2(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_sad16_approx_xy2_sse2(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                              ptrdiff_t stride, int h);
-int ff_vsad_intra8_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_vsad_intra8_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                           ptrdiff_t stride, int h);
-int ff_vsad_intra16_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_vsad_intra16_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                            ptrdiff_t stride, int h);
-int ff_vsad_intra16_sse2(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_vsad_intra16_sse2(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                          ptrdiff_t stride, int h);
-int ff_vsad8_approx_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_vsad8_approx_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                     ptrdiff_t stride, int h);
-int ff_vsad16_approx_mmxext(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_vsad16_approx_mmxext(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                      ptrdiff_t stride, int h);
-int ff_vsad16_approx_sse2(MpegEncContext *v, uint8_t *pix1, uint8_t *pix2,
+int ff_vsad16_approx_sse2(MpegEncContext *v, const uint8_t *pix1, const uint8_t *pix2,
                    ptrdiff_t stride, int h);
 
 #define hadamard_func(cpu)                                                    \
-    int ff_hadamard8_diff_ ## cpu(MpegEncContext *s, uint8_t *src1,           \
-                                  uint8_t *src2, ptrdiff_t stride, int h);    \
-    int ff_hadamard8_diff16_ ## cpu(MpegEncContext *s, uint8_t *src1,         \
-                                    uint8_t *src2, ptrdiff_t stride, int h);
+    int ff_hadamard8_diff_ ## cpu(MpegEncContext *s, const uint8_t *src1,     \
+                                  const uint8_t *src2, ptrdiff_t stride, int h); \
+    int ff_hadamard8_diff16_ ## cpu(MpegEncContext *s, const uint8_t *src1,   \
+                                    const uint8_t *src2, ptrdiff_t stride, int h);
 
 hadamard_func(mmxext)
 hadamard_func(sse2)
 hadamard_func(ssse3)
 
 #if HAVE_X86ASM
-static int nsse16_mmx(MpegEncContext *c, uint8_t *pix1, uint8_t *pix2,
+static int nsse16_mmx(MpegEncContext *c, const uint8_t *pix1, const uint8_t *pix2,
                       ptrdiff_t stride, int h)
 {
     int score1, score2;
@@ -106,7 +106,7 @@ static int nsse16_mmx(MpegEncContext *c, uint8_t *pix1, uint8_t *pix2,
         return score1 + FFABS(score2) * 8;
 }
 
-static int nsse8_mmx(MpegEncContext *c, uint8_t *pix1, uint8_t *pix2,
+static int nsse8_mmx(MpegEncContext *c, const uint8_t *pix1, const uint8_t *pix2,
                      ptrdiff_t stride, int h)
 {
     int score1 = ff_sse8_mmx(c, pix1, pix2, stride, h);
@@ -129,7 +129,7 @@ DECLARE_ASM_CONST(8, uint64_t, round_tab)[3] = {
     0x0002000200020002ULL,
 };
 
-static inline void sad8_4_mmx(uint8_t *blk1, uint8_t *blk2,
+static inline void sad8_4_mmx(const uint8_t *blk1, const uint8_t *blk2,
                               ptrdiff_t stride, int h)
 {
     x86_reg len = -stride * h;
@@ -199,22 +199,21 @@ static inline int sum_mmx(void)
 }
 
 #define PIX_SADXY(suf)                                                  \
-static int sad8_xy2_ ## suf(MpegEncContext *v, uint8_t *blk2,           \
-                            uint8_t *blk1, ptrdiff_t stride, int h)     \
+static int sad8_xy2_ ## suf(MpegEncContext *v, const uint8_t *blk2,     \
+                            const uint8_t *blk1, ptrdiff_t stride, int h) \
 {                                                                       \
-    av_assert2(h == 8);                                                     \
     __asm__ volatile (                                                  \
         "pxor %%mm7, %%mm7     \n\t"                                    \
         "pxor %%mm6, %%mm6     \n\t"                                    \
         ::);                                                            \
                                                                         \
-    sad8_4_ ## suf(blk1, blk2, stride, 8);                              \
+    sad8_4_ ## suf(blk1, blk2, stride, h);                              \
                                                                         \
     return sum_ ## suf();                                               \
 }                                                                       \
                                                                         \
-static int sad16_xy2_ ## suf(MpegEncContext *v, uint8_t *blk2,          \
-                             uint8_t *blk1, ptrdiff_t stride, int h)    \
+static int sad16_xy2_ ## suf(MpegEncContext *v, const uint8_t *blk2,    \
+                             const uint8_t *blk1, ptrdiff_t stride, int h) \
 {                                                                       \
     __asm__ volatile (                                                  \
         "pxor %%mm7, %%mm7     \n\t"                                    \
diff --git a/libavcodec/x86/mpegvideodsp.c b/libavcodec/x86/mpegvideodsp.c
index 6009b64..ea1d941 100644
--- a/libavcodec/x86/mpegvideodsp.c
+++ b/libavcodec/x86/mpegvideodsp.c
@@ -25,7 +25,7 @@
 
 #if HAVE_INLINE_ASM
 
-static void gmc_mmx(uint8_t *dst, uint8_t *src,
+static void gmc_mmx(uint8_t *dst, const uint8_t *src,
                     int stride, int h, int ox, int oy,
                     int dxx, int dxy, int dyx, int dyy,
                     int shift, int r, int width, int height)
diff --git a/libavcodec/x86/mpegvideoenc_qns_template.c b/libavcodec/x86/mpegvideoenc_qns_template.c
index 882d486..0d6454f 100644
--- a/libavcodec/x86/mpegvideoenc_qns_template.c
+++ b/libavcodec/x86/mpegvideoenc_qns_template.c
@@ -32,7 +32,7 @@
 
 #define MAX_ABS (512 >> (SCALE_OFFSET>0 ? SCALE_OFFSET : 0))
 
-static int DEF(try_8x8basis)(int16_t rem[64], int16_t weight[64], int16_t basis[64], int scale)
+static int DEF(try_8x8basis)(const int16_t rem[64], const int16_t weight[64], const int16_t basis[64], int scale)
 {
     x86_reg i=0;
 
@@ -74,7 +74,7 @@ static int DEF(try_8x8basis)(int16_t rem[64], int16_t weight[64], int16_t basis[
     return i;
 }
 
-static void DEF(add_8x8basis)(int16_t rem[64], int16_t basis[64], int scale)
+static void DEF(add_8x8basis)(int16_t rem[64], const int16_t basis[64], int scale)
 {
     x86_reg i=0;
 
diff --git a/libavcodec/x86/mpegvideoencdsp.asm b/libavcodec/x86/mpegvideoencdsp.asm
index e3d88f0..3cbe7b4 100644
--- a/libavcodec/x86/mpegvideoencdsp.asm
+++ b/libavcodec/x86/mpegvideoencdsp.asm
@@ -24,7 +24,7 @@
 %include "libavutil/x86/x86util.asm"
 
 SECTION .text
-; int ff_pix_sum16(uint8_t *pix, int line_size)
+; int ff_pix_sum16(const uint8_t *pix, int line_size)
 ; %1 = number of loops
 ; %2 = number of GPRs used
 %macro PIX_SUM16 3
@@ -72,7 +72,7 @@ INIT_XMM xop
 PIX_SUM16  4, 4, 4
 %endif
 
-; int ff_pix_norm1(uint8_t *pix, int line_size)
+; int ff_pix_norm1(const uint8_t *pix, int line_size)
 ; %1 = number of xmm registers used
 ; %2 = number of loops
 %macro PIX_NORM1 2
diff --git a/libavcodec/x86/mpegvideoencdsp_init.c b/libavcodec/x86/mpegvideoencdsp_init.c
index b9c80b5..ec174b1 100644
--- a/libavcodec/x86/mpegvideoencdsp_init.c
+++ b/libavcodec/x86/mpegvideoencdsp_init.c
@@ -23,9 +23,9 @@
 #include "libavcodec/avcodec.h"
 #include "libavcodec/mpegvideoencdsp.h"
 
-int ff_pix_sum16_sse2(uint8_t *pix, int line_size);
-int ff_pix_sum16_xop(uint8_t *pix, int line_size);
-int ff_pix_norm1_sse2(uint8_t *pix, int line_size);
+int ff_pix_sum16_sse2(const uint8_t *pix, int line_size);
+int ff_pix_sum16_xop(const uint8_t *pix, int line_size);
+int ff_pix_norm1_sse2(const uint8_t *pix, int line_size);
 
 #if HAVE_INLINE_ASM
 
diff --git a/libavcodec/x86/pngdsp.asm b/libavcodec/x86/pngdsp.asm
index 50e4255..7bc43c7 100644
--- a/libavcodec/x86/pngdsp.asm
+++ b/libavcodec/x86/pngdsp.asm
@@ -29,9 +29,8 @@ cextern pw_255
 
 SECTION .text
 
-; %1 = nr. of xmm registers used
-%macro ADD_BYTES_FN 1
-cglobal add_bytes_l2, 4, 6, %1, dst, src1, src2, wa, w, i
+INIT_XMM sse2
+cglobal add_bytes_l2, 4, 6, 2, dst, src1, src2, wa, w, i
 %if ARCH_X86_64
     movsxd             waq, wad
 %endif
@@ -53,7 +52,6 @@ cglobal add_bytes_l2, 4, 6, %1, dst, src1, src2, wa, w, i
     cmp                 iq, waq
     jl .loop_v
 
-%if mmsize == 16
     ; vector loop
     mov                waq, wq
     and                waq, ~7
@@ -66,7 +64,6 @@ cglobal add_bytes_l2, 4, 6, %1, dst, src1, src2, wa, w, i
 .end_l:
     cmp                 iq, waq
     jl .loop_l
-%endif
 
     ; scalar loop for leftover
     jmp .end_s
@@ -79,15 +76,6 @@ cglobal add_bytes_l2, 4, 6, %1, dst, src1, src2, wa, w, i
     cmp                 iq, wq
     jl .loop_s
     REP_RET
-%endmacro
-
-%if ARCH_X86_32
-INIT_MMX mmx
-ADD_BYTES_FN 0
-%endif
-
-INIT_XMM sse2
-ADD_BYTES_FN 2
 
 %macro ADD_PAETH_PRED_FN 1
 cglobal add_png_paeth_prediction, 5, 7, %1, dst, src, top, w, bpp, end, cntr
diff --git a/libavcodec/x86/pngdsp_init.c b/libavcodec/x86/pngdsp_init.c
index edbe866..e2cd5ef 100644
--- a/libavcodec/x86/pngdsp_init.c
+++ b/libavcodec/x86/pngdsp_init.c
@@ -20,7 +20,6 @@
  */
 
 #include <stdint.h>
-#include "config.h"
 #include "libavutil/attributes.h"
 #include "libavutil/x86/cpu.h"
 #include "libavcodec/pngdsp.h"
@@ -29,8 +28,6 @@ void ff_add_png_paeth_prediction_mmxext(uint8_t *dst, uint8_t *src,
                                         uint8_t *top, int w, int bpp);
 void ff_add_png_paeth_prediction_ssse3(uint8_t *dst, uint8_t *src,
                                        uint8_t *top, int w, int bpp);
-void ff_add_bytes_l2_mmx (uint8_t *dst, uint8_t *src1,
-                          uint8_t *src2, int w);
 void ff_add_bytes_l2_sse2(uint8_t *dst, uint8_t *src1,
                           uint8_t *src2, int w);
 
@@ -38,10 +35,6 @@ av_cold void ff_pngdsp_init_x86(PNGDSPContext *dsp)
 {
     int cpu_flags = av_get_cpu_flags();
 
-#if ARCH_X86_32
-    if (EXTERNAL_MMX(cpu_flags))
-        dsp->add_bytes_l2         = ff_add_bytes_l2_mmx;
-#endif
     if (EXTERNAL_MMXEXT(cpu_flags))
         dsp->add_paeth_prediction = ff_add_png_paeth_prediction_mmxext;
     if (EXTERNAL_SSE2(cpu_flags))
diff --git a/libavcodec/x86/rv40dsp_init.c b/libavcodec/x86/rv40dsp_init.c
index a04c5a5..ab9e644 100644
--- a/libavcodec/x86/rv40dsp_init.c
+++ b/libavcodec/x86/rv40dsp_init.c
@@ -40,14 +40,14 @@ static void op##_rv40_qpel##size##_mc33_##insn(uint8_t *dst, const uint8_t *src,
 }
 
 #if HAVE_X86ASM
-void ff_put_rv40_chroma_mc8_mmx  (uint8_t *dst, uint8_t *src,
+void ff_put_rv40_chroma_mc8_mmx  (uint8_t *dst, const uint8_t *src,
                                   ptrdiff_t stride, int h, int x, int y);
-void ff_avg_rv40_chroma_mc8_mmxext(uint8_t *dst, uint8_t *src,
+void ff_avg_rv40_chroma_mc8_mmxext(uint8_t *dst, const uint8_t *src,
                                    ptrdiff_t stride, int h, int x, int y);
 
-void ff_put_rv40_chroma_mc4_mmx  (uint8_t *dst, uint8_t *src,
+void ff_put_rv40_chroma_mc4_mmx  (uint8_t *dst, const uint8_t *src,
                                   ptrdiff_t stride, int h, int x, int y);
-void ff_avg_rv40_chroma_mc4_mmxext(uint8_t *dst, uint8_t *src,
+void ff_avg_rv40_chroma_mc4_mmxext(uint8_t *dst, const uint8_t *src,
                                    ptrdiff_t stride, int h, int x, int y);
 
 #define DECLARE_WEIGHT(opt) \
diff --git a/libavcodec/x86/vc1dsp_init.c b/libavcodec/x86/vc1dsp_init.c
index b1f68b0..90b2f36 100644
--- a/libavcodec/x86/vc1dsp_init.c
+++ b/libavcodec/x86/vc1dsp_init.c
@@ -80,13 +80,13 @@ DECLARE_FUNCTION(avg_, 16, _sse2)
 
 #endif /* HAVE_X86ASM */
 
-void ff_put_vc1_chroma_mc8_nornd_mmx  (uint8_t *dst, uint8_t *src,
+void ff_put_vc1_chroma_mc8_nornd_mmx  (uint8_t *dst, const uint8_t *src,
                                        ptrdiff_t stride, int h, int x, int y);
-void ff_avg_vc1_chroma_mc8_nornd_mmxext(uint8_t *dst, uint8_t *src,
+void ff_avg_vc1_chroma_mc8_nornd_mmxext(uint8_t *dst, const uint8_t *src,
                                         ptrdiff_t stride, int h, int x, int y);
-void ff_put_vc1_chroma_mc8_nornd_ssse3(uint8_t *dst, uint8_t *src,
+void ff_put_vc1_chroma_mc8_nornd_ssse3(uint8_t *dst, const uint8_t *src,
                                        ptrdiff_t stride, int h, int x, int y);
-void ff_avg_vc1_chroma_mc8_nornd_ssse3(uint8_t *dst, uint8_t *src,
+void ff_avg_vc1_chroma_mc8_nornd_ssse3(uint8_t *dst, const uint8_t *src,
                                        ptrdiff_t stride, int h, int x, int y);
 void ff_vc1_inv_trans_4x4_dc_mmxext(uint8_t *dest, ptrdiff_t linesize,
                                     int16_t *block);
diff --git a/libavcodec/x86/videodsp_init.c b/libavcodec/x86/videodsp_init.c
index a14c963..ae9db95 100644
--- a/libavcodec/x86/videodsp_init.c
+++ b/libavcodec/x86/videodsp_init.c
@@ -215,7 +215,7 @@ static av_noinline void emulated_edge_mc_avx2(uint8_t *buf, const uint8_t *src,
 #endif /* HAVE_AVX2_EXTERNAL */
 #endif /* HAVE_X86ASM */
 
-void ff_prefetch_mmxext(uint8_t *buf, ptrdiff_t stride, int h);
+void ff_prefetch_mmxext(const uint8_t *buf, ptrdiff_t stride, int h);
 
 av_cold void ff_videodsp_init_x86(VideoDSPContext *ctx, int bpc)
 {
diff --git a/libavcodec/x86/vpx_arith.h b/libavcodec/x86/vpx_arith.h
new file mode 100644
index 0000000..d9e4c0d
--- /dev/null
+++ b/libavcodec/x86/vpx_arith.h
@@ -0,0 +1,55 @@
+/**
+ * VP5 and VP6 compatible video decoder (arith decoder)
+ *
+ * Copyright (C) 2006  Aurelien Jacobs <aurel@gnuage.org>
+ * Copyright (C) 2010  Eli Friedman
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_X86_VPX_ARITH_H
+#define AVCODEC_X86_VPX_ARITH_H
+
+#include "libavutil/x86/asm.h"
+
+#if HAVE_INLINE_ASM && HAVE_FAST_CMOV && HAVE_6REGS
+#include "libavutil/attributes.h"
+
+#define vpx_rac_get_prob vpx_rac_get_prob
+static av_always_inline int vpx_rac_get_prob(VPXRangeCoder *c, uint8_t prob)
+{
+    unsigned int code_word = vpx_rac_renorm(c);
+    unsigned int low = 1 + (((c->high - 1) * prob) >> 8);
+    unsigned int low_shift = low << 16;
+    int bit = 0;
+    c->code_word = code_word;
+
+    __asm__(
+        "subl  %4, %1      \n\t"
+        "subl  %3, %2      \n\t"
+        "setae %b0         \n\t"
+        "cmovb %4, %1      \n\t"
+        "cmovb %5, %2      \n\t"
+        : "+q"(bit), "+&r"(c->high), "+&r"(c->code_word)
+        : "r"(low_shift), "r"(low), "r"(code_word)
+    );
+
+    return bit;
+}
+#endif
+
+#endif /* AVCODEC_X86_VPX_ARITH_H */
diff --git a/libavcodec/xan.c b/libavcodec/xan.c
index 3386a70..cdc302f 100644
--- a/libavcodec/xan.c
+++ b/libavcodec/xan.c
@@ -644,5 +644,5 @@ const FFCodec ff_xan_wc3_decoder = {
     .close          = xan_decode_end,
     FF_CODEC_DECODE_CB(xan_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/xbmenc.c b/libavcodec/xbmenc.c
index 60fb169..8369f53 100644
--- a/libavcodec/xbmenc.c
+++ b/libavcodec/xbmenc.c
@@ -32,7 +32,8 @@ static int xbm_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                             const AVFrame *p, int *got_packet)
 {
     int i, j, l, commas, ret, size, linesize, lineout, rowsout;
-    uint8_t *ptr, *buf;
+    const uint8_t *ptr;
+    uint8_t *buf;
 
     linesize = lineout = (avctx->width + 7) / 8;
     commas   = avctx->height * linesize;
diff --git a/libavcodec/xfacedec.c b/libavcodec/xfacedec.c
index f15bc2d..880a62c 100644
--- a/libavcodec/xfacedec.c
+++ b/libavcodec/xfacedec.c
@@ -185,5 +185,4 @@ const FFCodec ff_xface_decoder = {
     .init           = xface_decode_init,
     FF_CODEC_DECODE_CB(xface_decode_frame),
     .p.pix_fmts     = (const enum AVPixelFormat[]) { AV_PIX_FMT_MONOWHITE, AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/xl.c b/libavcodec/xl.c
index d2037b9..6fb050d 100644
--- a/libavcodec/xl.c
+++ b/libavcodec/xl.c
@@ -134,5 +134,4 @@ const FFCodec ff_xl_decoder = {
     .init         = decode_init,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/xsubdec.c b/libavcodec/xsubdec.c
index d62fa16..49c8e8e 100644
--- a/libavcodec/xsubdec.c
+++ b/libavcodec/xsubdec.c
@@ -161,5 +161,4 @@ const FFCodec ff_xsub_decoder = {
     .p.id      = AV_CODEC_ID_XSUB,
     .init      = decode_init,
     FF_CODEC_DECODE_SUB_CB(decode_frame),
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/xsubenc.c b/libavcodec/xsubenc.c
index 8ca411e..cc0fc09 100644
--- a/libavcodec/xsubenc.c
+++ b/libavcodec/xsubenc.c
@@ -218,5 +218,4 @@ const FFCodec ff_xsub_encoder = {
     .p.id       = AV_CODEC_ID_XSUB,
     .init       = xsub_encoder_init,
     FF_CODEC_ENCODE_SUB_CB(xsub_encode),
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/xwdenc.c b/libavcodec/xwdenc.c
index 0c6dfc6..01c43c1 100644
--- a/libavcodec/xwdenc.c
+++ b/libavcodec/xwdenc.c
@@ -31,7 +31,7 @@
 #define WINDOW_NAME_SIZE    11
 
 static int xwd_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
-                            const AVFrame *pict, int *got_packet)
+                            const AVFrame *p, int *got_packet)
 {
     enum AVPixelFormat pix_fmt = avctx->pix_fmt;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
@@ -39,8 +39,8 @@ static int xwd_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     uint32_t rgb[3] = { 0 }, bitorder = 0;
     uint32_t header_size;
     int i, out_size, ret;
-    uint8_t *ptr, *buf;
-    AVFrame * const p = (AVFrame *)pict;
+    const uint8_t *ptr;
+    uint8_t *buf;
     uint32_t pal[256];
 
     pixdepth = av_get_bits_per_pixel(desc);
@@ -151,9 +151,6 @@ static int xwd_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         return ret;
     buf = pkt->data;
 
-    p->key_frame = 1;
-    p->pict_type = AV_PICTURE_TYPE_I;
-
     bytestream_put_be32(&buf, header_size);
     bytestream_put_be32(&buf, XWD_VERSION);   // file version
     bytestream_put_be32(&buf, XWD_Z_PIXMAP);  // pixmap format
diff --git a/libavcodec/xxan.c b/libavcodec/xxan.c
index d73bd46..79edc16 100644
--- a/libavcodec/xxan.c
+++ b/libavcodec/xxan.c
@@ -443,5 +443,5 @@ const FFCodec ff_xan_wc4_decoder = {
     .close          = xan_decode_end,
     FF_CODEC_DECODE_CB(xan_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP | FF_CODEC_CAP_INIT_THREADSAFE,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/y41pdec.c b/libavcodec/y41pdec.c
index 4b1e64a..7179097 100644
--- a/libavcodec/y41pdec.c
+++ b/libavcodec/y41pdec.c
@@ -89,5 +89,4 @@ const FFCodec ff_y41p_decoder = {
     .init         = y41p_decode_init,
     FF_CODEC_DECODE_CB(y41p_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/y41penc.c b/libavcodec/y41penc.c
index 390bd10..f7ac58c 100644
--- a/libavcodec/y41penc.c
+++ b/libavcodec/y41penc.c
@@ -42,7 +42,7 @@ static int y41p_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                              const AVFrame *pic, int *got_packet)
 {
     uint8_t *dst;
-    uint8_t *y, *u, *v;
+    const uint8_t *y, *u, *v;
     int i, j, ret;
 
     ret = ff_get_encode_buffer(avctx, pkt, avctx->width * avctx->height * 1.5, 0);
@@ -87,5 +87,4 @@ const FFCodec ff_y41p_encoder = {
     FF_CODEC_ENCODE_CB(y41p_encode_frame),
     .p.pix_fmts   = (const enum AVPixelFormat[]) { AV_PIX_FMT_YUV411P,
                                                  AV_PIX_FMT_NONE },
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/ylc.c b/libavcodec/ylc.c
index 94d0388..4f629bd 100644
--- a/libavcodec/ylc.c
+++ b/libavcodec/ylc.c
@@ -459,5 +459,4 @@ const FFCodec ff_ylc_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1 | AV_CODEC_CAP_FRAME_THREADS,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/yop.c b/libavcodec/yop.c
index 7a11ca7..50bb64b 100644
--- a/libavcodec/yop.c
+++ b/libavcodec/yop.c
@@ -275,5 +275,4 @@ const FFCodec ff_yop_decoder = {
     .init           = yop_decode_init,
     .close          = yop_decode_close,
     FF_CODEC_DECODE_CB(yop_decode_frame),
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/yuv4dec.c b/libavcodec/yuv4dec.c
index bbd213e..4a1551e 100644
--- a/libavcodec/yuv4dec.c
+++ b/libavcodec/yuv4dec.c
@@ -81,5 +81,4 @@ const FFCodec ff_yuv4_decoder = {
     .init         = yuv4_decode_init,
     FF_CODEC_DECODE_CB(yuv4_decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal = FF_CODEC_CAP_INIT_THREADSAFE,
 };
diff --git a/libavcodec/yuv4enc.c b/libavcodec/yuv4enc.c
index 8d72382..94e9b5d 100644
--- a/libavcodec/yuv4enc.c
+++ b/libavcodec/yuv4enc.c
@@ -28,7 +28,7 @@ static int yuv4_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
                              const AVFrame *pic, int *got_packet)
 {
     uint8_t *dst;
-    uint8_t *y, *u, *v;
+    const uint8_t *y, *u, *v;
     int i, j, ret;
 
     ret = ff_get_encode_buffer(avctx, pkt, 6 * (avctx->width  + 1 >> 1)
diff --git a/libavcodec/zerocodec.c b/libavcodec/zerocodec.c
index 08511ca..8a0d8bc 100644
--- a/libavcodec/zerocodec.c
+++ b/libavcodec/zerocodec.c
@@ -144,6 +144,5 @@ const FFCodec ff_zerocodec_decoder = {
     .flush          = zerocodec_decode_flush,
     .close          = zerocodec_decode_close,
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE |
-                      FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/zmbv.c b/libavcodec/zmbv.c
index 37c18e3..a6d9824 100644
--- a/libavcodec/zmbv.c
+++ b/libavcodec/zmbv.c
@@ -655,5 +655,5 @@ const FFCodec ff_zmbv_decoder = {
     .close          = decode_end,
     FF_CODEC_DECODE_CB(decode_frame),
     .p.capabilities = AV_CODEC_CAP_DR1,
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavcodec/zmbvenc.c b/libavcodec/zmbvenc.c
index ef21a18..cc8578a 100644
--- a/libavcodec/zmbvenc.c
+++ b/libavcodec/zmbvenc.c
@@ -84,8 +84,8 @@ typedef struct ZmbvEncContext {
 /** Block comparing function
  * XXX should be optimized and moved to DSPContext
  */
-static inline int block_cmp(ZmbvEncContext *c, uint8_t *src, int stride,
-                            uint8_t *src2, int stride2, int bw, int bh,
+static inline int block_cmp(ZmbvEncContext *c, const uint8_t *src, int stride,
+                            const uint8_t *src2, int stride2, int bw, int bh,
                             int *xored)
 {
     int sum = 0;
@@ -119,7 +119,7 @@ static inline int block_cmp(ZmbvEncContext *c, uint8_t *src, int stride,
 /** Motion estimation function
  * TODO make better ME decisions
  */
-static int zmbv_me(ZmbvEncContext *c, uint8_t *src, int sstride, uint8_t *prev,
+static int zmbv_me(ZmbvEncContext *c, const uint8_t *src, int sstride, const uint8_t *prev,
                    int pstride, int x, int y, int *mx, int *my, int *xored)
 {
     int dx, dy, txored, tv, bv, bw, bh;
@@ -171,7 +171,8 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
     ZmbvEncContext * const c = avctx->priv_data;
     z_stream  *const zstream = &c->zstream.zstream;
     const AVFrame * const p = pict;
-    uint8_t *src, *prev, *buf;
+    const uint8_t *src;
+    uint8_t *prev, *buf;
     uint32_t *palptr;
     int keyframe, chpal;
     int fl;
@@ -218,7 +219,7 @@ static int encode_frame(AVCodecContext *avctx, AVPacket *pkt,
         }
     }else{
         int x, y, bh2, bw2, xored;
-        uint8_t *tsrc, *tprev;
+        const uint8_t *tsrc, *tprev;
         uint8_t *mv;
         int mx = 0, my = 0;
 
@@ -428,5 +429,5 @@ const FFCodec ff_zmbv_encoder = {
 #endif //ZMBV_ENABLE_24BPP
                                                      AV_PIX_FMT_BGR0,
                                                      AV_PIX_FMT_NONE },
-    .caps_internal  = FF_CODEC_CAP_INIT_THREADSAFE | FF_CODEC_CAP_INIT_CLEANUP,
+    .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP,
 };
diff --git a/libavdevice/Makefile b/libavdevice/Makefile
index bbe2f69..8a62822 100644
--- a/libavdevice/Makefile
+++ b/libavdevice/Makefile
@@ -59,7 +59,7 @@ OBJS-$(CONFIG_LIBDC1394_INDEV)           += libdc1394.o
 SHLIBOBJS-$(CONFIG_DECKLINK_INDEV)       += reverse.o
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES)             += avdeviceres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES)            += avdeviceres.o
 
 SKIPHEADERS                              += decklink_common.h
 SKIPHEADERS-$(CONFIG_DECKLINK)           += decklink_enc.h decklink_dec.h \
diff --git a/libavdevice/alsa_enc.c b/libavdevice/alsa_enc.c
index ac09e33..e461829 100644
--- a/libavdevice/alsa_enc.c
+++ b/libavdevice/alsa_enc.c
@@ -131,7 +131,14 @@ static int audio_write_frame(AVFormatContext *s1, int stream_index,
     pkt.data     = (*frame)->data[0];
     pkt.size     = (*frame)->nb_samples * s->frame_size;
     pkt.dts      = (*frame)->pkt_dts;
-    pkt.duration = (*frame)->pkt_duration;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+    if ((*frame)->pkt_duration)
+        pkt.duration = (*frame)->pkt_duration;
+    else
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    pkt.duration = (*frame)->duration;
     return audio_write_packet(s1, &pkt);
 }
 
diff --git a/libavdevice/lavfi.c b/libavdevice/lavfi.c
index db5d0b9..246f7df 100644
--- a/libavdevice/lavfi.c
+++ b/libavdevice/lavfi.c
@@ -54,32 +54,10 @@ typedef struct {
     int *sink_eof;
     int *stream_sink_map;
     int *sink_stream_subcc_map;
-    AVFrame *decoded_frame;
     int nb_sinks;
     AVPacket subcc_packet;
 } LavfiContext;
 
-static int *create_all_formats(int n)
-{
-    int i, j, *fmts, count = 0;
-
-    for (i = 0; i < n; i++) {
-        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(i);
-        if (!(desc->flags & AV_PIX_FMT_FLAG_HWACCEL))
-            count++;
-    }
-
-    if (!(fmts = av_malloc_array(count + 1, sizeof(*fmts))))
-        return NULL;
-    for (j = 0, i = 0; i < n; i++) {
-        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(i);
-        if (!(desc->flags & AV_PIX_FMT_FLAG_HWACCEL))
-            fmts[j++] = i;
-    }
-    fmts[j] = AV_PIX_FMT_NONE;
-    return fmts;
-}
-
 av_cold static int lavfi_read_close(AVFormatContext *avctx)
 {
     LavfiContext *lavfi = avctx->priv_data;
@@ -90,7 +68,6 @@ av_cold static int lavfi_read_close(AVFormatContext *avctx)
     av_freep(&lavfi->sink_stream_subcc_map);
     av_freep(&lavfi->sinks);
     avfilter_graph_free(&lavfi->graph);
-    av_frame_free(&lavfi->decoded_frame);
 
     return 0;
 }
@@ -125,15 +102,11 @@ av_cold static int lavfi_read_header(AVFormatContext *avctx)
     LavfiContext *lavfi = avctx->priv_data;
     AVFilterInOut *input_links = NULL, *output_links = NULL, *inout;
     const AVFilter *buffersink, *abuffersink;
-    int *pix_fmts = create_all_formats(AV_PIX_FMT_NB);
     enum AVMediaType type;
     int ret = 0, i, n;
 
 #define FAIL(ERR) { ret = ERR; goto end; }
 
-    if (!pix_fmts)
-        FAIL(AVERROR(ENOMEM));
-
     buffersink = avfilter_get_by_name("buffersink");
     abuffersink = avfilter_get_by_name("abuffersink");
 
@@ -264,8 +237,6 @@ av_cold static int lavfi_read_header(AVFormatContext *avctx)
             ret = avfilter_graph_create_filter(&sink, buffersink,
                                                inout->name, NULL,
                                                NULL, lavfi->graph);
-            if (ret >= 0)
-                ret = av_opt_set_int_list(sink, "pix_fmts", pix_fmts,  AV_PIX_FMT_NONE, AV_OPT_SEARCH_CHILDREN);
             if (ret < 0)
                 goto end;
         } else if (type == AVMEDIA_TYPE_AUDIO) {
@@ -316,21 +287,23 @@ av_cold static int lavfi_read_header(AVFormatContext *avctx)
     for (i = 0; i < lavfi->nb_sinks; i++) {
         AVFilterContext *sink = lavfi->sinks[lavfi->stream_sink_map[i]];
         AVRational time_base = av_buffersink_get_time_base(sink);
+        AVRational frame_rate = av_buffersink_get_frame_rate(sink);
         AVStream *st = avctx->streams[i];
         AVCodecParameters *const par = st->codecpar;
         avpriv_set_pts_info(st, 64, time_base.num, time_base.den);
         par->codec_type = av_buffersink_get_type(sink);
         if (par->codec_type == AVMEDIA_TYPE_VIDEO) {
-            int64_t probesize;
-            par->codec_id   = AV_CODEC_ID_RAWVIDEO;
+            par->codec_id   = AV_CODEC_ID_WRAPPED_AVFRAME;
             par->format     = av_buffersink_get_format(sink);
             par->width      = av_buffersink_get_w(sink);
             par->height     = av_buffersink_get_h(sink);
-            probesize       = par->width * par->height * 30 *
-                              av_get_padded_bits_per_pixel(av_pix_fmt_desc_get(par->format));
-            avctx->probesize = FFMAX(avctx->probesize, probesize);
-            st       ->sample_aspect_ratio =
+            avctx->probesize = FFMAX(avctx->probesize, sizeof(AVFrame) * 30);
+            st ->sample_aspect_ratio =
             par->sample_aspect_ratio = av_buffersink_get_sample_aspect_ratio(sink);
+            if (frame_rate.num > 0 && frame_rate.den > 0) {
+                st->avg_frame_rate = frame_rate;
+                st->r_frame_rate   = frame_rate;
+            }
         } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {
             par->sample_rate = av_buffersink_get_sample_rate(sink);
             ret = av_buffersink_get_ch_layout(sink, &par->ch_layout);
@@ -348,11 +321,7 @@ av_cold static int lavfi_read_header(AVFormatContext *avctx)
     if ((ret = create_subcc_streams(avctx)) < 0)
         goto end;
 
-    if (!(lavfi->decoded_frame = av_frame_alloc()))
-        FAIL(AVERROR(ENOMEM));
-
 end:
-    av_free(pix_fmts);
     avfilter_inout_free(&input_links);
     avfilter_inout_free(&output_links);
     return ret;
@@ -378,15 +347,20 @@ static int create_subcc_packet(AVFormatContext *avctx, AVFrame *frame,
     return 0;
 }
 
+static void lavfi_free_frame(void *opaque, uint8_t *data)
+{
+    AVFrame *frame = (AVFrame*)data;
+    av_frame_free(&frame);
+}
+
 static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)
 {
     LavfiContext *lavfi = avctx->priv_data;
     double min_pts = DBL_MAX;
     int stream_idx, min_pts_sink_idx = 0;
-    AVFrame *frame = lavfi->decoded_frame;
+    AVFrame *frame;
     AVDictionary *frame_metadata;
     int ret, i;
-    int size = 0;
     AVStream *st;
 
     if (lavfi->subcc_packet.size) {
@@ -394,12 +368,15 @@ static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)
         return pkt->size;
     }
 
+    frame = av_frame_alloc();
+    if (!frame)
+        return AVERROR(ENOMEM);
+
     /* iterate through all the graph sinks. Select the sink with the
      * minimum PTS */
     for (i = 0; i < lavfi->nb_sinks; i++) {
         AVRational tb = av_buffersink_get_time_base(lavfi->sinks[i]);
         double d;
-        int ret;
 
         if (lavfi->sink_eof[i])
             continue;
@@ -411,7 +388,7 @@ static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)
             lavfi->sink_eof[i] = 1;
             continue;
         } else if (ret < 0)
-            return ret;
+            goto fail;
         d = av_rescale_q_rnd(frame->pts, tb, AV_TIME_BASE_Q, AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX);
         ff_dlog(avctx, "sink_idx:%d time:%f\n", i, d);
         av_frame_unref(frame);
@@ -421,8 +398,10 @@ static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)
             min_pts_sink_idx = i;
         }
     }
-    if (min_pts == DBL_MAX)
-        return AVERROR_EOF;
+    if (min_pts == DBL_MAX) {
+        ret = AVERROR_EOF;
+        goto fail;
+    }
 
     ff_dlog(avctx, "min_pts_sink_idx:%i\n", min_pts_sink_idx);
 
@@ -431,15 +410,19 @@ static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)
     st = avctx->streams[stream_idx];
 
     if (st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
-        size = av_image_get_buffer_size(frame->format, frame->width, frame->height, 1);
-        if ((ret = av_new_packet(pkt, size)) < 0)
+        pkt->buf = av_buffer_create((uint8_t*)frame, sizeof(*frame),
+                                    &lavfi_free_frame, NULL, 0);
+        if (!pkt->buf) {
+            ret = AVERROR(ENOMEM);
             goto fail;
+        }
 
-        av_image_copy_to_buffer(pkt->data, size, (const uint8_t **)frame->data, frame->linesize,
-                                frame->format, frame->width, frame->height, 1);
+        pkt->data   = pkt->buf->data;
+        pkt->size   = pkt->buf->size;
+        pkt->flags |= AV_PKT_FLAG_TRUSTED;
     } else if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
-        size = frame->nb_samples * av_get_bytes_per_sample(frame->format) *
-                                   frame->ch_layout.nb_channels;
+        int size = frame->nb_samples * av_get_bytes_per_sample(frame->format) *
+                                       frame->ch_layout.nb_channels;
         if ((ret = av_new_packet(pkt, size)) < 0)
             goto fail;
         memcpy(pkt->data, frame->data[0], size);
@@ -468,10 +451,13 @@ static int lavfi_read_packet(AVFormatContext *avctx, AVPacket *pkt)
     pkt->stream_index = stream_idx;
     pkt->pts = frame->pts;
     pkt->pos = frame->pkt_pos;
-    av_frame_unref(frame);
-    return size;
+
+    if (st->codecpar->codec_type != AVMEDIA_TYPE_VIDEO)
+        av_frame_free(&frame);
+
+    return pkt->size;
 fail:
-    av_frame_unref(frame);
+    av_frame_free(&frame);
     return ret;
 
 }
diff --git a/libavdevice/pulse_audio_enc.c b/libavdevice/pulse_audio_enc.c
index d5928e2..038401c 100644
--- a/libavdevice/pulse_audio_enc.c
+++ b/libavdevice/pulse_audio_enc.c
@@ -686,7 +686,14 @@ static int pulse_write_frame(AVFormatContext *h, int stream_index,
     pkt.data     = (*frame)->data[0];
     pkt.size     = (*frame)->nb_samples * av_get_bytes_per_sample((*frame)->format) * (*frame)->ch_layout.nb_channels;
     pkt.dts      = (*frame)->pkt_dts;
-    pkt.duration = (*frame)->pkt_duration;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+    if ((*frame)->pkt_duration)
+        pkt.duration = (*frame)->pkt_duration;
+    else
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    pkt.duration = (*frame)->duration;
     return pulse_write_packet(h, &pkt);
 }
 
diff --git a/libavdevice/v4l2.c b/libavdevice/v4l2.c
index 5340382..be422d7 100644
--- a/libavdevice/v4l2.c
+++ b/libavdevice/v4l2.c
@@ -1011,6 +1011,7 @@ static int v4l2_read_close(AVFormatContext *ctx)
 
     mmap_close(s);
 
+    ff_timefilter_destroy(s->timefilter);
     v4l2_close(s->fd);
     return 0;
 }
diff --git a/libavdevice/version.h b/libavdevice/version.h
index a458e0f..3e654ff 100644
--- a/libavdevice/version.h
+++ b/libavdevice/version.h
@@ -29,8 +29,8 @@
 
 #include "version_major.h"
 
-#define LIBAVDEVICE_VERSION_MINOR   7
-#define LIBAVDEVICE_VERSION_MICRO 100
+#define LIBAVDEVICE_VERSION_MINOR   8
+#define LIBAVDEVICE_VERSION_MICRO 101
 
 #define LIBAVDEVICE_VERSION_INT AV_VERSION_INT(LIBAVDEVICE_VERSION_MAJOR, \
                                                LIBAVDEVICE_VERSION_MINOR, \
diff --git a/libavfilter/Makefile b/libavfilter/Makefile
index 30cc329..f87d317 100644
--- a/libavfilter/Makefile
+++ b/libavfilter/Makefile
@@ -181,6 +181,7 @@ OBJS-$(CONFIG_SINE_FILTER)                   += asrc_sine.o
 OBJS-$(CONFIG_ANULLSINK_FILTER)              += asink_anullsink.o
 
 # video filters
+OBJS-$(CONFIG_SCALE_RGA_FILTER)              += vf_scale_rga.o
 OBJS-$(CONFIG_ADDROI_FILTER)                 += vf_addroi.o
 OBJS-$(CONFIG_ALPHAEXTRACT_FILTER)           += vf_extractplanes.o
 OBJS-$(CONFIG_ALPHAMERGE_FILTER)             += vf_alphamerge.o framesync.o
@@ -557,6 +558,7 @@ OBJS-$(CONFIG_COLOR_FILTER)                  += vsrc_testsrc.o
 OBJS-$(CONFIG_COLORCHART_FILTER)             += vsrc_testsrc.o
 OBJS-$(CONFIG_COLORSPECTRUM_FILTER)          += vsrc_testsrc.o
 OBJS-$(CONFIG_COREIMAGESRC_FILTER)           += vf_coreimage.o
+OBJS-$(CONFIG_DDAGRAB_FILTER)                += vsrc_ddagrab.o
 OBJS-$(CONFIG_FREI0R_SRC_FILTER)             += vf_frei0r.o
 OBJS-$(CONFIG_GRADIENTS_FILTER)              += vsrc_gradients.o
 OBJS-$(CONFIG_HALDCLUTSRC_FILTER)            += vsrc_testsrc.o
@@ -604,7 +606,7 @@ OBJS-$(CONFIG_MOVIE_FILTER)                  += src_movie.o
 SHLIBOBJS                                    += log2_tab.o
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES)                 += avfilterres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES)                += avfilterres.o
 
 SKIPHEADERS-$(CONFIG_LCMS2)                  += fflcms2.h
 SKIPHEADERS-$(CONFIG_LIBVIDSTAB)             += vidstabutils.h
diff --git a/libavfilter/allfilters.c b/libavfilter/allfilters.c
index 5ebacfd..3109f8a 100644
--- a/libavfilter/allfilters.c
+++ b/libavfilter/allfilters.c
@@ -168,6 +168,7 @@ extern const AVFilter ff_asrc_sine;
 
 extern const AVFilter ff_asink_anullsink;
 
+extern const AVFilter ff_vf_scale_rga;
 extern const AVFilter ff_vf_addroi;
 extern const AVFilter ff_vf_alphaextract;
 extern const AVFilter ff_vf_alphamerge;
@@ -524,6 +525,7 @@ extern const AVFilter ff_vsrc_color;
 extern const AVFilter ff_vsrc_colorchart;
 extern const AVFilter ff_vsrc_colorspectrum;
 extern const AVFilter ff_vsrc_coreimagesrc;
+extern const AVFilter ff_vsrc_ddagrab;
 extern const AVFilter ff_vsrc_frei0r_src;
 extern const AVFilter ff_vsrc_gradients;
 extern const AVFilter ff_vsrc_haldclutsrc;
diff --git a/libavfilter/avfiltergraph.c b/libavfilter/avfiltergraph.c
index b7dbfc0..2161014 100644
--- a/libavfilter/avfiltergraph.c
+++ b/libavfilter/avfiltergraph.c
@@ -606,12 +606,15 @@ static int pick_format(AVFilterLink *link, AVFilterLink *ref)
     if (link->type == AVMEDIA_TYPE_VIDEO) {
         if(ref && ref->type == AVMEDIA_TYPE_VIDEO){
             //FIXME: This should check for AV_PIX_FMT_FLAG_ALPHA after PAL8 pixel format without alpha is implemented
-            int has_alpha= av_pix_fmt_desc_get(ref->format)->nb_components % 2 == 0;
+            AVPixFmtDescriptor *ref_desc= av_pix_fmt_desc_get(ref->format);
+            int has_alpha= ref_desc->nb_components % 2 == 0;
             enum AVPixelFormat best= AV_PIX_FMT_NONE;
             int i;
             for (i = 0; i < link->incfg.formats->nb_formats; i++) {
                 enum AVPixelFormat p = link->incfg.formats->formats[i];
                 best= av_find_best_pix_fmt_of_2(best, p, ref->format, has_alpha, NULL);
+                if (best != AV_PIX_FMT_NONE && ref_desc->flags & AV_PIX_FMT_FLAG_HWACCEL)
+                    break;
             }
             av_log(link->src,AV_LOG_DEBUG, "picking %s out of %d ref:%s alpha:%d\n",
                    av_get_pix_fmt_name(best), link->incfg.formats->nb_formats,
@@ -729,12 +732,12 @@ static int reduce_formats_on_filter(AVFilterContext *filter)
     /* reduce channel layouts */
     for (i = 0; i < filter->nb_inputs; i++) {
         AVFilterLink *inlink = filter->inputs[i];
-        AVChannelLayout fmt = { 0 };
+        const AVChannelLayout *fmt;
 
         if (!inlink->outcfg.channel_layouts ||
             inlink->outcfg.channel_layouts->nb_channel_layouts != 1)
             continue;
-        av_channel_layout_copy(&fmt, &inlink->outcfg.channel_layouts->channel_layouts[0]);
+        fmt = &inlink->outcfg.channel_layouts->channel_layouts[0];
 
         for (j = 0; j < filter->nb_outputs; j++) {
             AVFilterLink *outlink = filter->outputs[j];
@@ -745,24 +748,25 @@ static int reduce_formats_on_filter(AVFilterContext *filter)
                 continue;
 
             if (fmts->all_layouts &&
-                (KNOWN(&fmt) || fmts->all_counts)) {
+                (KNOWN(fmt) || fmts->all_counts)) {
                 /* Turn the infinite list into a singleton */
                 fmts->all_layouts = fmts->all_counts  = 0;
-                if (ff_add_channel_layout(&outlink->incfg.channel_layouts, &fmt) < 0)
+                if (ff_add_channel_layout(&outlink->incfg.channel_layouts, fmt) < 0)
                     ret = 1;
                 break;
             }
 
             for (k = 0; k < outlink->incfg.channel_layouts->nb_channel_layouts; k++) {
-                if (!av_channel_layout_compare(&fmts->channel_layouts[k], &fmt)) {
-                    av_channel_layout_copy(&fmts->channel_layouts[0], &fmt);
+                if (!av_channel_layout_compare(&fmts->channel_layouts[k], fmt)) {
+                    ret = av_channel_layout_copy(&fmts->channel_layouts[0], fmt);
+                    if (ret < 0)
+                        return ret;
                     fmts->nb_channel_layouts = 1;
                     ret = 1;
                     break;
                 }
             }
         }
-        av_channel_layout_uninit(&fmt);
     }
 
     return ret;
diff --git a/libavfilter/buffersrc.c b/libavfilter/buffersrc.c
index a319046..ae8bba1 100644
--- a/libavfilter/buffersrc.c
+++ b/libavfilter/buffersrc.c
@@ -243,6 +243,13 @@ FF_ENABLE_DEPRECATION_WARNINGS
         }
     }
 
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+    if (copy->pkt_duration && copy->pkt_duration != copy->duration)
+        copy->duration = copy->pkt_duration;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+
     ret = ff_filter_frame(ctx->outputs[0], copy);
     if (ret < 0)
         return ret;
diff --git a/libavfilter/dnn/dnn_backend_openvino.c b/libavfilter/dnn/dnn_backend_openvino.c
index cf012ac..b494f26 100644
--- a/libavfilter/dnn/dnn_backend_openvino.c
+++ b/libavfilter/dnn/dnn_backend_openvino.c
@@ -58,6 +58,8 @@ typedef struct OVModel{
     SafeQueue *request_queue;   // holds OVRequestItem
     Queue *task_queue;          // holds TaskItem
     Queue *lltask_queue;     // holds LastLevelTaskItem
+    const char *all_input_names;
+    const char *all_output_names;
 } OVModel;
 
 // one request for one call to openvino
@@ -211,19 +213,9 @@ static void infer_completion_callback(void *args)
 
     status = ie_infer_request_get_blob(request->infer_request, task->output_names[0], &output_blob);
     if (status != OK) {
-        //incorrect output name
-        char *model_output_name = NULL;
-        char *all_output_names = NULL;
-        size_t model_output_count = 0;
-        av_log(ctx, AV_LOG_ERROR, "Failed to get model output data\n");
-        status = ie_network_get_outputs_number(ov_model->network, &model_output_count);
-        for (size_t i = 0; i < model_output_count; i++) {
-            status = ie_network_get_output_name(ov_model->network, i, &model_output_name);
-            APPEND_STRING(all_output_names, model_output_name)
-        }
         av_log(ctx, AV_LOG_ERROR,
                "output \"%s\" may not correct, all output(s) are: \"%s\"\n",
-               task->output_names[0], all_output_names);
+               task->output_names[0], ov_model->all_output_names);
         return;
     }
 
@@ -336,13 +328,23 @@ static int init_model_ov(OVModel *ov_model, const char *input_name, const char *
     // while we pass NHWC data from FFmpeg to openvino
     status = ie_network_set_input_layout(ov_model->network, input_name, NHWC);
     if (status != OK) {
-        av_log(ctx, AV_LOG_ERROR, "Failed to set layout as NHWC for input %s\n", input_name);
+        if (status == NOT_FOUND) {
+            av_log(ctx, AV_LOG_ERROR, "Could not find \"%s\" in model, failed to set input layout as NHWC, "\
+                                      "all input(s) are: \"%s\"\n", input_name, ov_model->all_input_names);
+        } else{
+            av_log(ctx, AV_LOG_ERROR, "Failed to set layout as NHWC for input %s\n", input_name);
+        }
         ret = DNN_GENERIC_ERROR;
         goto err;
     }
     status = ie_network_set_output_layout(ov_model->network, output_name, NHWC);
     if (status != OK) {
-        av_log(ctx, AV_LOG_ERROR, "Failed to set layout as NHWC for output %s\n", output_name);
+        if (status == NOT_FOUND) {
+            av_log(ctx, AV_LOG_ERROR, "Could not find \"%s\" in model, failed to set output layout as NHWC, "\
+                                      "all output(s) are: \"%s\"\n", input_name, ov_model->all_output_names);
+        } else{
+            av_log(ctx, AV_LOG_ERROR, "Failed to set layout as NHWC for output %s\n", output_name);
+        }
         ret = DNN_GENERIC_ERROR;
         goto err;
     }
@@ -505,7 +507,6 @@ static int get_input_ov(void *model, DNNData *input, const char *input_name)
     OVModel *ov_model = model;
     OVContext *ctx = &ov_model->ctx;
     char *model_input_name = NULL;
-    char *all_input_names = NULL;
     IEStatusCode status;
     size_t model_input_count = 0;
     dimensions_t dims;
@@ -538,15 +539,12 @@ static int get_input_ov(void *model, DNNData *input, const char *input_name)
             input->width    = input_resizable ? -1 : dims.dims[3];
             input->dt       = precision_to_datatype(precision);
             return 0;
-        } else {
-            //incorrect input name
-            APPEND_STRING(all_input_names, model_input_name)
         }
 
         ie_network_name_free(&model_input_name);
     }
 
-    av_log(ctx, AV_LOG_ERROR, "Could not find \"%s\" in model, all input(s) are: \"%s\"\n", input_name, all_input_names);
+    av_log(ctx, AV_LOG_ERROR, "Could not find \"%s\" in model, all input(s) are: \"%s\"\n", input_name, ov_model->all_input_names);
     return AVERROR(EINVAL);
 }
 
@@ -729,6 +727,8 @@ DNNModel *ff_dnn_load_model_ov(const char *model_filename, DNNFunctionType func_
     OVModel *ov_model = NULL;
     OVContext *ctx = NULL;
     IEStatusCode status;
+    size_t node_count = 0;
+    char *node_name = NULL;
 
     model = av_mallocz(sizeof(DNNModel));
     if (!model){
@@ -744,6 +744,8 @@ DNNModel *ff_dnn_load_model_ov(const char *model_filename, DNNFunctionType func_
     ov_model->model = model;
     ov_model->ctx.class = &dnn_openvino_class;
     ctx = &ov_model->ctx;
+    ov_model->all_input_names = NULL;
+    ov_model->all_output_names = NULL;
 
     //parse options
     av_opt_set_defaults(ctx);
@@ -767,6 +769,34 @@ DNNModel *ff_dnn_load_model_ov(const char *model_filename, DNNFunctionType func_
         goto err;
     }
 
+    //get all the input and output names
+    status = ie_network_get_inputs_number(ov_model->network, &node_count);
+    if (status != OK) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to get input count\n");
+        goto err;
+    }
+    for (size_t i = 0; i < node_count; i++) {
+        status = ie_network_get_input_name(ov_model->network, i, &node_name);
+        if (status != OK) {
+            av_log(ctx, AV_LOG_ERROR, "Failed to get No.%d input's name\n", (int)i);
+            goto err;
+        }
+        APPEND_STRING(ov_model->all_input_names, node_name)
+    }
+    status = ie_network_get_outputs_number(ov_model->network, &node_count);
+    if (status != OK) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to get output count\n");
+        goto err;
+    }
+    for (size_t i = 0; i < node_count; i++) {
+        status = ie_network_get_output_name(ov_model->network, i, &node_name);
+        if (status != OK) {
+            av_log(ctx, AV_LOG_ERROR, "Failed to get No.%d output's name\n", (int)i);
+            goto err;
+        }
+        APPEND_STRING(ov_model->all_output_names, node_name)
+    }
+
     model->get_input = &get_input_ov;
     model->get_output = &get_output_ov;
     model->options = options;
diff --git a/libavfilter/edge_common.c b/libavfilter/edge_common.c
index d72e852..ebd47d7 100644
--- a/libavfilter/edge_common.c
+++ b/libavfilter/edge_common.c
@@ -46,33 +46,13 @@ static int get_rounded_direction(int gx, int gy)
     return DIRECTION_VERTICAL;
 }
 
-// Simple sobel operator to get rounded gradients
-void ff_sobel(int w, int h,
-                    uint16_t *dst, int dst_linesize,
-                    int8_t *dir, int dir_linesize,
-                    const uint8_t *src, int src_linesize)
-{
-    int i, j;
-
-    for (j = 1; j < h - 1; j++) {
-        dst += dst_linesize;
-        dir += dir_linesize;
-        src += src_linesize;
-        for (i = 1; i < w - 1; i++) {
-            const int gx =
-                -1*src[-src_linesize + i-1] + 1*src[-src_linesize + i+1]
-                -2*src[                i-1] + 2*src[                i+1]
-                -1*src[ src_linesize + i-1] + 1*src[ src_linesize + i+1];
-            const int gy =
-                -1*src[-src_linesize + i-1] + 1*src[ src_linesize + i-1]
-                -2*src[-src_linesize + i  ] + 2*src[ src_linesize + i  ]
-                -1*src[-src_linesize + i+1] + 1*src[ src_linesize + i+1];
+#undef DEPTH
+#define DEPTH 8
+#include "edge_template.c"
 
-            dst[i] = FFABS(gx) + FFABS(gy);
-            dir[i] = get_rounded_direction(gx, gy);
-        }
-    }
-}
+#undef DEPTH
+#define DEPTH 16
+#include "edge_template.c"
 
 // Filters rounded gradients to drop all non-maxima
 // Expects gradients generated by ff_sobel()
@@ -137,45 +117,3 @@ void ff_double_threshold(int low, int high, int w, int h,
         src += src_linesize;
     }
 }
-
-// Applies gaussian blur, using 5x5 kernels, sigma = 1.4
-void ff_gaussian_blur(int w, int h,
-                      uint8_t *dst, int dst_linesize,
-                      const uint8_t *src, int src_linesize)
-{
-    int i, j;
-
-    memcpy(dst, src, w); dst += dst_linesize; src += src_linesize;
-    memcpy(dst, src, w); dst += dst_linesize; src += src_linesize;
-    for (j = 2; j < h - 2; j++) {
-        dst[0] = src[0];
-        dst[1] = src[1];
-        for (i = 2; i < w - 2; i++) {
-            /* Gaussian mask of size 5x5 with sigma = 1.4 */
-            dst[i] = ((src[-2*src_linesize + i-2] + src[2*src_linesize + i-2]) * 2
-                    + (src[-2*src_linesize + i-1] + src[2*src_linesize + i-1]) * 4
-                    + (src[-2*src_linesize + i  ] + src[2*src_linesize + i  ]) * 5
-                    + (src[-2*src_linesize + i+1] + src[2*src_linesize + i+1]) * 4
-                    + (src[-2*src_linesize + i+2] + src[2*src_linesize + i+2]) * 2
-
-                    + (src[  -src_linesize + i-2] + src[  src_linesize + i-2]) *  4
-                    + (src[  -src_linesize + i-1] + src[  src_linesize + i-1]) *  9
-                    + (src[  -src_linesize + i  ] + src[  src_linesize + i  ]) * 12
-                    + (src[  -src_linesize + i+1] + src[  src_linesize + i+1]) *  9
-                    + (src[  -src_linesize + i+2] + src[  src_linesize + i+2]) *  4
-
-                    + src[i-2] *  5
-                    + src[i-1] * 12
-                    + src[i  ] * 15
-                    + src[i+1] * 12
-                    + src[i+2] *  5) / 159;
-        }
-        dst[i    ] = src[i    ];
-        dst[i + 1] = src[i + 1];
-
-        dst += dst_linesize;
-        src += src_linesize;
-    }
-    memcpy(dst, src, w); dst += dst_linesize; src += src_linesize;
-    memcpy(dst, src, w);
-}
diff --git a/libavfilter/edge_common.h b/libavfilter/edge_common.h
index 87c143f..cff4feb 100644
--- a/libavfilter/edge_common.h
+++ b/libavfilter/edge_common.h
@@ -48,10 +48,14 @@ enum AVRoundedDirection {
  * @param src           data pointers to source image
  * @param src_linesize  linesizes for the source image
  */
-void ff_sobel(int w, int h,
-              uint16_t *dst, int dst_linesize,
-              int8_t *dir, int dir_linesize,
-              const uint8_t *src, int src_linesize);
+#define PROTO_SOBEL(depth) \
+void ff_sobel_##depth(int w, int h,                                          \
+                      uint16_t *dst, int dst_linesize,                       \
+                      int8_t *dir, int dir_linesize,                         \
+                      const uint8_t *src, int src_linesize, int src_stride);
+
+PROTO_SOBEL(8)
+PROTO_SOBEL(16)
 
 /**
  * Filters rounded gradients to drop all non-maxima pixels in the magnitude image
@@ -100,8 +104,12 @@ void ff_double_threshold(int low, int high, int w, int h,
  * @param src           data pointers to source image
  * @param src_linesize  linesizes for the source image
  */
-void ff_gaussian_blur(int w, int h,
-                      uint8_t *dst, int dst_linesize,
-                      const uint8_t *src, int src_linesize);
+#define PROTO_GAUSSIAN_BLUR(depth)                                                   \
+void ff_gaussian_blur_##depth(int w, int h,                                          \
+                              uint8_t *dst, int dst_linesize,                        \
+                              const uint8_t *src, int src_linesize, int src_stride);
+
+PROTO_GAUSSIAN_BLUR(8)
+PROTO_GAUSSIAN_BLUR(16)
 
 #endif
diff --git a/libavfilter/edge_template.c b/libavfilter/edge_template.c
new file mode 100644
index 0000000..af33c17
--- /dev/null
+++ b/libavfilter/edge_template.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2022 Thilo Borgmann <thilo.borgmann _at_ mail.de>
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ * Redistribution and use in source and binary forms, with or without modification,
+ * are permitted provided that the following conditions are met:
+ */
+
+#include "libavutil/avassert.h"
+#include "avfilter.h"
+#include "formats.h"
+#include "internal.h"
+#include "video.h"
+
+#undef pixel
+#if DEPTH == 8
+#define pixel uint8_t
+#else
+#define pixel uint16_t
+#endif
+
+#undef fn
+#undef fn2
+#undef fn3
+#define fn3(a,b)   ff_##a##_##b
+#define fn2(a,b)   fn3(a,b)
+#define fn(a)      fn2(a, DEPTH)
+
+void fn(sobel)(int w, int h,
+               uint16_t *dst, int dst_linesize,
+               int8_t *dir, int dir_linesize,
+               const uint8_t *src, int src_linesize, int src_stride)
+{
+    pixel *srcp = (pixel *)src;
+
+    src_stride   /= sizeof(pixel);
+    src_linesize /= sizeof(pixel);
+    dst_linesize /= sizeof(pixel);
+
+    for (int j = 1; j < h - 1; j++) {
+        dst  += dst_linesize;
+        dir  += dir_linesize;
+        srcp += src_linesize;
+        for (int i = 1; i < w - 1; i++) {
+            const int gx =
+                -1*srcp[-src_linesize + (i-1)*src_stride] + 1*srcp[-src_linesize + (i+1)*src_stride]
+                -2*srcp[                (i-1)*src_stride] + 2*srcp[                (i+1)*src_stride]
+                -1*srcp[ src_linesize + (i-1)*src_stride] + 1*srcp[ src_linesize + (i+1)*src_stride];
+            const int gy =
+                -1*srcp[-src_linesize + (i-1)*src_stride] + 1*srcp[ src_linesize + (i-1)*src_stride]
+                -2*srcp[-src_linesize + (i  )*src_stride] + 2*srcp[ src_linesize + (i  )*src_stride]
+                -1*srcp[-src_linesize + (i+1)*src_stride] + 1*srcp[ src_linesize + (i+1)*src_stride];
+
+            dst[i] = FFABS(gx) + FFABS(gy);
+            dir[i] = get_rounded_direction(gx, gy);
+        }
+    }
+}
+
+void fn(gaussian_blur)(int w, int h,
+                       uint8_t *dst, int dst_linesize,
+                       const uint8_t *src, int src_linesize, int src_stride)
+{
+    pixel *srcp = (pixel *)src;
+    pixel *dstp = (pixel *)dst;
+
+    src_stride   /= sizeof(pixel);
+    src_linesize /= sizeof(pixel);
+    dst_linesize /= sizeof(pixel);
+
+    memcpy(dstp, srcp, w*sizeof(pixel)); dstp += dst_linesize; srcp += src_linesize;
+    memcpy(dstp, srcp, w*sizeof(pixel)); dstp += dst_linesize; srcp += src_linesize;
+    for (int j = 2; j < h - 2; j++) {
+        dstp[0] = srcp[(0)*src_stride];
+        dstp[1] = srcp[(1)*src_stride];
+        for (int i = 2; i < w - 2; i++) {
+            /* Gaussian mask of size 5x5 with sigma = 1.4 */
+            dstp[i] = ((srcp[-2*src_linesize + (i-2)*src_stride] + srcp[2*src_linesize + (i-2)*src_stride]) * 2
+                     + (srcp[-2*src_linesize + (i-1)*src_stride] + srcp[2*src_linesize + (i-1)*src_stride]) * 4
+                     + (srcp[-2*src_linesize + (i  )*src_stride] + srcp[2*src_linesize + (i  )*src_stride]) * 5
+                     + (srcp[-2*src_linesize + (i+1)*src_stride] + srcp[2*src_linesize + (i+1)*src_stride]) * 4
+                     + (srcp[-2*src_linesize + (i+2)*src_stride] + srcp[2*src_linesize + (i+2)*src_stride]) * 2
+
+                     + (srcp[  -src_linesize + (i-2)*src_stride] + srcp[  src_linesize + (i-2)*src_stride]) *  4
+                     + (srcp[  -src_linesize + (i-1)*src_stride] + srcp[  src_linesize + (i-1)*src_stride]) *  9
+                     + (srcp[  -src_linesize + (i  )*src_stride] + srcp[  src_linesize + (i  )*src_stride]) * 12
+                     + (srcp[  -src_linesize + (i+1)*src_stride] + srcp[  src_linesize + (i+1)*src_stride]) *  9
+                     + (srcp[  -src_linesize + (i+2)*src_stride] + srcp[  src_linesize + (i+2)*src_stride]) *  4
+
+                     + srcp[(i-2)*src_stride] *  5
+                     + srcp[(i-1)*src_stride] * 12
+                     + srcp[(i  )*src_stride] * 15
+                     + srcp[(i+1)*src_stride] * 12
+                     + srcp[(i+2)*src_stride] *  5) / 159;
+        }
+        dstp[w - 2] = srcp[(w - 2)*src_stride];
+        dstp[w - 1] = srcp[(w - 1)*src_stride];
+
+        dstp += dst_linesize;
+        srcp += src_linesize;
+    }
+    memcpy(dstp, srcp, w*sizeof(pixel)); dstp += dst_linesize; srcp += src_linesize;
+    memcpy(dstp, srcp, w*sizeof(pixel));
+}
diff --git a/libavfilter/f_loop.c b/libavfilter/f_loop.c
index 672aa4c..d217efe 100644
--- a/libavfilter/f_loop.c
+++ b/libavfilter/f_loop.c
@@ -331,9 +331,16 @@ static int push_frame(AVFilterContext *ctx)
     if (!out)
         return AVERROR(ENOMEM);
     out->pts += s->duration - s->start_pts;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
     if (out->pkt_duration)
         duration = out->pkt_duration;
     else
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    if (out->duration)
+        duration = out->duration;
+    else
         duration = av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
     pts = out->pts + duration;
     ret = ff_filter_frame(outlink, out);
@@ -368,9 +375,16 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
                 return AVERROR(ENOMEM);
             }
             s->nb_frames++;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
             if (frame->pkt_duration)
                 duration = frame->pkt_duration;
             else
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+            if (frame->duration)
+                duration = frame->duration;
+            else
                 duration = av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
             s->duration = frame->pts + duration;
             ret = ff_filter_frame(outlink, frame);
diff --git a/libavfilter/fflcms2.c b/libavfilter/fflcms2.c
index fd370fb..822462d 100644
--- a/libavfilter/fflcms2.c
+++ b/libavfilter/fflcms2.c
@@ -1,5 +1,4 @@
 /*
- * Copyright (c) 2022 Niklas Haas
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
@@ -17,295 +16,4 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-#include "libavutil/color_utils.h"
-#include "libavutil/csp.h"
-
-#include "fflcms2.h"
-
-static void log_cb(cmsContext ctx, cmsUInt32Number error, const char *str)
-{
-    FFIccContext *s = cmsGetContextUserData(ctx);
-    av_log(s->avctx, AV_LOG_ERROR, "lcms2: [%"PRIu32"] %s\n", error, str);
-}
-
-int ff_icc_context_init(FFIccContext *s, void *avctx)
-{
-    memset(s, 0, sizeof(*s));
-    s->avctx = avctx;
-    s->ctx = cmsCreateContext(NULL, s);
-    if (!s->ctx)
-        return AVERROR(ENOMEM);
-
-    cmsSetLogErrorHandlerTHR(s->ctx, log_cb);
-    return 0;
-}
-
-void ff_icc_context_uninit(FFIccContext *s)
-{
-    for (int i = 0; i < FF_ARRAY_ELEMS(s->curves); i++)
-        cmsFreeToneCurve(s->curves[i]);
-    cmsDeleteContext(s->ctx);
-    memset(s, 0, sizeof(*s));
-}
-
-static int get_curve(FFIccContext *s, enum AVColorTransferCharacteristic trc,
-                     cmsToneCurve **out_curve)
-{
-    if (trc >= AVCOL_TRC_NB)
-        return AVERROR_INVALIDDATA;
-
-    if (s->curves[trc])
-        goto done;
-
-    switch (trc) {
-    case AVCOL_TRC_LINEAR:
-        s->curves[trc] = cmsBuildGamma(s->ctx, 1.0);
-        break;
-    case AVCOL_TRC_GAMMA22:
-        s->curves[trc] = cmsBuildGamma(s->ctx, 2.2);
-        break;
-    case AVCOL_TRC_GAMMA28:
-        s->curves[trc] = cmsBuildGamma(s->ctx, 2.8);
-        break;
-    case AVCOL_TRC_BT709:
-    case AVCOL_TRC_SMPTE170M:
-    case AVCOL_TRC_BT2020_10:
-    case AVCOL_TRC_BT2020_12:
-        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 4, (double[5]) {
-            /*  = */ 1/0.45,
-            /* a = */ 1/1.099296826809442,
-            /* b = */ 1 - 1/1.099296826809442,
-            /* c = */ 1/4.5,
-            /* d = */ 4.5 * 0.018053968510807,
-        });
-        break;
-    case AVCOL_TRC_SMPTE240M:
-        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 4, (double[5]) {
-            /*  = */ 1/0.45,
-            /* a = */ 1/1.1115,
-            /* b = */ 1 - 1/1.1115,
-            /* c = */ 1/4.0,
-            /* d = */ 4.0 * 0.0228,
-        });
-        break;
-    case AVCOL_TRC_LOG:
-        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 8, (double[5]) {
-            /* a = */ 1.0,
-            /* b = */ 10.0,
-            /* c = */ 2.0,
-            /* d = */ -1.0,
-            /* e = */ 0.0
-        });
-        break;
-    case AVCOL_TRC_LOG_SQRT:
-        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 8, (double[5]) {
-            /* a = */ 1.0,
-            /* b = */ 10.0,
-            /* c = */ 2.5,
-            /* d = */ -1.0,
-            /* e = */ 0.0
-        });
-        break;
-    case AVCOL_TRC_IEC61966_2_1:
-        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 4, (double[5]) {
-            /*  = */ 2.4,
-            /* a = */ 1/1.055,
-            /* b = */ 1 - 1/1.055,
-            /* c = */ 1/12.92,
-            /* d = */ 12.92 * 0.0031308,
-        });
-        break;
-    case AVCOL_TRC_SMPTE428:
-        s->curves[trc] = cmsBuildParametricToneCurve(s->ctx, 2, (double[3]) {
-            /*  = */ 2.6,
-            /* a = */ pow(52.37/48.0, 1/2.6),
-            /* b = */ 0.0
-        });
-        break;
-
-    /* Can't be represented using the existing parametric tone curves.
-     * FIXME: use cmsBuildTabulatedToneCurveFloat instead */
-    case AVCOL_TRC_IEC61966_2_4:
-    case AVCOL_TRC_BT1361_ECG:
-    case AVCOL_TRC_SMPTE2084:
-    case AVCOL_TRC_ARIB_STD_B67:
-        return AVERROR_PATCHWELCOME;
-
-    default:
-        return AVERROR_INVALIDDATA;
-    }
-
-    if (!s->curves[trc])
-        return AVERROR(ENOMEM);
-
-done:
-    *out_curve = s->curves[trc];
-    return 0;
-}
-
-int ff_icc_profile_generate(FFIccContext *s,
-                            enum AVColorPrimaries color_prim,
-                            enum AVColorTransferCharacteristic color_trc,
-                            cmsHPROFILE *out_profile)
-{
-    cmsToneCurve *tonecurve;
-    const AVColorPrimariesDesc *prim;
-    int ret;
-
-    if (!(prim = av_csp_primaries_desc_from_id(color_prim)))
-        return AVERROR_INVALIDDATA;
-    if ((ret = get_curve(s, color_trc, &tonecurve)) < 0)
-        return ret;
-
-    *out_profile = cmsCreateRGBProfileTHR(s->ctx,
-        &(cmsCIExyY) { av_q2d(prim->wp.x), av_q2d(prim->wp.y), 1.0 },
-        &(cmsCIExyYTRIPLE) {
-            .Red    = { av_q2d(prim->prim.r.x), av_q2d(prim->prim.r.y), 1.0 },
-            .Green  = { av_q2d(prim->prim.g.x), av_q2d(prim->prim.g.y), 1.0 },
-            .Blue   = { av_q2d(prim->prim.b.x), av_q2d(prim->prim.b.y), 1.0 },
-        },
-        (cmsToneCurve *[3]) { tonecurve, tonecurve, tonecurve }
-    );
-
-    return *out_profile == NULL ? AVERROR(ENOMEM) : 0;
-}
-
-int ff_icc_profile_attach(FFIccContext *s, cmsHPROFILE profile, AVFrame *frame)
-{
-    cmsUInt32Number size;
-    AVBufferRef *buf;
-
-    if (!cmsSaveProfileToMem(profile, NULL, &size))
-        return AVERROR_EXTERNAL;
-
-    buf = av_buffer_alloc(size);
-    if (!buf)
-        return AVERROR(ENOMEM);
-
-    if (!cmsSaveProfileToMem(profile, buf->data, &size) || size != buf->size) {
-        av_buffer_unref(&buf);
-        return AVERROR_EXTERNAL;
-    }
-
-    if (!av_frame_new_side_data_from_buf(frame, AV_FRAME_DATA_ICC_PROFILE, buf)) {
-        av_buffer_unref(&buf);
-        return AVERROR(ENOMEM);
-    }
-
-    return 0;
-}
-
-static av_always_inline void XYZ_xy(cmsCIEXYZ XYZ, AVCIExy *xy)
-{
-    double k = 1.0 / (XYZ.X + XYZ.Y + XYZ.Z);
-    xy->x = av_d2q(k * XYZ.X, 100000);
-    xy->y = av_d2q(k * XYZ.Y, 100000);
-}
-
-int ff_icc_profile_read_primaries(FFIccContext *s, cmsHPROFILE profile,
-                                  AVColorPrimariesDesc *out_primaries)
-{
-    static const uint8_t testprimaries[4][3] = {
-        { 0xFF,    0,    0 }, /* red */
-        {    0, 0xFF,    0 }, /* green */
-        {    0,    0, 0xFF }, /* blue */
-        { 0xFF, 0xFF, 0xFF }, /* white */
-    };
-
-    AVWhitepointCoefficients *wp = &out_primaries->wp;
-    AVPrimaryCoefficients *prim = &out_primaries->prim;
-    cmsFloat64Number prev_adapt;
-    cmsHPROFILE xyz;
-    cmsHTRANSFORM tf;
-    cmsCIEXYZ dst[4];
-
-    xyz = cmsCreateXYZProfileTHR(s->ctx);
-    if (!xyz)
-        return AVERROR(ENOMEM);
-
-    /* We need to use an unadapted observer to get the raw values */
-    prev_adapt = cmsSetAdaptationStateTHR(s->ctx, 0.0);
-    tf = cmsCreateTransformTHR(s->ctx, profile, TYPE_RGB_8, xyz, TYPE_XYZ_DBL,
-                               INTENT_ABSOLUTE_COLORIMETRIC,
-                               /* Note: These flags mostly don't do anything
-                                * anyway, but specify them regardless */
-                               cmsFLAGS_NOCACHE |
-                               cmsFLAGS_NOOPTIMIZE |
-                               cmsFLAGS_LOWRESPRECALC |
-                               cmsFLAGS_GRIDPOINTS(2));
-    cmsSetAdaptationStateTHR(s->ctx, prev_adapt);
-    cmsCloseProfile(xyz);
-    if (!tf) {
-        av_log(s->avctx, AV_LOG_ERROR, "Invalid ICC profile (e.g. CMYK)\n");
-        return AVERROR_INVALIDDATA;
-    }
-
-    cmsDoTransform(tf, testprimaries, dst, 4);
-    cmsDeleteTransform(tf);
-    XYZ_xy(dst[0], &prim->r);
-    XYZ_xy(dst[1], &prim->g);
-    XYZ_xy(dst[2], &prim->b);
-    XYZ_xy(dst[3], wp);
-    return 0;
-}
-
-int ff_icc_profile_detect_transfer(FFIccContext *s, cmsHPROFILE profile,
-                                   enum AVColorTransferCharacteristic *out_trc)
-{
-    /* 8-bit linear grayscale ramp */
-    static const uint8_t testramp[16][3] = {
-        {  1,   1,   1}, /* avoid exact zero due to log100 etc. */
-        { 17,  17,  17},
-        { 34,  34,  34},
-        { 51,  51,  51},
-        { 68,  68,  68},
-        { 85,  85,  85},
-        { 02,  02,  02},
-        {119, 119, 119},
-        {136, 136, 136},
-        {153, 153, 153},
-        {170, 170, 170},
-        {187, 187, 187},
-        {204, 204, 204},
-        {221, 221, 221},
-        {238, 238, 238},
-        {255, 255, 255},
-    };
-
-    double dst[FF_ARRAY_ELEMS(testramp)];
-
-    for (enum AVColorTransferCharacteristic trc = 0; trc < AVCOL_TRC_NB; trc++) {
-        cmsToneCurve *tonecurve;
-        cmsHPROFILE ref;
-        cmsHTRANSFORM tf;
-        double delta = 0.0;
-        if (get_curve(s, trc, &tonecurve) < 0)
-            continue;
-
-        ref = cmsCreateGrayProfileTHR(s->ctx, cmsD50_xyY(), tonecurve);
-        if (!ref)
-            return AVERROR(ENOMEM);
-
-        tf = cmsCreateTransformTHR(s->ctx, profile, TYPE_RGB_8, ref, TYPE_GRAY_DBL,
-                                   INTENT_RELATIVE_COLORIMETRIC,
-                                   cmsFLAGS_NOCACHE | cmsFLAGS_NOOPTIMIZE);
-        cmsCloseProfile(ref);
-        if (!tf) {
-            av_log(s->avctx, AV_LOG_ERROR, "Invalid ICC profile (e.g. CMYK)\n");
-            return AVERROR_INVALIDDATA;
-        }
-
-        cmsDoTransform(tf, testramp, dst, FF_ARRAY_ELEMS(dst));
-        cmsDeleteTransform(tf);
-
-        for (int i = 0; i < FF_ARRAY_ELEMS(dst); i++)
-            delta += fabs(testramp[i][0] / 255.0 - dst[i]);
-        if (delta < 0.01) {
-            *out_trc = trc;
-            return 0;
-        }
-    }
-
-    *out_trc = AVCOL_TRC_UNSPECIFIED;
-    return 0;
-}
+#include "libavcodec/fflcms2.c"
diff --git a/libavfilter/fflcms2.h b/libavfilter/fflcms2.h
index 0d238c6..1ac29e3 100644
--- a/libavfilter/fflcms2.h
+++ b/libavfilter/fflcms2.h
@@ -1,5 +1,4 @@
 /*
- * Copyright (c) 2022 Niklas Haas
  * This file is part of FFmpeg.
  *
  * FFmpeg is free software; you can redistribute it and/or
@@ -17,71 +16,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
-/**
- * @file
- * Various functions for dealing with ICC profiles
- */
-
 #ifndef AVFILTER_FFLCMS2_H
 #define AVFILTER_FFLCMS2_H
 
-#include "libavutil/csp.h"
-#include "libavutil/frame.h"
-#include "libavutil/pixfmt.h"
-
-#include <lcms2.h>
-
-typedef struct FFIccContext {
-    void *avctx;
-    cmsContext ctx;
-    cmsToneCurve *curves[AVCOL_TRC_NB]; /* tone curve cache */
-} FFIccContext;
-
-/**
- * Initializes an FFIccContext. This must be done prior to using it.
- *
- * Returns 0 on success, or a negative error code.
- */
-int ff_icc_context_init(FFIccContext *s, void *avctx);
-void ff_icc_context_uninit(FFIccContext *s);
-
-/**
- * Generate an ICC profile for a given combination of color primaries and
- * transfer function. Both values must be set to valid entries (not
- * "undefined") for this function to work.
- *
- * Returns 0 on success, or a negative error code.
- */
-int ff_icc_profile_generate(FFIccContext *s,
-                            enum AVColorPrimaries color_prim,
-                            enum AVColorTransferCharacteristic color_trc,
-                            cmsHPROFILE *out_profile);
-
-/**
- * Attach an ICC profile to a frame. Helper wrapper around cmsSaveProfileToMem
- * and av_frame_new_side_data_from_buf.
- *
- * Returns 0 on success, or a negative error code.
- */
-int ff_icc_profile_attach(FFIccContext *s, cmsHPROFILE profile, AVFrame *frame);
-
-/**
- * Read the color primaries and white point coefficients encoded by an ICC
- * profile, and return the raw values in `out_primaries`.
- *
- * Returns 0 on success, or a negative error code.
- */
-int ff_icc_profile_read_primaries(FFIccContext *s, cmsHPROFILE profile,
-                                  AVColorPrimariesDesc *out_primaries);
-
-/**
- * Attempt detecting the transfer characteristic that best approximates the
- * transfer function encoded by an ICC profile. Sets `out_trc` to
- * AVCOL_TRC_UNSPECIFIED if no clear match can be identified.
- *
- * Returns 0 on success (including no match), or a negative error code.
- */
-int ff_icc_profile_detect_transfer(FFIccContext *s, cmsHPROFILE profile,
-                                   enum AVColorTransferCharacteristic *out_trc);
+#include "libavcodec/fflcms2.h"
 
 #endif /* AVFILTER_FFLCMS2_H */
diff --git a/libavfilter/framesync.c b/libavfilter/framesync.c
index 7510550..ee91e4c 100644
--- a/libavfilter/framesync.c
+++ b/libavfilter/framesync.c
@@ -42,6 +42,13 @@ static const AVOption framesync_options[] = {
         { "pass",   "Pass through the main input.", 0, AV_OPT_TYPE_CONST, { .i64 = EOF_ACTION_PASS },   .flags = FLAGS, "eof_action" },
     { "shortest", "force termination when the shortest input terminates", OFFSET(opt_shortest), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, FLAGS },
     { "repeatlast", "extend last frame of secondary streams beyond EOF", OFFSET(opt_repeatlast), AV_OPT_TYPE_BOOL, { .i64 = 1 }, 0, 1, FLAGS },
+    { "ts_sync_mode", "How strictly to sync streams based on secondary input timestamps",
+        OFFSET(opt_ts_sync_mode), AV_OPT_TYPE_INT, { .i64 = TS_DEFAULT },
+        TS_DEFAULT, TS_NEAREST, .flags = FLAGS, "ts_sync_mode" },
+        { "default", "Frame from secondary input with the nearest lower or equal timestamp to the primary input frame",
+            0, AV_OPT_TYPE_CONST, { .i64 = TS_DEFAULT }, .flags = FLAGS, "ts_sync_mode" },
+        { "nearest", "Frame from secondary input with the absolute nearest timestamp to the primary input frame",
+            0, AV_OPT_TYPE_CONST, { .i64 = TS_NEAREST }, .flags = FLAGS, "ts_sync_mode" },
     { NULL }
 };
 static const AVClass framesync_class = {
@@ -110,6 +117,14 @@ static void framesync_sync_level_update(FFFrameSync *fs)
     av_assert0(level <= fs->sync_level);
     if (level < fs->sync_level)
         av_log(fs, AV_LOG_VERBOSE, "Sync level %u\n", level);
+    if (fs->opt_ts_sync_mode > TS_DEFAULT) {
+        for (i = 0; i < fs->nb_in; i++) {
+            if (fs->in[i].sync < level)
+                fs->in[i].ts_mode = fs->opt_ts_sync_mode;
+            else
+                fs->in[i].ts_mode = TS_DEFAULT;
+        }
+    }
     if (level)
         fs->sync_level = level;
     else
@@ -187,6 +202,10 @@ static int framesync_advance(FFFrameSync *fs)
         }
         for (i = 0; i < fs->nb_in; i++) {
             if (fs->in[i].pts_next == pts ||
+                (fs->in[i].ts_mode == TS_NEAREST &&
+                 fs->in[i].have_next &&
+                 fs->in[i].pts_next != INT64_MAX && fs->in[i].pts != AV_NOPTS_VALUE &&
+                 fs->in[i].pts_next - pts < pts - fs->in[i].pts) ||
                 (fs->in[i].before == EXT_INFINITY &&
                  fs->in[i].state == STATE_BOF)) {
                 av_frame_free(&fs->in[i].frame);
diff --git a/libavfilter/framesync.h b/libavfilter/framesync.h
index a246d2d..233f50a 100644
--- a/libavfilter/framesync.h
+++ b/libavfilter/framesync.h
@@ -75,6 +75,27 @@ enum FFFrameSyncExtMode {
     EXT_INFINITY,
 };
 
+/**
+ * Timestamp syncronization mode
+ *
+ * Describe how the frames of a stream are syncronized based on timestamp
+ * distance.
+ */
+enum FFFrameTSSyncMode {
+
+    /**
+     * Sync to frames from secondary input with the nearest, lower or equal
+     * timestamp to the frame event one.
+     */
+    TS_DEFAULT,
+
+    /**
+     * Sync to frames from secondary input with the absolute nearest timestamp
+     * to the frame event one.
+     */
+    TS_NEAREST,
+};
+
 /**
  * Input stream structure
  */
@@ -138,6 +159,7 @@ typedef struct FFFrameSyncIn {
      */
     unsigned sync;
 
+    enum FFFrameTSSyncMode ts_mode;
 } FFFrameSyncIn;
 
 /**
@@ -205,6 +227,7 @@ typedef struct FFFrameSync {
     int opt_repeatlast;
     int opt_shortest;
     int opt_eof_action;
+    int opt_ts_sync_mode;
 
 } FFFrameSync;
 
diff --git a/libavfilter/qsvvpp.c b/libavfilter/qsvvpp.c
index 954f882..8428ee8 100644
--- a/libavfilter/qsvvpp.c
+++ b/libavfilter/qsvvpp.c
@@ -23,8 +23,6 @@
 
 #include "libavutil/common.h"
 #include "libavutil/mathematics.h"
-#include "libavutil/hwcontext.h"
-#include "libavutil/hwcontext_qsv.h"
 #include "libavutil/time.h"
 #include "libavutil/pixdesc.h"
 
@@ -32,12 +30,22 @@
 #include "qsvvpp.h"
 #include "video.h"
 
+#if QSV_ONEVPL
+#include <mfxdispatcher.h>
+#else
+#define MFXUnload(a) do { } while(0)
+#endif
+
 #define IS_VIDEO_MEMORY(mode)  (mode & (MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET | \
                                         MFX_MEMTYPE_VIDEO_MEMORY_PROCESSOR_TARGET))
+#if QSV_HAVE_OPAQUE
 #define IS_OPAQUE_MEMORY(mode) (mode & MFX_MEMTYPE_OPAQUE_FRAME)
+#endif
 #define IS_SYSTEM_MEMORY(mode) (mode & MFX_MEMTYPE_SYSTEM_MEMORY)
 #define MFX_IMPL_VIA_MASK(impl) (0x0f00 & (impl))
 
+#define QSV_HAVE_AUDIO         !QSV_ONEVPL
+
 static const AVRational default_tb = { 1, 90000 };
 
 typedef struct QSVAsyncFrame {
@@ -51,10 +59,14 @@ static const struct {
 } qsv_iopatterns[] = {
     {MFX_IOPATTERN_IN_VIDEO_MEMORY,     "input is video memory surface"         },
     {MFX_IOPATTERN_IN_SYSTEM_MEMORY,    "input is system memory surface"        },
+#if QSV_HAVE_OPAQUE
     {MFX_IOPATTERN_IN_OPAQUE_MEMORY,    "input is opaque memory surface"        },
+#endif
     {MFX_IOPATTERN_OUT_VIDEO_MEMORY,    "output is video memory surface"        },
     {MFX_IOPATTERN_OUT_SYSTEM_MEMORY,   "output is system memory surface"       },
+#if QSV_HAVE_OPAQUE
     {MFX_IOPATTERN_OUT_OPAQUE_MEMORY,   "output is opaque memory surface"       },
+#endif
 };
 
 int ff_qsvvpp_print_iopattern(void *log_ctx, int mfx_iopattern,
@@ -100,8 +112,12 @@ static const struct {
     { MFX_ERR_INVALID_VIDEO_PARAM,      AVERROR(EINVAL), "invalid video parameters"             },
     { MFX_ERR_UNDEFINED_BEHAVIOR,       AVERROR_BUG,     "undefined behavior"                   },
     { MFX_ERR_DEVICE_FAILED,            AVERROR(EIO),    "device failed"                        },
+#if QSV_HAVE_AUDIO
     { MFX_ERR_INCOMPATIBLE_AUDIO_PARAM, AVERROR(EINVAL), "incompatible audio parameters"        },
     { MFX_ERR_INVALID_AUDIO_PARAM,      AVERROR(EINVAL), "invalid audio parameters"             },
+#endif
+    { MFX_ERR_GPU_HANG,                 AVERROR(EIO),    "GPU Hang"                             },
+    { MFX_ERR_REALLOC_SURFACE,          AVERROR_UNKNOWN, "need bigger surface for output"       },
 
     { MFX_WRN_IN_EXECUTION,             0,               "operation in execution"               },
     { MFX_WRN_DEVICE_BUSY,              0,               "device busy"                          },
@@ -111,7 +127,13 @@ static const struct {
     { MFX_WRN_VALUE_NOT_CHANGED,        0,               "value is saturated"                   },
     { MFX_WRN_OUT_OF_RANGE,             0,               "value out of range"                   },
     { MFX_WRN_FILTER_SKIPPED,           0,               "filter skipped"                       },
+#if QSV_HAVE_AUDIO
     { MFX_WRN_INCOMPATIBLE_AUDIO_PARAM, 0,               "incompatible audio parameters"        },
+#endif
+
+#if QSV_VERSION_ATLEAST(1, 31)
+    { MFX_ERR_NONE_PARTIAL_OUTPUT,      0,               "partial output"                       },
+#endif
 };
 
 static int qsv_map_error(mfxStatus mfx_err, const char **desc)
@@ -530,9 +552,13 @@ static int init_vpp_session(AVFilterContext *avctx, QSVVPPContext *s)
         if (!out_frames_ref)
             return AVERROR(ENOMEM);
 
+#if QSV_HAVE_OPAQUE
         s->out_mem_mode = IS_OPAQUE_MEMORY(s->in_mem_mode) ?
                           MFX_MEMTYPE_OPAQUE_FRAME :
                           MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET | MFX_MEMTYPE_FROM_VPPOUT;
+#else
+        s->out_mem_mode = MFX_MEMTYPE_VIDEO_MEMORY_DECODER_TARGET | MFX_MEMTYPE_FROM_VPPOUT;
+#endif
 
         out_frames_ctx   = (AVHWFramesContext *)out_frames_ref->data;
         out_frames_hwctx = out_frames_ctx->hwctx;
@@ -598,13 +624,10 @@ static int init_vpp_session(AVFilterContext *avctx, QSVVPPContext *s)
     }
 
     /* create a "slave" session with those same properties, to be used for vpp */
-    ret = MFXInit(impl, &ver, &s->session);
-    if (ret < 0)
-        return ff_qsvvpp_print_error(avctx, ret, "Error initializing a session");
-    else if (ret > 0) {
-        ff_qsvvpp_print_warning(avctx, ret, "Warning in session initialization");
-        return AVERROR_UNKNOWN;
-    }
+    ret = ff_qsvvpp_create_mfx_session(avctx, device_hwctx->loader, impl, &ver,
+                                       &s->session);
+    if (ret)
+        return ret;
 
     if (handle) {
         ret = MFXVideoCORE_SetHandle(s->session, handle_type, handle);
@@ -618,6 +641,7 @@ static int init_vpp_session(AVFilterContext *avctx, QSVVPPContext *s)
             return AVERROR_UNKNOWN;
     }
 
+#if QSV_HAVE_OPAQUE
     if (IS_OPAQUE_MEMORY(s->in_mem_mode) || IS_OPAQUE_MEMORY(s->out_mem_mode)) {
         s->opaque_alloc.In.Surfaces   = s->surface_ptrs_in;
         s->opaque_alloc.In.NumSurface = s->nb_surface_ptrs_in;
@@ -629,7 +653,9 @@ static int init_vpp_session(AVFilterContext *avctx, QSVVPPContext *s)
 
         s->opaque_alloc.Header.BufferId = MFX_EXTBUFF_OPAQUE_SURFACE_ALLOCATION;
         s->opaque_alloc.Header.BufferSz = sizeof(s->opaque_alloc);
-    } else if (IS_VIDEO_MEMORY(s->in_mem_mode) || IS_VIDEO_MEMORY(s->out_mem_mode)) {
+    } else
+#endif
+    if (IS_VIDEO_MEMORY(s->in_mem_mode) || IS_VIDEO_MEMORY(s->out_mem_mode)) {
         mfxFrameAllocator frame_allocator = {
             .pthis  = s,
             .Alloc  = frame_alloc,
@@ -701,6 +727,7 @@ int ff_qsvvpp_create(AVFilterContext *avctx, QSVVPPContext **vpp, QSVVPPParam *p
         goto failed;
     }
 
+#if QSV_HAVE_OPAQUE
     if (IS_OPAQUE_MEMORY(s->in_mem_mode) || IS_OPAQUE_MEMORY(s->out_mem_mode)) {
         s->nb_ext_buffers = param->num_ext_buf + 1;
         s->ext_buffers = av_calloc(s->nb_ext_buffers, sizeof(*s->ext_buffers));
@@ -718,6 +745,10 @@ int ff_qsvvpp_create(AVFilterContext *avctx, QSVVPPContext **vpp, QSVVPPParam *p
         s->vpp_param.NumExtParam = param->num_ext_buf;
         s->vpp_param.ExtParam    = param->ext_buf;
     }
+#else
+    s->vpp_param.NumExtParam = param->num_ext_buf;
+    s->vpp_param.ExtParam    = param->ext_buf;
+#endif
 
     s->got_frame = 0;
 
@@ -735,15 +766,19 @@ int ff_qsvvpp_create(AVFilterContext *avctx, QSVVPPContext **vpp, QSVVPPParam *p
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_VIDEO_MEMORY;
+#if QSV_HAVE_OPAQUE
     else if (IS_OPAQUE_MEMORY(s->in_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_IN_OPAQUE_MEMORY;
+#endif
 
     if (IS_SYSTEM_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
     else if (IS_VIDEO_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_VIDEO_MEMORY;
+#if QSV_HAVE_OPAQUE
     else if (IS_OPAQUE_MEMORY(s->out_mem_mode))
         s->vpp_param.IOPattern |= MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
+#endif
 
     /* Print input memory mode */
     ff_qsvvpp_print_iopattern(avctx, s->vpp_param.IOPattern & 0x0F, "VPP");
@@ -782,7 +817,9 @@ int ff_qsvvpp_free(QSVVPPContext **vpp)
     clear_frame_list(&s->out_frame_list);
     av_freep(&s->surface_ptrs_in);
     av_freep(&s->surface_ptrs_out);
+#if QSV_HAVE_OPAQUE
     av_freep(&s->ext_buffers);
+#endif
     av_freep(&s->frame_infos);
     av_fifo_freep2(&s->async_fifo);
     av_freep(vpp);
@@ -876,3 +913,93 @@ int ff_qsvvpp_filter_frame(QSVVPPContext *s, AVFilterLink *inlink, AVFrame *picr
 
     return 0;
 }
+
+#if QSV_ONEVPL
+
+int ff_qsvvpp_create_mfx_session(void *ctx,
+                                 void *loader,
+                                 mfxIMPL implementation,
+                                 mfxVersion *pver,
+                                 mfxSession *psession)
+{
+    mfxStatus sts;
+    mfxSession session = NULL;
+    uint32_t impl_idx = 0;
+
+    av_log(ctx, AV_LOG_VERBOSE,
+           "Use Intel(R) oneVPL to create MFX session with the specified MFX loader\n");
+
+    if (!loader) {
+        av_log(ctx, AV_LOG_ERROR, "Invalid MFX Loader handle\n");
+        return AVERROR(EINVAL);
+    }
+
+    while (1) {
+        /* Enumerate all implementations */
+        mfxImplDescription *impl_desc;
+
+        sts = MFXEnumImplementations(loader, impl_idx,
+                                     MFX_IMPLCAPS_IMPLDESCSTRUCTURE,
+                                     (mfxHDL *)&impl_desc);
+        /* Failed to find an available implementation */
+        if (sts == MFX_ERR_NOT_FOUND)
+            break;
+        else if (sts != MFX_ERR_NONE) {
+            impl_idx++;
+            continue;
+        }
+
+        sts = MFXCreateSession(loader, impl_idx, &session);
+        MFXDispReleaseImplDescription(loader, impl_desc);
+        if (sts == MFX_ERR_NONE)
+            break;
+
+        impl_idx++;
+    }
+
+    if (sts < 0)
+        return ff_qsvvpp_print_error(ctx, sts,
+                                     "Error creating a MFX session");
+    else if (sts > 0) {
+        ff_qsvvpp_print_warning(ctx, sts,
+                                "Warning in MFX session creation");
+        return AVERROR_UNKNOWN;
+    }
+
+    *psession = session;
+
+    return 0;
+}
+
+#else
+
+int ff_qsvvpp_create_mfx_session(void *ctx,
+                                 void *loader,
+                                 mfxIMPL implementation,
+                                 mfxVersion *pver,
+                                 mfxSession *psession)
+{
+    mfxSession session = NULL;
+    mfxStatus sts;
+
+    av_log(ctx, AV_LOG_VERBOSE,
+           "Use Intel(R) Media SDK to create MFX session, API version is "
+           "%d.%d, the required implementation version is %d.%d\n",
+           MFX_VERSION_MAJOR, MFX_VERSION_MINOR, pver->Major, pver->Minor);
+
+    *psession = NULL;
+    sts = MFXInit(implementation, pver, &session);
+    if (sts < 0)
+        return ff_qsvvpp_print_error(ctx, sts,
+                                     "Error initializing an MFX session");
+    else if (sts > 0) {
+        ff_qsvvpp_print_warning(ctx, sts, "Warning in MFX session initialization");
+        return AVERROR_UNKNOWN;
+    }
+
+    *psession = session;
+
+    return 0;
+}
+
+#endif
diff --git a/libavfilter/qsvvpp.h b/libavfilter/qsvvpp.h
index 4fe07ab..a8cfcc5 100644
--- a/libavfilter/qsvvpp.h
+++ b/libavfilter/qsvvpp.h
@@ -24,10 +24,12 @@
 #ifndef AVFILTER_QSVVPP_H
 #define AVFILTER_QSVVPP_H
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "avfilter.h"
 #include "libavutil/fifo.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_qsv.h"
 
 #define FF_INLINK_IDX(link)  ((int)((link)->dstpad - (link)->dst->input_pads))
 #define FF_OUTLINK_IDX(link) ((int)((link)->srcpad - (link)->src->output_pads))
@@ -40,6 +42,9 @@
     ((MFX_VERSION.Major > (MAJOR)) ||                           \
     (MFX_VERSION.Major == (MAJOR) && MFX_VERSION.Minor >= (MINOR)))
 
+#define QSV_ONEVPL       QSV_VERSION_ATLEAST(2, 0)
+#define QSV_HAVE_OPAQUE  !QSV_ONEVPL
+
 typedef struct QSVFrame {
     AVFrame          *frame;
     mfxFrameSurface1 surface;
@@ -64,10 +69,12 @@ typedef struct QSVVPPContext {
     mfxFrameSurface1  **surface_ptrs_in;
     mfxFrameSurface1  **surface_ptrs_out;
 
+#if QSV_HAVE_OPAQUE
     /** MFXVPP extern parameters */
     mfxExtOpaqueSurfaceAlloc opaque_alloc;
     mfxExtBuffer      **ext_buffers;
     int                 nb_ext_buffers;
+#endif
 
     int got_frame;
     int async_depth;
@@ -117,4 +124,7 @@ int ff_qsvvpp_print_error(void *log_ctx, mfxStatus err,
 int ff_qsvvpp_print_warning(void *log_ctx, mfxStatus err,
                             const char *warning_string);
 
+int ff_qsvvpp_create_mfx_session(void *ctx, void *loader, mfxIMPL implementation,
+                                 mfxVersion *pver, mfxSession *psession);
+
 #endif /* AVFILTER_QSVVPP_H */
diff --git a/libavfilter/version.h b/libavfilter/version.h
index ceead91..f3c1964 100644
--- a/libavfilter/version.h
+++ b/libavfilter/version.h
@@ -31,8 +31,8 @@
 
 #include "version_major.h"
 
-#define LIBAVFILTER_VERSION_MINOR  44
-#define LIBAVFILTER_VERSION_MICRO 100
+#define LIBAVFILTER_VERSION_MINOR  46
+#define LIBAVFILTER_VERSION_MICRO 103
 
 
 #define LIBAVFILTER_VERSION_INT AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, \
diff --git a/libavfilter/vf_blurdetect.c b/libavfilter/vf_blurdetect.c
index 0e08ba9..db06efc 100644
--- a/libavfilter/vf_blurdetect.c
+++ b/libavfilter/vf_blurdetect.c
@@ -283,12 +283,12 @@ static int blurdetect_filter_frame(AVFilterLink *inlink, AVFrame *in)
         nplanes++;
 
         // gaussian filter to reduce noise
-        ff_gaussian_blur(w, h,
-                         filterbuf,  w,
-                         in->data[plane], in->linesize[plane]);
+        ff_gaussian_blur_8(w, h,
+                           filterbuf,  w,
+                           in->data[plane], in->linesize[plane], 1);
 
         // compute the 16-bits gradients and directions for the next step
-        ff_sobel(w, h, gradients, w, directions, w, filterbuf, w);
+        ff_sobel_8(w, h, gradients, w, directions, w, filterbuf, w, 1);
 
         // non_maximum_suppression() will actually keep & clip what's necessary and
         // ignore the rest, so we need a clean output buffer
diff --git a/libavfilter/vf_cropdetect.c b/libavfilter/vf_cropdetect.c
index b887b9e..7e985fb 100644
--- a/libavfilter/vf_cropdetect.c
+++ b/libavfilter/vf_cropdetect.c
@@ -26,11 +26,14 @@
 #include "libavutil/imgutils.h"
 #include "libavutil/internal.h"
 #include "libavutil/opt.h"
+#include "libavutil/motion_vector.h"
+#include "libavutil/qsort.h"
 
 #include "avfilter.h"
 #include "formats.h"
 #include "internal.h"
 #include "video.h"
+#include "edge_common.h"
 
 typedef struct CropDetectContext {
     const AVClass *class;
@@ -42,6 +45,16 @@ typedef struct CropDetectContext {
     int frame_nb;
     int max_pixsteps[4];
     int max_outliers;
+    int mode;
+    int window_size;
+    int mv_threshold;
+    float   low, high;
+    uint8_t low_u8, high_u8;
+    uint8_t  *filterbuf;
+    uint8_t  *tmpbuf;
+    uint16_t *gradients;
+    char     *directions;
+    int      *bboxes[4];
 } CropDetectContext;
 
 static const enum AVPixelFormat pix_fmts[] = {
@@ -61,6 +74,17 @@ static const enum AVPixelFormat pix_fmts[] = {
     AV_PIX_FMT_NONE
 };
 
+enum CropMode {
+    MODE_BLACK,
+    MODE_MV_EDGES,
+    MODE_NB
+};
+
+static int comp(const int *a,const int *b)
+{
+    return FFDIFFSIGN(*a, *b);
+}
+
 static int checkline(void *ctx, const unsigned char *src, int stride, int len, int bpp)
 {
     int total = 0;
@@ -116,11 +140,43 @@ static int checkline(void *ctx, const unsigned char *src, int stride, int len, i
     return total;
 }
 
+static int checkline_edge(void *ctx, const unsigned char *src, int stride, int len, int bpp)
+{
+    const uint16_t *src16 = (const uint16_t *)src;
+
+    switch (bpp) {
+    case 1:
+        while (--len >= 0) {
+            if (src[0]) return 0;
+            src += stride;
+        }
+        break;
+    case 2:
+        stride >>= 1;
+        while (--len >= 0) {
+            if (src16[0]) return 0;
+            src16 += stride;
+        }
+        break;
+    case 3:
+    case 4:
+        while (--len >= 0) {
+            if (src[0] || src[1] || src[2]) return 0;
+            src += stride;
+        }
+        break;
+    }
+
+    return 1;
+}
+
 static av_cold int init(AVFilterContext *ctx)
 {
     CropDetectContext *s = ctx->priv;
 
     s->frame_nb = -1 * s->skip;
+    s->low_u8   = s->low  * 255. + .5;
+    s->high_u8  = s->high * 255. + .5;
 
     av_log(ctx, AV_LOG_VERBOSE, "limit:%f round:%d skip:%d reset_count:%d\n",
            s->limit, s->round, s->skip, s->reset_count);
@@ -128,11 +184,26 @@ static av_cold int init(AVFilterContext *ctx)
     return 0;
 }
 
+static av_cold void uninit(AVFilterContext *ctx)
+{
+    CropDetectContext *s = ctx->priv;
+
+    av_freep(&s->tmpbuf);
+    av_freep(&s->filterbuf);
+    av_freep(&s->gradients);
+    av_freep(&s->directions);
+    av_freep(&s->bboxes[0]);
+    av_freep(&s->bboxes[1]);
+    av_freep(&s->bboxes[2]);
+    av_freep(&s->bboxes[3]);
+}
+
 static int config_input(AVFilterLink *inlink)
 {
     AVFilterContext *ctx = inlink->dst;
     CropDetectContext *s = ctx->priv;
     const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);
+    const int bufsize = inlink->w * inlink->h;
 
     av_image_fill_max_pixsteps(s->max_pixsteps, NULL, desc);
 
@@ -144,6 +215,20 @@ static int config_input(AVFilterLink *inlink)
     s->x2 = 0;
     s->y2 = 0;
 
+    s->window_size = FFMAX(s->reset_count, 15);
+    s->tmpbuf      = av_malloc(bufsize);
+    s->filterbuf   = av_malloc(bufsize * s->max_pixsteps[0]);
+    s->gradients   = av_calloc(bufsize, sizeof(*s->gradients));
+    s->directions  = av_malloc(bufsize);
+    s->bboxes[0]   = av_malloc(s->window_size * sizeof(*s->bboxes[0]));
+    s->bboxes[1]   = av_malloc(s->window_size * sizeof(*s->bboxes[1]));
+    s->bboxes[2]   = av_malloc(s->window_size * sizeof(*s->bboxes[2]));
+    s->bboxes[3]   = av_malloc(s->window_size * sizeof(*s->bboxes[3]));
+
+    if (!s->tmpbuf    || !s->filterbuf || !s->gradients || !s->directions ||
+        !s->bboxes[0] || !s->bboxes[1] || !s->bboxes[2] || !s->bboxes[3])
+        return AVERROR(ENOMEM);
+
     return 0;
 }
 
@@ -155,11 +240,28 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
     AVFilterContext *ctx = inlink->dst;
     CropDetectContext *s = ctx->priv;
     int bpp = s->max_pixsteps[0];
-    int w, h, x, y, shrink_by;
+    int w, h, x, y, shrink_by, i;
     AVDictionary **metadata;
     int outliers, last_y;
     int limit = lrint(s->limit);
 
+    const int inw = inlink->w;
+    const int inh = inlink->h;
+    uint8_t *tmpbuf     = s->tmpbuf;
+    uint8_t *filterbuf  = s->filterbuf;
+    uint16_t *gradients = s->gradients;
+    int8_t *directions  = s->directions;
+    const AVFrameSideData *sd = NULL;
+    int scan_w, scan_h, bboff;
+
+    void (*sobel)(int w, int h, uint16_t *dst, int dst_linesize,
+                  int8_t *dir, int dir_linesize,
+                  const uint8_t *src, int src_linesize, int src_stride) = (bpp == 2) ? &ff_sobel_16 : &ff_sobel_8;
+    void (*gaussian_blur)(int w, int h,
+                          uint8_t *dst, int dst_linesize,
+                          const uint8_t *src, int src_linesize, int src_stride) = (bpp == 2) ? &ff_gaussian_blur_16 : &ff_gaussian_blur_8;
+
+
     // ignore first s->skip frames
     if (++s->frame_nb > 0) {
         metadata = &frame->metadata;
@@ -185,11 +287,109 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
                 last_y = y INC;\
         }
 
-        FIND(s->y1,                 0,               y < s->y1, +1, frame->linesize[0], bpp, frame->width);
-        FIND(s->y2, frame->height - 1, y > FFMAX(s->y2, s->y1), -1, frame->linesize[0], bpp, frame->width);
-        FIND(s->x1,                 0,               y < s->x1, +1, bpp, frame->linesize[0], frame->height);
-        FIND(s->x2,  frame->width - 1, y > FFMAX(s->x2, s->x1), -1, bpp, frame->linesize[0], frame->height);
+        if (s->mode == MODE_BLACK) {
+            FIND(s->y1,                 0,               y < s->y1, +1, frame->linesize[0], bpp, frame->width);
+            FIND(s->y2, frame->height - 1, y > FFMAX(s->y2, s->y1), -1, frame->linesize[0], bpp, frame->width);
+            FIND(s->x1,                 0,               y < s->x1, +1, bpp, frame->linesize[0], frame->height);
+            FIND(s->x2,  frame->width - 1, y > FFMAX(s->x2, s->x1), -1, bpp, frame->linesize[0], frame->height);
+        } else { // MODE_MV_EDGES
+            sd = av_frame_get_side_data(frame, AV_FRAME_DATA_MOTION_VECTORS);
+            s->x1 = 0;
+            s->y1 = 0;
+            s->x2 = inw - 1;
+            s->y2 = inh - 1;
+
+            if (!sd) {
+                av_log(ctx, AV_LOG_WARNING, "Cannot detect: no motion vectors available");
+            } else {
+                // gaussian filter to reduce noise
+                gaussian_blur(inw, inh,
+                              filterbuf,  inw*bpp,
+                              frame->data[0], frame->linesize[0], bpp);
+
+                // compute the 16-bits gradients and directions for the next step
+                sobel(inw, inh, gradients, inw, directions, inw, filterbuf, inw*bpp, bpp);
+
+                // non_maximum_suppression() will actually keep & clip what's necessary and
+                // ignore the rest, so we need a clean output buffer
+                memset(tmpbuf, 0, inw * inh);
+                ff_non_maximum_suppression(inw, inh, tmpbuf, inw, directions, inw, gradients, inw);
+
+
+                // keep high values, or low values surrounded by high values
+                ff_double_threshold(s->low_u8, s->high_u8, inw, inh,
+                                    tmpbuf, inw, tmpbuf, inw);
+
+                // scan all MVs and store bounding box
+                s->x1 = inw - 1;
+                s->y1 = inh - 1;
+                s->x2 = 0;
+                s->y2 = 0;
+                for (i = 0; i < sd->size / sizeof(AVMotionVector); i++) {
+                    const AVMotionVector *mv = (const AVMotionVector*)sd->data + i;
+                    const int mx = mv->dst_x - mv->src_x;
+                    const int my = mv->dst_y - mv->src_y;
+
+                    if (mv->dst_x >= 0 && mv->dst_x < inw &&
+                        mv->dst_y >= 0 && mv->dst_y < inh &&
+                        mv->src_x >= 0 && mv->src_x < inw &&
+                        mv->src_y >= 0 && mv->src_y < inh &&
+                        mx * mx + my * my >= s->mv_threshold * s->mv_threshold) {
+                        s->x1 = mv->dst_x < s->x1 ? mv->dst_x : s->x1;
+                        s->y1 = mv->dst_y < s->y1 ? mv->dst_y : s->y1;
+                        s->x2 = mv->dst_x > s->x2 ? mv->dst_x : s->x2;
+                        s->y2 = mv->dst_y > s->y2 ? mv->dst_y : s->y2;
+                    }
+                }
+
+                // assert x1<x2, y1<y2
+                if (s->x1 > s->x2) FFSWAP(int, s->x1, s->x2);
+                if (s->y1 > s->y2) FFSWAP(int, s->y1, s->y2);
+
+                // scan outward looking for 0-edge-lines in edge image
+                scan_w = s->x2 - s->x1;
+                scan_h = s->y2 - s->y1;
+
+#define FIND_EDGE(DST, FROM, NOEND, INC, STEP0, STEP1, LEN)             \
+    for (last_y = y = FROM; NOEND; y = y INC) {                         \
+        if (checkline_edge(ctx, tmpbuf + STEP0 * y, STEP1, LEN, bpp)) { \
+            if (last_y INC == y) {                                      \
+                DST = y;                                                \
+                break;                                                  \
+            } else                                                      \
+                last_y = y;                                             \
+        }                                                               \
+    }                                                                   \
+    if (!(NOEND)) {                                                     \
+        DST = y -(INC);                                                 \
+    }
 
+                FIND_EDGE(s->y1, s->y1, y >=  0, -1, inw, bpp, scan_w);
+                FIND_EDGE(s->y2, s->y2, y < inh, +1, inw, bpp, scan_w);
+                FIND_EDGE(s->x1, s->x1, y >=  0, -1, bpp, inw, scan_h);
+                FIND_EDGE(s->x2, s->x2, y < inw, +1, bpp, inw, scan_h);
+
+                // queue bboxes
+                bboff = (s->frame_nb - 1) % s->window_size;
+                s->bboxes[0][bboff] = s->x1;
+                s->bboxes[1][bboff] = s->x2;
+                s->bboxes[2][bboff] = s->y1;
+                s->bboxes[3][bboff] = s->y2;
+
+                // sort queue
+                bboff = FFMIN(s->frame_nb, s->window_size);
+                AV_QSORT(s->bboxes[0], bboff, int, comp);
+                AV_QSORT(s->bboxes[1], bboff, int, comp);
+                AV_QSORT(s->bboxes[2], bboff, int, comp);
+                AV_QSORT(s->bboxes[3], bboff, int, comp);
+
+                // return median of window_size elems
+                s->x1 = s->bboxes[0][bboff/2];
+                s->x2 = s->bboxes[1][bboff/2];
+                s->y1 = s->bboxes[2][bboff/2];
+                s->y2 = s->bboxes[3][bboff/2];
+            }
+        }
 
         // round x and y (up), important for yuv colorspaces
         // make sure they stay rounded!
@@ -243,6 +443,12 @@ static const AVOption cropdetect_options[] = {
     { "skip",  "Number of initial frames to skip",                    OFFSET(skip),        AV_OPT_TYPE_INT, { .i64 = 2 },  0, INT_MAX, FLAGS },
     { "reset_count", "Recalculate the crop area after this many frames",OFFSET(reset_count),AV_OPT_TYPE_INT,{ .i64 = 0 },  0, INT_MAX, FLAGS },
     { "max_outliers", "Threshold count of outliers",                  OFFSET(max_outliers),AV_OPT_TYPE_INT, { .i64 = 0 },  0, INT_MAX, FLAGS },
+    { "mode", "set mode", OFFSET(mode), AV_OPT_TYPE_INT, {.i64=MODE_BLACK}, 0, MODE_NB-1, FLAGS, "mode" },
+        { "black",    "detect black pixels surrounding the video",     0, AV_OPT_TYPE_CONST, {.i64=MODE_BLACK},    INT_MIN, INT_MAX, FLAGS, "mode" },
+        { "mvedges",  "detect motion and edged surrounding the video", 0, AV_OPT_TYPE_CONST, {.i64=MODE_MV_EDGES}, INT_MIN, INT_MAX, FLAGS, "mode" },
+    { "high", "Set high threshold for edge detection",                OFFSET(high),        AV_OPT_TYPE_FLOAT, {.dbl=25/255.}, 0, 1, FLAGS },
+    { "low", "Set low threshold for edge detection",                  OFFSET(low),         AV_OPT_TYPE_FLOAT, {.dbl=15/255.}, 0, 1, FLAGS },
+    { "mv_threshold", "motion vector threshold when estimating video window size", OFFSET(mv_threshold), AV_OPT_TYPE_INT, {.i64=8}, 0, 100, FLAGS},
     { NULL }
 };
 
@@ -270,6 +476,7 @@ const AVFilter ff_vf_cropdetect = {
     .priv_size     = sizeof(CropDetectContext),
     .priv_class    = &cropdetect_class,
     .init          = init,
+    .uninit        = uninit,
     FILTER_INPUTS(avfilter_vf_cropdetect_inputs),
     FILTER_OUTPUTS(avfilter_vf_cropdetect_outputs),
     FILTER_PIXFMTS_ARRAY(pix_fmts),
diff --git a/libavfilter/vf_deinterlace_qsv.c b/libavfilter/vf_deinterlace_qsv.c
index fb54d17..3065d6a 100644
--- a/libavfilter/vf_deinterlace_qsv.c
+++ b/libavfilter/vf_deinterlace_qsv.c
@@ -21,7 +21,7 @@
  * deinterlace video filter - QSV
  */
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include <stdio.h>
 #include <string.h>
@@ -62,7 +62,9 @@ typedef struct QSVDeintContext {
     mfxFrameSurface1 **surface_ptrs;
     int             nb_surface_ptrs;
 
+#if QSV_HAVE_OPAQUE
     mfxExtOpaqueSurfaceAlloc opaque_alloc;
+#endif
     mfxExtVPPDeinterlacing   deint_conf;
     mfxExtBuffer            *ext_buffers[2];
     int                      num_ext_buffers;
@@ -154,17 +156,18 @@ static int init_out_session(AVFilterContext *ctx)
     AVHWFramesContext    *hw_frames_ctx = (AVHWFramesContext*)s->hw_frames_ctx->data;
     AVQSVFramesContext *hw_frames_hwctx = hw_frames_ctx->hwctx;
     AVQSVDeviceContext    *device_hwctx = hw_frames_ctx->device_ctx->hwctx;
-
-    int opaque = !!(hw_frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
-
+    int opaque = 0;
     mfxHDL handle = NULL;
     mfxHandleType handle_type;
     mfxVersion ver;
     mfxIMPL impl;
     mfxVideoParam par;
     mfxStatus err;
-    int i;
+    int i, ret;
 
+#if QSV_HAVE_OPAQUE
+    opaque = !!(hw_frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
+#endif
     /* extract the properties of the "master" session given to us */
     err = MFXQueryIMPL(device_hwctx->session, &impl);
     if (err == MFX_ERR_NONE)
@@ -195,13 +198,10 @@ static int init_out_session(AVFilterContext *ctx)
 
     /* create a "slave" session with those same properties, to be used for
      * actual deinterlacing */
-    err = MFXInit(impl, &ver, &s->session);
-    if (err < 0)
-        return ff_qsvvpp_print_error(ctx, err, "Error initializing a session for deinterlacing");
-    else if (err > 0) {
-        ff_qsvvpp_print_warning(ctx, err, "Warning in session initialization");
-        return AVERROR_UNKNOWN;
-    }
+    ret = ff_qsvvpp_create_mfx_session(ctx, device_hwctx->loader, impl, &ver,
+                                       &s->session);
+    if (ret)
+        return ret;
 
     if (handle) {
         err = MFXVideoCORE_SetHandle(s->session, handle_type, handle);
@@ -223,28 +223,7 @@ static int init_out_session(AVFilterContext *ctx)
 
     s->ext_buffers[s->num_ext_buffers++] = (mfxExtBuffer *)&s->deint_conf;
 
-    if (opaque) {
-        s->surface_ptrs = av_calloc(hw_frames_hwctx->nb_surfaces,
-                                    sizeof(*s->surface_ptrs));
-        if (!s->surface_ptrs)
-            return AVERROR(ENOMEM);
-        for (i = 0; i < hw_frames_hwctx->nb_surfaces; i++)
-            s->surface_ptrs[i] = hw_frames_hwctx->surfaces + i;
-        s->nb_surface_ptrs = hw_frames_hwctx->nb_surfaces;
-
-        s->opaque_alloc.In.Surfaces   = s->surface_ptrs;
-        s->opaque_alloc.In.NumSurface = s->nb_surface_ptrs;
-        s->opaque_alloc.In.Type       = hw_frames_hwctx->frame_type;
-
-        s->opaque_alloc.Out = s->opaque_alloc.In;
-
-        s->opaque_alloc.Header.BufferId = MFX_EXTBUFF_OPAQUE_SURFACE_ALLOCATION;
-        s->opaque_alloc.Header.BufferSz = sizeof(s->opaque_alloc);
-
-        s->ext_buffers[s->num_ext_buffers++] = (mfxExtBuffer *)&s->opaque_alloc;
-
-        par.IOPattern = MFX_IOPATTERN_IN_OPAQUE_MEMORY | MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
-    } else {
+    if (!opaque) {
         mfxFrameAllocator frame_allocator = {
             .pthis  = ctx,
             .Alloc  = frame_alloc,
@@ -268,6 +247,31 @@ static int init_out_session(AVFilterContext *ctx)
 
         par.IOPattern = MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_OUT_VIDEO_MEMORY;
     }
+#if QSV_HAVE_OPAQUE
+    else {
+        s->surface_ptrs = av_calloc(hw_frames_hwctx->nb_surfaces,
+                                    sizeof(*s->surface_ptrs));
+
+        if (!s->surface_ptrs)
+            return AVERROR(ENOMEM);
+        for (i = 0; i < hw_frames_hwctx->nb_surfaces; i++)
+            s->surface_ptrs[i] = hw_frames_hwctx->surfaces + i;
+        s->nb_surface_ptrs = hw_frames_hwctx->nb_surfaces;
+
+        s->opaque_alloc.In.Surfaces   = s->surface_ptrs;
+        s->opaque_alloc.In.NumSurface = s->nb_surface_ptrs;
+        s->opaque_alloc.In.Type       = hw_frames_hwctx->frame_type;
+
+        s->opaque_alloc.Out = s->opaque_alloc.In;
+
+        s->opaque_alloc.Header.BufferId = MFX_EXTBUFF_OPAQUE_SURFACE_ALLOCATION;
+        s->opaque_alloc.Header.BufferSz = sizeof(s->opaque_alloc);
+
+        s->ext_buffers[s->num_ext_buffers++] = (mfxExtBuffer *)&s->opaque_alloc;
+
+        par.IOPattern = MFX_IOPATTERN_IN_OPAQUE_MEMORY | MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
+    }
+#endif
 
     par.ExtParam    = s->ext_buffers;
     par.NumExtParam = s->num_ext_buffers;
diff --git a/libavfilter/vf_deshake_opencl.c b/libavfilter/vf_deshake_opencl.c
index c2b5bef..d488da7 100644
--- a/libavfilter/vf_deshake_opencl.c
+++ b/libavfilter/vf_deshake_opencl.c
@@ -1413,8 +1413,15 @@ static int filter_frame(AVFilterLink *link, AVFrame *input_frame)
             &debug_matches, 1);
     }
 
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
     if (input_frame->pkt_duration) {
         duration = input_frame->pkt_duration;
+    } else
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    if (input_frame->duration) {
+        duration = input_frame->duration;
     } else {
         duration = av_rescale_q(1, av_inv_q(outlink->frame_rate), outlink->time_base);
     }
diff --git a/libavfilter/vf_drawtext.c b/libavfilter/vf_drawtext.c
index feb6898..50012bb 100644
--- a/libavfilter/vf_drawtext.c
+++ b/libavfilter/vf_drawtext.c
@@ -91,8 +91,11 @@ static const char *const var_names[] = {
     "y",
     "pict_type",
     "pkt_pos",
+#if FF_API_PKT_DURATION
     "pkt_duration",
+#endif
     "pkt_size",
+    "duration",
     NULL
 };
 
@@ -131,8 +134,11 @@ enum var_name {
     VAR_Y,
     VAR_PICT_TYPE,
     VAR_PKT_POS,
+#if FF_API_PKT_DURATION
     VAR_PKT_DURATION,
+#endif
     VAR_PKT_SIZE,
+    VAR_DURATION,
     VAR_VARS_NB
 };
 
@@ -1649,8 +1655,18 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
 
     s->var_values[VAR_PICT_TYPE] = frame->pict_type;
     s->var_values[VAR_PKT_POS] = frame->pkt_pos;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
     s->var_values[VAR_PKT_DURATION] = frame->pkt_duration * av_q2d(inlink->time_base);
+
+    if (frame->pkt_duration)
+        s->var_values[VAR_DURATION] = frame->pkt_duration * av_q2d(inlink->time_base);
+    else
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+    s->var_values[VAR_DURATION] = frame->duration * av_q2d(inlink->time_base);
     s->var_values[VAR_PKT_SIZE] = frame->pkt_size;
+
     s->metadata = frame->metadata;
 
     for (int i = 0; i < loop; i++) {
diff --git a/libavfilter/vf_edgedetect.c b/libavfilter/vf_edgedetect.c
index 90390ce..603f06f 100644
--- a/libavfilter/vf_edgedetect.c
+++ b/libavfilter/vf_edgedetect.c
@@ -191,15 +191,15 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in)
         }
 
         /* gaussian filter to reduce noise  */
-        ff_gaussian_blur(width, height,
-                         tmpbuf,      width,
-                         in->data[p], in->linesize[p]);
+        ff_gaussian_blur_8(width, height,
+                           tmpbuf,      width,
+                           in->data[p], in->linesize[p], 1);
 
         /* compute the 16-bits gradients and directions for the next step */
-        ff_sobel(width, height,
-              gradients, width,
-              directions,width,
-              tmpbuf,    width);
+        ff_sobel_8(width, height,
+                   gradients, width,
+                   directions,width,
+                   tmpbuf,    width, 1);
 
         /* non_maximum_suppression() will actually keep & clip what's necessary and
          * ignore the rest, so we need a clean output buffer */
diff --git a/libavfilter/vf_hwdownload.c b/libavfilter/vf_hwdownload.c
index 5ef23cb..ebdbf42 100644
--- a/libavfilter/vf_hwdownload.c
+++ b/libavfilter/vf_hwdownload.c
@@ -39,10 +39,11 @@ static int hwdownload_query_formats(AVFilterContext *avctx)
 {
     int err;
 
-    if ((err = ff_formats_ref(ff_formats_pixdesc_filter(AV_PIX_FMT_FLAG_HWACCEL, 0),
-                              &avctx->inputs[0]->outcfg.formats))  ||
-        (err = ff_formats_ref(ff_formats_pixdesc_filter(0, AV_PIX_FMT_FLAG_HWACCEL),
-                              &avctx->outputs[0]->incfg.formats)))
+    if ((err = ff_formats_ref(ff_all_formats(AVMEDIA_TYPE_VIDEO),
+                             &avctx->inputs[0]->outcfg.formats)) < 0)
+        return err;
+    if ((err = ff_formats_ref(ff_formats_pixdesc_filter(0, AV_PIX_FMT_FLAG_HWACCEL),
+                             &avctx->outputs[0]->incfg.formats)) < 0)
         return err;
 
     return 0;
@@ -53,13 +54,11 @@ static int hwdownload_config_input(AVFilterLink *inlink)
     AVFilterContext *avctx = inlink->dst;
     HWDownloadContext *ctx = avctx->priv;
 
-    av_buffer_unref(&ctx->hwframes_ref);
-
     if (!inlink->hw_frames_ctx) {
-        av_log(ctx, AV_LOG_ERROR, "The input must have a hardware frame "
-               "reference.\n");
-        return AVERROR(EINVAL);
+        av_log(avctx, AV_LOG_VERBOSE, "Passthrough software frame.\n");
+        return 0;
     }
+    av_buffer_unref(&ctx->hwframes_ref);
 
     ctx->hwframes_ref = av_buffer_ref(inlink->hw_frames_ctx);
     if (!ctx->hwframes_ref)
@@ -76,30 +75,34 @@ static int hwdownload_config_output(AVFilterLink *outlink)
     AVFilterLink *inlink   = avctx->inputs[0];
     HWDownloadContext *ctx = avctx->priv;
     enum AVPixelFormat *formats;
-    int err, i, found;
-
-    if (!ctx->hwframes_ref)
-        return AVERROR(EINVAL);
-
-    err = av_hwframe_transfer_get_formats(ctx->hwframes_ref,
-                                          AV_HWFRAME_TRANSFER_DIRECTION_FROM,
-                                          &formats, 0);
-    if (err < 0)
-        return err;
-
-    found = 0;
-    for (i = 0; formats[i] != AV_PIX_FMT_NONE; i++) {
-        if (formats[i] == outlink->format) {
+    int err, i, j, found;
+
+    if (ctx->hwframes_ref) {
+        err = av_hwframe_transfer_get_formats(ctx->hwframes_ref,
+                                            AV_HWFRAME_TRANSFER_DIRECTION_FROM,
+                                            &formats, 0);
+        if (err < 0)
+            return err;
+
+        found = 0;
+        for (i = 0; formats[i] != AV_PIX_FMT_NONE; i++) {
+            if (formats[i] == outlink->format) {
+                found = 1;
+                break;
+            }
+        }
+        if (!found && (err = ff_formats_ref(ff_make_format_list(formats),
+                              &outlink->incfg.formats)) >= 0) {
             found = 1;
-            break;
+            outlink->format = formats[0];
         }
-    }
-    av_freep(&formats);
+        av_freep(&formats);
 
-    if (!found) {
-        av_log(ctx, AV_LOG_ERROR, "Invalid output format %s for hwframe "
-               "download.\n", av_get_pix_fmt_name(outlink->format));
-        return AVERROR(EINVAL);
+        if (!found) {
+            av_log(ctx, AV_LOG_ERROR, "Invalid output format %s for hwframe "
+                "download.\n", av_get_pix_fmt_name(outlink->format));
+            return AVERROR(EINVAL);
+        }
     }
 
     outlink->w = inlink->w;
@@ -116,7 +119,10 @@ static int hwdownload_filter_frame(AVFilterLink *link, AVFrame *input)
     AVFrame *output = NULL;
     int err;
 
-    if (!ctx->hwframes_ref || !input->hw_frames_ctx) {
+    if (!input->hw_frames_ctx) {
+        return ff_filter_frame(outlink, input);
+    }
+    if (!ctx->hwframes_ref) {
         av_log(ctx, AV_LOG_ERROR, "Input frames must have hardware context.\n");
         err = AVERROR(EINVAL);
         goto fail;
diff --git a/libavfilter/vf_overlay_qsv.c b/libavfilter/vf_overlay_qsv.c
index 7e76b39..d947a1f 100644
--- a/libavfilter/vf_overlay_qsv.c
+++ b/libavfilter/vf_overlay_qsv.c
@@ -276,6 +276,7 @@ static int config_output(AVFilterLink *outlink)
     int ret;
 
     av_log(ctx, AV_LOG_DEBUG, "Output is of %s.\n", av_get_pix_fmt_name(outlink->format));
+    vpp->qsv_param.out_sw_format = in0->format;
     if ((in0->format == AV_PIX_FMT_QSV && in1->format != AV_PIX_FMT_QSV) ||
         (in0->format != AV_PIX_FMT_QSV && in1->format == AV_PIX_FMT_QSV)) {
         av_log(ctx, AV_LOG_ERROR, "Mixing hardware and software pixel formats is not supported.\n");
@@ -288,6 +289,7 @@ static int config_output(AVFilterLink *outlink)
             av_log(ctx, AV_LOG_ERROR, "Inputs with different underlying QSV devices are forbidden.\n");
             return AVERROR(EINVAL);
         }
+        vpp->qsv_param.out_sw_format = hw_frame0->sw_format;
     }
 
     outlink->w          = vpp->var_values[VAR_MW];
diff --git a/libavfilter/vf_overlay_vaapi.c b/libavfilter/vf_overlay_vaapi.c
index b3a624a..3e6a0de 100644
--- a/libavfilter/vf_overlay_vaapi.c
+++ b/libavfilter/vf_overlay_vaapi.c
@@ -380,7 +380,7 @@ static const AVOption overlay_vaapi_options[] = {
     { "h", "Overlay height",
       OFFSET(overlay_oh), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, .flags = FLAGS },
     { "alpha", "Overlay global alpha",
-      OFFSET(alpha), AV_OPT_TYPE_FLOAT, { .dbl = 0.0}, 0.0, 1.0, .flags = FLAGS},
+      OFFSET(alpha), AV_OPT_TYPE_FLOAT, { .dbl = 1.0}, 0.0, 1.0, .flags = FLAGS},
     { NULL },
 };
 
diff --git a/libavfilter/vf_scale.c b/libavfilter/vf_scale.c
index 2b12cf2..996f7aa 100644
--- a/libavfilter/vf_scale.c
+++ b/libavfilter/vf_scale.c
@@ -491,19 +491,19 @@ static int config_props(AVFilterLink *outlink)
     if ((ret = scale_eval_dimensions(ctx)) < 0)
         goto fail;
 
-    outlink->w = scale->w;
-    outlink->h = scale->h;
-
-    ff_scale_adjust_dimensions(inlink, &outlink->w, &outlink->h,
+    ff_scale_adjust_dimensions(inlink, &scale->w, &scale->h,
                                scale->force_original_aspect_ratio,
                                scale->force_divisible_by);
 
-    if (outlink->w > INT_MAX ||
-        outlink->h > INT_MAX ||
-        (outlink->h * inlink->w) > INT_MAX ||
-        (outlink->w * inlink->h) > INT_MAX)
+    if (scale->w > INT_MAX ||
+        scale->h > INT_MAX ||
+        (scale->h * inlink->w) > INT_MAX ||
+        (scale->w * inlink->h) > INT_MAX)
         av_log(ctx, AV_LOG_ERROR, "Rescaled value for width or height is too big.\n");
 
+    outlink->w = scale->w;
+    outlink->h = scale->h;
+
     /* TODO: make algorithm configurable */
 
     scale->input_is_pal = desc->flags & AV_PIX_FMT_FLAG_PAL;
@@ -718,9 +718,9 @@ static int scale_frame(AVFilterLink *link, AVFrame *in, AVFrame **frame_out)
             goto scale;
 
         if (scale->eval_mode == EVAL_MODE_INIT) {
-            snprintf(buf, sizeof(buf) - 1, "%d", scale->w);
+            snprintf(buf, sizeof(buf)-1, "%d", outlink->w);
             av_opt_set(scale, "w", buf, 0);
-            snprintf(buf, sizeof(buf) - 1, "%d", scale->h);
+            snprintf(buf, sizeof(buf)-1, "%d", outlink->h);
             av_opt_set(scale, "h", buf, 0);
 
             ret = scale_parse_expr(ctx, NULL, &scale->w_pexpr, "width", scale->w_expr);
diff --git a/libavfilter/vf_scale_qsv.c b/libavfilter/vf_scale_qsv.c
index da3c2ec..758e730 100644
--- a/libavfilter/vf_scale_qsv.c
+++ b/libavfilter/vf_scale_qsv.c
@@ -21,7 +21,7 @@
  * scale video filter - QSV
  */
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include <stdio.h>
 #include <string.h>
@@ -89,7 +89,9 @@ typedef struct QSVScaleContext {
     mfxFrameSurface1 **surface_ptrs_out;
     int             nb_surface_ptrs_out;
 
+#if QSV_HAVE_OPAQUE
     mfxExtOpaqueSurfaceAlloc opaque_alloc;
+#endif
 
     mfxExtVPPScaling         scale_conf;
     int                      mode;
@@ -268,7 +270,7 @@ static int init_out_session(AVFilterContext *ctx)
     AVQSVFramesContext *out_frames_hwctx = out_frames_ctx->hwctx;
     AVQSVDeviceContext     *device_hwctx = in_frames_ctx->device_ctx->hwctx;
 
-    int opaque = !!(in_frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
+    int opaque = 0;
 
     mfxHDL handle = NULL;
     mfxHandleType handle_type;
@@ -276,8 +278,11 @@ static int init_out_session(AVFilterContext *ctx)
     mfxIMPL impl;
     mfxVideoParam par;
     mfxStatus err;
-    int i;
+    int i, ret;
 
+#if QSV_HAVE_OPAQUE
+    opaque = !!(in_frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
+#endif
     s->num_ext_buf = 0;
 
     /* extract the properties of the "master" session given to us */
@@ -310,11 +315,10 @@ static int init_out_session(AVFilterContext *ctx)
 
     /* create a "slave" session with those same properties, to be used for
      * actual scaling */
-    err = MFXInit(impl, &ver, &s->session);
-    if (err != MFX_ERR_NONE) {
-        av_log(ctx, AV_LOG_ERROR, "Error initializing a session for scaling\n");
-        return AVERROR_UNKNOWN;
-    }
+    ret = ff_qsvvpp_create_mfx_session(ctx, device_hwctx->loader, impl, &ver,
+                                       &s->session);
+    if (ret)
+        return ret;
 
     if (handle) {
         err = MFXVideoCORE_SetHandle(s->session, handle_type, handle);
@@ -330,38 +334,7 @@ static int init_out_session(AVFilterContext *ctx)
 
     memset(&par, 0, sizeof(par));
 
-    if (opaque) {
-        s->surface_ptrs_in = av_calloc(in_frames_hwctx->nb_surfaces,
-                                       sizeof(*s->surface_ptrs_in));
-        if (!s->surface_ptrs_in)
-            return AVERROR(ENOMEM);
-        for (i = 0; i < in_frames_hwctx->nb_surfaces; i++)
-            s->surface_ptrs_in[i] = in_frames_hwctx->surfaces + i;
-        s->nb_surface_ptrs_in = in_frames_hwctx->nb_surfaces;
-
-        s->surface_ptrs_out = av_calloc(out_frames_hwctx->nb_surfaces,
-                                        sizeof(*s->surface_ptrs_out));
-        if (!s->surface_ptrs_out)
-            return AVERROR(ENOMEM);
-        for (i = 0; i < out_frames_hwctx->nb_surfaces; i++)
-            s->surface_ptrs_out[i] = out_frames_hwctx->surfaces + i;
-        s->nb_surface_ptrs_out = out_frames_hwctx->nb_surfaces;
-
-        s->opaque_alloc.In.Surfaces   = s->surface_ptrs_in;
-        s->opaque_alloc.In.NumSurface = s->nb_surface_ptrs_in;
-        s->opaque_alloc.In.Type       = in_frames_hwctx->frame_type;
-
-        s->opaque_alloc.Out.Surfaces   = s->surface_ptrs_out;
-        s->opaque_alloc.Out.NumSurface = s->nb_surface_ptrs_out;
-        s->opaque_alloc.Out.Type       = out_frames_hwctx->frame_type;
-
-        s->opaque_alloc.Header.BufferId = MFX_EXTBUFF_OPAQUE_SURFACE_ALLOCATION;
-        s->opaque_alloc.Header.BufferSz = sizeof(s->opaque_alloc);
-
-        s->ext_buffers[s->num_ext_buf++] = (mfxExtBuffer*)&s->opaque_alloc;
-
-        par.IOPattern = MFX_IOPATTERN_IN_OPAQUE_MEMORY | MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
-    } else {
+    if (!opaque) {
         mfxFrameAllocator frame_allocator = {
             .pthis  = ctx,
             .Alloc  = frame_alloc,
@@ -393,6 +366,40 @@ static int init_out_session(AVFilterContext *ctx)
 
         par.IOPattern = MFX_IOPATTERN_IN_VIDEO_MEMORY | MFX_IOPATTERN_OUT_VIDEO_MEMORY;
     }
+#if QSV_HAVE_OPAQUE
+    else {
+        s->surface_ptrs_in = av_calloc(in_frames_hwctx->nb_surfaces,
+                                       sizeof(*s->surface_ptrs_in));
+        if (!s->surface_ptrs_in)
+            return AVERROR(ENOMEM);
+        for (i = 0; i < in_frames_hwctx->nb_surfaces; i++)
+            s->surface_ptrs_in[i] = in_frames_hwctx->surfaces + i;
+        s->nb_surface_ptrs_in = in_frames_hwctx->nb_surfaces;
+
+        s->surface_ptrs_out = av_calloc(out_frames_hwctx->nb_surfaces,
+                                        sizeof(*s->surface_ptrs_out));
+        if (!s->surface_ptrs_out)
+            return AVERROR(ENOMEM);
+        for (i = 0; i < out_frames_hwctx->nb_surfaces; i++)
+            s->surface_ptrs_out[i] = out_frames_hwctx->surfaces + i;
+        s->nb_surface_ptrs_out = out_frames_hwctx->nb_surfaces;
+
+        s->opaque_alloc.In.Surfaces   = s->surface_ptrs_in;
+        s->opaque_alloc.In.NumSurface = s->nb_surface_ptrs_in;
+        s->opaque_alloc.In.Type       = in_frames_hwctx->frame_type;
+
+        s->opaque_alloc.Out.Surfaces   = s->surface_ptrs_out;
+        s->opaque_alloc.Out.NumSurface = s->nb_surface_ptrs_out;
+        s->opaque_alloc.Out.Type       = out_frames_hwctx->frame_type;
+
+        s->opaque_alloc.Header.BufferId = MFX_EXTBUFF_OPAQUE_SURFACE_ALLOCATION;
+        s->opaque_alloc.Header.BufferSz = sizeof(s->opaque_alloc);
+
+        s->ext_buffers[s->num_ext_buf++] = (mfxExtBuffer*)&s->opaque_alloc;
+
+        par.IOPattern = MFX_IOPATTERN_IN_OPAQUE_MEMORY | MFX_IOPATTERN_OUT_OPAQUE_MEMORY;
+    }
+#endif
 
     memset(&s->scale_conf, 0, sizeof(mfxExtVPPScaling));
     s->scale_conf.Header.BufferId     = MFX_EXTBUFF_VPP_SCALING;
diff --git a/libavfilter/vf_scale_rga.c b/libavfilter/vf_scale_rga.c
new file mode 100644
index 0000000..cb80df6
--- /dev/null
+++ b/libavfilter/vf_scale_rga.c
@@ -0,0 +1,180 @@
+/**
+ * @file
+ * Rockchip RGA based scale filter
+ * @author: jjm2473 (jjm2473 at gmail.com)
+ */
+
+#include "libavrkmpp/avrkmpp.h"
+#include "libavutil/parseutils.h"
+#include "internal.h"
+#include "scale_eval.h"
+
+#include "libavutil/opt.h"
+
+static int scale_rga_query_formats(AVFilterContext *avctx) {
+    enum AVPixelFormat input_pix_fmts[] = {
+        AV_PIX_FMT_DRM_PRIME,
+        AV_PIX_FMT_YUV420P,
+        AV_PIX_FMT_NV12,
+        // AV_PIX_FMT_P010,
+        // AV_PIX_FMT_NV16,
+        // AV_PIX_FMT_YUYV422,
+        // AV_PIX_FMT_UYVY422,
+        AV_PIX_FMT_NONE,
+    };
+    enum AVPixelFormat output_pix_fmts[] = {
+        AV_PIX_FMT_DRM_PRIME, AV_PIX_FMT_NONE,
+    };
+    int err;
+
+    if ((err = ff_formats_ref(ff_make_format_list(input_pix_fmts),
+                              &avctx->inputs[0]->outcfg.formats)) < 0)
+        return err;
+    if ((err = ff_formats_ref(ff_make_format_list(output_pix_fmts),
+                              &avctx->outputs[0]->incfg.formats)) < 0)
+        return err;
+
+    return 0;
+}
+
+static int scale_rga_filter_frame_l(AVFilterLink *inlink, AVFrame *input_frame) {
+    AVFrame *output_frame;
+    AVFilterContext *avctx   = inlink->dst;
+    AVFilterLink *outlink    = avctx->outputs[0];
+    int ret = avrkmpp_scale_rga_filter_frame(inlink, input_frame, &output_frame);
+    if (!ret) {
+        ret = ff_filter_frame(outlink, output_frame);
+    }
+    return ret;
+}
+
+static int scale_rga_config_output_l(AVFilterLink *outlink) {
+    AVFilterContext *avctx = outlink->src;
+    AVFilterLink *inlink   = outlink->src->inputs[0];
+    ScaleRGAContext *ctx   = avctx->priv;
+    rga_rect_t *rect = &ctx->output;
+    int err;
+
+    if ((err = ff_scale_eval_dimensions(ctx,
+                                        ctx->w_expr, ctx->h_expr,
+                                        inlink, outlink,
+                                        &rect->width, &rect->height)) < 0)
+        return err;
+
+    ff_scale_adjust_dimensions(inlink, &rect->width, &rect->height,
+                               ctx->force_original_aspect_ratio, ctx->force_divisible_by);
+
+    if ((ctx->down_scale_only == 1) && (rect->width > inlink->w || rect->height > inlink->h)) {
+        rect->width = inlink->w;
+        rect->height = inlink->h;
+    }
+
+    if ((err = avrkmpp_scale_rga_config_output(outlink)) < 0) {
+        return err;
+    }
+
+    if (inlink->sample_aspect_ratio.num)
+        outlink->sample_aspect_ratio = av_mul_q((AVRational){outlink->h * inlink->w, outlink->w * inlink->h}, inlink->sample_aspect_ratio);
+    else
+        outlink->sample_aspect_ratio = inlink->sample_aspect_ratio;
+
+    return 0;
+}
+
+static av_cold int init_dict(AVFilterContext *ctx)
+{
+    ScaleRGAContext *scale = ctx->priv;
+    rga_rect_t *rect = &scale->output;
+    int ret;
+
+    if (scale->size_str && (scale->w_expr || scale->h_expr)) {
+        av_log(ctx, AV_LOG_ERROR,
+               "Size and width/height expressions cannot be set at the same time.\n");
+            return AVERROR(EINVAL);
+    }
+
+    if (scale->w_expr && !scale->h_expr)
+        FFSWAP(char *, scale->w_expr, scale->size_str);
+
+    if (scale->size_str) {
+        char buf[32];
+        if ((ret = av_parse_video_size(&rect->width, &rect->height, scale->size_str)) < 0) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "Invalid size '%s'\n", scale->size_str);
+            return ret;
+        }
+        snprintf(buf, sizeof(buf)-1, "%d", rect->width);
+        av_opt_set(scale, "w", buf, 0);
+        snprintf(buf, sizeof(buf)-1, "%d", rect->height);
+        av_opt_set(scale, "h", buf, 0);
+    }
+    if (!scale->w_expr)
+        av_opt_set(scale, "w", "iw", 0);
+    if (!scale->h_expr)
+        av_opt_set(scale, "h", "ih", 0);
+
+    av_log(ctx, AV_LOG_VERBOSE, "Parsed expr w:%s h:%s\n",
+           scale->w_expr, scale->h_expr);
+
+    return 0;
+}
+
+static av_cold int scale_rga_init_l(AVFilterContext *avctx) {
+    int ret;
+    if (ret = init_dict(avctx))
+        return ret;
+
+    return avrkmpp_scale_rga_init(avctx);
+}
+
+static av_cold void scale_rga_uninit_l(AVFilterContext *avctx) {
+    avrkmpp_scale_rga_uninit(avctx);
+}
+
+#define OFFSET(x) offsetof(ScaleRGAContext, x)
+#define FLAGS (AV_OPT_FLAG_FILTERING_PARAM|AV_OPT_FLAG_VIDEO_PARAM)
+static const AVOption scale_rga_options[] = {
+    { "w", "output video width", OFFSET(w_expr), AV_OPT_TYPE_STRING, {.str = NULL}, .flags = FLAGS },
+    { "h", "output video height", OFFSET(h_expr), AV_OPT_TYPE_STRING, {.str = NULL}, .flags = FLAGS },
+    { "s", "output video size (WxH)", OFFSET(size_str), AV_OPT_TYPE_STRING, {.str = NULL}, .flags = FLAGS },
+    { "force_original_aspect_ratio", "decrease or increase w/h if necessary to keep the original AR", 
+            OFFSET(force_original_aspect_ratio), AV_OPT_TYPE_INT, { .i64 = 1}, 0, 2, FLAGS, "force_oar" },
+        { "disable",  NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 0 }, 0, 0, FLAGS, "force_oar" },
+        { "decrease", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 1 }, 0, 0, FLAGS, "force_oar" },
+        { "increase", NULL, 0, AV_OPT_TYPE_CONST, {.i64 = 2 }, 0, 0, FLAGS, "force_oar" },
+    { "force_divisible_by", "enforce that the output resolution is divisible by a defined integer when force_original_aspect_ratio is used", 
+            OFFSET(force_divisible_by), AV_OPT_TYPE_INT, { .i64 = 1}, 1, 256, FLAGS },
+    { "down_scale_only", "do not upscale", OFFSET(down_scale_only), AV_OPT_TYPE_BOOL, { .i64 = 1}, 0, 1, FLAGS },
+    { NULL },
+};
+
+AVFILTER_DEFINE_CLASS(scale_rga);
+
+static const AVFilterPad scale_rga_inputs[] = {
+    {
+        .name         = "default",
+        .type         = AVMEDIA_TYPE_VIDEO,
+        .filter_frame = &scale_rga_filter_frame_l,
+    },
+};
+
+static const AVFilterPad scale_rga_outputs[] = {
+    {
+        .name = "default",
+        .type = AVMEDIA_TYPE_VIDEO,
+        .config_props = &scale_rga_config_output_l,
+    },
+};
+
+const AVFilter ff_vf_scale_rga = {
+    .name          = "scale_rga",
+    .description   = NULL_IF_CONFIG_SMALL("Scale to/from RGA surfaces."),
+    .priv_size     = sizeof(ScaleRGAContext),
+    .priv_class    = &scale_rga_class,
+    .init          = &scale_rga_init_l,
+    .uninit        = &scale_rga_uninit_l,
+    FILTER_INPUTS(scale_rga_inputs),
+    FILTER_OUTPUTS(scale_rga_outputs),
+    FILTER_QUERY_FUNC(&scale_rga_query_formats),
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
diff --git a/libavfilter/vf_showinfo.c b/libavfilter/vf_showinfo.c
index 68fbe8c..2c8514f 100644
--- a/libavfilter/vf_showinfo.c
+++ b/libavfilter/vf_showinfo.c
@@ -709,10 +709,13 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
     }
 
     av_log(ctx, AV_LOG_INFO,
-           "n:%4"PRId64" pts:%7s pts_time:%-7s pos:%9"PRId64" "
+           "n:%4"PRId64" pts:%7s pts_time:%-7s duration:%7"PRId64
+           " duration_time:%-7s pos:%9"PRId64" "
            "fmt:%s sar:%d/%d s:%dx%d i:%c iskey:%d type:%c ",
            inlink->frame_count_out,
-           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base), frame->pkt_pos,
+           av_ts2str(frame->pts), av_ts2timestr(frame->pts, &inlink->time_base),
+           frame->duration, av_ts2timestr(frame->duration, &inlink->time_base),
+           frame->pkt_pos,
            desc->name,
            frame->sample_aspect_ratio.num, frame->sample_aspect_ratio.den,
            frame->width, frame->height,
@@ -730,15 +733,12 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *frame)
             av_log(ctx, AV_LOG_INFO, " %08"PRIX32, plane_checksum[plane]);
         av_log(ctx, AV_LOG_INFO, "] mean:[");
         for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)
-            av_log(ctx, AV_LOG_INFO, "%s%"PRId64,
-                   plane ? " ":"",
-                   (sum[plane] + pixelcount[plane]/2) / pixelcount[plane]);
-        av_log(ctx, AV_LOG_INFO, "] stdev:[");
+            av_log(ctx, AV_LOG_INFO, "%"PRId64" ", (sum[plane] + pixelcount[plane]/2) / pixelcount[plane]);
+        av_log(ctx, AV_LOG_INFO, "\b] stdev:[");
         for (plane = 0; plane < 4 && frame->data[plane] && frame->linesize[plane]; plane++)
-            av_log(ctx, AV_LOG_INFO, "%s%3.1f",
-                   plane ? " ":"",
+            av_log(ctx, AV_LOG_INFO, "%3.1f ",
                    sqrt((sum2[plane] - sum[plane]*(double)sum[plane]/pixelcount[plane])/pixelcount[plane]));
-        av_log(ctx, AV_LOG_INFO, "]");
+        av_log(ctx, AV_LOG_INFO, "\b]");
     }
     av_log(ctx, AV_LOG_INFO, "\n");
 
diff --git a/libavfilter/vf_sr.c b/libavfilter/vf_sr.c
index 0890c8b..cb24c09 100644
--- a/libavfilter/vf_sr.c
+++ b/libavfilter/vf_sr.c
@@ -159,8 +159,9 @@ static int filter_frame(AVFilterLink *inlink, AVFrame *in)
         sws_scale(ctx->sws_uv_scale, (const uint8_t **)(in->data + 2), in->linesize + 2,
                   0, ctx->sws_uv_height, out->data + 2, out->linesize + 2);
     }
-
-    av_frame_free(&in);
+    if (in != out) {
+        av_frame_free(&in);
+    }
     return ff_filter_frame(outlink, out);
 }
 
diff --git a/libavfilter/vf_zscale.c b/libavfilter/vf_zscale.c
index 91166dc..999147b 100644
--- a/libavfilter/vf_zscale.c
+++ b/libavfilter/vf_zscale.c
@@ -1033,6 +1033,7 @@ static const AVOption zscale_options[] = {
     {     "bt470m",           0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_TRANSFER_470_M},       0, 0, FLAGS, "transfer" },
     {     "bt470bg",          0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_TRANSFER_470_BG},      0, 0, FLAGS, "transfer" },
     {     "smpte170m",        0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_TRANSFER_601},         0, 0, FLAGS, "transfer" },
+    {     "smpte240m",        0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_TRANSFER_240M},        0, 0, FLAGS, "transfer" },
     {     "bt709",            0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_TRANSFER_709},         0, 0, FLAGS, "transfer" },
     {     "linear",           0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_TRANSFER_LINEAR},      0, 0, FLAGS, "transfer" },
     {     "log100",           0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_TRANSFER_LOG_100},     0, 0, FLAGS, "transfer" },
@@ -1058,7 +1059,7 @@ static const AVOption zscale_options[] = {
     {     "fcc",              0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_FCC},         0, 0, FLAGS, "matrix" },
     {     "bt470bg",          0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_470BG},       0, 0, FLAGS, "matrix" },
     {     "smpte170m",        0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_170M},        0, 0, FLAGS, "matrix" },
-    {     "smpte2400m",       0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_240M},        0, 0, FLAGS, "matrix" },
+    {     "smpte240m",        0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_240M},        0, 0, FLAGS, "matrix" },
     {     "ycgco",            0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_YCGCO},       0, 0, FLAGS, "matrix" },
     {     "bt2020nc",         0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_2020_NCL},    0, 0, FLAGS, "matrix" },
     {     "bt2020c",          0,       0,                 AV_OPT_TYPE_CONST, {.i64 = ZIMG_MATRIX_2020_CL},     0, 0, FLAGS, "matrix" },
diff --git a/libavfilter/vsrc_ddagrab.c b/libavfilter/vsrc_ddagrab.c
new file mode 100644
index 0000000..00c7218
--- /dev/null
+++ b/libavfilter/vsrc_ddagrab.c
@@ -0,0 +1,1059 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include "config.h"
+
+#if !defined(_WIN32_WINNT) || _WIN32_WINNT < 0x0A00
+#undef _WIN32_WINNT
+#define _WIN32_WINNT 0x0A00
+#endif
+#define WIN32_LEAN_AND_MEAN
+
+#include <windows.h>
+
+#define COBJMACROS
+
+#include <initguid.h>
+#include <d3d11.h>
+#include <dxgi1_2.h>
+#if HAVE_IDXGIOUTPUT5
+#include <dxgi1_5.h>
+#endif
+
+#include "libavutil/opt.h"
+#include "libavutil/time.h"
+#include "libavutil/avstring.h"
+#include "libavutil/avassert.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_d3d11va.h"
+#include "compat/w32dlfcn.h"
+#include "avfilter.h"
+#include "internal.h"
+#include "formats.h"
+#include "video.h"
+
+#include "vsrc_ddagrab_shaders.h"
+
+// avutil/time.h takes and returns time in microseconds
+#define TIMER_RES 1000000
+#define TIMER_RES64 INT64_C(1000000)
+
+typedef struct DdagrabContext {
+    const AVClass *class;
+
+    AVBufferRef *device_ref;
+    AVHWDeviceContext *device_ctx;
+    AVD3D11VADeviceContext *device_hwctx;
+
+    AVBufferRef *frames_ref;
+    AVHWFramesContext *frames_ctx;
+    AVD3D11VAFramesContext *frames_hwctx;
+
+    DXGI_OUTPUT_DESC output_desc;
+    IDXGIOutputDuplication *dxgi_outdupl;
+    AVFrame *last_frame;
+
+    int mouse_x, mouse_y;
+    ID3D11Texture2D *mouse_texture;
+    ID3D11ShaderResourceView* mouse_resource_view ;
+
+    AVRational time_base;
+    int64_t time_frame;
+    int64_t time_timeout;
+    int64_t first_pts;
+
+    DXGI_FORMAT raw_format;
+    int raw_width;
+    int raw_height;
+
+    ID3D11Texture2D *probed_texture;
+
+    ID3D11VertexShader *vertex_shader;
+    ID3D11InputLayout *input_layout;
+    ID3D11PixelShader *pixel_shader;
+    ID3D11Buffer *const_buffer;
+    ID3D11SamplerState *sampler_state;
+    ID3D11BlendState *blend_state;
+
+    int        output_idx;
+    int        draw_mouse;
+    AVRational framerate;
+    int        width;
+    int        height;
+    int        offset_x;
+    int        offset_y;
+    int        out_fmt;
+    int        allow_fallback;
+    int        force_fmt;
+} DdagrabContext;
+
+#define OFFSET(x) offsetof(DdagrabContext, x)
+#define FLAGS AV_OPT_FLAG_VIDEO_PARAM|AV_OPT_FLAG_FILTERING_PARAM
+static const AVOption ddagrab_options[] = {
+    { "output_idx", "dda output index to capture", OFFSET(output_idx), AV_OPT_TYPE_INT,        { .i64 = 0    },       0, INT_MAX, FLAGS },
+    { "draw_mouse", "draw the mouse pointer",      OFFSET(draw_mouse), AV_OPT_TYPE_BOOL,       { .i64 = 1    },       0,       1, FLAGS },
+    { "framerate",  "set video frame rate",        OFFSET(framerate),  AV_OPT_TYPE_VIDEO_RATE, { .str = "30" },       0, INT_MAX, FLAGS },
+    { "video_size", "set video frame size",        OFFSET(width),      AV_OPT_TYPE_IMAGE_SIZE, { .str = NULL },       0,       0, FLAGS },
+    { "offset_x",   "capture area x offset",       OFFSET(offset_x),   AV_OPT_TYPE_INT,        { .i64 = 0    }, INT_MIN, INT_MAX, FLAGS },
+    { "offset_y",   "capture area y offset",       OFFSET(offset_y),   AV_OPT_TYPE_INT,        { .i64 = 0    }, INT_MIN, INT_MAX, FLAGS },
+    { "output_fmt", "desired output format",       OFFSET(out_fmt),    AV_OPT_TYPE_INT,        { .i64 = DXGI_FORMAT_B8G8R8A8_UNORM },    0, INT_MAX, FLAGS, "output_fmt" },
+    { "auto",       "let dda pick its preferred format", 0,            AV_OPT_TYPE_CONST,      { .i64 = 0 },                             0, INT_MAX, FLAGS, "output_fmt" },
+    { "8bit",       "only output default 8 Bit format",  0,            AV_OPT_TYPE_CONST,      { .i64 = DXGI_FORMAT_B8G8R8A8_UNORM },    0, INT_MAX, FLAGS, "output_fmt" },
+    { "bgra",       "only output 8 Bit BGRA",            0,            AV_OPT_TYPE_CONST,      { .i64 = DXGI_FORMAT_B8G8R8A8_UNORM },    0, INT_MAX, FLAGS, "output_fmt" },
+    { "10bit",      "only output default 10 Bit format", 0,            AV_OPT_TYPE_CONST,      { .i64 = DXGI_FORMAT_R10G10B10A2_UNORM }, 0, INT_MAX, FLAGS, "output_fmt" },
+    { "x2bgr10",    "only output 10 Bit X2BGR10",        0,            AV_OPT_TYPE_CONST,      { .i64 = DXGI_FORMAT_R10G10B10A2_UNORM }, 0, INT_MAX, FLAGS, "output_fmt" },
+    { "16bit",      "only output default 16 Bit format", 0,            AV_OPT_TYPE_CONST,      { .i64 = DXGI_FORMAT_R16G16B16A16_FLOAT },0, INT_MAX, FLAGS, "output_fmt" },
+    { "rgbaf16",    "only output 16 Bit RGBAF16",        0,            AV_OPT_TYPE_CONST,      { .i64 = DXGI_FORMAT_R16G16B16A16_FLOAT },0, INT_MAX, FLAGS, "output_fmt" },
+    { "allow_fallback", "don't error on fallback to default 8 Bit format",
+                                                   OFFSET(allow_fallback), AV_OPT_TYPE_BOOL,   { .i64 = 0    },       0,       1, FLAGS },
+    { "force_fmt",  "exclude BGRA from format list (experimental, discouraged by Microsoft)",
+                                                   OFFSET(force_fmt),  AV_OPT_TYPE_BOOL,       { .i64 = 0    },       0,       1, FLAGS },
+    { NULL }
+};
+
+AVFILTER_DEFINE_CLASS(ddagrab);
+
+static inline void release_resource(void *resource)
+{
+    IUnknown **resp = (IUnknown**)resource;
+    if (*resp) {
+        IUnknown_Release(*resp);
+        *resp = NULL;
+    }
+}
+
+static av_cold void ddagrab_uninit(AVFilterContext *avctx)
+{
+    DdagrabContext *dda = avctx->priv;
+
+    release_resource(&dda->blend_state);
+    release_resource(&dda->sampler_state);
+    release_resource(&dda->pixel_shader);
+    release_resource(&dda->input_layout);
+    release_resource(&dda->vertex_shader);
+    release_resource(&dda->const_buffer);
+
+    release_resource(&dda->probed_texture);
+
+    release_resource(&dda->dxgi_outdupl);
+    release_resource(&dda->mouse_resource_view);
+    release_resource(&dda->mouse_texture);
+
+    av_frame_free(&dda->last_frame);
+    av_buffer_unref(&dda->frames_ref);
+    av_buffer_unref(&dda->device_ref);
+}
+
+static av_cold int init_dxgi_dda(AVFilterContext *avctx)
+{
+    DdagrabContext *dda = avctx->priv;
+    IDXGIDevice *dxgi_device = NULL;
+    IDXGIAdapter *dxgi_adapter = NULL;
+    IDXGIOutput *dxgi_output = NULL;
+    IDXGIOutput1 *dxgi_output1 = NULL;
+#if HAVE_IDXGIOUTPUT5 && HAVE_DPI_AWARENESS_CONTEXT
+    IDXGIOutput5 *dxgi_output5 = NULL;
+
+    typedef DPI_AWARENESS_CONTEXT (*set_thread_dpi_t)(DPI_AWARENESS_CONTEXT);
+    set_thread_dpi_t set_thread_dpi;
+    HMODULE user32_module;
+#endif
+    int w, h;
+    HRESULT hr;
+
+    hr = ID3D11Device_QueryInterface(dda->device_hwctx->device, &IID_IDXGIDevice, (void**)&dxgi_device);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed querying IDXGIDevice\n");
+        return AVERROR_EXTERNAL;
+    }
+
+    hr = IDXGIDevice_GetParent(dxgi_device, &IID_IDXGIAdapter, (void**)&dxgi_adapter);
+    IDXGIDevice_Release(dxgi_device);
+    dxgi_device = NULL;
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed getting parent IDXGIAdapter\n");
+        return AVERROR_EXTERNAL;
+    }
+
+    hr = IDXGIAdapter_EnumOutputs(dxgi_adapter, dda->output_idx, &dxgi_output);
+    IDXGIAdapter_Release(dxgi_adapter);
+    dxgi_adapter = NULL;
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to enumerate DXGI output %d\n", dda->output_idx);
+        return AVERROR_EXTERNAL;
+    }
+
+    hr = IDXGIOutput_GetDesc(dxgi_output, &dda->output_desc);
+    if (FAILED(hr)) {
+        IDXGIOutput_Release(dxgi_output);
+        av_log(avctx, AV_LOG_ERROR, "Failed getting output description\n");
+        return AVERROR_EXTERNAL;
+    }
+
+#if HAVE_IDXGIOUTPUT5 && HAVE_DPI_AWARENESS_CONTEXT
+    user32_module = dlopen("user32.dll", 0);
+    if (!user32_module) {
+        av_log(avctx, AV_LOG_ERROR, "Failed loading user32.dll\n");
+        return AVERROR_EXTERNAL;
+    }
+
+    set_thread_dpi = (set_thread_dpi_t)dlsym(user32_module, "SetThreadDpiAwarenessContext");
+
+    if (set_thread_dpi)
+        hr = IDXGIOutput_QueryInterface(dxgi_output, &IID_IDXGIOutput5, (void**)&dxgi_output5);
+
+    if (set_thread_dpi && SUCCEEDED(hr)) {
+        DPI_AWARENESS_CONTEXT prev_dpi_ctx;
+        DXGI_FORMAT formats[] = {
+            DXGI_FORMAT_R16G16B16A16_FLOAT,
+            DXGI_FORMAT_R10G10B10A2_UNORM,
+            DXGI_FORMAT_B8G8R8A8_UNORM
+        };
+        int nb_formats = FF_ARRAY_ELEMS(formats);
+
+        if(dda->out_fmt == DXGI_FORMAT_B8G8R8A8_UNORM) {
+            formats[0] = DXGI_FORMAT_B8G8R8A8_UNORM;
+            nb_formats = 1;
+        } else if (dda->out_fmt) {
+            formats[0] = dda->out_fmt;
+            formats[1] = DXGI_FORMAT_B8G8R8A8_UNORM;
+            nb_formats = dda->force_fmt ? 1 : 2;
+        }
+
+        IDXGIOutput_Release(dxgi_output);
+        dxgi_output = NULL;
+
+        prev_dpi_ctx = set_thread_dpi(DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2);
+        if (!prev_dpi_ctx)
+            av_log(avctx, AV_LOG_WARNING, "Failed enabling DPI awareness for DDA\n");
+
+        hr = IDXGIOutput5_DuplicateOutput1(dxgi_output5,
+            (IUnknown*)dda->device_hwctx->device,
+            0,
+            nb_formats,
+            formats,
+            &dda->dxgi_outdupl);
+        IDXGIOutput5_Release(dxgi_output5);
+        dxgi_output5 = NULL;
+
+        if (prev_dpi_ctx)
+            set_thread_dpi(prev_dpi_ctx);
+
+        dlclose(user32_module);
+        user32_module = NULL;
+        set_thread_dpi = NULL;
+
+        av_log(avctx, AV_LOG_DEBUG, "Using IDXGIOutput5 interface\n");
+    } else {
+        dlclose(user32_module);
+        user32_module = NULL;
+        set_thread_dpi = NULL;
+
+        av_log(avctx, AV_LOG_DEBUG, "Falling back to IDXGIOutput1\n");
+#else
+    {
+#endif
+        if (dda->out_fmt && dda->out_fmt != DXGI_FORMAT_B8G8R8A8_UNORM && (!dda->allow_fallback || dda->force_fmt)) {
+            av_log(avctx, AV_LOG_ERROR, "Only 8 bit output supported with legacy API\n");
+            return AVERROR(ENOTSUP);
+        }
+
+        hr = IDXGIOutput_QueryInterface(dxgi_output, &IID_IDXGIOutput1, (void**)&dxgi_output1);
+        IDXGIOutput_Release(dxgi_output);
+        dxgi_output = NULL;
+        if (FAILED(hr)) {
+            av_log(avctx, AV_LOG_ERROR, "Failed querying IDXGIOutput1\n");
+            return AVERROR_EXTERNAL;
+        }
+
+        hr = IDXGIOutput1_DuplicateOutput(dxgi_output1,
+            (IUnknown*)dda->device_hwctx->device,
+            &dda->dxgi_outdupl);
+        IDXGIOutput1_Release(dxgi_output1);
+        dxgi_output1 = NULL;
+    }
+
+    if (hr == DXGI_ERROR_NOT_CURRENTLY_AVAILABLE) {
+        av_log(avctx, AV_LOG_ERROR, "Too many open duplication sessions\n");
+        return AVERROR(EBUSY);
+    } else if (hr == DXGI_ERROR_UNSUPPORTED) {
+        av_log(avctx, AV_LOG_ERROR, "Selected output not supported\n");
+        return AVERROR_EXTERNAL;
+    } else if (hr == E_INVALIDARG) {
+        av_log(avctx, AV_LOG_ERROR, "Invalid output duplication argument\n");
+        return AVERROR(EINVAL);
+    } else if (hr == E_ACCESSDENIED) {
+        av_log(avctx, AV_LOG_ERROR, "Desktop duplication access denied\n");
+        return AVERROR(EPERM);
+    } else if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed duplicating output\n");
+        return AVERROR_EXTERNAL;
+    }
+
+    w = dda->output_desc.DesktopCoordinates.right - dda->output_desc.DesktopCoordinates.left;
+    h = dda->output_desc.DesktopCoordinates.bottom - dda->output_desc.DesktopCoordinates.top;
+    av_log(avctx, AV_LOG_VERBOSE, "Opened dxgi output %d with dimensions %dx%d\n", dda->output_idx, w, h);
+
+    return 0;
+}
+
+typedef struct ConstBufferData
+{
+    float width;
+    float height;
+
+    uint64_t padding;
+} ConstBufferData;
+
+static const D3D11_INPUT_ELEMENT_DESC vertex_shader_input_layout[] =
+{
+    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D11_INPUT_PER_VERTEX_DATA, 0 },
+    { "TEXCOORD", 0, DXGI_FORMAT_R32G32_FLOAT,    0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 }
+};
+
+static av_cold int init_render_resources(AVFilterContext *avctx)
+{
+    DdagrabContext *dda = avctx->priv;
+    ID3D11Device *dev = dda->device_hwctx->device;
+    D3D11_SAMPLER_DESC sampler_desc = { 0 };
+    D3D11_BLEND_DESC blend_desc = { 0 };
+    D3D11_BUFFER_DESC buffer_desc = { 0 };
+    D3D11_SUBRESOURCE_DATA buffer_data = { 0 };
+    ConstBufferData const_data = { 0 };
+    HRESULT hr;
+
+    hr = ID3D11Device_CreateVertexShader(dev,
+        vertex_shader_bytes,
+        FF_ARRAY_ELEMS(vertex_shader_bytes),
+        NULL,
+        &dda->vertex_shader);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "CreateVertexShader failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    hr = ID3D11Device_CreateInputLayout(dev,
+        vertex_shader_input_layout,
+        FF_ARRAY_ELEMS(vertex_shader_input_layout),
+        vertex_shader_bytes,
+        FF_ARRAY_ELEMS(vertex_shader_bytes),
+        &dda->input_layout);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "CreateInputLayout failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    hr = ID3D11Device_CreatePixelShader(dev,
+        pixel_shader_bytes,
+        FF_ARRAY_ELEMS(pixel_shader_bytes),
+        NULL,
+        &dda->pixel_shader);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "CreatePixelShader failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    const_data = (ConstBufferData){ dda->width, dda->height };
+
+    buffer_data.pSysMem = &const_data;
+    buffer_desc.ByteWidth = sizeof(const_data);
+    buffer_desc.Usage = D3D11_USAGE_IMMUTABLE;
+    buffer_desc.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
+    hr = ID3D11Device_CreateBuffer(dev,
+        &buffer_desc,
+        &buffer_data,
+        &dda->const_buffer);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "CreateBuffer const buffer failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    sampler_desc.Filter = D3D11_FILTER_MIN_MAG_MIP_LINEAR;
+    sampler_desc.AddressU = D3D11_TEXTURE_ADDRESS_CLAMP;
+    sampler_desc.AddressV = D3D11_TEXTURE_ADDRESS_CLAMP;
+    sampler_desc.AddressW = D3D11_TEXTURE_ADDRESS_CLAMP;
+    sampler_desc.ComparisonFunc = D3D11_COMPARISON_NEVER;
+    hr = ID3D11Device_CreateSamplerState(dev,
+        &sampler_desc,
+        &dda->sampler_state);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "CreateSamplerState failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    blend_desc.AlphaToCoverageEnable = FALSE;
+    blend_desc.IndependentBlendEnable = FALSE;
+    blend_desc.RenderTarget[0].BlendEnable = TRUE;
+    blend_desc.RenderTarget[0].SrcBlend = D3D11_BLEND_SRC_ALPHA;
+    blend_desc.RenderTarget[0].DestBlend = D3D11_BLEND_INV_SRC_ALPHA;
+    blend_desc.RenderTarget[0].BlendOp = D3D11_BLEND_OP_ADD;
+    blend_desc.RenderTarget[0].SrcBlendAlpha = D3D11_BLEND_ONE;
+    blend_desc.RenderTarget[0].DestBlendAlpha = D3D11_BLEND_ZERO;
+    blend_desc.RenderTarget[0].BlendOpAlpha = D3D11_BLEND_OP_ADD;
+    blend_desc.RenderTarget[0].RenderTargetWriteMask = D3D11_COLOR_WRITE_ENABLE_ALL;
+    hr = ID3D11Device_CreateBlendState(dev,
+        &blend_desc,
+        &dda->blend_state);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "CreateBlendState failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    return 0;
+}
+
+static av_cold int ddagrab_init(AVFilterContext *avctx)
+{
+    DdagrabContext *dda = avctx->priv;
+
+    dda->last_frame = av_frame_alloc();
+    if (!dda->last_frame)
+        return AVERROR(ENOMEM);
+
+    dda->mouse_x = -1;
+    dda->mouse_y = -1;
+
+    return 0;
+}
+
+static int create_d3d11_pointer_tex(AVFilterContext *avctx,
+                                    uint8_t *buf,
+                                    DXGI_OUTDUPL_POINTER_SHAPE_INFO *shape_info,
+                                    ID3D11Texture2D **out_tex,
+                                    ID3D11ShaderResourceView **res_view)
+{
+    DdagrabContext *dda = avctx->priv;
+    D3D11_TEXTURE2D_DESC desc = { 0 };
+    D3D11_SUBRESOURCE_DATA init_data = { 0 };
+    D3D11_SHADER_RESOURCE_VIEW_DESC resource_desc = { 0 };
+    HRESULT hr;
+
+    desc.MipLevels = 1;
+    desc.ArraySize = 1;
+    desc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
+    desc.SampleDesc.Count = 1;
+    desc.SampleDesc.Quality = 0;
+    desc.Usage = D3D11_USAGE_IMMUTABLE;
+    desc.BindFlags = D3D11_BIND_SHADER_RESOURCE;
+
+    desc.Width = shape_info->Width;
+    desc.Height = shape_info->Height;
+
+    init_data.pSysMem = buf;
+    init_data.SysMemPitch = shape_info->Pitch;
+
+    resource_desc.Format = desc.Format;
+    resource_desc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D;
+    resource_desc.Texture2D.MostDetailedMip = 0;
+    resource_desc.Texture2D.MipLevels = 1;
+
+    hr = ID3D11Device_CreateTexture2D(dda->device_hwctx->device,
+        &desc,
+        &init_data,
+        out_tex);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "Failed creating pointer texture\n");
+        return AVERROR_EXTERNAL;
+    }
+
+    hr = ID3D11Device_CreateShaderResourceView(dda->device_hwctx->device,
+        (ID3D11Resource*)dda->mouse_texture,
+        &resource_desc,
+        res_view);
+    if (FAILED(hr)) {
+        release_resource(out_tex);
+        av_log(avctx, AV_LOG_ERROR, "CreateShaderResourceView for mouse failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    return 0;
+}
+
+static uint8_t *convert_mono_buffer(uint8_t *input, int *_width, int *_height, int *_pitch)
+{
+    int width = *_width, height = *_height, pitch = *_pitch;
+    int real_height = height / 2;
+    uint8_t *output = av_malloc(real_height * width * 4);
+    int y, x;
+
+    if (!output)
+        return NULL;
+
+    // This simulates drawing the cursor on a full black surface
+    // i.e. ignore the AND mask, turn XOR mask into all 4 color channels
+    for (y = 0; y < real_height; y++) {
+        for (x = 0; x < width; x++) {
+            int v = input[(real_height + y) * pitch + (x / 8)];
+            v = (v >> (7 - (x % 8))) & 1;
+            memset(&output[4 * ((y*width) + x)], v ? 0xFF : 0, 4);
+        }
+    }
+
+    *_pitch = width * 4;
+    *_height = real_height;
+
+    return output;
+}
+
+static void fixup_color_mask(uint8_t *buf, int width, int height, int pitch)
+{
+    int x, y;
+    // There is no good way to replicate XOR'ig parts of the texture with the screen
+    // best effort is rendering the non-masked parts, and make the rest transparent
+    for (y = 0; y < height; y++) {
+        for (x = 0; x < width; x++) {
+            int pos = (y*pitch) + (4*x) + 3;
+            buf[pos] = buf[pos] ? 0 : 0xFF;
+        }
+    }
+}
+
+static int update_mouse_pointer(AVFilterContext *avctx, DXGI_OUTDUPL_FRAME_INFO *frame_info)
+{
+    DdagrabContext *dda = avctx->priv;
+    HRESULT hr;
+    int ret;
+
+    if (frame_info->LastMouseUpdateTime.QuadPart == 0)
+        return 0;
+
+    if (frame_info->PointerPosition.Visible) {
+        dda->mouse_x = frame_info->PointerPosition.Position.x;
+        dda->mouse_y = frame_info->PointerPosition.Position.y;
+    } else {
+        dda->mouse_x = dda->mouse_y = -1;
+    }
+
+    if (frame_info->PointerShapeBufferSize) {
+        UINT size = frame_info->PointerShapeBufferSize;
+        DXGI_OUTDUPL_POINTER_SHAPE_INFO shape_info;
+        uint8_t *buf = av_malloc(size);
+        if (!buf)
+            return AVERROR(ENOMEM);
+
+        hr = IDXGIOutputDuplication_GetFramePointerShape(dda->dxgi_outdupl,
+            size,
+            buf,
+            &size,
+            &shape_info);
+        if (FAILED(hr)) {
+            av_free(buf);
+            av_log(avctx, AV_LOG_ERROR, "Failed getting pointer shape: %lx\n", hr);
+            return AVERROR_EXTERNAL;
+        }
+
+        if (shape_info.Type == DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MONOCHROME) {
+            uint8_t *new_buf = convert_mono_buffer(buf, &shape_info.Width, &shape_info.Height, &shape_info.Pitch);
+            av_free(buf);
+            if (!new_buf)
+                return AVERROR(ENOMEM);
+            buf = new_buf;
+        } else if (shape_info.Type == DXGI_OUTDUPL_POINTER_SHAPE_TYPE_MASKED_COLOR) {
+            fixup_color_mask(buf, shape_info.Width, shape_info.Height, shape_info.Pitch);
+        } else if (shape_info.Type != DXGI_OUTDUPL_POINTER_SHAPE_TYPE_COLOR) {
+            av_log(avctx, AV_LOG_WARNING, "Unsupported pointer shape type: %d\n", (int)shape_info.Type);
+            av_free(buf);
+            return 0;
+        }
+
+        release_resource(&dda->mouse_resource_view);
+        release_resource(&dda->mouse_texture);
+
+        ret = create_d3d11_pointer_tex(avctx, buf, &shape_info, &dda->mouse_texture, &dda->mouse_resource_view);
+        av_freep(&buf);
+        if (ret < 0)
+            return ret;
+
+        av_log(avctx, AV_LOG_VERBOSE, "Updated pointer shape texture\n");
+    }
+
+    return 0;
+}
+
+static int next_frame_internal(AVFilterContext *avctx, ID3D11Texture2D **desktop_texture)
+{
+    DXGI_OUTDUPL_FRAME_INFO frame_info;
+    DdagrabContext *dda = avctx->priv;
+    IDXGIResource *desktop_resource = NULL;
+    HRESULT hr;
+    int ret;
+
+    hr = IDXGIOutputDuplication_AcquireNextFrame(
+        dda->dxgi_outdupl,
+        dda->time_timeout,
+        &frame_info,
+        &desktop_resource);
+    if (hr == DXGI_ERROR_WAIT_TIMEOUT) {
+        return AVERROR(EAGAIN);
+    } else if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "AcquireNextFrame failed: %lx\n", hr);
+        return AVERROR_EXTERNAL;
+    }
+
+    if (dda->draw_mouse) {
+        ret = update_mouse_pointer(avctx, &frame_info);
+        if (ret < 0)
+            return ret;
+    }
+
+    hr = IDXGIResource_QueryInterface(desktop_resource, &IID_ID3D11Texture2D, (void**)desktop_texture);
+    IDXGIResource_Release(desktop_resource);
+    desktop_resource = NULL;
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "DXGIResource QueryInterface failed\n");
+        return AVERROR_EXTERNAL;
+    }
+
+    return 0;
+}
+
+static int probe_output_format(AVFilterContext *avctx)
+{
+    DdagrabContext *dda = avctx->priv;
+    D3D11_TEXTURE2D_DESC desc;
+    int ret;
+
+    av_assert1(!dda->probed_texture);
+
+    do {
+        ret = next_frame_internal(avctx, &dda->probed_texture);
+    } while(ret == AVERROR(EAGAIN));
+    if (ret < 0)
+        return ret;
+
+    ID3D11Texture2D_GetDesc(dda->probed_texture, &desc);
+
+    dda->raw_format = desc.Format;
+    dda->raw_width = desc.Width;
+    dda->raw_height = desc.Height;
+
+    if (dda->width <= 0)
+        dda->width = dda->raw_width;
+    if (dda->height <= 0)
+        dda->height = dda->raw_height;
+
+    return 0;
+}
+
+static av_cold int init_hwframes_ctx(AVFilterContext *avctx)
+{
+    DdagrabContext *dda = avctx->priv;
+    int ret = 0;
+
+    dda->frames_ref = av_hwframe_ctx_alloc(dda->device_ref);
+    if (!dda->frames_ref)
+        return AVERROR(ENOMEM);
+    dda->frames_ctx = (AVHWFramesContext*)dda->frames_ref->data;
+    dda->frames_hwctx = (AVD3D11VAFramesContext*)dda->frames_ctx->hwctx;
+
+    dda->frames_ctx->format    = AV_PIX_FMT_D3D11;
+    dda->frames_ctx->width     = dda->width;
+    dda->frames_ctx->height    = dda->height;
+
+    switch (dda->raw_format) {
+    case DXGI_FORMAT_B8G8R8A8_UNORM:
+        av_log(avctx, AV_LOG_VERBOSE, "Probed 8 bit RGB frame format\n");
+        dda->frames_ctx->sw_format = AV_PIX_FMT_BGRA;
+        break;
+    case DXGI_FORMAT_R10G10B10A2_UNORM:
+        av_log(avctx, AV_LOG_VERBOSE, "Probed 10 bit RGB frame format\n");
+        dda->frames_ctx->sw_format = AV_PIX_FMT_X2BGR10;
+        break;
+    case DXGI_FORMAT_R16G16B16A16_FLOAT:
+        av_log(avctx, AV_LOG_VERBOSE, "Probed 16 bit float RGB frame format\n");
+        dda->frames_ctx->sw_format = AV_PIX_FMT_RGBAF16;
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "Unexpected texture output format!\n");
+        return AVERROR_BUG;
+    }
+
+    if (dda->draw_mouse)
+        dda->frames_hwctx->BindFlags |= D3D11_BIND_RENDER_TARGET;
+
+    ret = av_hwframe_ctx_init(dda->frames_ref);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to initialise hardware frames context: %d.\n", ret);
+        goto fail;
+    }
+
+    return 0;
+fail:
+    av_buffer_unref(&dda->frames_ref);
+    return ret;
+}
+
+static int ddagrab_config_props(AVFilterLink *outlink)
+{
+    AVFilterContext *avctx = outlink->src;
+    DdagrabContext *dda = avctx->priv;
+    int ret;
+
+    if (avctx->hw_device_ctx) {
+        dda->device_ctx = (AVHWDeviceContext*)avctx->hw_device_ctx->data;
+
+        if (dda->device_ctx->type != AV_HWDEVICE_TYPE_D3D11VA) {
+            av_log(avctx, AV_LOG_ERROR, "Non-D3D11VA input hw_device_ctx\n");
+            return AVERROR(EINVAL);
+        }
+
+        dda->device_ref = av_buffer_ref(avctx->hw_device_ctx);
+        if (!dda->device_ref)
+            return AVERROR(ENOMEM);
+
+        av_log(avctx, AV_LOG_VERBOSE, "Using provided hw_device_ctx\n");
+    } else {
+        ret = av_hwdevice_ctx_create(&dda->device_ref, AV_HWDEVICE_TYPE_D3D11VA, NULL, NULL, 0);
+        if (ret < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to create D3D11VA device.\n");
+            return ret;
+        }
+
+        dda->device_ctx = (AVHWDeviceContext*)dda->device_ref->data;
+
+        av_log(avctx, AV_LOG_VERBOSE, "Created internal hw_device_ctx\n");
+    }
+
+    dda->device_hwctx = (AVD3D11VADeviceContext*)dda->device_ctx->hwctx;
+
+    ret = init_dxgi_dda(avctx);
+    if (ret < 0)
+        return ret;
+
+    ret = probe_output_format(avctx);
+    if (ret < 0)
+        return ret;
+
+    if (dda->out_fmt && dda->raw_format != dda->out_fmt && (!dda->allow_fallback || dda->force_fmt)) {
+        av_log(avctx, AV_LOG_ERROR, "Requested output format unavailable.\n");
+        return AVERROR(ENOTSUP);
+    }
+
+    dda->width -= FFMAX(dda->width - dda->raw_width + dda->offset_x, 0);
+    dda->height -= FFMAX(dda->height - dda->raw_height + dda->offset_y, 0);
+
+    dda->time_base  = av_inv_q(dda->framerate);
+    dda->time_frame = av_gettime_relative() / av_q2d(dda->time_base);
+    dda->time_timeout = av_rescale_q(1, dda->time_base, (AVRational) { 1, 1000 }) / 2;
+
+    if (dda->draw_mouse) {
+        ret = init_render_resources(avctx);
+        if (ret < 0)
+            return ret;
+    }
+
+    ret = init_hwframes_ctx(avctx);
+    if (ret < 0)
+        return ret;
+
+    outlink->hw_frames_ctx = av_buffer_ref(dda->frames_ref);
+    if (!outlink->hw_frames_ctx)
+        return AVERROR(ENOMEM);
+
+    outlink->w = dda->width;
+    outlink->h = dda->height;
+    outlink->time_base = (AVRational){1, TIMER_RES};
+    outlink->frame_rate = dda->framerate;
+
+    return 0;
+}
+
+static int draw_mouse_pointer(AVFilterContext *avctx, AVFrame *frame)
+{
+    DdagrabContext *dda = avctx->priv;
+    ID3D11DeviceContext *devctx = dda->device_hwctx->device_context;
+    ID3D11Texture2D *frame_tex = (ID3D11Texture2D*)frame->data[0];
+    D3D11_RENDER_TARGET_VIEW_DESC target_desc = { 0 };
+    ID3D11RenderTargetView* target_view = NULL;
+    ID3D11Buffer *mouse_vertex_buffer = NULL;
+    D3D11_TEXTURE2D_DESC tex_desc;
+    int num_vertices = 0;
+    int x, y;
+    HRESULT hr;
+    int ret = 0;
+
+    if (!dda->mouse_texture || dda->mouse_x < 0 || dda->mouse_y < 0)
+        return 0;
+
+    ID3D11Texture2D_GetDesc(dda->mouse_texture, &tex_desc);
+
+    x = dda->mouse_x - dda->offset_x;
+    y = dda->mouse_y - dda->offset_y;
+
+    if (x >= dda->width || y >= dda->height ||
+        -x >= (int)tex_desc.Width || -y >= (int)tex_desc.Height)
+        return 0;
+
+    target_desc.Format = dda->raw_format;
+    target_desc.ViewDimension = D3D11_RTV_DIMENSION_TEXTURE2D;
+    target_desc.Texture2D.MipSlice = 0;
+
+    hr = ID3D11Device_CreateRenderTargetView(dda->device_hwctx->device,
+        (ID3D11Resource*)frame_tex,
+        &target_desc,
+        &target_view);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "CreateRenderTargetView failed: %lx\n", hr);
+        ret = AVERROR_EXTERNAL;
+        goto end;
+    }
+
+    ID3D11DeviceContext_ClearState(devctx);
+
+    {
+        D3D11_VIEWPORT viewport = { 0 };
+        viewport.Width = dda->width;
+        viewport.Height = dda->height;
+        viewport.MinDepth = 0.0f;
+        viewport.MaxDepth = 1.0f;
+
+        ID3D11DeviceContext_RSSetViewports(devctx, 1, &viewport);
+    }
+
+    {
+        FLOAT vertices[] = {
+            // x, y, z,  u, v
+            x                 , y + tex_desc.Height, 0.0f,  0.0f, 1.0f,
+            x                 , y                  , 0.0f,  0.0f, 0.0f,
+            x + tex_desc.Width, y + tex_desc.Height, 0.0f,  1.0f, 1.0f,
+            x + tex_desc.Width, y                  , 0.0f,  1.0f, 0.0f,
+        };
+        UINT stride = sizeof(FLOAT) * 5;
+        UINT offset = 0;
+
+        D3D11_SUBRESOURCE_DATA init_data = { 0 };
+        D3D11_BUFFER_DESC buf_desc = { 0 };
+
+        num_vertices = sizeof(vertices) / (sizeof(FLOAT) * 5);
+
+        buf_desc.Usage = D3D11_USAGE_DEFAULT;
+        buf_desc.BindFlags = D3D11_BIND_VERTEX_BUFFER;
+        buf_desc.ByteWidth = sizeof(vertices);
+        init_data.pSysMem = vertices;
+
+        hr = ID3D11Device_CreateBuffer(dda->device_hwctx->device,
+            &buf_desc,
+            &init_data,
+            &mouse_vertex_buffer);
+        if (FAILED(hr)) {
+            av_log(avctx, AV_LOG_ERROR, "CreateBuffer failed: %lx\n", hr);
+            ret = AVERROR_EXTERNAL;
+            goto end;
+        }
+
+        ID3D11DeviceContext_IASetVertexBuffers(devctx, 0, 1, &mouse_vertex_buffer, &stride, &offset);
+        ID3D11DeviceContext_IASetInputLayout(devctx, dda->input_layout);
+        ID3D11DeviceContext_IASetPrimitiveTopology(devctx, D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+    }
+
+    ID3D11DeviceContext_VSSetShader(devctx, dda->vertex_shader, NULL, 0);
+    ID3D11DeviceContext_VSSetConstantBuffers(devctx, 0, 1, &dda->const_buffer);
+    ID3D11DeviceContext_PSSetSamplers(devctx, 0, 1, &dda->sampler_state);
+    ID3D11DeviceContext_PSSetShaderResources(devctx, 0, 1, &dda->mouse_resource_view);
+    ID3D11DeviceContext_PSSetShader(devctx, dda->pixel_shader, NULL, 0);
+
+    ID3D11DeviceContext_OMSetBlendState(devctx, dda->blend_state, NULL, 0xFFFFFFFF);
+    ID3D11DeviceContext_OMSetRenderTargets(devctx, 1, &target_view, NULL);
+
+    ID3D11DeviceContext_Draw(devctx, num_vertices, 0);
+
+end:
+    release_resource(&mouse_vertex_buffer);
+    release_resource(&target_view);
+
+    return ret;
+}
+
+static int ddagrab_request_frame(AVFilterLink *outlink)
+{
+    AVFilterContext *avctx = outlink->src;
+    DdagrabContext *dda = avctx->priv;
+
+    ID3D11Texture2D *cur_texture = NULL;
+    D3D11_TEXTURE2D_DESC desc = { 0 };
+    D3D11_BOX box = { 0 };
+
+    int64_t time_frame = dda->time_frame;
+    int64_t now, delay;
+    AVFrame *frame = NULL;
+    HRESULT hr;
+    int ret;
+
+    /* time_frame is in units of microseconds divided by the time_base.
+     * This means that adding a clean 1M to it is the equivalent of adding
+     * 1M*time_base microseconds to it, except it avoids all rounding error.
+     * The only time rounding error occurs is when multiplying to calculate
+     * the delay. So any rounding error there corrects itself over time.
+     */
+    time_frame += TIMER_RES64;
+    for (;;) {
+        now = av_gettime_relative();
+        delay = time_frame * av_q2d(dda->time_base) - now;
+        if (delay <= 0) {
+            if (delay < -TIMER_RES64 * av_q2d(dda->time_base)) {
+                time_frame += TIMER_RES64;
+            }
+            break;
+        }
+        av_usleep(delay);
+    }
+
+    if (!dda->first_pts)
+        dda->first_pts = now;
+    now -= dda->first_pts;
+
+    if (!dda->probed_texture) {
+        ret = next_frame_internal(avctx, &cur_texture);
+    } else {
+        cur_texture = dda->probed_texture;
+        dda->probed_texture = NULL;
+        ret = 0;
+    }
+
+    if (ret == AVERROR(EAGAIN) && dda->last_frame->buf[0]) {
+        frame = av_frame_alloc();
+        if (!frame)
+            return AVERROR(ENOMEM);
+
+        ret = av_frame_ref(frame, dda->last_frame);
+        if (ret < 0) {
+            av_frame_free(&frame);
+            return ret;
+        }
+
+        av_log(avctx, AV_LOG_DEBUG, "Duplicated output frame\n");
+
+        goto frame_done;
+    } else if (ret == AVERROR(EAGAIN)) {
+        av_log(avctx, AV_LOG_VERBOSE, "Initial DDA AcquireNextFrame timeout!\n");
+        return AVERROR(EAGAIN);
+    } else if (ret < 0) {
+        return ret;
+    }
+
+    // AcquireNextFrame sometimes has bursts of delay.
+    // This increases accuracy of the timestamp, but might upset consumers due to more jittery framerate?
+    now = av_gettime_relative() - dda->first_pts;
+
+    ID3D11Texture2D_GetDesc(cur_texture, &desc);
+    if (desc.Format != dda->raw_format ||
+        (int)desc.Width != dda->raw_width ||
+        (int)desc.Height != dda->raw_height) {
+        av_log(avctx, AV_LOG_ERROR, "Output parameters changed!");
+        ret = AVERROR_OUTPUT_CHANGED;
+        goto fail;
+    }
+
+    frame = ff_get_video_buffer(outlink, dda->width, dda->height);
+    if (!frame) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    box.left = dda->offset_x;
+    box.top = dda->offset_y;
+    box.right = box.left + dda->width;
+    box.bottom = box.top + dda->height;
+    box.front = 0;
+    box.back = 1;
+
+    ID3D11DeviceContext_CopySubresourceRegion(
+        dda->device_hwctx->device_context,
+        (ID3D11Resource*)frame->data[0], (UINT)(intptr_t)frame->data[1],
+        0, 0, 0,
+        (ID3D11Resource*)cur_texture, 0,
+        &box);
+
+    release_resource(&cur_texture);
+
+    hr = IDXGIOutputDuplication_ReleaseFrame(dda->dxgi_outdupl);
+    if (FAILED(hr)) {
+        av_log(avctx, AV_LOG_ERROR, "DDA ReleaseFrame failed!\n");
+        ret = AVERROR_EXTERNAL;
+        goto fail;
+    }
+
+    if (dda->draw_mouse) {
+        ret = draw_mouse_pointer(avctx, frame);
+        if (ret < 0)
+            goto fail;
+    }
+
+    frame->sample_aspect_ratio = (AVRational){1, 1};
+
+    if (desc.Format == DXGI_FORMAT_B8G8R8A8_UNORM ||
+        desc.Format == DXGI_FORMAT_R10G10B10A2_UNORM) {
+        // According to MSDN, all integer formats contain sRGB image data
+        frame->color_range     = AVCOL_RANGE_JPEG;
+        frame->color_primaries = AVCOL_PRI_BT709;
+        frame->color_trc       = AVCOL_TRC_IEC61966_2_1;
+        frame->colorspace      = AVCOL_SPC_RGB;
+    } else if(desc.Format == DXGI_FORMAT_R16G16B16A16_FLOAT) {
+        // According to MSDN, all floating point formats contain sRGB image data with linear 1.0 gamma.
+        frame->color_range     = AVCOL_RANGE_JPEG;
+        frame->color_primaries = AVCOL_PRI_BT709;
+        frame->color_trc       = AVCOL_TRC_LINEAR;
+        frame->colorspace      = AVCOL_SPC_RGB;
+    } else {
+        ret = AVERROR_BUG;
+        goto fail;
+    }
+
+    av_frame_unref(dda->last_frame);
+    ret = av_frame_ref(dda->last_frame, frame);
+    if (ret < 0)
+        return ret;
+
+frame_done:
+    frame->pts = now;
+    dda->time_frame = time_frame;
+
+    return ff_filter_frame(outlink, frame);
+
+fail:
+    if (frame)
+        av_frame_free(&frame);
+
+    if (cur_texture)
+        IDXGIOutputDuplication_ReleaseFrame(dda->dxgi_outdupl);
+
+    release_resource(&cur_texture);
+    return ret;
+}
+
+static const AVFilterPad ddagrab_outputs[] = {
+    {
+        .name          = "default",
+        .type          = AVMEDIA_TYPE_VIDEO,
+        .request_frame = ddagrab_request_frame,
+        .config_props  = ddagrab_config_props,
+    },
+};
+
+const AVFilter ff_vsrc_ddagrab = {
+    .name          = "ddagrab",
+    .description   = NULL_IF_CONFIG_SMALL("Grab Windows Desktop images using Desktop Duplication API"),
+    .priv_size     = sizeof(DdagrabContext),
+    .priv_class    = &ddagrab_class,
+    .init          = ddagrab_init,
+    .uninit        = ddagrab_uninit,
+    .inputs        = NULL,
+    FILTER_OUTPUTS(ddagrab_outputs),
+    FILTER_SINGLE_PIXFMT(AV_PIX_FMT_D3D11),
+    .flags_internal = FF_FILTER_FLAG_HWFRAME_AWARE,
+};
diff --git a/libavfilter/vsrc_ddagrab_shaders.h b/libavfilter/vsrc_ddagrab_shaders.h
new file mode 100644
index 0000000..894cba8
--- /dev/null
+++ b/libavfilter/vsrc_ddagrab_shaders.h
@@ -0,0 +1,122 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVFILTER_VSRC_DDAGRAB_SHADERS_H
+#define AVFILTER_VSRC_DDAGRAB_SHADERS_H
+
+#include <stdint.h>
+
+#if 0
+
+cbuffer PARAMS : register ( b0 )
+{
+    float2 Dimensions;
+};
+
+struct VS_INPUT
+{
+    float3 Pos : POSITION;
+    float2 Tex : TEXCOORD;
+};
+
+struct VS_OUTPUT
+{
+    float4 Pos : SV_POSITION;
+    float2 Tex : TEXCOORD;
+};
+
+VS_OUTPUT VS(VS_INPUT input)
+{
+    VS_OUTPUT output;
+    float2 center = Dimensions / 2;
+    output.Pos = float4((input.Pos.xy - center) / center, input.Pos.z, 1.0f);
+    output.Pos.y *= -1;
+    output.Tex = input.Tex;
+    return output;
+}
+
+Texture2D tx : register( t0 );
+SamplerState samLinear : register( s0 );
+
+float4 PS(VS_OUTPUT input) : SV_Target
+{
+    return tx.Sample(samLinear, input.Tex);
+}
+
+#endif
+
+static const uint8_t vertex_shader_bytes[] =
+{
+     68,  88,  66,  67, 207, 194, 142, 193, 255,  85,  32,  72, 116,  77, 242, 140,  26, 229,  67,  69,   1,   0,   0,   0,
+     40,   3,   0,   0,   4,   0,   0,   0,  48,   0,   0,   0,  56,   1,   0,   0, 124,   2,   0,   0, 208,   2,   0,   0,
+     65, 111, 110,  57,   0,   1,   0,   0,   0,   1,   0,   0,   0,   2, 254, 255, 204,   0,   0,   0,  52,   0,   0,   0,
+      1,   0,  36,   0,   0,   0,  48,   0,   0,   0,  48,   0,   0,   0,  36,   0,   1,   0,  48,   0,   0,   0,   0,   0,
+      1,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   2, 254, 255,  81,   0,   0,   5,   2,   0,  15, 160,
+      0,   0,   0,  63,   0,   0, 128,  63,   0,   0,   0,   0,   0,   0,   0,   0,  31,   0,   0,   2,   5,   0,   0, 128,
+      0,   0,  15, 144,  31,   0,   0,   2,   5,   0,   1, 128,   1,   0,  15, 144,   1,   0,   0,   2,   0,   0,   1, 128,
+      2,   0,   0, 160,   4,   0,   0,   4,   0,   0,   6, 128,   1,   0, 208, 160,   0,   0,   0, 129,   0,   0, 208, 144,
+      5,   0,   0,   3,   0,   0,   9, 128,   0,   0,   0, 128,   1,   0, 100, 160,   6,   0,   0,   2,   1,   0,   1, 128,
+      0,   0,   0, 128,   6,   0,   0,   2,   1,   0,   2, 128,   0,   0, 255, 128,   5,   0,   0,   3,   0,   0,   3, 128,
+      0,   0, 233, 128,   1,   0, 228, 128,   1,   0,   0,   2,   0,   0,   4, 128,   0,   0,  85, 129,   2,   0,   0,   3,
+      0,   0,   3, 192,   0,   0, 232, 128,   0,   0, 228, 160,   4,   0,   0,   4,   0,   0,  12, 192,   0,   0, 170, 144,
+      2,   0, 148, 160,   2,   0, 100, 160,   1,   0,   0,   2,   0,   0,   3, 224,   1,   0, 228, 144, 255, 255,   0,   0,
+     83,  72,  68,  82,  60,   1,   0,   0,  64,   0,   1,   0,  79,   0,   0,   0,  89,   0,   0,   4,  70, 142,  32,   0,
+      0,   0,   0,   0,   1,   0,   0,   0,  95,   0,   0,   3, 114,  16,  16,   0,   0,   0,   0,   0,  95,   0,   0,   3,
+     50,  16,  16,   0,   1,   0,   0,   0, 103,   0,   0,   4, 242,  32,  16,   0,   0,   0,   0,   0,   1,   0,   0,   0,
+    101,   0,   0,   3,  50,  32,  16,   0,   1,   0,   0,   0, 104,   0,   0,   2,   1,   0,   0,   0,  56,   0,   0,  11,
+     50,   0,  16,   0,   0,   0,   0,   0,  70, 128,  32,   0,   0,   0,   0,   0,   0,   0,   0,   0,   2,  64,   0,   0,
+      0,   0,   0,  63,   0,   0,   0,  63,   0,   0,   0,   0,   0,   0,   0,   0,  50,   0,   0,  14, 194,   0,  16,   0,
+      0,   0,   0,   0,   6, 132,  32, 128,  65,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   2,  64,   0,   0,
+      0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,  63,   0,   0,   0,  63,   6,  20,  16,   0,   0,   0,   0,   0,
+     14,   0,   0,   7,  50,   0,  16,   0,   0,   0,   0,   0, 230,  10,  16,   0,   0,   0,   0,   0,  70,   0,  16,   0,
+      0,   0,   0,   0,  56,   0,   0,  10,  50,  32,  16,   0,   0,   0,   0,   0,  70,   0,  16,   0,   0,   0,   0,   0,
+      2,  64,   0,   0,   0,   0, 128,  63,   0,   0, 128, 191,   0,   0,   0,   0,   0,   0,   0,   0,  54,   0,   0,   5,
+     66,  32,  16,   0,   0,   0,   0,   0,  42,  16,  16,   0,   0,   0,   0,   0,  54,   0,   0,   5, 130,  32,  16,   0,
+      0,   0,   0,   0,   1,  64,   0,   0,   0,   0, 128,  63,  54,   0,   0,   5,  50,  32,  16,   0,   1,   0,   0,   0,
+     70,  16,  16,   0,   1,   0,   0,   0,  62,   0,   0,   1,  73,  83,  71,  78,  76,   0,   0,   0,   2,   0,   0,   0,
+      8,   0,   0,   0,  56,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,   0,   0,   0,   0,
+      7,   7,   0,   0,  65,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,   1,   0,   0,   0,
+      3,   3,   0,   0,  80,  79,  83,  73,  84,  73,  79,  78,   0,  84,  69,  88,  67,  79,  79,  82,  68,   0, 171, 171,
+     79,  83,  71,  78,  80,   0,   0,   0,   2,   0,   0,   0,   8,   0,   0,   0,  56,   0,   0,   0,   0,   0,   0,   0,
+      1,   0,   0,   0,   3,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,   0,  68,   0,   0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   3,   0,   0,   0,   1,   0,   0,   0,   3,  12,   0,   0,  83,  86,  95,  80,  79,  83,  73,  84,
+     73,  79,  78,   0,  84,  69,  88,  67,  79,  79,  82,  68,   0, 171, 171, 171
+};
+
+static const uint8_t pixel_shader_bytes[] =
+{
+     68,  88,  66,  67,   0,  95,  83, 169,  90,  60, 208,  75, 219, 179, 108, 203,   8, 232, 255,  27,   1,   0,   0,   0,
+    148,   1,   0,   0,   4,   0,   0,   0,  48,   0,   0,   0, 156,   0,   0,   0,   8,   1,   0,   0,  96,   1,   0,   0,
+     65, 111, 110,  57, 100,   0,   0,   0, 100,   0,   0,   0,   0,   2, 255, 255,  60,   0,   0,   0,  40,   0,   0,   0,
+      0,   0,  40,   0,   0,   0,  40,   0,   0,   0,  40,   0,   1,   0,  36,   0,   0,   0,  40,   0,   0,   0,   0,   0,
+      0,   2, 255, 255,  31,   0,   0,   2,   0,   0,   0, 128,   0,   0,   3, 176,  31,   0,   0,   2,   0,   0,   0, 144,
+      0,   8,  15, 160,  66,   0,   0,   3,   0,   0,  15, 128,   0,   0, 228, 176,   0,   8, 228, 160,   1,   0,   0,   2,
+      0,   8,  15, 128,   0,   0, 228, 128, 255, 255,   0,   0,  83,  72,  68,  82, 100,   0,   0,   0,  64,   0,   0,   0,
+     25,   0,   0,   0,  90,   0,   0,   3,   0,  96,  16,   0,   0,   0,   0,   0,  88,  24,   0,   4,   0, 112,  16,   0,
+      0,   0,   0,   0,  85,  85,   0,   0,  98,  16,   0,   3,  50,  16,  16,   0,   1,   0,   0,   0, 101,   0,   0,   3,
+    242,  32,  16,   0,   0,   0,   0,   0,  69,   0,   0,   9, 242,  32,  16,   0,   0,   0,   0,   0,  70,  16,  16,   0,
+      1,   0,   0,   0,  70, 126,  16,   0,   0,   0,   0,   0,   0,  96,  16,   0,   0,   0,   0,   0,  62,   0,   0,   1,
+     73,  83,  71,  78,  80,   0,   0,   0,   2,   0,   0,   0,   8,   0,   0,   0,  56,   0,   0,   0,   0,   0,   0,   0,
+      1,   0,   0,   0,   3,   0,   0,   0,   0,   0,   0,   0,  15,   0,   0,   0,  68,   0,   0,   0,   0,   0,   0,   0,
+      0,   0,   0,   0,   3,   0,   0,   0,   1,   0,   0,   0,   3,   3,   0,   0,  83,  86,  95,  80,  79,  83,  73,  84,
+     73,  79,  78,   0,  84,  69,  88,  67,  79,  79,  82,  68,   0, 171, 171, 171,  79,  83,  71,  78,  44,   0,   0,   0,
+      1,   0,   0,   0,   8,   0,   0,   0,  32,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   3,   0,   0,   0,
+      0,   0,   0,   0,  15,   0,   0,   0,  83,  86,  95,  84,  97, 114, 103, 101, 116,   0, 171, 171
+};
+
+#endif
diff --git a/libavformat/Makefile b/libavformat/Makefile
index 6c6b779..f67a99f 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -273,6 +273,7 @@ OBJS-$(CONFIG_IMAGE_DPX_PIPE_DEMUXER)     += img2dec.o img2.o
 OBJS-$(CONFIG_IMAGE_EXR_PIPE_DEMUXER)     += img2dec.o img2.o
 OBJS-$(CONFIG_IMAGE_GEM_PIPE_DEMUXER)     += img2dec.o img2.o
 OBJS-$(CONFIG_IMAGE_GIF_PIPE_DEMUXER)     += img2dec.o img2.o
+OBJS-$(CONFIG_IMAGE_HDR_PIPE_DEMUXER)     += img2dec.o img2.o
 OBJS-$(CONFIG_IMAGE_J2K_PIPE_DEMUXER)     += img2dec.o img2.o
 OBJS-$(CONFIG_IMAGE_JPEG_PIPE_DEMUXER)    += img2dec.o img2.o
 OBJS-$(CONFIG_IMAGE_JPEGLS_PIPE_DEMUXER)  += img2dec.o img2.o
@@ -713,7 +714,7 @@ SHLIBOBJS-$(CONFIG_SPDIF_MUXER)          += dca_sample_rate_tab.o
 OBJS-$(CONFIG_IEC61883_INDEV)            += dv.o
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES)             += avformatres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES)            += avformatres.o
 
 SKIPHEADERS-$(CONFIG_IMF_DEMUXER)        += imf.h
 SKIPHEADERS-$(CONFIG_FFRTMPCRYPT_PROTOCOL) += rtmpdh.h
diff --git a/libavformat/ac3dec.c b/libavformat/ac3dec.c
index 51461be..989d126 100644
--- a/libavformat/ac3dec.c
+++ b/libavformat/ac3dec.c
@@ -131,7 +131,7 @@ const AVInputFormat ff_eac3_demuxer = {
     .read_header    = ff_raw_audio_read_header,
     .read_packet    = ff_raw_read_partial_packet,
     .flags          = AVFMT_GENERIC_INDEX,
-    .extensions     = "eac3",
+    .extensions     = "eac3,ec3",
     .raw_codec_id   = AV_CODEC_ID_EAC3,
     .priv_data_size = sizeof(FFRawDemuxerContext),
     .priv_class     = &ff_raw_demuxer_class,
diff --git a/libavformat/aiffdec.c b/libavformat/aiffdec.c
index 80733e5..0487d3f 100644
--- a/libavformat/aiffdec.c
+++ b/libavformat/aiffdec.c
@@ -372,8 +372,6 @@ got_sound:
         av_log(s, AV_LOG_ERROR, "could not find COMM tag or invalid block_align value\n");
         return AVERROR_INVALIDDATA;
     }
-    if (aiff->block_duration < 0)
-        return AVERROR_INVALIDDATA;
 
     /* Now positioned, get the sound data start and end */
     avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
@@ -428,7 +426,7 @@ static int aiff_read_packet(AVFormatContext *s,
         pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
     /* Only one stream in an AIFF file */
     pkt->stream_index = 0;
-    pkt->duration     = (res / st->codecpar->block_align) * (int64_t) aiff->block_duration;
+    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
     return 0;
 }
 
diff --git a/libavformat/allformats.c b/libavformat/allformats.c
index 32698b8..ae4479f 100644
--- a/libavformat/allformats.c
+++ b/libavformat/allformats.c
@@ -508,6 +508,7 @@ extern const AVInputFormat  ff_image_dpx_pipe_demuxer;
 extern const AVInputFormat  ff_image_exr_pipe_demuxer;
 extern const AVInputFormat  ff_image_gem_pipe_demuxer;
 extern const AVInputFormat  ff_image_gif_pipe_demuxer;
+extern const AVInputFormat  ff_image_hdr_pipe_demuxer;
 extern const AVInputFormat  ff_image_j2k_pipe_demuxer;
 extern const AVInputFormat  ff_image_jpeg_pipe_demuxer;
 extern const AVInputFormat  ff_image_jpegls_pipe_demuxer;
diff --git a/libavformat/ape.c b/libavformat/ape.c
index d6c8ec2..bf1254e 100644
--- a/libavformat/ape.c
+++ b/libavformat/ape.c
@@ -298,8 +298,6 @@ static int ape_read_header(AVFormatContext * s)
             ape->frames[i].pos  -= ape->frames[i].skip;
             ape->frames[i].size += ape->frames[i].skip;
         }
-        if (ape->frames[i].size > INT_MAX - 3)
-            return AVERROR_INVALIDDATA;
         ape->frames[i].size = (ape->frames[i].size + 3) & ~3;
     }
     if (ape->fileversion < 3810) {
diff --git a/libavformat/apm.c b/libavformat/apm.c
index a3ddc08..baf7d2f 100644
--- a/libavformat/apm.c
+++ b/libavformat/apm.c
@@ -148,7 +148,7 @@ static int apm_read_header(AVFormatContext *s)
     par->codec_id              = AV_CODEC_ID_ADPCM_IMA_APM;
     par->format                = AV_SAMPLE_FMT_S16;
     par->bit_rate              = par->ch_layout.nb_channels *
-                                 (int64_t)par->sample_rate *
+                                 par->sample_rate *
                                  par->bits_per_coded_sample;
 
     if ((ret = avio_read(s->pb, buf, APM_FILE_EXTRADATA_SIZE)) < 0)
diff --git a/libavformat/argo_cvg.c b/libavformat/argo_cvg.c
index f324870..edf75c9 100644
--- a/libavformat/argo_cvg.c
+++ b/libavformat/argo_cvg.c
@@ -40,9 +40,9 @@
 #define ARGO_CVG_SAMPLES_PER_BLOCK  28
 
 typedef struct ArgoCVGHeader {
-    uint32_t size; /*< File size -8 (this + trailing checksum) */
-    uint32_t unk1; /*< Unknown. Always seems to be 0 or 1. */
-    uint32_t unk2; /*< Unknown. Always seems to be 0 or 1. */
+    uint32_t size;   /*< File size -8 (this + trailing checksum) */
+    uint32_t loop;   /*< Loop flag. */
+    uint32_t reverb; /*< Reverb flag. */
 } ArgoCVGHeader;
 
 typedef struct ArgoCVGOverride {
@@ -62,6 +62,8 @@ typedef struct ArgoCVGDemuxContext {
 typedef struct ArgoCVGMuxContext {
     const AVClass *class;
     int           skip_rate_check;
+    int           loop;
+    int           reverb;
     uint32_t      checksum;
     size_t        size;
 } ArgoCVGMuxContext;
@@ -91,17 +93,17 @@ static int argo_cvg_probe(const AVProbeData *p)
     if (p->buf_size < ARGO_CVG_HEADER_SIZE)
         return 0;
 
-    cvg.size = AV_RL32(p->buf + 0);
-    cvg.unk1 = AV_RL32(p->buf + 4);
-    cvg.unk2 = AV_RL32(p->buf + 8);
+    cvg.size   = AV_RL32(p->buf + 0);
+    cvg.loop   = AV_RL32(p->buf + 4);
+    cvg.reverb = AV_RL32(p->buf + 8);
 
     if (cvg.size < 8)
         return 0;
 
-    if (cvg.unk1 != 0 && cvg.unk1 != 1)
+    if (cvg.loop != 0 && cvg.loop != 1)
         return 0;
 
-    if (cvg.unk2 != 0 && cvg.unk2 != 1)
+    if (cvg.reverb != 0 && cvg.reverb != 1)
         return 0;
 
     return AVPROBE_SCORE_MAX / 4 + 1;
@@ -150,20 +152,24 @@ static int argo_cvg_read_header(AVFormatContext *s)
     else if (ret != ARGO_CVG_HEADER_SIZE)
         return AVERROR(EIO);
 
-    ctx->header.size = AV_RL32(buf + 0);
-    ctx->header.unk1 = AV_RL32(buf + 4);
-    ctx->header.unk2 = AV_RL32(buf + 8);
+    ctx->header.size   = AV_RL32(buf + 0);
+    ctx->header.loop   = AV_RL32(buf + 4);
+    ctx->header.reverb = AV_RL32(buf + 8);
 
     if (ctx->header.size < 8)
         return AVERROR_INVALIDDATA;
 
-    av_log(s, AV_LOG_TRACE, "size       = %u\n", ctx->header.size);
-    av_log(s, AV_LOG_TRACE, "unk        = %u, %u\n", ctx->header.unk1, ctx->header.unk2);
-
     if ((ret = argo_cvg_read_checksum(s->pb, &ctx->header, &ctx->checksum)) < 0)
         return ret;
 
-    av_log(s, AV_LOG_TRACE, "checksum   = %u\n", ctx->checksum);
+    if ((ret = av_dict_set_int(&st->metadata, "loop", ctx->header.loop, 0)) < 0)
+        return ret;
+
+    if ((ret = av_dict_set_int(&st->metadata, "reverb", ctx->header.reverb, 0)) < 0)
+        return ret;
+
+    if ((ret = av_dict_set_int(&st->metadata, "checksum", ctx->checksum, 0)) < 0)
+        return ret;
 
     par                         = st->codecpar;
     par->codec_type             = AVMEDIA_TYPE_AUDIO;
@@ -172,10 +178,10 @@ static int argo_cvg_read_header(AVFormatContext *s)
 
     for (size_t i = 0; i < FF_ARRAY_ELEMS(overrides); i++) {
         const ArgoCVGOverride *ovr = overrides + i;
-        if (ovr->header.size != ctx->header.size ||
-            ovr->header.unk1 != ctx->header.unk1 ||
-            ovr->header.unk2 != ctx->header.unk2 ||
-            ovr->checksum    != ctx->checksum    ||
+        if (ovr->header.size   != ctx->header.size ||
+            ovr->header.loop   != ctx->header.loop ||
+            ovr->header.reverb != ctx->header.reverb ||
+            ovr->checksum      != ctx->checksum    ||
             av_strcasecmp(filename, ovr->name) != 0)
             continue;
 
@@ -302,10 +308,10 @@ static int argo_cvg_write_header(AVFormatContext *s)
     ArgoCVGMuxContext *ctx = s->priv_data;
 
     avio_wl32(s->pb, 0); /* Size, fixed later. */
-    avio_wl32(s->pb, 0);
-    avio_wl32(s->pb, 1);
+    avio_wl32(s->pb, !!ctx->loop);
+    avio_wl32(s->pb, !!ctx->reverb);
 
-    ctx->checksum = 1;
+    ctx->checksum = !!ctx->loop + !!ctx->reverb;
     ctx->size     = 8;
     return 0;
 }
@@ -364,6 +370,26 @@ static const AVOption argo_cvg_options[] = {
         .max         = 1,
         .flags       = AV_OPT_FLAG_ENCODING_PARAM
     },
+    {
+        .name        = "loop",
+        .help        = "set loop flag",
+        .offset      = offsetof(ArgoCVGMuxContext, loop),
+        .type        = AV_OPT_TYPE_BOOL,
+        .default_val = {.i64 = 0},
+        .min         = 0,
+        .max         = 1,
+        .flags       = AV_OPT_FLAG_ENCODING_PARAM
+    },
+        {
+        .name        = "reverb",
+        .help        = "set reverb flag",
+        .offset      = offsetof(ArgoCVGMuxContext, reverb),
+        .type        = AV_OPT_TYPE_BOOL,
+        .default_val = {.i64 = 1},
+        .min         = 0,
+        .max         = 1,
+        .flags       = AV_OPT_FLAG_ENCODING_PARAM
+    },
     { NULL }
 };
 
diff --git a/libavformat/asfcrypt.c b/libavformat/asfcrypt.c
index c77e375..ed68fb6 100644
--- a/libavformat/asfcrypt.c
+++ b/libavformat/asfcrypt.c
@@ -73,7 +73,7 @@ static void multiswap_invert_keys(uint32_t keys[12])
         keys[i] = inverse(keys[i]);
 }
 
-static uint32_t multiswap_step(const uint32_t keys[12], uint32_t v)
+static uint32_t multiswap_step(const uint32_t keys[6], uint32_t v)
 {
     int i;
     v *= keys[0];
@@ -85,7 +85,7 @@ static uint32_t multiswap_step(const uint32_t keys[12], uint32_t v)
     return v;
 }
 
-static uint32_t multiswap_inv_step(const uint32_t keys[12], uint32_t v)
+static uint32_t multiswap_inv_step(const uint32_t keys[6], uint32_t v)
 {
     int i;
     v -= keys[5];
diff --git a/libavformat/asfdec_o.c b/libavformat/asfdec_o.c
index e837ca6..907be6d 100644
--- a/libavformat/asfdec_o.c
+++ b/libavformat/asfdec_o.c
@@ -109,7 +109,6 @@ typedef struct ASFContext {
     int64_t data_offset;
     int64_t first_packet_offset; // packet offset
     int64_t unknown_offset;   // for top level header objects or subobjects without specified behavior
-    int in_asf_read_unknown;
 
     // ASF file must not contain more than 128 streams according to the specification
     ASFStream *asf_st[ASF_MAX_STREAMS];
@@ -174,7 +173,7 @@ static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
     uint64_t size   = avio_rl64(pb);
     int ret;
 
-    if (size > INT64_MAX || asf->in_asf_read_unknown > 5)
+    if (size > INT64_MAX)
         return AVERROR_INVALIDDATA;
 
     if (asf->is_header)
@@ -183,11 +182,8 @@ static int asf_read_unknown(AVFormatContext *s, const GUIDParseTable *g)
     if (!g->is_subobject) {
         if (!(ret = strcmp(g->name, "Header Extension")))
             avio_skip(pb, 22); // skip reserved fields and Data Size
-        asf->in_asf_read_unknown ++;
-        ret = detect_unknown_subobject(s, asf->unknown_offset,
-                                            asf->unknown_size);
-        asf->in_asf_read_unknown --;
-        if (ret < 0)
+        if ((ret = detect_unknown_subobject(s, asf->unknown_offset,
+                                            asf->unknown_size)) < 0)
             return ret;
     } else {
         if (size < 24) {
@@ -1242,8 +1238,6 @@ static int asf_read_packet_header(AVFormatContext *s)
     unsigned char error_flags, len_flags, pay_flags;
 
     asf->packet_offset = avio_tell(pb);
-    if (asf->packet_offset > INT64_MAX/2)
-        asf->packet_offset = 0;
     error_flags = avio_r8(pb); // read Error Correction Flags
     if (error_flags & ASF_PACKET_FLAG_ERROR_CORRECTION_PRESENT) {
         if (!(error_flags & ASF_ERROR_CORRECTION_LENGTH_TYPE)) {
diff --git a/libavformat/avformat.c b/libavformat/avformat.c
index 30d6ea6..19c7219 100644
--- a/libavformat/avformat.c
+++ b/libavformat/avformat.c
@@ -235,6 +235,72 @@ int ff_stream_side_data_copy(AVStream *dst, const AVStream *src)
     return 0;
 }
 
+/**
+ * Copy all stream parameters from source to destination stream, with the
+ * exception of the index field, which is usually set by avformat_new_stream().
+ *
+ * @param dst pointer to destination AVStream
+ * @param src pointer to source AVStream
+ * @return >=0 on success, AVERROR code on error
+ */
+static int stream_params_copy(AVStream *dst, const AVStream *src)
+{
+    int ret;
+
+    dst->id                  = src->id;
+    dst->time_base           = src->time_base;
+    dst->start_time          = src->start_time;
+    dst->duration            = src->duration;
+    dst->nb_frames           = src->nb_frames;
+    dst->disposition         = src->disposition;
+    dst->discard             = src->discard;
+    dst->sample_aspect_ratio = src->sample_aspect_ratio;
+    dst->avg_frame_rate      = src->avg_frame_rate;
+    dst->event_flags         = src->event_flags;
+    dst->r_frame_rate        = src->r_frame_rate;
+    dst->pts_wrap_bits       = src->pts_wrap_bits;
+
+    av_dict_free(&dst->metadata);
+    ret = av_dict_copy(&dst->metadata, src->metadata, 0);
+    if (ret < 0)
+        return ret;
+
+    ret = avcodec_parameters_copy(dst->codecpar, src->codecpar);
+    if (ret < 0)
+        return ret;
+
+    ret = ff_stream_side_data_copy(dst, src);
+    if (ret < 0)
+        return ret;
+
+    av_packet_unref(&dst->attached_pic);
+    if (src->attached_pic.data) {
+        ret = av_packet_ref(&dst->attached_pic, &src->attached_pic);
+        if (ret < 0)
+            return ret;
+    }
+
+    return 0;
+}
+
+AVStream *ff_stream_clone(AVFormatContext *dst_ctx, const AVStream *src)
+{
+    AVStream *st;
+    int ret;
+
+    st = avformat_new_stream(dst_ctx, NULL);
+    if (!st)
+        return NULL;
+
+    ret = stream_params_copy(st, src);
+    if (ret < 0) {
+        ff_remove_stream(dst_ctx, st);
+        return NULL;
+    }
+
+    return st;
+}
+
 AVProgram *av_new_program(AVFormatContext *ac, int id)
 {
     AVProgram *program = NULL;
diff --git a/libavformat/avidec.c b/libavformat/avidec.c
index 910a4e8..937d9e6 100644
--- a/libavformat/avidec.c
+++ b/libavformat/avidec.c
@@ -82,8 +82,6 @@ typedef struct AVIContext {
     int stream_index;
     DVDemuxContext *dv_demux;
     int odml_depth;
-    int64_t odml_read;
-    int64_t odml_max_pos;
     int use_odml;
 #define MAX_ODML_DEPTH 1000
     int64_t dts_max;
@@ -202,7 +200,7 @@ static int read_odml_index(AVFormatContext *s, int64_t frame_num)
     st  = s->streams[stream_id];
     ast = st->priv_data;
 
-    if (index_sub_type || entries_in_use < 0)
+    if (index_sub_type)
         return AVERROR_INVALIDDATA;
 
     avio_rl32(pb);
@@ -223,18 +221,11 @@ static int read_odml_index(AVFormatContext *s, int64_t frame_num)
     }
 
     for (i = 0; i < entries_in_use; i++) {
-        avi->odml_max_pos = FFMAX(avi->odml_max_pos, avio_tell(pb));
-
-        // If we read more than there are bytes then we must have been reading something twice
-        if (avi->odml_read > avi->odml_max_pos)
-            return AVERROR_INVALIDDATA;
-
         if (index_type) {
             int64_t pos = avio_rl32(pb) + base - 8;
             int len     = avio_rl32(pb);
             int key     = len >= 0;
             len &= 0x7FFFFFFF;
-            avi->odml_read += 8;
 
             av_log(s, AV_LOG_TRACE, "pos:%"PRId64", len:%X\n", pos, len);
 
@@ -253,7 +244,6 @@ static int read_odml_index(AVFormatContext *s, int64_t frame_num)
             int64_t offset, pos;
             int duration;
             int ret;
-            avi->odml_read += 16;
 
             offset = avio_rl64(pb);
             avio_rl32(pb);       /* size */
diff --git a/libavformat/avisynth.c b/libavformat/avisynth.c
index ec595da..3d9fa2b 100644
--- a/libavformat/avisynth.c
+++ b/libavformat/avisynth.c
@@ -728,6 +728,7 @@ static int avisynth_create_stream_video(AVFormatContext *s, AVStream *st)
                 st->codecpar->chroma_location = AVCHROMA_LOC_UNSPECIFIED;
             }
         }
+        avs_library.avs_release_video_frame(frame);
     } else {
         st->codecpar->field_order = AV_FIELD_UNKNOWN;
         /* AviSynth works with frame-based video, detecting field order can
@@ -750,10 +751,10 @@ static int avisynth_create_stream_audio(AVFormatContext *s, AVStream *st)
 {
     AviSynthContext *avs = s->priv_data;
 
-    st->codecpar->codec_type  = AVMEDIA_TYPE_AUDIO;
-    st->codecpar->sample_rate = avs->vi->audio_samples_per_second;
-    st->codecpar->ch_layout.nb_channels    = avs->vi->nchannels;
-    st->duration              = avs->vi->num_audio_samples;
+    st->codecpar->codec_type            = AVMEDIA_TYPE_AUDIO;
+    st->codecpar->sample_rate           = avs->vi->audio_samples_per_second;
+    st->codecpar->ch_layout.nb_channels = avs->vi->nchannels;
+    st->duration                        = avs->vi->num_audio_samples;
     avpriv_set_pts_info(st, 64, 1, avs->vi->audio_samples_per_second);
 
     switch (avs->vi->sample_type) {
diff --git a/libavformat/cafdec.c b/libavformat/cafdec.c
index e0a9031..d5b8c38 100644
--- a/libavformat/cafdec.c
+++ b/libavformat/cafdec.c
@@ -387,7 +387,7 @@ static int read_header(AVFormatContext *s)
 
 found_data:
     if (caf->bytes_per_packet > 0 && caf->frames_per_packet > 0) {
-        if (caf->data_size > 0 && caf->data_size / caf->bytes_per_packet < INT64_MAX / caf->frames_per_packet)
+        if (caf->data_size > 0)
             st->nb_frames = (caf->data_size / caf->bytes_per_packet) * caf->frames_per_packet;
     } else if (ffstream(st)->nb_index_entries && st->duration > 0) {
         if (st->codecpar->sample_rate && caf->data_size / st->duration > INT64_MAX / st->codecpar->sample_rate / 8) {
diff --git a/libavformat/cafenc.c b/libavformat/cafenc.c
index b90811d..fedb430 100644
--- a/libavformat/cafenc.c
+++ b/libavformat/cafenc.c
@@ -53,11 +53,7 @@ static uint32_t codec_flags(enum AVCodecID codec_id) {
     }
 }
 
-static uint32_t samples_per_packet(const AVCodecParameters *par) {
-    enum AVCodecID codec_id = par->codec_id;
-    int channels = par->ch_layout.nb_channels, block_align = par->block_align;
-    int frame_size = par->frame_size, sample_rate = par->sample_rate;
-
+static uint32_t samples_per_packet(enum AVCodecID codec_id, int channels, int block_align) {
     switch (codec_id) {
     case AV_CODEC_ID_PCM_S8:
     case AV_CODEC_ID_PCM_S16LE:
@@ -87,8 +83,6 @@ static uint32_t samples_per_packet(const AVCodecParameters *par) {
         return 320;
     case AV_CODEC_ID_MP1:
         return 384;
-    case AV_CODEC_ID_OPUS:
-        return frame_size * 48000 / sample_rate;
     case AV_CODEC_ID_MP2:
     case AV_CODEC_ID_MP3:
         return 1152;
@@ -116,7 +110,7 @@ static int caf_write_header(AVFormatContext *s)
     AVDictionaryEntry *t = NULL;
     unsigned int codec_tag = ff_codec_get_tag(ff_codec_caf_tags, par->codec_id);
     int64_t chunk_size = 0;
-    int frame_size = par->frame_size, sample_rate = par->sample_rate;
+    int frame_size = par->frame_size;
 
     if (s->nb_streams != 1) {
         av_log(s, AV_LOG_ERROR, "CAF files have exactly one stream\n");
@@ -145,10 +139,7 @@ static int caf_write_header(AVFormatContext *s)
     }
 
     if (par->codec_id != AV_CODEC_ID_MP3 || frame_size != 576)
-        frame_size = samples_per_packet(par);
-
-    if (par->codec_id == AV_CODEC_ID_OPUS)
-        sample_rate = 48000;
+        frame_size = samples_per_packet(par->codec_id, par->ch_layout.nb_channels, par->block_align);
 
     ffio_wfourcc(pb, "caff"); //< mFileType
     avio_wb16(pb, 1);         //< mFileVersion
@@ -156,7 +147,7 @@ static int caf_write_header(AVFormatContext *s)
 
     ffio_wfourcc(pb, "desc");                         //< Audio Description chunk
     avio_wb64(pb, 32);                                //< mChunkSize
-    avio_wb64(pb, av_double2int(sample_rate));        //< mSampleRate
+    avio_wb64(pb, av_double2int(par->sample_rate));   //< mSampleRate
     avio_wl32(pb, codec_tag);                         //< mFormatID
     avio_wb32(pb, codec_flags(par->codec_id));        //< mFormatFlags
     avio_wb32(pb, par->block_align);                  //< mBytesPerPacket
@@ -257,7 +248,7 @@ static int caf_write_trailer(AVFormatContext *s)
         avio_seek(pb, caf->data, SEEK_SET);
         avio_wb64(pb, file_size - caf->data - 8);
         if (!par->block_align) {
-            int packet_size = samples_per_packet(par);
+            int packet_size = samples_per_packet(par->codec_id, par->ch_layout.nb_channels, par->block_align);
             if (!packet_size) {
                 packet_size = st->duration / (caf->packets - 1);
                 avio_seek(pb, FRAME_SIZE_OFFSET, SEEK_SET);
diff --git a/libavformat/dashdec.c b/libavformat/dashdec.c
index 2ca91be..63bf7e9 100644
--- a/libavformat/dashdec.c
+++ b/libavformat/dashdec.c
@@ -956,11 +956,7 @@ static int parse_manifest_representation(AVFormatContext *s, const char *url,
             xmlFree(val);
         }
         if (adaptionset_supplementalproperty_node) {
-            char *scheme_id_uri = xmlGetProp(adaptionset_supplementalproperty_node, "schemeIdUri");
-            if (scheme_id_uri) {
-                int is_last_segment_number = !av_strcasecmp(scheme_id_uri, "http://dashif.org/guidelines/last-segment-number");
-                xmlFree(scheme_id_uri);
-                if (is_last_segment_number) {
+            if (!av_strcasecmp(xmlGetProp(adaptionset_supplementalproperty_node,"schemeIdUri"), "http://dashif.org/guidelines/last-segment-number")) {
                 val = xmlGetProp(adaptionset_supplementalproperty_node,"value");
                 if (!val) {
                     av_log(s, AV_LOG_ERROR, "Missing value attribute in adaptionset_supplementalproperty_node\n");
@@ -969,7 +965,6 @@ static int parse_manifest_representation(AVFormatContext *s, const char *url,
                     xmlFree(val);
                 }
             }
-            }
         }
 
         fragment_timeline_node = find_child_node_by_name(representation_segmenttemplate_node, "SegmentTimeline");
diff --git a/libavformat/dhav.c b/libavformat/dhav.c
index 4e720f2..9d26efe 100644
--- a/libavformat/dhav.c
+++ b/libavformat/dhav.c
@@ -242,7 +242,7 @@ static int64_t get_duration(AVFormatContext *s)
     avio_seek(s->pb, avio_size(s->pb) - 8, SEEK_SET);
     while (avio_tell(s->pb) > 12 && max_interations--) {
         if (avio_rl32(s->pb) == MKTAG('d','h','a','v')) {
-            int64_t seek_back = avio_rl32(s->pb);
+            int seek_back = avio_rl32(s->pb);
 
             avio_seek(s->pb, -seek_back, SEEK_CUR);
             read_chunk(s);
diff --git a/libavformat/dxa.c b/libavformat/dxa.c
index 474b852..16fbb08 100644
--- a/libavformat/dxa.c
+++ b/libavformat/dxa.c
@@ -118,12 +118,9 @@ static int dxa_read_header(AVFormatContext *s)
             if(tag == MKTAG('d', 'a', 't', 'a')) break;
             avio_skip(pb, fsize);
         }
-        c->bpc = (fsize + (int64_t)c->frames - 1) / c->frames;
-        if(ast->codecpar->block_align) {
-            if (c->bpc > INT_MAX - ast->codecpar->block_align + 1)
-                return AVERROR_INVALIDDATA;
+        c->bpc = (fsize + c->frames - 1) / c->frames;
+        if(ast->codecpar->block_align)
             c->bpc = ((c->bpc + ast->codecpar->block_align - 1) / ast->codecpar->block_align) * ast->codecpar->block_align;
-        }
         c->bytes_left = fsize;
         c->wavpos = avio_tell(pb);
         avio_seek(pb, c->vidpos, SEEK_SET);
diff --git a/libavformat/fifo.c b/libavformat/fifo.c
index ead2bdc..692c854 100644
--- a/libavformat/fifo.c
+++ b/libavformat/fifo.c
@@ -505,13 +505,9 @@ static int fifo_mux_init(AVFormatContext *avf, const AVOutputFormat *oformat,
     avf2->flags = avf->flags;
 
     for (i = 0; i < avf->nb_streams; ++i) {
-        AVStream *st = avformat_new_stream(avf2, NULL);
+        AVStream *st = ff_stream_clone(avf2, avf->streams[i]);
         if (!st)
             return AVERROR(ENOMEM);
-
-        ret = ff_stream_encode_params_copy(st, avf->streams[i]);
-        if (ret < 0)
-            return ret;
     }
 
     return 0;
diff --git a/libavformat/flvdec.c b/libavformat/flvdec.c
index 7242296..10f0ea7 100644
--- a/libavformat/flvdec.c
+++ b/libavformat/flvdec.c
@@ -65,7 +65,7 @@ typedef struct FLVContext {
     uint8_t resync_buffer[2*RESYNC_BUFFER_SIZE];
 
     int broken_sizes;
-    int64_t sum_flv_tag_size;
+    int sum_flv_tag_size;
 
     int last_keyframe_stream_index;
     int keyframe_count;
@@ -146,9 +146,9 @@ static void add_keyframes_index(AVFormatContext *s)
     if (ffstream(stream)->nb_index_entries == 0) {
         for (i = 0; i < flv->keyframe_count; i++) {
             av_log(s, AV_LOG_TRACE, "keyframe filepositions = %"PRId64" times = %"PRId64"\n",
-                   flv->keyframe_filepositions[i], flv->keyframe_times[i] * 1000);
+                   flv->keyframe_filepositions[i], flv->keyframe_times[i]);
             av_add_index_entry(stream, flv->keyframe_filepositions[i],
-                flv->keyframe_times[i] * 1000, 0, 0, AVINDEX_KEYFRAME);
+                flv->keyframe_times[i], 0, 0, AVINDEX_KEYFRAME);
         }
     } else
         av_log(s, AV_LOG_WARNING, "Skipping duplicate index\n");
@@ -428,6 +428,7 @@ static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, int64_t m
            amf_get_string(ioc, str_val, sizeof(str_val)) > 0) {
         int64_t **current_array;
         unsigned int arraylen;
+        int factor;
 
         // Expect array object in context
         if (avio_r8(ioc) != AMF_DATA_TYPE_ARRAY)
@@ -440,10 +441,12 @@ static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, int64_t m
         if       (!strcmp(KEYFRAMES_TIMESTAMP_TAG , str_val) && !times) {
             current_array = &times;
             timeslen      = arraylen;
+            factor = 1000;
         } else if (!strcmp(KEYFRAMES_BYTEOFFSET_TAG, str_val) &&
                    !filepositions) {
             current_array = &filepositions;
             fileposlen    = arraylen;
+            factor = 1;
         } else
             // unexpected metatag inside keyframes, will not use such
             // metadata for indexing
@@ -458,11 +461,9 @@ static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, int64_t m
             double d;
             if (avio_r8(ioc) != AMF_DATA_TYPE_NUMBER)
                 goto invalid;
-            d = av_int2double(avio_rb64(ioc));
+            d = av_int2double(avio_rb64(ioc)) * factor;
             if (isnan(d) || d < INT64_MIN || d > INT64_MAX)
                 goto invalid;
-            if (current_array == &times && (d <= INT64_MIN / 1000 || d >= INT64_MAX / 1000))
-                goto invalid;
             if (avio_feof(ioc))
                 goto invalid;
             current_array[0][i] = d;
@@ -478,7 +479,7 @@ static int parse_keyframes_index(AVFormatContext *s, AVIOContext *ioc, int64_t m
     if (timeslen == fileposlen && fileposlen>1 && max_pos <= filepositions[0]) {
         for (i = 0; i < FFMIN(2,fileposlen); i++) {
             flv->validate_index[i].pos = filepositions[i];
-            flv->validate_index[i].dts = times[i] * 1000;
+            flv->validate_index[i].dts = times[i];
             flv->validate_count        = i + 1;
         }
         flv->keyframe_times = times;
@@ -1030,7 +1031,7 @@ retry:
     type = (avio_r8(s->pb) & 0x1F);
     orig_size =
     size = avio_rb24(s->pb);
-    flv->sum_flv_tag_size += size + 11LL;
+    flv->sum_flv_tag_size += size + 11;
     dts  = avio_rb24(s->pb);
     dts |= (unsigned)avio_r8(s->pb) << 24;
     av_log(s, AV_LOG_TRACE, "type:%d, size:%d, last:%d, dts:%"PRId64" pos:%"PRId64"\n", type, size, last, dts, avio_tell(s->pb));
@@ -1330,7 +1331,7 @@ leave:
             !avio_feof(s->pb) &&
             (last != orig_size || !last) && last != flv->sum_flv_tag_size &&
             !flv->broken_sizes) {
-            av_log(s, AV_LOG_ERROR, "Packet mismatch %d %d %"PRId64"\n", last, orig_size + 11, flv->sum_flv_tag_size);
+            av_log(s, AV_LOG_ERROR, "Packet mismatch %d %d %d\n", last, orig_size + 11, flv->sum_flv_tag_size);
             avio_seek(s->pb, pos + 1, SEEK_SET);
             ret = resync(s);
             av_packet_unref(pkt);
diff --git a/libavformat/flvenc.c b/libavformat/flvenc.c
index 770ca31..5d574fa 100644
--- a/libavformat/flvenc.c
+++ b/libavformat/flvenc.c
@@ -104,7 +104,6 @@ typedef struct FLVContext {
     int64_t lastkeyframelocation_offset;
     int64_t lastkeyframelocation;
 
-    int acurframeindex;
     int64_t keyframes_info_offset;
 
     int64_t filepositions_count;
@@ -391,7 +390,6 @@ static void write_metadata(AVFormatContext *s, unsigned int ts)
     }
 
     if (flv->flags & FLV_ADD_KEYFRAME_INDEX) {
-        flv->acurframeindex = 0;
         flv->keyframe_index_size = 0;
 
         put_amf_string(pb, "hasVideo");
@@ -993,15 +991,11 @@ static int flv_write_packet(AVFormatContext *s, AVPacket *pkt)
         switch (par->codec_type) {
             case AVMEDIA_TYPE_VIDEO:
                 flv->videosize += (avio_tell(pb) - cur_offset);
-                flv->lasttimestamp = flv->acurframeindex / flv->framerate;
-                flv->acurframeindex++;
+                flv->lasttimestamp = pkt->dts / 1000.0;
                 if (pkt->flags & AV_PKT_FLAG_KEY) {
-                    double ts = flv->lasttimestamp;
-                    int64_t pos = cur_offset;
-
-                    flv->lastkeyframetimestamp = ts;
-                    flv->lastkeyframelocation = pos;
-                    ret = flv_append_keyframe_info(s, flv, ts, pos);
+                    flv->lastkeyframetimestamp = flv->lasttimestamp;
+                    flv->lastkeyframelocation = cur_offset;
+                    ret = flv_append_keyframe_info(s, flv, flv->lasttimestamp, cur_offset);
                     if (ret < 0)
                         goto fail;
                 }
diff --git a/libavformat/genh.c b/libavformat/genh.c
index 1f707b5..a25d4d6 100644
--- a/libavformat/genh.c
+++ b/libavformat/genh.c
@@ -78,8 +78,6 @@ static int genh_read_header(AVFormatContext *s)
     case  0: st->codecpar->codec_id = AV_CODEC_ID_ADPCM_PSX;        break;
     case  1:
     case 11: st->codecpar->bits_per_coded_sample = 4;
-             if (st->codecpar->ch_layout.nb_channels > INT_MAX / 36)
-                return AVERROR_INVALIDDATA;
              st->codecpar->block_align = 36 * st->codecpar->ch_layout.nb_channels;
              st->codecpar->codec_id = AV_CODEC_ID_ADPCM_IMA_WAV;    break;
     case  2: st->codecpar->codec_id = AV_CODEC_ID_ADPCM_DTK;        break;
diff --git a/libavformat/hevc.c b/libavformat/hevc.c
index df141ae..37d9794 100644
--- a/libavformat/hevc.c
+++ b/libavformat/hevc.c
@@ -924,31 +924,31 @@ static int hvcc_write(AVIOContext *pb, HEVCDecoderConfigurationRecord *hvcc)
     avio_w8(pb, hvcc->general_level_idc);
 
     /*
-     * bit(4) reserved = 1111b;
+     * bit(4) reserved = '1111'b;
      * unsigned int(12) min_spatial_segmentation_idc;
      */
     avio_wb16(pb, hvcc->min_spatial_segmentation_idc | 0xf000);
 
     /*
-     * bit(6) reserved = 111111b;
+     * bit(6) reserved = '111111'b;
      * unsigned int(2) parallelismType;
      */
     avio_w8(pb, hvcc->parallelismType | 0xfc);
 
     /*
-     * bit(6) reserved = 111111b;
+     * bit(6) reserved = '111111'b;
      * unsigned int(2) chromaFormat;
      */
     avio_w8(pb, hvcc->chromaFormat | 0xfc);
 
     /*
-     * bit(5) reserved = 11111b;
+     * bit(5) reserved = '11111'b;
      * unsigned int(3) bitDepthLumaMinus8;
      */
     avio_w8(pb, hvcc->bitDepthLumaMinus8 | 0xf8);
 
     /*
-     * bit(5) reserved = 11111b;
+     * bit(5) reserved = '11111'b;
      * unsigned int(3) bitDepthChromaMinus8;
      */
     avio_w8(pb, hvcc->bitDepthChromaMinus8 | 0xf8);
diff --git a/libavformat/hls.c b/libavformat/hls.c
index e622425..3dc7bd3 100644
--- a/libavformat/hls.c
+++ b/libavformat/hls.c
@@ -250,7 +250,6 @@ static void free_init_section_list(struct playlist *pls)
 {
     int i;
     for (i = 0; i < pls->n_init_sections; i++) {
-        av_freep(&pls->init_sections[i]->key);
         av_freep(&pls->init_sections[i]->url);
         av_freep(&pls->init_sections[i]);
     }
diff --git a/libavformat/icodec.c b/libavformat/icodec.c
index 85dab3b..290f658 100644
--- a/libavformat/icodec.c
+++ b/libavformat/icodec.c
@@ -196,9 +196,6 @@ static int read_packet(AVFormatContext *s, AVPacket *pkt)
             AV_WL32(buf + 32, image->nb_pal);
         }
 
-        if (image->nb_pal > INT_MAX / 4 - 14 - 40)
-            return AVERROR_INVALIDDATA;
-
         AV_WL32(buf - 4, 14 + 40 + image->nb_pal * 4);
         AV_WL32(buf + 8, AV_RL32(buf + 8) / 2);
     }
diff --git a/libavformat/iff.c b/libavformat/iff.c
index b8e8bff..b376006 100644
--- a/libavformat/iff.c
+++ b/libavformat/iff.c
@@ -501,9 +501,6 @@ static int iff_read_header(AVFormatContext *s)
         case ID_DST:
         case ID_MDAT:
             iff->body_pos = avio_tell(pb);
-            if (iff->body_pos < 0 || iff->body_pos + data_size > INT64_MAX)
-                return AVERROR_INVALIDDATA;
-
             iff->body_end = iff->body_pos + data_size;
             iff->body_size = data_size;
             if (chunk_id == ID_DST) {
diff --git a/libavformat/imfdec.c b/libavformat/imfdec.c
index 71dfb26..5bbe7a5 100644
--- a/libavformat/imfdec.c
+++ b/libavformat/imfdec.c
@@ -573,18 +573,14 @@ static int set_context_streams_from_tracks(AVFormatContext *s)
         first_resource_stream = c->tracks[i]->resources[0].ctx->streams[0];
         av_log(s, AV_LOG_DEBUG, "Open the first resource of track %d\n", c->tracks[i]->index);
 
-        /* Copy stream information */
-        asset_stream = avformat_new_stream(s, NULL);
+        asset_stream = ff_stream_clone(s, first_resource_stream);
         if (!asset_stream) {
-            av_log(s, AV_LOG_ERROR, "Could not create stream\n");
+            av_log(s, AV_LOG_ERROR, "Could not clone stream\n");
             return AVERROR(ENOMEM);
         }
+
         asset_stream->id = i;
-        ret = avcodec_parameters_copy(asset_stream->codecpar, first_resource_stream->codecpar);
-        if (ret < 0) {
-            av_log(s, AV_LOG_ERROR, "Could not copy stream parameters\n");
-            return ret;
-        }
+        asset_stream->nb_frames = 0;
         avpriv_set_pts_info(asset_stream,
                             first_resource_stream->pts_wrap_bits,
                             first_resource_stream->time_base.num,
diff --git a/libavformat/img2.c b/libavformat/img2.c
index 870d2eb..06e4854 100644
--- a/libavformat/img2.c
+++ b/libavformat/img2.c
@@ -91,6 +91,8 @@ const IdStrMap ff_img_tags[] = {
     { AV_CODEC_ID_VBN,        "vbn"      },
     { AV_CODEC_ID_JPEGXL,     "jxl"      },
     { AV_CODEC_ID_QOI,        "qoi"      },
+    { AV_CODEC_ID_RADIANCE_HDR, "hdr"    },
+    { AV_CODEC_ID_WBMP,       "wbmp"     },
     { AV_CODEC_ID_NONE,       NULL       }
 };
 
diff --git a/libavformat/img2dec.c b/libavformat/img2dec.c
index e7ff26e..5a63d7c 100644
--- a/libavformat/img2dec.c
+++ b/libavformat/img2dec.c
@@ -1070,6 +1070,13 @@ static int pam_probe(const AVProbeData *p)
     return pnm_magic_check(p, 7) ? pnm_probe(p) : 0;
 }
 
+static int hdr_probe(const AVProbeData *p)
+{
+    if (!memcmp(p->buf, "#?RADIANCE\n", 11))
+        return AVPROBE_SCORE_MAX;
+    return 0;
+}
+
 static int xbm_probe(const AVProbeData *p)
 {
     if (!memcmp(p->buf, "/* XBM X10 format */", 20))
@@ -1221,6 +1228,7 @@ IMAGEAUTO_DEMUXER(dpx,       DPX)
 IMAGEAUTO_DEMUXER(exr,       EXR)
 IMAGEAUTO_DEMUXER(gem,       GEM)
 IMAGEAUTO_DEMUXER(gif,       GIF)
+IMAGEAUTO_DEMUXER_EXT(hdr,   RADIANCE_HDR, HDR)
 IMAGEAUTO_DEMUXER_EXT(j2k,   JPEG2000, J2K)
 IMAGEAUTO_DEMUXER_EXT(jpeg,  MJPEG, JPEG)
 IMAGEAUTO_DEMUXER(jpegls,    JPEGLS)
diff --git a/libavformat/img2enc.c b/libavformat/img2enc.c
index 0224fb5..c05f37e 100644
--- a/libavformat/img2enc.c
+++ b/libavformat/img2enc.c
@@ -273,7 +273,7 @@ const AVOutputFormat ff_image2_muxer = {
     .long_name      = NULL_IF_CONFIG_SMALL("image2 sequence"),
     .extensions     = "bmp,dpx,exr,jls,jpeg,jpg,jxl,ljpg,pam,pbm,pcx,pfm,pgm,pgmyuv,phm,"
                       "png,ppm,sgi,tga,tif,tiff,jp2,j2c,j2k,xwd,sun,ras,rs,im1,im8,"
-                      "im24,sunras,vbn,xbm,xface,pix,y,avif,qoi",
+                      "im24,sunras,vbn,xbm,xface,pix,y,avif,qoi,hdr,wbmp",
     .priv_data_size = sizeof(VideoMuxData),
     .video_codec    = AV_CODEC_ID_MJPEG,
     .write_header   = write_header,
diff --git a/libavformat/internal.h b/libavformat/internal.h
index b6b8fbf..9b07cfb 100644
--- a/libavformat/internal.h
+++ b/libavformat/internal.h
@@ -625,6 +625,17 @@ enum AVCodecID ff_get_pcm_codec_id(int bps, int flt, int be, int sflags);
  */
 int ff_stream_side_data_copy(AVStream *dst, const AVStream *src);
 
+/**
+ * Create a new stream and copy to it all parameters from a source stream, with
+ * the exception of the index field, which is set when the new stream is
+ * created.
+ *
+ * @param dst_ctx pointer to the context in which the new stream is created
+ * @param src pointer to source AVStream
+ * @return pointer to the new stream or NULL on error
+ */
+AVStream *ff_stream_clone(AVFormatContext *dst_ctx, const AVStream *src);
+
 /**
  * Wrap ffurl_move() and log if error happens.
  *
diff --git a/libavformat/isom.c b/libavformat/isom.c
index cf27f58..6d01988 100644
--- a/libavformat/isom.c
+++ b/libavformat/isom.c
@@ -61,7 +61,6 @@ const AVCodecTag ff_mp4_obj_type[] = {
     { AV_CODEC_ID_DTS         , 0xA9 }, /* mp4ra.org */
     { AV_CODEC_ID_OPUS        , 0xAD }, /* mp4ra.org */
     { AV_CODEC_ID_VP9         , 0xB1 }, /* mp4ra.org */
-    { AV_CODEC_ID_FLAC        , 0xC1 }, /* nonstandard, update when there is a standard value */
     { AV_CODEC_ID_TSCC2       , 0xD0 }, /* nonstandard, camtasia uses it */
     { AV_CODEC_ID_EVRC        , 0xD1 }, /* nonstandard, pvAuthor uses it */
     { AV_CODEC_ID_VORBIS      , 0xDD }, /* nonstandard, gpac uses it */
diff --git a/libavformat/isom.h b/libavformat/isom.h
index f05c2d9..fd236b9 100644
--- a/libavformat/isom.h
+++ b/libavformat/isom.h
@@ -135,6 +135,8 @@ typedef struct MOVFragmentStreamInfo {
     int64_t first_tfra_pts;
     int64_t tfdt_dts;
     int64_t next_trun_dts;
+    // Index of the first sample/trun in the fragment.
+    int index_base;
     int index_entry;
     MOVEncryptionIndex *encryption_index;
 } MOVFragmentStreamInfo;
@@ -253,7 +255,6 @@ typedef struct MOVStreamContext {
     struct {
         struct AVAESCTR* aes_ctr;
         struct AVAES *aes_ctx;
-        unsigned int frag_index_entry_base;
         unsigned int per_sample_iv_size;  // Either 0, 8, or 16.
         AVEncryptionInfo *default_encrypted_sample;
         MOVEncryptionIndex *encryption_index;
@@ -318,6 +319,12 @@ typedef struct MOVContext {
     uint32_t max_stts_delta;
     int is_still_picture_avif;
     int primary_item_id;
+    struct {
+        int item_id;
+        int extent_length;
+        int64_t extent_offset;
+    } *avif_info;
+    int avif_info_size;
 } MOVContext;
 
 int ff_mp4_read_descr_len(AVIOContext *pb);
diff --git a/libavformat/isom_tags.c b/libavformat/isom_tags.c
index c5fd798..362cb77 100644
--- a/libavformat/isom_tags.c
+++ b/libavformat/isom_tags.c
@@ -332,7 +332,7 @@ const AVCodecTag ff_codec_movaudio_tags[] = {
     { AV_CODEC_ID_SPEEX,           MKTAG('S', 'P', 'X', 'N') }, /* ZygoAudio (quality 10 mode) */
     { AV_CODEC_ID_EVRC,            MKTAG('s', 'e', 'v', 'c') }, /* 3GPP2 */
     { AV_CODEC_ID_SMV,             MKTAG('s', 's', 'm', 'v') }, /* 3GPP2 */
-    { AV_CODEC_ID_FLAC,            MKTAG('f', 'L', 'a', 'C') }, /* nonstandard */
+    { AV_CODEC_ID_FLAC,            MKTAG('f', 'L', 'a', 'C') },
     { AV_CODEC_ID_TRUEHD,          MKTAG('m', 'l', 'p', 'a') }, /* mp4ra.org */
     { AV_CODEC_ID_OPUS,            MKTAG('O', 'p', 'u', 's') }, /* mp4ra.org */
     { AV_CODEC_ID_MPEGH_3D_AUDIO,  MKTAG('m', 'h', 'm', '1') }, /* MPEG-H 3D Audio bitstream */
diff --git a/libavformat/jacosubdec.c b/libavformat/jacosubdec.c
index 61b1316..0ee4820 100644
--- a/libavformat/jacosubdec.c
+++ b/libavformat/jacosubdec.c
@@ -144,7 +144,7 @@ static int get_shift(int timeres, const char *buf)
     ret = 0;
     switch (n) {
     case 4:
-        ret = sign * (((int64_t)a*3600 + (int64_t)b*60 + c) * timeres + d);
+        ret = sign * (((int64_t)a*3600 + b*60 + c) * timeres + d);
         break;
     case 3:
         ret = sign * ((         (int64_t)a*60 + b) * timeres + c);
diff --git a/libavformat/lrcenc.c b/libavformat/lrcenc.c
index cdf94e6..f7a5a69 100644
--- a/libavformat/lrcenc.c
+++ b/libavformat/lrcenc.c
@@ -105,7 +105,7 @@ static int lrc_write_packet(AVFormatContext *s, AVPacket *pkt)
                     size--;
                 next_line++;
             }
-            if(line[0] == '[') {
+            if (size && line[0] == '[') {
                 av_log(s, AV_LOG_WARNING,
                        "Subtitle starts with '[', may cause problems with LRC format.\n");
             }
diff --git a/libavformat/mov.c b/libavformat/mov.c
index 2b1131b..31f3249 100644
--- a/libavformat/mov.c
+++ b/libavformat/mov.c
@@ -1369,6 +1369,7 @@ static int update_frag_index(MOVContext *c, int64_t offset)
         frag_stream_info[i].tfdt_dts = AV_NOPTS_VALUE;
         frag_stream_info[i].next_trun_dts = AV_NOPTS_VALUE;
         frag_stream_info[i].first_tfra_pts = AV_NOPTS_VALUE;
+        frag_stream_info[i].index_base = -1;
         frag_stream_info[i].index_entry = -1;
         frag_stream_info[i].encryption_index = NULL;
     }
@@ -3062,6 +3063,21 @@ static int mov_read_stts(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     st->nb_frames= total_sample_count;
     if (duration)
         st->duration= FFMIN(st->duration, duration);
+
+    // All samples have zero duration. They have higher chance be chose by
+    // mov_find_next_sample, which leads to seek again and again.
+    //
+    // It's AVERROR_INVALIDDATA actually, but such files exist in the wild.
+    // So only mark data stream as discarded for safety.
+    if (!duration && sc->stts_count &&
+            st->codecpar->codec_type == AVMEDIA_TYPE_DATA) {
+        av_log(c->fc, AV_LOG_WARNING,
+               "All samples in data stream index:id [%d:%d] have zero "
+               "duration, stream set to be discarded by default. Override "
+               "using AVStream->discard or -discard for ffmpeg command.\n",
+               st->index, st->id);
+        st->discard = AVDISCARD_ALL;
+    }
     sc->track_end = duration;
     return 0;
 }
@@ -3949,11 +3965,8 @@ static int build_open_gop_key_points(AVStream *st)
 
     /* Build an unrolled index of the samples */
     sc->sample_offsets_count = 0;
-    for (uint32_t i = 0; i < sc->ctts_count; i++) {
-        if (sc->ctts_data[i].count > INT_MAX - sc->sample_offsets_count)
-            return AVERROR(ENOMEM);
+    for (uint32_t i = 0; i < sc->ctts_count; i++)
         sc->sample_offsets_count += sc->ctts_data[i].count;
-    }
     av_freep(&sc->sample_offsets);
     sc->sample_offsets = av_calloc(sc->sample_offsets_count, sizeof(*sc->sample_offsets));
     if (!sc->sample_offsets)
@@ -3972,11 +3985,8 @@ static int build_open_gop_key_points(AVStream *st)
     /* Build a list of open-GOP key samples */
     sc->open_key_samples_count = 0;
     for (uint32_t i = 0; i < sc->sync_group_count; i++)
-        if (sc->sync_group[i].index == cra_index) {
-            if (sc->sync_group[i].count > INT_MAX - sc->open_key_samples_count)
-                return AVERROR(ENOMEM);
+        if (sc->sync_group[i].index == cra_index)
             sc->open_key_samples_count += sc->sync_group[i].count;
-        }
     av_freep(&sc->open_key_samples);
     sc->open_key_samples = av_calloc(sc->open_key_samples_count, sizeof(*sc->open_key_samples));
     if (!sc->open_key_samples)
@@ -3987,8 +3997,6 @@ static int build_open_gop_key_points(AVStream *st)
         if (sg->index == cra_index)
             for (uint32_t j = 0; j < sg->count; j++)
                 sc->open_key_samples[k++] = sample_id;
-        if (sg->count > INT_MAX - sample_id)
-            return AVERROR_PATCHWELCOME;
         sample_id += sg->count;
     }
 
@@ -4691,6 +4699,69 @@ static int mov_read_custom(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     return ret;
 }
 
+static int avif_add_stream(MOVContext *c, int item_id)
+{
+    MOVStreamContext *sc;
+    AVStream *st;
+    int item_index = -1;
+    for (int i = 0; i < c->avif_info_size; i++)
+        if (c->avif_info[i].item_id == item_id) {
+            item_index = i;
+            break;
+        }
+    if (item_index < 0)
+        return AVERROR_INVALIDDATA;
+    st = avformat_new_stream(c->fc, NULL);
+    if (!st)
+        return AVERROR(ENOMEM);
+    st->id = c->fc->nb_streams;
+    sc = av_mallocz(sizeof(MOVStreamContext));
+    if (!sc)
+        return AVERROR(ENOMEM);
+
+    st->priv_data = sc;
+    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
+    st->codecpar->codec_id = AV_CODEC_ID_AV1;
+    sc->ffindex = st->index;
+    c->trak_index = st->index;
+    st->avg_frame_rate.num = st->avg_frame_rate.den = 1;
+    st->time_base.num = st->time_base.den = 1;
+    st->nb_frames = 1;
+    sc->time_scale = 1;
+    sc = st->priv_data;
+    sc->pb = c->fc->pb;
+    sc->pb_is_copied = 1;
+
+    // Populate the necessary fields used by mov_build_index.
+    sc->stsc_count = 1;
+    sc->stsc_data = av_malloc_array(1, sizeof(*sc->stsc_data));
+    if (!sc->stsc_data)
+        return AVERROR(ENOMEM);
+    sc->stsc_data[0].first = 1;
+    sc->stsc_data[0].count = 1;
+    sc->stsc_data[0].id = 1;
+    sc->chunk_count = 1;
+    sc->chunk_offsets = av_malloc_array(1, sizeof(*sc->chunk_offsets));
+    if (!sc->chunk_offsets)
+        return AVERROR(ENOMEM);
+    sc->sample_count = 1;
+    sc->sample_sizes = av_malloc_array(1, sizeof(*sc->sample_sizes));
+    if (!sc->sample_sizes)
+        return AVERROR(ENOMEM);
+    sc->stts_count = 1;
+    sc->stts_data = av_malloc_array(1, sizeof(*sc->stts_data));
+    if (!sc->stts_data)
+        return AVERROR(ENOMEM);
+    sc->stts_data[0].count = 1;
+    // Not used for still images. But needed by mov_build_index.
+    sc->stts_data[0].duration = 0;
+    sc->sample_sizes[0] = c->avif_info[item_index].extent_length;
+    sc->chunk_offsets[0] = c->avif_info[item_index].extent_offset;
+
+    mov_build_index(c, st);
+    return 0;
+}
+
 static int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)
 {
     while (atom.size > 8) {
@@ -4700,9 +4771,23 @@ static int mov_read_meta(MOVContext *c, AVIOContext *pb, MOVAtom atom)
         tag = avio_rl32(pb);
         atom.size -= 4;
         if (tag == MKTAG('h','d','l','r')) {
+            int ret;
             avio_seek(pb, -8, SEEK_CUR);
             atom.size += 8;
-            return mov_read_default(c, pb, atom);
+            if ((ret = mov_read_default(c, pb, atom)) < 0)
+                return ret;
+            if (c->is_still_picture_avif) {
+                int ret;
+                // Add a stream for the YUV planes (primary item).
+                if ((ret = avif_add_stream(c, c->primary_item_id)) < 0)
+                    return ret;
+                // For still AVIF images, the meta box contains all the
+                // necessary information that would generally be provided by the
+                // moov box. So simply mark that we have found the moov box so
+                // that parsing can continue.
+                c->found_moov = 1;
+            }
+            return ret;
         }
     }
     return 0;
@@ -5118,8 +5203,11 @@ static int mov_read_trun(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     sc->ctts_count = sti->nb_index_entries;
 
     // Record the index_entry position in frag_index of this fragment
-    if (frag_stream_info)
+    if (frag_stream_info) {
         frag_stream_info->index_entry = index_entry_pos;
+        if (frag_stream_info->index_base < 0)
+            frag_stream_info->index_base = index_entry_pos;
+    }
 
     if (index_entry_pos > 0)
         prev_dts = sti->index_entries[index_entry_pos-1].timestamp;
@@ -7088,6 +7176,31 @@ static int cenc_decrypt(MOVContext *c, MOVStreamContext *sc, AVEncryptionInfo *s
     }
 }
 
+static MOVFragmentStreamInfo *get_frag_stream_info_from_pkt(MOVFragmentIndex *frag_index, AVPacket *pkt, int id)
+{
+    int current = frag_index->current;
+
+    if (!frag_index->nb_items)
+        return NULL;
+
+    // Check frag_index->current is the right one for pkt. It can out of sync.
+    if (current >= 0 && current < frag_index->nb_items) {
+        if (frag_index->item[current].moof_offset < pkt->pos &&
+            (current + 1 == frag_index->nb_items ||
+             frag_index->item[current + 1].moof_offset > pkt->pos))
+            return get_frag_stream_info(frag_index, current, id);
+    }
+
+
+    for (int i = 0; i < frag_index->nb_items; i++) {
+        if (frag_index->item[i].moof_offset > pkt->pos)
+            break;
+        current = i;
+    }
+    frag_index->current = current;
+    return get_frag_stream_info(frag_index, current, id);
+}
+
 static int cenc_filter(MOVContext *mov, AVStream* st, MOVStreamContext *sc, AVPacket *pkt, int current_index)
 {
     MOVFragmentStreamInfo *frag_stream_info;
@@ -7095,16 +7208,14 @@ static int cenc_filter(MOVContext *mov, AVStream* st, MOVStreamContext *sc, AVPa
     AVEncryptionInfo *encrypted_sample;
     int encrypted_index, ret;
 
-    frag_stream_info = get_frag_stream_info(&mov->frag_index, mov->frag_index.current, st->id);
+    frag_stream_info = get_frag_stream_info_from_pkt(&mov->frag_index, pkt, st->id);
     encrypted_index = current_index;
     encryption_index = NULL;
     if (frag_stream_info) {
         // Note this only supports encryption info in the first sample descriptor.
         if (mov->fragment.stsd_id == 1) {
             if (frag_stream_info->encryption_index) {
-                if (!current_index && frag_stream_info->index_entry)
-                    sc->cenc.frag_index_entry_base = frag_stream_info->index_entry;
-                encrypted_index = current_index - (frag_stream_info->index_entry - sc->cenc.frag_index_entry_base);
+                encrypted_index = current_index - frag_stream_info->index_base;
                 encryption_index = frag_stream_info->encryption_index;
             } else {
                 encryption_index = sc->cenc.encryption_index;
@@ -7471,8 +7582,6 @@ static int mov_read_iloc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     int item_count, extent_count;
     uint64_t base_offset, extent_offset, extent_length;
     uint8_t value;
-    AVStream *st;
-    MOVStreamContext *sc;
 
     if (!c->is_still_picture_avif) {
         // * For non-avif, we simply ignore the iloc box.
@@ -7486,27 +7595,6 @@ static int mov_read_iloc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
         return 0;
     }
 
-    st = avformat_new_stream(c->fc, NULL);
-    if (!st)
-        return AVERROR(ENOMEM);
-    st->id = c->fc->nb_streams;
-    sc = av_mallocz(sizeof(MOVStreamContext));
-    if (!sc)
-        return AVERROR(ENOMEM);
-
-    st->priv_data = sc;
-    st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
-    st->codecpar->codec_id = AV_CODEC_ID_AV1;
-    sc->ffindex = st->index;
-    c->trak_index = st->index;
-    st->avg_frame_rate.num = st->avg_frame_rate.den = 1;
-    st->time_base.num = st->time_base.den = 1;
-    st->nb_frames = 1;
-    sc->time_scale = 1;
-    sc = st->priv_data;
-    sc->pb = c->fc->pb;
-    sc->pb_is_copied = 1;
-
     version = avio_r8(pb);
     avio_rb24(pb);  // flags.
 
@@ -7522,34 +7610,17 @@ static int mov_read_iloc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
     }
     item_count = (version < 2) ? avio_rb16(pb) : avio_rb32(pb);
 
-    // Populate the necessary fields used by mov_build_index.
-    sc->stsc_count = 1;
-    sc->stsc_data = av_malloc_array(1, sizeof(*sc->stsc_data));
-    if (!sc->stsc_data)
-        return AVERROR(ENOMEM);
-    sc->stsc_data[0].first = 1;
-    sc->stsc_data[0].count = 1;
-    sc->stsc_data[0].id = 1;
-    sc->chunk_count = 1;
-    sc->chunk_offsets = av_malloc_array(1, sizeof(*sc->chunk_offsets));
-    if (!sc->chunk_offsets)
+    c->avif_info = av_malloc_array(item_count, sizeof(*c->avif_info));
+    if (!c->avif_info)
         return AVERROR(ENOMEM);
-    sc->sample_count = 1;
-    sc->sample_sizes = av_malloc_array(1, sizeof(*sc->sample_sizes));
-    if (!sc->sample_sizes)
-        return AVERROR(ENOMEM);
-    sc->stts_count = 1;
-    sc->stts_data = av_malloc_array(1, sizeof(*sc->stts_data));
-    if (!sc->stts_data)
-        return AVERROR(ENOMEM);
-    sc->stts_data[0].count = 1;
-    // Not used for still images. But needed by mov_build_index.
-    sc->stts_data[0].duration = 0;
+    c->avif_info_size = item_count;
 
     for (int i = 0; i < item_count; i++) {
         int item_id = (version < 2) ? avio_rb16(pb) : avio_rb32(pb);
         if (avio_feof(pb))
             return AVERROR_INVALIDDATA;
+        c->avif_info[i].item_id = item_id;
+
         if (version > 0)
             avio_rb16(pb);  // construction_method.
         avio_rb16(pb);  // data_reference_index.
@@ -7565,20 +7636,11 @@ static int mov_read_iloc(MOVContext *c, AVIOContext *pb, MOVAtom atom)
             if (rb_size(pb, &extent_offset, offset_size) < 0 ||
                 rb_size(pb, &extent_length, length_size) < 0)
                 return AVERROR_INVALIDDATA;
-            if (item_id == c->primary_item_id) {
-                sc->sample_sizes[0] = extent_length;
-                sc->chunk_offsets[0] = base_offset + extent_offset;
-            }
+            c->avif_info[i].extent_length = extent_length;
+            c->avif_info[i].extent_offset = base_offset + extent_offset;
         }
     }
 
-    mov_build_index(c, st);
-
-    // For still AVIF images, the iloc box contains all the necessary
-    // information that would generally be provided by the moov box. So simply
-    // mark that we have found the moov box so that parsing can continue.
-    c->found_moov = 1;
-
     return atom.size;
 }
 
@@ -8182,6 +8244,7 @@ static int mov_read_close(AVFormatContext *s)
 
     av_freep(&mov->aes_decrypt);
     av_freep(&mov->chapter_tracks);
+    av_freep(&mov->avif_info);
 
     return 0;
 }
diff --git a/libavformat/movenc.c b/libavformat/movenc.c
index 5608afd..c8b2e14 100644
--- a/libavformat/movenc.c
+++ b/libavformat/movenc.c
@@ -7160,7 +7160,7 @@ static int mov_init(AVFormatContext *s)
                     av_log(s, AV_LOG_ERROR, "%s only supported in MP4.\n", avcodec_get_name(track->par->codec_id));
                     return AVERROR(EINVAL);
                 }
-                if (track->par->codec_id != AV_CODEC_ID_OPUS &&
+                if (track->par->codec_id == AV_CODEC_ID_TRUEHD &&
                     s->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {
                     av_log(s, AV_LOG_ERROR,
                            "%s in MP4 support is experimental, add "
diff --git a/libavformat/mpc8.c b/libavformat/mpc8.c
index 2822a08..95a1529 100644
--- a/libavformat/mpc8.c
+++ b/libavformat/mpc8.c
@@ -135,37 +135,40 @@ static void mpc8_get_chunk_header(AVIOContext *pb, int *tag, int64_t *size)
         *size += pos;
 }
 
-static void mpc8_parse_seektable(AVFormatContext *s, int64_t off)
+static int mpc8_parse_seektable(AVFormatContext *s, int64_t off)
 {
     MPCContext *c = s->priv_data;
     int tag;
     int64_t size, pos, ppos[2];
     uint8_t *buf;
     int i, t, seekd, ret;
+    int64_t ret64;
     GetBitContext gb;
 
     if (s->nb_streams == 0) {
         av_log(s, AV_LOG_ERROR, "No stream added before parsing seek table\n");
-        return;
+        return AVERROR_INVALIDDATA;
     }
 
-    avio_seek(s->pb, off, SEEK_SET);
+    ret64 = avio_seek(s->pb, off, SEEK_SET);
+    if (ret64 < 0)
+        return AVERROR_INVALIDDATA;
     mpc8_get_chunk_header(s->pb, &tag, &size);
-    if(tag != TAG_SEEKTABLE){
+    if(tag != TAG_SEEKTABLE || avio_feof(s->pb)){
         av_log(s, AV_LOG_ERROR, "No seek table at given position\n");
-        return;
+        return AVERROR_INVALIDDATA;
     }
     if (size > INT_MAX/10 || size<=0) {
         av_log(s, AV_LOG_ERROR, "Bad seek table size\n");
-        return;
+        return AVERROR_INVALIDDATA;
     }
     if(!(buf = av_malloc(size + AV_INPUT_BUFFER_PADDING_SIZE)))
-        return;
+        return AVERROR(ENOMEM);
     ret = avio_read(s->pb, buf, size);
     if (ret != size) {
         av_log(s, AV_LOG_ERROR, "seek table truncated\n");
         av_free(buf);
-        return;
+        return AVERROR_INVALIDDATA;
     }
     memset(buf+size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 
@@ -174,14 +177,14 @@ static void mpc8_parse_seektable(AVFormatContext *s, int64_t off)
     if(size > UINT_MAX/4 || size > c->samples/1152){
         av_log(s, AV_LOG_ERROR, "Seek table is too big\n");
         av_free(buf);
-        return;
+        return AVERROR_INVALIDDATA;
     }
     seekd = get_bits(&gb, 4);
     for(i = 0; i < 2; i++){
         pos = gb_get_v(&gb);
         if (av_sat_add64(pos, c->header_pos) != pos + (uint64_t)c->header_pos) {
             av_free(buf);
-            return;
+            return AVERROR_INVALIDDATA;
         }
 
         pos += c->header_pos;
@@ -191,7 +194,7 @@ static void mpc8_parse_seektable(AVFormatContext *s, int64_t off)
     for(; i < size; i++){
         if (get_bits_left(&gb) < 13) {
             av_free(buf);
-            return;
+            return AVERROR_INVALIDDATA;
         }
         t = get_unary(&gb, 1, 33) << 12;
         t += get_bits(&gb, 12);
@@ -203,26 +206,31 @@ static void mpc8_parse_seektable(AVFormatContext *s, int64_t off)
         ppos[0] = pos;
     }
     av_free(buf);
+    return 0;
 }
 
-static void mpc8_handle_chunk(AVFormatContext *s, int tag, int64_t chunk_pos, int64_t size)
+static int mpc8_handle_chunk(AVFormatContext *s, int tag, int64_t chunk_pos, int64_t size)
 {
     AVIOContext *pb = s->pb;
     int64_t pos, off;
+    int ret;
 
     switch(tag){
     case TAG_SEEKTBLOFF:
         pos = avio_tell(pb);
         off = ffio_read_varlen(pb);
         if (pos > INT64_MAX - size || off < 0 || off > INT64_MAX - chunk_pos)
-            return;
+            return AVERROR_INVALIDDATA;
         pos += size;
-        mpc8_parse_seektable(s, chunk_pos + off);
+        ret = mpc8_parse_seektable(s, chunk_pos + off);
+        if (ret < 0)
+            return AVERROR_INVALIDDATA;
         avio_seek(pb, pos, SEEK_SET);
         break;
     default:
         avio_skip(pb, size);
     }
+    return 0;
 }
 
 static int mpc8_read_header(AVFormatContext *s)
@@ -249,7 +257,9 @@ static int mpc8_read_header(AVFormatContext *s)
         }
         if(tag == TAG_STREAMHDR)
             break;
-        mpc8_handle_chunk(s, tag, pos, size);
+        ret = mpc8_handle_chunk(s, tag, pos, size);
+        if (ret < 0)
+            return ret;
     }
     if(tag != TAG_STREAMHDR){
         av_log(s, AV_LOG_ERROR, "Stream header not found\n");
diff --git a/libavformat/mux.c b/libavformat/mux.c
index 31361f9..a3b50da 100644
--- a/libavformat/mux.c
+++ b/libavformat/mux.c
@@ -1417,7 +1417,14 @@ static int write_uncoded_frame_internal(AVFormatContext *s, int stream_index,
         pkt->size         = sizeof(frame);
         pkt->pts          =
         pkt->dts          = frame->pts;
-        pkt->duration     = frame->pkt_duration;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
+        if (frame->pkt_duration)
+            pkt->duration     = frame->pkt_duration;
+        else
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
+        pkt->duration = frame->duration;
         pkt->stream_index = stream_index;
         pkt->flags |= AV_PKT_FLAG_UNCODED_FRAME;
     }
diff --git a/libavformat/mux.h b/libavformat/mux.h
index c01da82..1bfcaf7 100644
--- a/libavformat/mux.h
+++ b/libavformat/mux.h
@@ -113,15 +113,6 @@ int ff_format_shift_data(AVFormatContext *s, int64_t read_start, int shift_size)
  */
 int ff_format_output_open(AVFormatContext *s, const char *url, AVDictionary **options);
 
-/**
- * Copy encoding parameters from source to destination stream
- *
- * @param dst pointer to destination AVStream
- * @param src pointer to source AVStream
- * @return >=0 on success, AVERROR code on error
- */
-int ff_stream_encode_params_copy(AVStream *dst, const AVStream *src);
-
 /**
  * Parse creation_time in AVFormatContext metadata if exists and warn if the
  * parsing fails.
diff --git a/libavformat/mux_utils.c b/libavformat/mux_utils.c
index eb8ea3d..2fa2ab5 100644
--- a/libavformat/mux_utils.c
+++ b/libavformat/mux_utils.c
@@ -121,34 +121,6 @@ int ff_format_output_open(AVFormatContext *s, const char *url, AVDictionary **op
     return 0;
 }
 
-int ff_stream_encode_params_copy(AVStream *dst, const AVStream *src)
-{
-    int ret;
-
-    dst->id                  = src->id;
-    dst->time_base           = src->time_base;
-    dst->nb_frames           = src->nb_frames;
-    dst->disposition         = src->disposition;
-    dst->sample_aspect_ratio = src->sample_aspect_ratio;
-    dst->avg_frame_rate      = src->avg_frame_rate;
-    dst->r_frame_rate        = src->r_frame_rate;
-
-    av_dict_free(&dst->metadata);
-    ret = av_dict_copy(&dst->metadata, src->metadata, 0);
-    if (ret < 0)
-        return ret;
-
-    ret = avcodec_parameters_copy(dst->codecpar, src->codecpar);
-    if (ret < 0)
-        return ret;
-
-    ret = ff_stream_side_data_copy(dst, src);
-    if (ret < 0)
-        return ret;
-
-    return 0;
-}
-
 int ff_parse_creation_time_metadata(AVFormatContext *s, int64_t *timestamp, int return_seconds)
 {
     AVDictionaryEntry *entry;
diff --git a/libavformat/mxf.c b/libavformat/mxf.c
index 36d662b..8ef928b 100644
--- a/libavformat/mxf.c
+++ b/libavformat/mxf.c
@@ -66,6 +66,9 @@ const MXFCodecUL ff_mxf_codec_uls[] = {
     { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x0A,0x04,0x01,0x02,0x01,0x01,0x02,0x02,0x01 }, 16,       AV_CODEC_ID_V210 }, /* V210 */
     { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x0E,0x04,0x02,0x01,0x02,0x11,0x00,0x00 }, 14,     AV_CODEC_ID_PRORES }, /* Avid MC7 ProRes */
     { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x0D,0x04,0x01,0x02,0x02,0x03,0x06,0x00,0x00 }, 14,     AV_CODEC_ID_PRORES }, /* Apple ProRes */
+    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0D,0x04,0x01,0x02,0x02,0x03,0x09,0x01,0x00 }, 15,       AV_CODEC_ID_FFV1 }, /*FFV1 V0 */
+    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0D,0x04,0x01,0x02,0x02,0x03,0x09,0x02,0x00 }, 15,       AV_CODEC_ID_FFV1 }, /*FFV1 V1 */
+    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0D,0x04,0x01,0x02,0x02,0x03,0x09,0x04,0x00 }, 15,       AV_CODEC_ID_FFV1 }, /*FFV1 V3 */
     /* SoundEssenceCompression */
     { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x03,0x04,0x02,0x02,0x02,0x03,0x03,0x01,0x00 }, 14,        AV_CODEC_ID_AAC }, /* MPEG-2 AAC ADTS (legacy) */
     { { 0x06,0x0E,0x2B,0x34,0x04,0x01,0x01,0x01,0x04,0x02,0x02,0x01,0x00,0x00,0x00,0x00 }, 13,  AV_CODEC_ID_PCM_S16LE }, /* uncompressed */
diff --git a/libavformat/mxf.h b/libavformat/mxf.h
index 4d9f511..2561605 100644
--- a/libavformat/mxf.h
+++ b/libavformat/mxf.h
@@ -54,6 +54,7 @@ enum MXFMetadataSetType {
     AudioChannelLabelSubDescriptor,
     SoundfieldGroupLabelSubDescriptor,
     GroupOfSoundfieldGroupsLabelSubDescriptor,
+    FFV1SubDescriptor,
 };
 
 enum MXFFrameLayout {
diff --git a/libavformat/mxfdec.c b/libavformat/mxfdec.c
index 4a31490..feebff6 100644
--- a/libavformat/mxfdec.c
+++ b/libavformat/mxfdec.c
@@ -64,7 +64,6 @@
 #include "mxf.h"
 
 #define MXF_MAX_CHUNK_SIZE (32 << 20)
-#define RUN_IN_MAX (65535+1)  // S377m-2004 section 5.5 and S377-1-2009 section 6.5, the +1 is to be slightly more tolerant
 
 typedef enum {
     Header,
@@ -238,6 +237,12 @@ typedef struct MXFMCASubDescriptor {
     char *language;
 } MXFMCASubDescriptor;
 
+typedef struct MXFFFV1SubDescriptor {
+    MXFMetadataSet meta;
+    uint8_t *extradata;
+    int extradata_size;
+} MXFFFV1SubDescriptor;
+
 typedef struct MXFIndexTableSegment {
     MXFMetadataSet meta;
     int edit_unit_byte_count;
@@ -338,6 +343,7 @@ static const uint8_t mxf_crypto_source_container_ul[]      = { 0x06,0x0e,0x2b,0x
 static const uint8_t mxf_encrypted_triplet_key[]           = { 0x06,0x0e,0x2b,0x34,0x02,0x04,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x7e,0x01,0x00 };
 static const uint8_t mxf_encrypted_essence_container[]     = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x07,0x0d,0x01,0x03,0x01,0x02,0x0b,0x01,0x00 };
 static const uint8_t mxf_sony_mpeg4_extradata[]            = { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0e,0x06,0x06,0x02,0x02,0x01,0x00,0x00 };
+static const uint8_t mxf_ffv1_extradata[]                  = { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0x0e,0x04,0x01,0x06,0x0c,0x01,0x00,0x00,0x00 }; // FFV1InitializationMetadata
 static const uint8_t mxf_avid_project_name[]               = { 0xa5,0xfb,0x7b,0x25,0xf6,0x15,0x94,0xb9,0x62,0xfc,0x37,0x17,0x49,0x2d,0x42,0xbf };
 static const uint8_t mxf_jp2k_rsiz[]                       = { 0x06,0x0e,0x2b,0x34,0x01,0x01,0x01,0x0a,0x04,0x01,0x06,0x03,0x01,0x00,0x00,0x00 };
 static const uint8_t mxf_indirect_value_utf16le[]          = { 0x4c,0x00,0x02,0x10,0x01,0x00,0x00,0x00,0x00,0x06,0x0e,0x2b,0x34,0x01,0x04,0x01,0x01 };
@@ -378,6 +384,9 @@ static void mxf_free_metadataset(MXFMetadataSet **ctx, int freectx)
         av_freep(&((MXFDescriptor *)*ctx)->file_descriptors_refs);
         av_freep(&((MXFDescriptor *)*ctx)->sub_descriptors_refs);
         break;
+    case FFV1SubDescriptor:
+        av_freep(&((MXFFFV1SubDescriptor *)*ctx)->extradata);
+        break;
     case AudioChannelLabelSubDescriptor:
     case SoundfieldGroupLabelSubDescriptor:
     case GroupOfSoundfieldGroupsLabelSubDescriptor:
@@ -1474,6 +1483,25 @@ static int mxf_read_mca_sub_descriptor(void *arg, AVIOContext *pb, int tag, int
     return 0;
 }
 
+static int mxf_read_ffv1_sub_descriptor(void *arg, AVIOContext *pb, int tag, int size, UID uid, int64_t klv_offset)
+{
+    MXFFFV1SubDescriptor *ffv1_sub_descriptor = arg;
+
+    if (IS_KLV_KEY(uid, mxf_ffv1_extradata) && size <= INT_MAX - AV_INPUT_BUFFER_PADDING_SIZE ) {
+        if (ffv1_sub_descriptor->extradata)
+            av_log(NULL, AV_LOG_WARNING, "Duplicate ffv1_extradata\n");
+        av_free(ffv1_sub_descriptor->extradata);
+        ffv1_sub_descriptor->extradata_size = 0;
+        ffv1_sub_descriptor->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);
+        if (!ffv1_sub_descriptor->extradata)
+            return AVERROR(ENOMEM);
+        ffv1_sub_descriptor->extradata_size = size;
+        avio_read(pb, ffv1_sub_descriptor->extradata, size);
+    }
+
+    return 0;
+}
+
 static int mxf_read_indirect_value(void *arg, AVIOContext *pb, int size)
 {
     MXFTaggedValue *tagged_value = arg;
@@ -1555,6 +1583,7 @@ static const MXFCodecUL mxf_picture_essence_container_uls[] = {
     { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x1c,0x01,0x00 }, 14,     AV_CODEC_ID_PRORES, NULL, 14 }, /* ProRes */
     { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x02,0x0d,0x01,0x03,0x01,0x02,0x04,0x60,0x01 }, 14, AV_CODEC_ID_MPEG2VIDEO, NULL, 15 }, /* MPEG-ES */
     { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x01,0x04,0x01 }, 14, AV_CODEC_ID_MPEG2VIDEO, NULL, 15, D10D11Wrap }, /* SMPTE D-10 mapping */
+    { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0d,0x0d,0x01,0x03,0x01,0x02,0x23,0x01,0x00 }, 14,       AV_CODEC_ID_FFV1, NULL, 14 },
     { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x02,0x41,0x01 }, 14,    AV_CODEC_ID_DVVIDEO, NULL, 15 }, /* DV 625 25mbps */
     { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x01,0x0d,0x01,0x03,0x01,0x02,0x05,0x00,0x00 }, 14,   AV_CODEC_ID_RAWVIDEO, NULL, 15, RawVWrap }, /* uncompressed picture */
     { { 0x06,0x0e,0x2b,0x34,0x04,0x01,0x01,0x0a,0x0e,0x0f,0x03,0x01,0x02,0x20,0x01,0x01 }, 15,     AV_CODEC_ID_HQ_HQA },
@@ -2445,6 +2474,21 @@ static MXFMCASubDescriptor *find_mca_link_id(MXFContext *mxf, enum MXFMetadataSe
     return NULL;
 }
 
+static void parse_ffv1_sub_descriptor(MXFContext *mxf, MXFTrack *source_track, MXFDescriptor *descriptor, AVStream *st)
+{
+    for (int i = 0; i < descriptor->sub_descriptors_count; i++) {
+        MXFFFV1SubDescriptor *ffv1_sub_descriptor = mxf_resolve_strong_ref(mxf, &descriptor->sub_descriptors_refs[i], FFV1SubDescriptor);
+        if (ffv1_sub_descriptor == NULL)
+            continue;
+
+        descriptor->extradata      = ffv1_sub_descriptor->extradata;
+        descriptor->extradata_size = ffv1_sub_descriptor->extradata_size;
+        ffv1_sub_descriptor->extradata = NULL;
+        ffv1_sub_descriptor->extradata_size = 0;
+        break;
+    }
+}
+
 static int parse_mca_labels(MXFContext *mxf, MXFTrack *source_track, MXFDescriptor *descriptor, AVStream *st)
 {
     uint64_t routing[FF_SANE_NB_CHANNELS] = {0};
@@ -2973,6 +3017,8 @@ static int mxf_parse_structural_metadata(MXFContext *mxf)
                 st->codecpar->codec_id = AV_CODEC_ID_EIA_608;
             }
         }
+        if (!descriptor->extradata)
+            parse_ffv1_sub_descriptor(mxf, source_track, descriptor, st);
         if (descriptor->extradata) {
             if (!ff_alloc_extradata(st->codecpar, descriptor->extradata_size)) {
                 memcpy(st->codecpar->extradata, descriptor->extradata, descriptor->extradata_size);
@@ -3160,6 +3206,7 @@ static const MXFMetadataReadTableEntry mxf_metadata_read_table[] = {
     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x6b,0x00 }, mxf_read_mca_sub_descriptor, sizeof(MXFMCASubDescriptor), AudioChannelLabelSubDescriptor },
     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x6c,0x00 }, mxf_read_mca_sub_descriptor, sizeof(MXFMCASubDescriptor), SoundfieldGroupLabelSubDescriptor },
     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x6d,0x00 }, mxf_read_mca_sub_descriptor, sizeof(MXFMCASubDescriptor), GroupOfSoundfieldGroupsLabelSubDescriptor },
+    { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x81,0x03 }, mxf_read_ffv1_sub_descriptor, sizeof(MXFFFV1SubDescriptor), FFV1SubDescriptor },
     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3A,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Static Track */
     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x3B,0x00 }, mxf_read_track, sizeof(MXFTrack), Track }, /* Generic Track */
     { { 0x06,0x0e,0x2b,0x34,0x02,0x53,0x01,0x01,0x0d,0x01,0x01,0x01,0x01,0x01,0x14,0x00 }, mxf_read_timecode_component, sizeof(MXFTimecodeComponent), TimecodeComponent },
@@ -3633,7 +3680,6 @@ static int mxf_read_header(AVFormatContext *s)
     KLVPacket klv;
     int64_t essence_offset = 0;
     int ret;
-    int64_t run_in;
 
     mxf->last_forward_tell = INT64_MAX;
 
@@ -3643,10 +3689,7 @@ static int mxf_read_header(AVFormatContext *s)
     }
     avio_seek(s->pb, -14, SEEK_CUR);
     mxf->fc = s;
-    run_in = avio_tell(s->pb);
-    if (run_in < 0 || run_in > RUN_IN_MAX)
-        return AVERROR_INVALIDDATA;
-    mxf->run_in = run_in;
+    mxf->run_in = avio_tell(s->pb);
 
     mxf_read_random_index_pack(s);
 
@@ -4052,7 +4095,7 @@ static int mxf_read_close(AVFormatContext *s)
 
 static int mxf_probe(const AVProbeData *p) {
     const uint8_t *bufp = p->buf;
-    const uint8_t *end = p->buf + FFMIN(p->buf_size, RUN_IN_MAX + 1 + sizeof(mxf_header_partition_pack_key));
+    const uint8_t *end = p->buf + p->buf_size;
 
     if (p->buf_size < sizeof(mxf_header_partition_pack_key))
         return 0;
diff --git a/libavformat/nutdec.c b/libavformat/nutdec.c
index 24dedc4..8cc5661 100644
--- a/libavformat/nutdec.c
+++ b/libavformat/nutdec.c
@@ -245,11 +245,6 @@ static int decode_main_header(NUTContext *nut)
     for (i = 0; i < 256;) {
         int tmp_flags  = ffio_read_varlen(bc);
         int tmp_fields = ffio_read_varlen(bc);
-        if (tmp_fields < 0) {
-            av_log(s, AV_LOG_ERROR, "fields %d is invalid\n", tmp_fields);
-            ret = AVERROR_INVALIDDATA;
-            goto fail;
-        }
 
         if (tmp_fields > 0)
             tmp_pts = get_s(bc);
diff --git a/libavformat/protocols.c b/libavformat/protocols.c
index 6ee62a5..8b7d1b9 100644
--- a/libavformat/protocols.c
+++ b/libavformat/protocols.c
@@ -17,6 +17,7 @@
  */
 
 #include "libavutil/avstring.h"
+#include "libavutil/log.h"
 #include "libavutil/mem.h"
 
 #include "url.h"
diff --git a/libavformat/rawenc.c b/libavformat/rawenc.c
index 26099cb..267fce2 100644
--- a/libavformat/rawenc.c
+++ b/libavformat/rawenc.c
@@ -252,7 +252,7 @@ const AVOutputFormat ff_eac3_muxer = {
     .name              = "eac3",
     .long_name         = NULL_IF_CONFIG_SMALL("raw E-AC-3"),
     .mime_type         = "audio/x-eac3",
-    .extensions        = "eac3",
+    .extensions        = "eac3,ec3",
     .audio_codec       = AV_CODEC_ID_EAC3,
     .video_codec       = AV_CODEC_ID_NONE,
     .init              = force_one_stream,
diff --git a/libavformat/riff.c b/libavformat/riff.c
index df7e9df..7a97cf1 100644
--- a/libavformat/riff.c
+++ b/libavformat/riff.c
@@ -237,6 +237,7 @@ const AVCodecTag ff_codec_bmp_tags[] = {
     { AV_CODEC_ID_RAWVIDEO,     MKTAG('U', 'Y', 'V', 'Y') },
     { AV_CODEC_ID_RAWVIDEO,     MKTAG('V', 'Y', 'U', 'Y') },
     { AV_CODEC_ID_RAWVIDEO,     MKTAG('I', 'Y', 'U', 'V') },
+    { AV_CODEC_ID_RAWVIDEO,     MKTAG('A', 'Y', 'U', 'V') },
     { AV_CODEC_ID_RAWVIDEO,     MKTAG('Y', '8', '0', '0') },
     { AV_CODEC_ID_RAWVIDEO,     MKTAG('Y', '8', ' ', ' ') },
     { AV_CODEC_ID_RAWVIDEO,     MKTAG('H', 'D', 'Y', 'C') },
@@ -302,7 +303,6 @@ const AVCodecTag ff_codec_bmp_tags[] = {
     { AV_CODEC_ID_V210,         MKTAG('C', '2', '1', '0') },
     { AV_CODEC_ID_V308,         MKTAG('v', '3', '0', '8') },
     { AV_CODEC_ID_V408,         MKTAG('v', '4', '0', '8') },
-    { AV_CODEC_ID_AYUV,         MKTAG('A', 'Y', 'U', 'V') },
     { AV_CODEC_ID_V410,         MKTAG('v', '4', '1', '0') },
     { AV_CODEC_ID_YUV4,         MKTAG('y', 'u', 'v', '4') },
     { AV_CODEC_ID_INDEO3,       MKTAG('I', 'V', '3', '1') },
diff --git a/libavformat/riffdec.c b/libavformat/riffdec.c
index c1e4a04..3946ecb 100644
--- a/libavformat/riffdec.c
+++ b/libavformat/riffdec.c
@@ -102,8 +102,6 @@ int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,
         return AVERROR_INVALIDDATA;
     }
 
-    av_channel_layout_uninit(&par->ch_layout);
-
     par->codec_type  = AVMEDIA_TYPE_AUDIO;
     if (!big_endian) {
         id                 = avio_rl16(pb);
@@ -191,12 +189,9 @@ int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb,
     if (par->codec_id == AV_CODEC_ID_ADPCM_G726 && par->sample_rate)
         par->bits_per_coded_sample = par->bit_rate / par->sample_rate;
 
-    /* ignore WAVEFORMATEXTENSIBLE layout if different from channel count */
-    if (channels != par->ch_layout.nb_channels) {
-        av_channel_layout_uninit(&par->ch_layout);
-        par->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
-        par->ch_layout.nb_channels = channels;
-    }
+    av_channel_layout_uninit(&par->ch_layout);
+    par->ch_layout.order       = AV_CHANNEL_ORDER_UNSPEC;
+    par->ch_layout.nb_channels = channels;
 
     return 0;
 }
diff --git a/libavformat/rmdec.c b/libavformat/rmdec.c
index 0f1534b..881d700 100644
--- a/libavformat/rmdec.c
+++ b/libavformat/rmdec.c
@@ -563,8 +563,6 @@ static int rm_read_header(AVFormatContext *s)
     }
 
     tag_size = avio_rb32(pb);
-    if (tag_size < 0)
-        return AVERROR_INVALIDDATA;
     avio_skip(pb, tag_size - 8);
 
     for(;;) {
diff --git a/libavformat/rpl.c b/libavformat/rpl.c
index 3ef6fda..d025589 100644
--- a/libavformat/rpl.c
+++ b/libavformat/rpl.c
@@ -279,7 +279,7 @@ static int rpl_read_header(AVFormatContext *s)
     error |= read_line(pb, line, sizeof(line));  // size of "helpful" sprite
     if (vst) {
         error |= read_line(pb, line, sizeof(line));  // offset to key frame list
-        vst->duration = number_of_chunks * (int64_t)rpl->frames_per_chunk;
+        vst->duration = number_of_chunks * rpl->frames_per_chunk;
     }
 
     // Read the index
diff --git a/libavformat/sbgdec.c b/libavformat/sbgdec.c
index 5edb966..8a6d679 100644
--- a/libavformat/sbgdec.c
+++ b/libavformat/sbgdec.c
@@ -1317,8 +1317,6 @@ static int generate_intervals(void *log, struct sbg_script *s, int sample_rate,
 
     /* Pseudo event before the first one */
     ev0 = s->events[s->nb_events - 1];
-    if (av_sat_sub64(ev0.ts_int, period) != (uint64_t)ev0.ts_int - period)
-        return AVERROR_INVALIDDATA;
     ev0.ts_int   -= period;
     ev0.ts_trans -= period;
     ev0.ts_next  -= period;
@@ -1480,7 +1478,7 @@ static int sbg_read_packet(AVFormatContext *avf, AVPacket *packet)
     int ret;
 
     ts = ffstream(avf->streams[0])->cur_dts;
-    end_ts = av_sat_add64(ts, avf->streams[0]->codecpar->frame_size);
+    end_ts = ts + avf->streams[0]->codecpar->frame_size;
     if (avf->streams[0]->duration != AV_NOPTS_VALUE)
         end_ts = FFMIN(avf->streams[0]->start_time + avf->streams[0]->duration,
                        end_ts);
diff --git a/libavformat/sdsdec.c b/libavformat/sdsdec.c
index d296500..f98096d 100644
--- a/libavformat/sdsdec.c
+++ b/libavformat/sdsdec.c
@@ -112,7 +112,7 @@ static int sds_read_header(AVFormatContext *ctx)
     st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;
     st->codecpar->ch_layout.nb_channels = 1;
     st->codecpar->sample_rate = sample_period ? 1000000000 / sample_period : 16000;
-    st->duration = av_rescale((avio_size(pb) - 21) / 127,  s->size, 4);
+    st->duration = (avio_size(pb) - 21) / (127) * s->size / 4;
 
     avpriv_set_pts_info(st, 64, 1, st->codecpar->sample_rate);
 
diff --git a/libavformat/segment.c b/libavformat/segment.c
index fa435d9..c904e20 100644
--- a/libavformat/segment.c
+++ b/libavformat/segment.c
@@ -167,11 +167,9 @@ static int segment_mux_init(AVFormatContext *s)
         AVStream *st, *ist = s->streams[i];
         AVCodecParameters *ipar = ist->codecpar, *opar;
 
-        if (!(st = avformat_new_stream(oc, NULL)))
+        st = ff_stream_clone(oc, ist);
+        if (!st)
             return AVERROR(ENOMEM);
-        ret = ff_stream_encode_params_copy(st, ist);
-        if (ret < 0)
-            return ret;
         opar = st->codecpar;
         if (!oc->oformat->codec_tag ||
             av_codec_get_id (oc->oformat->codec_tag, ipar->codec_tag) == opar->codec_id ||
diff --git a/libavformat/spdifdec.c b/libavformat/spdifdec.c
index 6721335..2af75ca 100644
--- a/libavformat/spdifdec.c
+++ b/libavformat/spdifdec.c
@@ -226,7 +226,7 @@ int ff_spdif_read_packet(AVFormatContext *s, AVPacket *pkt)
     if (!s->bit_rate && s->streams[0]->codecpar->sample_rate)
         /* stream bitrate matches 16-bit stereo PCM bitrate for currently
            supported codecs */
-        s->bit_rate = 2 * 16LL * s->streams[0]->codecpar->sample_rate;
+        s->bit_rate = 2 * 16 * s->streams[0]->codecpar->sample_rate;
 
     return 0;
 }
diff --git a/libavformat/subviewerdec.c b/libavformat/subviewerdec.c
index 6ffdc98..e3a950f 100644
--- a/libavformat/subviewerdec.c
+++ b/libavformat/subviewerdec.c
@@ -50,32 +50,26 @@ static int subviewer_probe(const AVProbeData *p)
     return 0;
 }
 
-static int get_multiplier(int e) {
-    switch (e) {
-    case 1  : return 100;
-    case 2  : return 10;
-    case 3  : return 1;
-    default : return -1;
-    }
-}
-
 static int read_ts(const char *s, int64_t *start, int *duration)
 {
     int64_t end;
     int hh1, mm1, ss1, ms1;
     int hh2, mm2, ss2, ms2;
-    int multiplier1, multiplier2;
-    int ms1p1, ms1p2, ms2p1, ms2p2;
-
-    if (sscanf(s, "%u:%u:%u.%n%u%n,%u:%u:%u.%n%u%n",
-               &hh1, &mm1, &ss1, &ms1p1, &ms1, &ms1p2, &hh2, &mm2, &ss2, &ms2p1, &ms2, &ms2p2) == 8) {
-        multiplier1 = get_multiplier(ms1p2 - ms1p1);
-        multiplier2 = get_multiplier(ms2p2 - ms2p1);
-        if (multiplier1 <= 0 ||multiplier2 <= 0)
-            return -1;
-
-        end    = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2 * multiplier2;
-        *start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1 * multiplier1;
+    int multiplier = 1;
+
+    if (sscanf(s, "%u:%u:%u.%2u,%u:%u:%u.%2u",
+               &hh1, &mm1, &ss1, &ms1, &hh2, &mm2, &ss2, &ms2) == 8) {
+        multiplier = 10;
+    } else if (sscanf(s, "%u:%u:%u.%1u,%u:%u:%u.%1u",
+                      &hh1, &mm1, &ss1, &ms1, &hh2, &mm2, &ss2, &ms2) == 8) {
+        multiplier = 100;
+    }
+    if (sscanf(s, "%u:%u:%u.%u,%u:%u:%u.%u",
+               &hh1, &mm1, &ss1, &ms1, &hh2, &mm2, &ss2, &ms2) == 8) {
+        ms1 = FFMIN(ms1, 999);
+        ms2 = FFMIN(ms2, 999);
+        end    = (hh2*3600LL + mm2*60LL + ss2) * 1000LL + ms2 * multiplier;
+        *start = (hh1*3600LL + mm1*60LL + ss1) * 1000LL + ms1 * multiplier;
         *duration = end - *start;
         return 0;
     }
diff --git a/libavformat/tee.c b/libavformat/tee.c
index f1f2a9d..dd408dd 100644
--- a/libavformat/tee.c
+++ b/libavformat/tee.c
@@ -284,14 +284,11 @@ static int open_slave(AVFormatContext *avf, char *slave, TeeSlave *tee_slave)
         }
         tee_slave->stream_map[i] = stream_count++;
 
-        if (!(st2 = avformat_new_stream(avf2, NULL))) {
+        st2 = ff_stream_clone(avf2, st);
+        if (!st2) {
             ret = AVERROR(ENOMEM);
             goto end;
         }
-
-        ret = ff_stream_encode_params_copy(st2, st);
-        if (ret < 0)
-            goto end;
     }
 
     ret = ff_format_output_open(avf2, filename, &options);
diff --git a/libavformat/ttmlenc.c b/libavformat/ttmlenc.c
index 896fc81..fc8069f 100644
--- a/libavformat/ttmlenc.c
+++ b/libavformat/ttmlenc.c
@@ -91,7 +91,7 @@ static int ttml_set_header_values_from_extradata(
     if (!additional_data_size) {
         // simple case, we don't have to go through local_params and just
         // set default fall-back values (for old extradata format).
-        header_params->tt_element_params = ttml_default_namespacing;
+        header_params->tt_element_params = TTML_DEFAULT_NAMESPACING;
         header_params->pre_body_elements = "";
 
         return 0;
diff --git a/libavformat/version.h b/libavformat/version.h
index b234218..7b41403 100644
--- a/libavformat/version.h
+++ b/libavformat/version.h
@@ -31,7 +31,7 @@
 
 #include "version_major.h"
 
-#define LIBAVFORMAT_VERSION_MINOR  27
+#define LIBAVFORMAT_VERSION_MINOR  30
 #define LIBAVFORMAT_VERSION_MICRO 100
 
 #define LIBAVFORMAT_VERSION_INT AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, \
diff --git a/libavformat/webm_chunk.c b/libavformat/webm_chunk.c
index d69db3a..9e71a12 100644
--- a/libavformat/webm_chunk.c
+++ b/libavformat/webm_chunk.c
@@ -91,12 +91,10 @@ static int webm_chunk_init(AVFormatContext *s)
     if ((ret = av_dict_copy(&oc->metadata, s->metadata, 0)) < 0)
         return ret;
 
-    if (!(st = avformat_new_stream(oc, NULL)))
+    st = ff_stream_clone(oc, ost);
+    if (!st)
         return AVERROR(ENOMEM);
 
-    if ((ret = ff_stream_encode_params_copy(st, ost)) < 0)
-        return ret;
-
     if (wc->http_method)
         if ((ret = av_dict_set(&dict, "method", wc->http_method, 0)) < 0)
             return ret;
diff --git a/libavformat/xwma.c b/libavformat/xwma.c
index 12689f3..c16ff1b 100644
--- a/libavformat/xwma.c
+++ b/libavformat/xwma.c
@@ -278,7 +278,7 @@ static int xwma_read_header(AVFormatContext *s)
          * the total duration using the average bits per sample and the
          * total data length.
          */
-        st->duration = av_rescale((size<<3), st->codecpar->sample_rate, st->codecpar->bit_rate);
+        st->duration = (size<<3) * st->codecpar->sample_rate / st->codecpar->bit_rate;
     }
 
 fail:
diff --git a/libavrkmpp/Makefile b/libavrkmpp/Makefile
new file mode 100644
index 0000000..1b9b194
--- /dev/null
+++ b/libavrkmpp/Makefile
@@ -0,0 +1,17 @@
+NAME = avrkmpp
+DESC = Rockchip MPP adapter
+
+HEADERS = avrkmpp.h                                                     \
+          version.h                                                     \
+          version_major.h                                               \
+
+OBJS-codec = rkmppdec.o                                                 \
+             rkmppenc.o                                                 \
+
+OBJS-filter-$(CONFIG_LIBRGA) = vf_scale_rga.o                           \
+
+OBJS = $(OBJS-codec) $(OBJS-filter-yes) version.o
+
+$(OBJS-codec:%=$(SUBDIR)%): CFLAGS  += -I$(SRC_LINK)/libavcodec/
+
+$(OBJS-filter-yes:%=$(SUBDIR)%): CFLAGS  += -I$(SRC_LINK)/libavfilter/
diff --git a/libavrkmpp/avrkmpp.h b/libavrkmpp/avrkmpp.h
new file mode 100644
index 0000000..ea2ee51
--- /dev/null
+++ b/libavrkmpp/avrkmpp.h
@@ -0,0 +1,95 @@
+
+#ifndef AVRKMPP_AVRKMPP_H
+#define AVRKMPP_AVRKMPP_H
+
+#include "version_major.h"
+#ifndef HAVE_AV_CONFIG_H
+/* When included as part of the ffmpeg build, only include the major version
+ * to avoid unnecessary rebuilds. When included externally, keep including
+ * the full version information. */
+#include "version.h"
+#endif
+
+/**
+ * Return the LIBAVRKMPP_VERSION_INT constant.
+ */
+unsigned avrkmpp_version(void);
+
+/**
+ * Return the libavrkmpp build-time configuration.
+ */
+const char *avrkmpp_configuration(void);
+
+/**
+ * Return the libavrkmpp license.
+ */
+const char *avrkmpp_license(void);
+
+#include <rockchip/mpp_buffer.h>
+#include <rga/RgaApi.h>
+
+#include "libavutil/log.h"
+#include "libavutil/buffer.h"
+#include "libavutil/frame.h"
+
+typedef struct ScaleRGAContext {
+    const AVClass *class;
+
+    AVBufferRef *frame_group_ref;
+
+    AVBufferRef *device_ref;
+    AVBufferRef *hwframes_ref;
+    rga_rect_t output;
+    int passthrough;
+
+    MppBufferGroup frame_group;
+
+    AVFrame *sw_frame;
+
+    char *w_expr;      // width expression string
+    char *h_expr;      // height expression string
+    char *size_str;    // WxH expression
+    int force_original_aspect_ratio;
+    int force_divisible_by;
+
+    int down_scale_only;
+} ScaleRGAContext;
+
+#include "libavfilter/avfilter.h"
+
+int avrkmpp_scale_rga_filter_frame(AVFilterLink *, AVFrame *, AVFrame **);
+
+int avrkmpp_scale_rga_config_output(AVFilterLink *);
+
+int avrkmpp_scale_rga_init(AVFilterContext *);
+
+void avrkmpp_scale_rga_uninit(AVFilterContext *);
+
+
+typedef struct {
+    AVClass *av_class;
+    AVBufferRef *decoder_ref;
+} RKMPPDecodeContext;
+
+#include "libavcodec/avcodec.h"
+
+int avrkmpp_init_decoder(AVCodecContext *);
+int avrkmpp_close_decoder(AVCodecContext *);
+int avrkmpp_receive_frame(AVCodecContext *, AVFrame *, int (*)(AVCodecContext *, AVPacket *));
+void avrkmpp_decoder_flush(AVCodecContext *);
+
+
+typedef struct {
+    AVClass *av_class;
+    AVBufferRef *encoder_ref;
+    void *prep_cfg;
+    int profile;
+    int dct8x8;
+} RKMPPEncodeContext;
+
+int avrkmpp_init_encoder(AVCodecContext *);
+int avrkmpp_close_encoder(AVCodecContext *);
+int avrkmpp_encode_frame(AVCodecContext *, AVPacket *, const AVFrame *, int *);
+
+
+#endif /* AVRKMPP_AVRKMPP_H */
diff --git a/libavrkmpp/libavrkmpp.v b/libavrkmpp/libavrkmpp.v
new file mode 100644
index 0000000..e9eca76
--- /dev/null
+++ b/libavrkmpp/libavrkmpp.v
@@ -0,0 +1,7 @@
+LIBAVRKMPP_MAJOR {
+    global:
+        avrkmpp_*;
+        av_*;
+    local:
+        *;
+};
diff --git a/libavrkmpp/rkmppdec.c b/libavrkmpp/rkmppdec.c
new file mode 100644
index 0000000..470fea5
--- /dev/null
+++ b/libavrkmpp/rkmppdec.c
@@ -0,0 +1,754 @@
+/*
+ * RockChip MPP Video Decoder
+ * Copyright (c) 2017 Lionel CHAZALLON
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <drm_fourcc.h>
+#include <pthread.h>
+#include <rockchip/mpp_buffer.h>
+#include <rockchip/rk_mpi.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+#include "avrkmpp.h"
+
+#include "libavutil/hwcontext_drm.h"
+
+#if CONFIG_LIBRGA
+#include <rga/rga.h>
+#include <rga/RgaApi.h>
+#endif
+
+// HACK: Older BSP kernel use NA12 for NV15.
+#ifndef DRM_FORMAT_NV15 // fourcc_code('N', 'V', '1', '5')
+#define DRM_FORMAT_NV15 fourcc_code('N', 'A', '1', '2')
+#endif
+
+#define FPS_UPDATE_INTERVAL     120
+
+typedef struct {
+    MppCtx ctx;
+    MppApi *mpi;
+    MppBufferGroup frame_group;
+
+    int8_t eos;
+    int8_t draining;
+
+    AVPacket packet;
+    AVBufferRef *frames_ref;
+    AVBufferRef *device_ref;
+
+    char print_fps;
+
+    uint64_t last_fps_time;
+    uint64_t frames;
+
+    char sync;
+} RKMPPDecoder;
+
+typedef struct {
+    MppFrame frame;
+    AVBufferRef *decoder_ref;
+} RKMPPFrameContext;
+
+static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
+{
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H263:          return MPP_VIDEO_CodingH263;
+    case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
+    case AV_CODEC_ID_HEVC:          return MPP_VIDEO_CodingHEVC;
+    case AV_CODEC_ID_AV1:           return MPP_VIDEO_CodingAV1;
+    case AV_CODEC_ID_VP8:           return MPP_VIDEO_CodingVP8;
+    case AV_CODEC_ID_VP9:           return MPP_VIDEO_CodingVP9;
+    case AV_CODEC_ID_MPEG1VIDEO:    /* fallthrough */
+    case AV_CODEC_ID_MPEG2VIDEO:    return MPP_VIDEO_CodingMPEG2;
+    case AV_CODEC_ID_MPEG4:         return MPP_VIDEO_CodingMPEG4;
+    default:                        return MPP_VIDEO_CodingUnused;
+    }
+}
+
+static uint32_t rkmpp_get_frameformat(MppFrameFormat mppformat)
+{
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return DRM_FORMAT_NV12;
+    case MPP_FMT_YUV420SP_10BIT:    return DRM_FORMAT_NV15;
+    case MPP_FMT_YUV422SP:          return DRM_FORMAT_NV16;
+    default:                        return 0;
+    }
+}
+
+static uint32_t rkmpp_get_avformat(MppFrameFormat mppformat)
+{
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return AV_PIX_FMT_NV12;
+    case MPP_FMT_YUV420SP_10BIT:    return AV_PIX_FMT_P010;
+    case MPP_FMT_YUV422SP:          return AV_PIX_FMT_NV16;
+    default:                        return 0;
+    }
+}
+
+#if CONFIG_LIBRGA
+static uint32_t rkmpp_get_rgaformat(MppFrameFormat mppformat)
+{
+    switch (mppformat & MPP_FRAME_FMT_MASK) {
+    case MPP_FMT_YUV420SP:          return RK_FORMAT_YCbCr_420_SP;
+    case MPP_FMT_YUV420SP_10BIT:    return RK_FORMAT_YCbCr_420_SP_10B;
+    case MPP_FMT_YUV422SP:          return RK_FORMAT_YCbCr_422_SP;
+    default:                        return RK_FORMAT_UNKNOWN;
+    }
+}
+#endif
+
+int avrkmpp_close_decoder(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+
+    av_packet_unref(&decoder->packet);
+
+    av_buffer_unref(&rk_context->decoder_ref);
+    return 0;
+}
+
+static void rkmpp_release_decoder(void *opaque, uint8_t *data)
+{
+    RKMPPDecoder *decoder = (RKMPPDecoder *)data;
+
+    if (decoder->mpi) {
+        decoder->mpi->reset(decoder->ctx);
+        mpp_destroy(decoder->ctx);
+        decoder->ctx = NULL;
+    }
+
+    if (decoder->frame_group) {
+        mpp_buffer_group_put(decoder->frame_group);
+        decoder->frame_group = NULL;
+    }
+
+    av_buffer_unref(&decoder->frames_ref);
+    av_buffer_unref(&decoder->device_ref);
+
+    av_free(decoder);
+}
+
+static int rkmpp_prepare_decoder(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket packet;
+    int ret;
+
+    // HACK: somehow MPP cannot handle extra data for AV1
+    if (avctx->extradata_size && avctx->codec_id != AV_CODEC_ID_AV1) {
+        ret = mpp_packet_init(&packet, avctx->extradata, avctx->extradata_size);
+        if (ret < 0)
+            return AVERROR_UNKNOWN;
+        ret = decoder->mpi->decode_put_packet(decoder->ctx, packet);
+        mpp_packet_deinit(&packet);
+        if (ret < 0)
+            return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+int avrkmpp_init_decoder(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = NULL;
+    MppCodingType codectype = MPP_VIDEO_CodingUnused;
+    char *env;
+    int ret;
+
+    avctx->pix_fmt = AV_PIX_FMT_DRM_PRIME;
+
+    // create a decoder and a ref to it
+    decoder = av_mallocz(sizeof(RKMPPDecoder));
+    if (!decoder) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    env = getenv("FFMPEG_RKMPP_LOG_FPS");
+    if (env != NULL)
+        decoder->print_fps = !!atoi(env);
+
+    rk_context->decoder_ref = av_buffer_create((uint8_t *)decoder, sizeof(*decoder), rkmpp_release_decoder,
+                                               NULL, AV_BUFFER_FLAG_READONLY);
+    if (!rk_context->decoder_ref) {
+        av_free(decoder);
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Initializing RKMPP decoder.\n");
+
+    codectype = rkmpp_get_codingtype(avctx);
+    if (codectype == MPP_VIDEO_CodingUnused) {
+        av_log(avctx, AV_LOG_ERROR, "Unknown codec type (%d).\n", avctx->codec_id);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpp_check_support_format(MPP_CTX_DEC, codectype);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Codec type (%d) unsupported by MPP\n", avctx->codec_id);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // Create the MPP context
+    ret = mpp_create(&decoder->ctx, &decoder->mpi);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = 1;
+    decoder->mpi->control(decoder->ctx, MPP_DEC_SET_PARSER_FAST_MODE, &ret);
+
+    // initialize mpp
+    ret = mpp_init(decoder->ctx, MPP_CTX_DEC, codectype);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to initialize MPP context (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpp_buffer_group_get_internal(&decoder->frame_group, MPP_BUFFER_TYPE_DRM | MPP_BUFFER_FLAGS_DMA32);
+    if (ret) {
+       av_log(avctx, AV_LOG_ERROR, "Failed to get buffer group (code = %d)\n", ret);
+       ret = AVERROR_UNKNOWN;
+       goto fail;
+    }
+
+    ret = decoder->mpi->control(decoder->ctx, MPP_DEC_SET_EXT_BUF_GROUP, decoder->frame_group);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to assign buffer group (code = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    decoder->mpi->control(decoder->ctx, MPP_DEC_SET_DISABLE_ERROR, NULL);
+
+    // wait for decode result after feeding any packets
+    if (getenv("FFMPEG_RKMPP_SYNC")){
+        decoder->sync = 1;
+        ret = 1;
+        decoder->mpi->control(decoder->ctx, MPP_DEC_SET_IMMEDIATE_OUT, &ret);
+    }
+    ret = rkmpp_prepare_decoder(avctx);
+    if (ret < 0) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to prepare decoder (code = %d)\n", ret);
+        goto fail;
+    }
+
+    decoder->device_ref = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_DRM);
+    if (!decoder->device_ref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    ret = av_hwdevice_ctx_init(decoder->device_ref);
+    if (ret < 0)
+        goto fail;
+
+    av_log(avctx, AV_LOG_DEBUG, "RKMPP decoder initialized successfully.\n");
+
+    return 0;
+
+fail:
+    av_log(avctx, AV_LOG_ERROR, "Failed to initialize RKMPP decoder.\n");
+    avrkmpp_close_decoder(avctx);
+    return ret;
+}
+
+static void rkmpp_release_frame(void *opaque, uint8_t *data)
+{
+    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
+    AVBufferRef *framecontextref = (AVBufferRef *)opaque;
+    RKMPPFrameContext *framecontext = (RKMPPFrameContext *)framecontextref->data;
+
+    mpp_frame_deinit(&framecontext->frame);
+    av_buffer_unref(&framecontext->decoder_ref);
+    av_buffer_unref(&framecontextref);
+
+    av_free(desc);
+}
+
+static int rkmpp_convert_frame(AVCodecContext *avctx, AVFrame *frame,
+                               MppFrame mppframe, MppBuffer buffer)
+{
+    char *src = mpp_buffer_get_ptr(buffer);
+    char *dst_y = frame->data[0];
+    char *dst_u = frame->data[1];
+    char *dst_v = frame->data[2];
+#if CONFIG_LIBRGA
+    RgaSURF_FORMAT format = rkmpp_get_rgaformat(mpp_frame_get_fmt(mppframe));
+#endif
+    int width = mpp_frame_get_width(mppframe);
+    int height = mpp_frame_get_height(mppframe);
+    int hstride = mpp_frame_get_hor_stride(mppframe);
+    int vstride = mpp_frame_get_ver_stride(mppframe);
+    int y_pitch = frame->linesize[0];
+    int u_pitch = frame->linesize[1];
+    int v_pitch = frame->linesize[2];
+    int i, j;
+
+#if CONFIG_LIBRGA
+    rga_info_t src_info = {0};
+    rga_info_t dst_info = {0};
+    int dst_height = (dst_u - dst_y) / y_pitch;
+
+    static int rga_supported = 1;
+    static int rga_inited = 0;
+
+    if (!rga_supported)
+        goto bail;
+
+    if (!rga_inited) {
+        if (c_RkRgaInit() < 0) {
+            rga_supported = 0;
+            av_log(avctx, AV_LOG_WARNING, "RGA not available\n");
+            goto bail;
+        }
+        rga_inited = 1;
+    }
+
+    if (format == RK_FORMAT_UNKNOWN)
+        goto bail;
+
+    if (u_pitch != y_pitch / 2 || v_pitch != y_pitch / 2 ||
+        dst_u != dst_y + y_pitch * dst_height ||
+        dst_v != dst_u + u_pitch * dst_height / 2)
+        goto bail;
+
+    src_info.fd = mpp_buffer_get_fd(buffer);
+    src_info.mmuFlag = 1;
+    rga_set_rect(&src_info.rect, 0, 0, width, height, hstride, vstride,
+                 format);
+
+    dst_info.virAddr = dst_y;
+    dst_info.mmuFlag = 1;
+    rga_set_rect(&dst_info.rect, 0, 0, frame->width, frame->height,
+                 y_pitch, dst_height, RK_FORMAT_YCbCr_420_P);
+
+    if (c_RkRgaBlit(&src_info, &dst_info, NULL) < 0)
+        goto bail;
+
+    return 0;
+
+bail:
+#endif
+    if (mpp_frame_get_fmt(mppframe) != MPP_FMT_YUV420SP) {
+        av_log(avctx, AV_LOG_WARNING, "Unable to convert\n");
+        return -1;
+    }
+
+    av_log(avctx, AV_LOG_WARNING, "Doing slow software conversion\n");
+
+    for (i = 0; i < frame->height; i++)
+        memcpy(dst_y + i * y_pitch, src + i * hstride, frame->width);
+
+    src += hstride * vstride;
+
+    for (i = 0; i < frame->height / 2; i++) {
+        for (j = 0; j < frame->width; j++) {
+            dst_u[j] = src[2 * j + 0];
+            dst_v[j] = src[2 * j + 1];
+        }
+        dst_u += u_pitch;
+        dst_v += v_pitch;
+        src += hstride;
+    }
+
+    return 0;
+}
+
+static void rkmpp_update_fps(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    struct timeval tv;
+    uint64_t curr_time;
+    float fps;
+
+    if (!decoder->print_fps)
+        return;
+
+    if (!decoder->last_fps_time) {
+        gettimeofday(&tv, NULL);
+        decoder->last_fps_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+    }
+
+    if (++decoder->frames % FPS_UPDATE_INTERVAL)
+        return;
+
+    gettimeofday(&tv, NULL);
+    curr_time = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+
+    fps = 1000.0f * FPS_UPDATE_INTERVAL / (curr_time - decoder->last_fps_time);
+    decoder->last_fps_time = curr_time;
+
+    av_log(avctx, AV_LOG_INFO,
+           "[FFMPEG RKMPP] FPS: %6.1f || Frames: %" PRIu64 "\n",
+           fps, decoder->frames);
+}
+
+static int rkmpp_get_frame(AVCodecContext *avctx, AVFrame *frame, int timeout)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    RKMPPFrameContext *framecontext = NULL;
+    AVBufferRef *framecontextref = NULL;
+    int ret;
+    MppFrame mppframe = NULL;
+    MppBuffer buffer = NULL;
+    AVDRMFrameDescriptor *desc = NULL;
+    AVDRMLayerDescriptor *layer = NULL;
+    int mode;
+    MppFrameFormat mppformat;
+    uint32_t drmformat;
+
+    // should not provide any frame after EOS
+    if (decoder->eos)
+        return AVERROR_EOF;
+
+    decoder->mpi->control(decoder->ctx, MPP_SET_OUTPUT_TIMEOUT, (MppParam)&timeout);
+
+    ret = decoder->mpi->decode_get_frame(decoder->ctx, &mppframe);
+    if (ret != MPP_OK && ret != MPP_ERR_TIMEOUT) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get frame (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    if (!mppframe) {
+        if (timeout != MPP_TIMEOUT_NON_BLOCK)
+            av_log(avctx, AV_LOG_DEBUG, "Timeout getting decoded frame.\n");
+        return AVERROR(EAGAIN);
+    }
+
+    if (mpp_frame_get_eos(mppframe)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a EOS frame.\n");
+        decoder->eos = 1;
+        ret = AVERROR_EOF;
+        goto fail;
+    }
+
+    if (mpp_frame_get_discard(mppframe)) {
+        av_log(avctx, AV_LOG_DEBUG, "Received a discard frame.\n");
+        ret = AVERROR(EAGAIN);
+        goto fail;
+    }
+
+    if (mpp_frame_get_errinfo(mppframe)) {
+        av_log(avctx, AV_LOG_ERROR, "Received a errinfo frame.\n");
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    if (mpp_frame_get_info_change(mppframe)) {
+        AVHWFramesContext *hwframes;
+
+        av_log(avctx, AV_LOG_INFO, "Decoder noticed an info change (%dx%d), stride(%dx%d), format=%d\n",
+               (int)mpp_frame_get_width(mppframe), (int)mpp_frame_get_height(mppframe),
+               (int)mpp_frame_get_hor_stride(mppframe), (int)mpp_frame_get_ver_stride(mppframe), 
+               (int)mpp_frame_get_fmt(mppframe));
+
+        avctx->width = mpp_frame_get_width(mppframe);
+        avctx->height = mpp_frame_get_height(mppframe);
+
+        // chromium would align planes' width and height to 32, adding this
+        // hack to avoid breaking the plane buffers' contiguous.
+        avctx->coded_width = FFALIGN(avctx->width, 64);
+        avctx->coded_height = FFALIGN(avctx->height, 64);
+
+        decoder->mpi->control(decoder->ctx, MPP_DEC_SET_INFO_CHANGE_READY, NULL);
+
+        av_buffer_unref(&decoder->frames_ref);
+
+        decoder->frames_ref = av_hwframe_ctx_alloc(decoder->device_ref);
+        if (!decoder->frames_ref) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        av_log(avctx, AV_LOG_VERBOSE, "hw_frames_ctx->data=%p\n", decoder->frames_ref->data);
+
+        mppformat = mpp_frame_get_fmt(mppframe);
+
+        hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
+        hwframes->format    = AV_PIX_FMT_DRM_PRIME;
+        hwframes->sw_format = rkmpp_get_avformat(mppformat);
+        hwframes->width     = avctx->width;
+        hwframes->height    = avctx->height;
+        ret = av_hwframe_ctx_init(decoder->frames_ref);
+        if (!ret)
+            ret = AVERROR(EAGAIN);
+
+        goto fail;
+    }
+
+    // here we should have a valid frame
+    av_log(avctx, AV_LOG_DEBUG, "Received a frame.\n");
+
+    // now setup the frame buffer info
+    buffer = mpp_frame_get_buffer(mppframe);
+    if (!buffer) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get the frame buffer, frame is dropped (code = %d)\n", ret);
+        ret = AVERROR(EAGAIN);
+        goto fail;
+    }
+
+    rkmpp_update_fps(avctx);
+
+/*
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
+        av_log(avctx, AV_LOG_DEBUG, "Not drm prime.\n");
+        ret = ff_get_buffer(avctx, frame, 0);
+        if (ret < 0)
+            goto out;
+    }
+*/
+    // setup general frame fields
+    frame->format           = AV_PIX_FMT_DRM_PRIME;
+    frame->width            = mpp_frame_get_width(mppframe);
+    frame->height           = mpp_frame_get_height(mppframe);
+    frame->pts              = mpp_frame_get_pts(mppframe);
+    frame->reordered_opaque = frame->pts;
+    frame->color_range      = mpp_frame_get_color_range(mppframe);
+    frame->color_primaries  = mpp_frame_get_color_primaries(mppframe);
+    frame->color_trc        = mpp_frame_get_color_trc(mppframe);
+    frame->colorspace       = mpp_frame_get_colorspace(mppframe);
+
+    mode = mpp_frame_get_mode(mppframe);
+    frame->interlaced_frame = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_DEINTERLACED);
+    frame->top_field_first  = ((mode & MPP_FRAME_FLAG_FIELD_ORDER_MASK) == MPP_FRAME_FLAG_TOP_FIRST);
+
+/*
+    if (avctx->pix_fmt != AV_PIX_FMT_DRM_PRIME) {
+        ret = rkmpp_convert_frame(avctx, frame, mppframe, buffer);
+        goto out;
+    }
+*/
+
+    mppformat = mpp_frame_get_fmt(mppframe);
+    drmformat = rkmpp_get_frameformat(mppformat);
+
+    desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
+    if (!desc) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    desc->nb_objects = 1;
+    desc->objects[0].fd = mpp_buffer_get_fd(buffer);
+    desc->objects[0].size = mpp_buffer_get_size(buffer);
+
+    desc->nb_layers = 1;
+    layer = &desc->layers[0];
+    layer->format = drmformat;
+    layer->nb_planes = 2;
+
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset = 0;
+    layer->planes[0].pitch = mpp_frame_get_hor_stride(mppframe);
+
+    layer->planes[1].object_index = 0;
+    layer->planes[1].offset = layer->planes[0].pitch * mpp_frame_get_ver_stride(mppframe);
+    layer->planes[1].pitch = layer->planes[0].pitch;
+
+    // we also allocate a struct in buf[0] that will allow to hold additionnal information
+    // for releasing properly MPP frames and decoder
+    framecontextref = av_buffer_allocz(sizeof(*framecontext));
+    if (!framecontextref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    // MPP decoder needs to be closed only when all frames have been released.
+    framecontext = (RKMPPFrameContext *)framecontextref->data;
+    framecontext->decoder_ref = av_buffer_ref(rk_context->decoder_ref);
+    framecontext->frame = mppframe;
+
+    frame->data[0]  = (uint8_t *)desc;
+    frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rkmpp_release_frame,
+                                       framecontextref, AV_BUFFER_FLAG_READONLY);
+
+    if (!frame->buf[0]) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    frame->hw_frames_ctx = av_buffer_ref(decoder->frames_ref);
+    if (!frame->hw_frames_ctx) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    return 0;
+
+out:
+fail:
+    if (mppframe)
+        mpp_frame_deinit(&mppframe);
+
+    if (framecontext)
+        av_buffer_unref(&framecontext->decoder_ref);
+
+    if (framecontextref)
+        av_buffer_unref(&framecontextref);
+
+    if (desc)
+        av_free(desc);
+
+    return ret;
+}
+
+static int rkmpp_send_packet(AVCodecContext *avctx, AVPacket *packet)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket mpkt;
+    int64_t pts = packet->pts;
+    int ret;
+
+    // avoid sending new data after EOS
+    if (decoder->draining)
+        return AVERROR_EOF;
+
+    if (!pts || pts == AV_NOPTS_VALUE)
+        pts = avctx->reordered_opaque;
+
+    ret = mpp_packet_init(&mpkt, packet->data, packet->size);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init MPP packet (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    mpp_packet_set_pts(mpkt, pts);
+
+    ret = decoder->mpi->decode_put_packet(decoder->ctx, mpkt);
+    mpp_packet_deinit(&mpkt);
+
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_DEBUG, "Buffer full\n");
+        return AVERROR(EAGAIN);
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Wrote %d bytes to decoder\n", packet->size);
+    return 0;
+}
+
+static int rkmpp_send_eos(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    MppPacket mpkt;
+    int ret;
+
+    ret = mpp_packet_init(&mpkt, NULL, 0);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init EOS packet (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    mpp_packet_set_eos(mpkt);
+
+    do {
+        ret = decoder->mpi->decode_put_packet(decoder->ctx, mpkt);
+    } while (ret != MPP_OK);
+    mpp_packet_deinit(&mpkt);
+
+    decoder->draining = 1;
+
+    return 0;
+}
+
+int avrkmpp_receive_frame(AVCodecContext *avctx, AVFrame *frame, 
+    int (*ff_decode_get_packet)(AVCodecContext *, AVPacket *))
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+    AVPacket *packet = &decoder->packet;
+    int ret;
+
+    // no more frames after EOS
+    if (decoder->eos)
+        return AVERROR_EOF;
+
+    // draining remain frames
+    if (decoder->draining)
+        return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+
+    while (1) {
+        if (!packet->size) {
+            ret = ff_decode_get_packet(avctx, packet);
+            if (ret == AVERROR_EOF) {
+                av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
+                // send EOS and start draining
+                rkmpp_send_eos(avctx);
+                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+            } else if (ret == AVERROR(EAGAIN)) {
+                // not blocking so that we can feed new data ASAP
+                return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_NON_BLOCK);
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to get packet (code = %d)\n", ret);
+                return ret;
+            }
+        } else {
+            // send pending data to decoder
+            ret = rkmpp_send_packet(avctx, packet);
+            if (ret == AVERROR(EAGAIN)) {
+                // some streams might need more packets to start returning frames
+                ret = rkmpp_get_frame(avctx, frame, 5);
+                if (ret != AVERROR(EAGAIN))
+                    return ret;
+            } else if (ret < 0) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to send data (code = %d)\n", ret);
+                return ret;
+            } else {
+                av_packet_unref(packet);
+                packet->size = 0;
+
+                // blocked waiting for decode result
+                if (decoder->sync)
+                    return rkmpp_get_frame(avctx, frame, MPP_TIMEOUT_BLOCK);
+            }
+        }
+    }
+}
+
+void avrkmpp_decoder_flush(AVCodecContext *avctx)
+{
+    RKMPPDecodeContext *rk_context = avctx->priv_data;
+    RKMPPDecoder *decoder = (RKMPPDecoder *)rk_context->decoder_ref->data;
+
+    av_log(avctx, AV_LOG_DEBUG, "Flush.\n");
+
+    decoder->mpi->reset(decoder->ctx);
+
+    rkmpp_prepare_decoder(avctx);
+
+    decoder->eos = 0;
+    decoder->draining = 0;
+    decoder->last_fps_time = decoder->frames = 0;
+
+    av_packet_unref(&decoder->packet);
+}
diff --git a/libavrkmpp/rkmppenc.c b/libavrkmpp/rkmppenc.c
new file mode 100644
index 0000000..2b1d2e7
--- /dev/null
+++ b/libavrkmpp/rkmppenc.c
@@ -0,0 +1,709 @@
+/*
+ * RockChip MPP Video Encoder
+ * Copyright (c) 2018 hertz.wang@rock-chips.com
+ * Copyright (c) 2023 jjm2473 at gmail.com
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <drm_fourcc.h>
+#include <pthread.h>
+#include <rockchip/mpp_buffer.h>
+#include <rockchip/rk_mpi.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "avrkmpp.h"
+
+#include "libavutil/hwcontext_drm.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/avassert.h"
+
+#define SEND_FRAME_TIMEOUT          100
+#define RECEIVE_PACKET_TIMEOUT      100
+
+#define SZ_1K                   (1024)
+
+typedef struct {
+    MppCtx ctx;
+    MppApi *mpi;
+
+    char eos_reached;
+} RKMPPEncoder;
+
+typedef struct {
+    MppPacket packet;
+    AVBufferRef *encoder_ref;
+} RKMPPPacketContext;
+
+static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
+{
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
+    case AV_CODEC_ID_HEVC:          return MPP_VIDEO_CodingHEVC;
+    case AV_CODEC_ID_VP8:           return MPP_VIDEO_CodingVP8;
+    default:                        return MPP_VIDEO_CodingUnused;
+    }
+}
+
+static MppFrameFormat rkmpp_get_mppformat(enum AVPixelFormat avformat)
+{
+    switch (avformat) {
+    case AV_PIX_FMT_NV12:           return MPP_FMT_YUV420SP;
+    case AV_PIX_FMT_YUV420P:        return MPP_FMT_YUV420P;
+    case AV_PIX_FMT_YUYV422:        return MPP_FMT_YUV422_YUYV;
+    case AV_PIX_FMT_UYVY422:        return MPP_FMT_YUV422_UYVY;
+    case AV_PIX_FMT_P010:           return MPP_FMT_YUV420SP_10BIT;
+    case AV_PIX_FMT_NV16:           return MPP_FMT_YUV422SP;
+    default:                        return -1;
+    }
+}
+
+av_cold int avrkmpp_close_encoder(AVCodecContext *avctx)
+{
+    RKMPPEncodeContext *rk_context = avctx->priv_data;
+    av_buffer_unref(&rk_context->encoder_ref);
+    return 0;
+}
+
+static av_cold void rkmpp_release_encoder(void *opaque, uint8_t *data)
+{
+    RKMPPEncoder *encoder = (RKMPPEncoder *)data;
+
+    if (encoder->mpi) {
+        encoder->mpi->reset(encoder->ctx);
+        mpp_destroy(encoder->ctx);
+        encoder->ctx = NULL;
+    }
+
+    av_free(encoder);
+
+    if (opaque) {
+        av_free(opaque);
+    }
+}
+
+static av_cold int rkmpp_preg_config(AVCodecContext *avctx, RKMPPEncoder *encoder,
+                             MppEncPrepCfg *prep_cfg)
+{
+    int ret;
+
+    memset(prep_cfg, 0, sizeof(*prep_cfg));
+    prep_cfg->change        = MPP_ENC_PREP_CFG_CHANGE_INPUT |
+                              MPP_ENC_PREP_CFG_CHANGE_ROTATION |
+                              MPP_ENC_PREP_CFG_CHANGE_FORMAT;
+    prep_cfg->width         = avctx->width;
+    prep_cfg->height        = avctx->height;
+    prep_cfg->hor_stride    = FFALIGN(avctx->width, 16);
+    prep_cfg->ver_stride    = FFALIGN(avctx->height, 16);
+    prep_cfg->format        = rkmpp_get_mppformat(
+        avctx->hw_frames_ctx
+        ?((AVHWFramesContext *)avctx->hw_frames_ctx->data)->sw_format
+        :avctx->pix_fmt);
+    prep_cfg->rotation      = MPP_ENC_ROT_0;
+
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_PREP_CFG, prep_cfg);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set prep cfg on MPI (code = %d).\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+static av_cold int rkmpp_rc_config(AVCodecContext *avctx, RKMPPEncoder *encoder,
+                           MppEncRcCfg *rc_cfg)
+{
+    int ret;
+
+    memset(rc_cfg, 0, sizeof(*rc_cfg));
+    rc_cfg->change  = MPP_ENC_RC_CFG_CHANGE_ALL;
+
+    rc_cfg->rc_mode = MPP_ENC_RC_MODE_VBR;
+    rc_cfg->quality = MPP_ENC_RC_QUALITY_MEDIUM;
+    if (avctx->flags & AV_CODEC_FLAG_QSCALE)
+        rc_cfg->rc_mode = MPP_ENC_RC_MODE_FIXQP;
+    else if (avctx->bit_rate > 0 && avctx->rc_max_rate == avctx->bit_rate)
+        rc_cfg->rc_mode = MPP_ENC_RC_MODE_CBR;
+    else if (avctx->bit_rate > 0)
+        rc_cfg->rc_mode = MPP_ENC_RC_MODE_AVBR;
+
+    rc_cfg->bps_target  = avctx->bit_rate;
+
+    if (rc_cfg->rc_mode == MPP_ENC_RC_MODE_FIXQP) {
+        rc_cfg->qp_init = 10 + avctx->global_quality / (FF_QP2LAMBDA << 2);
+        if (rc_cfg->qp_init > 40)
+            rc_cfg->qp_init = 40;
+        av_log(avctx, AV_LOG_VERBOSE, "FIXQP %d => %d.\n", avctx->global_quality, rc_cfg->qp_init);
+        rc_cfg->qp_max      = rc_cfg->qp_init;
+        rc_cfg->qp_min      = rc_cfg->qp_init;
+        rc_cfg->qp_max_i    = rc_cfg->qp_init;
+        rc_cfg->qp_min_i    = rc_cfg->qp_init;
+        rc_cfg->qp_delta_ip = 0;
+    } else {
+        if (rc_cfg->rc_mode == MPP_ENC_RC_MODE_VBR && rc_cfg->quality == MPP_ENC_RC_QUALITY_CQP) {
+            /* constant QP does not have bps */
+            rc_cfg->bps_target  = -1;
+            rc_cfg->bps_max     = -1;
+            rc_cfg->bps_min     = -1;
+        } else {
+            if (rc_cfg->rc_mode == MPP_ENC_RC_MODE_CBR) {
+                av_log(avctx, AV_LOG_VERBOSE, "CBR %d bps.\n", rc_cfg->bps_target);
+                /* constant bitrate has very small bps range of 1/16 bps */
+                rc_cfg->bps_max     = avctx->bit_rate * 17 / 16;
+                rc_cfg->bps_min     = avctx->bit_rate * 15 / 16;
+            } else {
+                av_log(avctx, AV_LOG_VERBOSE, "(A)VBR %d bps.\n", rc_cfg->bps_target);
+                /* variable bitrate has large bps range */
+                rc_cfg->bps_max     = avctx->bit_rate * 17 / 16;
+                rc_cfg->bps_min     = avctx->bit_rate * 1 / 16;
+            }
+            rc_cfg->qp_init     = -1;
+            rc_cfg->qp_max      = 51;
+            rc_cfg->qp_min      = 10;
+            rc_cfg->qp_max_i    = 51;
+            rc_cfg->qp_min_i    = 10;
+            rc_cfg->qp_delta_ip = 2;
+        }
+    }
+
+    /* fix input / output frame rate */
+    rc_cfg->fps_in_flex     = 0;
+    av_reduce(&rc_cfg->fps_in_num, &rc_cfg->fps_in_denorm,
+                avctx->time_base.den, avctx->time_base.num, 65535);
+
+    rc_cfg->fps_out_flex    = 0;
+    if (avctx->framerate.num > 0 && avctx->framerate.den > 0)
+        av_reduce(&rc_cfg->fps_out_num, &rc_cfg->fps_out_denorm,
+                  avctx->framerate.num, avctx->framerate.den, 65535);
+    else
+        av_reduce(&rc_cfg->fps_out_num, &rc_cfg->fps_out_denorm,
+                  avctx->time_base.den, avctx->time_base.num, 65535);
+
+    rc_cfg->gop             = FFMAX(avctx->gop_size, 1);
+    rc_cfg->skip_cnt        = 0;
+
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_RC_CFG, rc_cfg);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set rc cfg on MPI (code = %d).\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+static av_cold int rkmpp_codec_config(AVCodecContext *avctx, RKMPPEncoder *encoder,
+                              MppCodingType codectype, RKMPPEncodeContext *ctx,
+                              MppEncCodecCfg *codec_cfg)
+{
+    int ret;
+
+    memset(codec_cfg, 0, sizeof(*codec_cfg));
+    codec_cfg->coding = codectype;
+    switch (codectype) {
+    case MPP_VIDEO_CodingAVC: {
+        codec_cfg->h264.change = MPP_ENC_H264_CFG_CHANGE_PROFILE |
+                                 MPP_ENC_H264_CFG_CHANGE_ENTROPY |
+                                 MPP_ENC_H264_CFG_CHANGE_TRANS_8x8;
+        if (ctx->profile == -1) {
+            ctx->profile = avctx->profile;
+        }
+        /*
+         * H.264 profile_idc parameter
+         * Support: Baseline profile
+         *          Main profile
+         *          High profile
+         */
+        if (ctx->profile != FF_PROFILE_H264_BASELINE &&
+            ctx->profile != FF_PROFILE_H264_MAIN &&
+            ctx->profile != FF_PROFILE_H264_HIGH) {
+            av_log(avctx, AV_LOG_INFO, "Unsupport profile %d, force set to %d\n",
+                   ctx->profile, FF_PROFILE_H264_HIGH);
+            ctx->profile = FF_PROFILE_H264_HIGH;
+        }
+        codec_cfg->h264.profile = ctx->profile;
+
+        /*
+         * H.264 level_idc parameter
+         * 10 / 11 / 12 / 13    - qcif@15fps / cif@7.5fps / cif@15fps / cif@30fps
+         * 20 / 21 / 22         - cif@30fps / half-D1@@25fps / D1@12.5fps
+         * 30 / 31 / 32         - D1@25fps / 720p@30fps / 720p@60fps
+         * 40 / 41 / 42         - 1080p@30fps / 1080p@30fps / 1080p@60fps
+         * 50 / 51 / 52         - 4K@30fps
+         */
+        if (avctx->level == FF_LEVEL_UNKNOWN) {
+            av_log(avctx, AV_LOG_INFO, "Unsupport level %d, force set to %d\n",
+                   avctx->level, 51);
+            avctx->level = 51;
+        }
+        codec_cfg->h264.level               = avctx->level;
+        codec_cfg->h264.entropy_coding_mode =
+            (codec_cfg->h264.profile == FF_PROFILE_H264_HIGH) ? 1 : 0;
+        codec_cfg->h264.cabac_init_idc      = 0;
+        codec_cfg->h264.transform8x8_mode   = ctx->dct8x8==0?0:1;
+    } break;
+    case MPP_VIDEO_CodingMJPEG:
+        codec_cfg->jpeg.change  = MPP_ENC_JPEG_CFG_CHANGE_QP;
+        codec_cfg->jpeg.quant   = 10; // 1 ~ 10
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "TODO encoder coding type %d\n", codectype);
+        return AVERROR_UNKNOWN;
+    }
+
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_CODEC_CFG, codec_cfg);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set codec cfg on MPI (code = %d).\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+av_cold int avrkmpp_init_encoder(AVCodecContext *avctx)
+{
+    int ret;
+    MppCodingType codectype;
+    RKMPPEncodeContext *rk_context;
+    RKMPPEncoder *encoder;
+    MppEncPrepCfg *prep_cfg;
+    MppEncRcCfg rc_cfg;
+    MppEncCodecCfg codec_cfg;
+    RK_S64 paramS64;
+    MppEncSeiMode sei_mode;
+    RK_U8 enc_hdr_buf[SZ_1K];
+    RK_S32 enc_hdr_buf_size = SZ_1K;
+    MppPacket packet = NULL;
+
+    if (avctx->hw_frames_ctx)
+        av_log(avctx, AV_LOG_VERBOSE, "hw_frames_ctx->data=%p sw_format=%d(%s)\n", avctx->hw_frames_ctx->data,
+            ((AVHWFramesContext*)avctx->hw_frames_ctx->data)->sw_format,
+            av_get_pix_fmt_name(((AVHWFramesContext*)avctx->hw_frames_ctx->data)->sw_format));
+
+    rk_context = avctx->priv_data;
+    rk_context->encoder_ref = NULL;
+    prep_cfg = av_mallocz(sizeof(MppEncPrepCfg));
+    if (!prep_cfg) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    rk_context->prep_cfg = prep_cfg;
+    codectype = rkmpp_get_codingtype(avctx);
+    if (codectype == MPP_VIDEO_CodingUnused) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupport codec type (%d).\n", avctx->codec_id);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpp_check_support_format(MPP_CTX_ENC, codectype);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Codec type (%d) unsupported by MPP\n", avctx->codec_id);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // create a encoder and a ref to it
+    encoder = av_mallocz(sizeof(RKMPPEncoder));
+    if (!encoder) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    rk_context->encoder_ref =
+        av_buffer_create((uint8_t *)encoder, sizeof(*encoder),
+                         rkmpp_release_encoder, prep_cfg, AV_BUFFER_FLAG_READONLY);
+    if (!rk_context->encoder_ref) {
+        av_free(encoder);
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Initializing RKMPP encoder.\n");
+
+    // mpp init
+    ret = mpp_create(&encoder->ctx, &encoder->mpi);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpp_init(encoder->ctx, MPP_CTX_ENC, codectype);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to initialize MPP context (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // mpp setup
+    ret = rkmpp_preg_config(avctx, encoder, prep_cfg);
+    if (ret)
+        goto fail;
+
+    ret = rkmpp_rc_config(avctx, encoder, &rc_cfg);
+    if (ret)
+        goto fail;
+
+    ret = rkmpp_codec_config(avctx, encoder, codectype, rk_context, &codec_cfg);
+    if (ret)
+        goto fail;
+
+    sei_mode = MPP_ENC_SEI_MODE_ONE_FRAME;
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_SEI_CFG, &sei_mode);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set sei cfg on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // TODO: osd if hardware support
+
+    paramS64 = SEND_FRAME_TIMEOUT;
+    ret = encoder->mpi->control(encoder->ctx, MPP_SET_INPUT_TIMEOUT, &paramS64);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set input timeout on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    paramS64 = RECEIVE_PACKET_TIMEOUT;
+    ret = encoder->mpi->control(encoder->ctx, MPP_SET_OUTPUT_TIMEOUT, &paramS64);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    memset(enc_hdr_buf, 0 , enc_hdr_buf_size);
+    ret = mpp_packet_init(&packet, (void *)enc_hdr_buf, enc_hdr_buf_size);
+    if (!packet) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to init extra info packet (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    mpp_packet_set_length(packet, 0);
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_GET_HDR_SYNC, packet);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get extra info on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    /* get and write sps/pps for H.264 */
+    void *ptr   = mpp_packet_get_pos(packet);
+    size_t len  = mpp_packet_get_length(packet);
+
+    if (avctx->extradata != NULL && avctx->extradata_size != len) {
+        av_free(avctx->extradata);
+        avctx->extradata = NULL;
+    }
+    if (!avctx->extradata)
+        avctx->extradata = av_malloc(len);
+    if (avctx->extradata == NULL) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+    avctx->extradata_size = len;
+    memcpy(avctx->extradata, ptr, len);
+
+    packet = NULL;
+
+    av_log(avctx, AV_LOG_DEBUG, "RKMPP encoder initialized successfully.\n");
+
+    return 0;
+
+fail:
+    av_log(avctx, AV_LOG_ERROR, "Failed to initialize RKMPP encoder.\n");
+    avrkmpp_close_encoder(avctx);
+    if (prep_cfg) {
+        av_free(prep_cfg);
+    }
+    return ret;
+}
+
+static int rkmpp_queue_frame(AVCodecContext *avctx, RKMPPEncoder *encoder, MppEncPrepCfg *prep_cfg,
+                             const AVFrame *avframe, MppFrame *out_frame)
+{
+    int ret;
+    MppFrameFormat mppformat;
+    MppCtx ctx;
+    MppApi *mpi;
+    MppBuffer buffer = NULL;
+    MppBufferInfo info;
+    MppFrame frame = NULL;
+    MppTask task = NULL;
+    RK_S32 hor_stride;
+    RK_S32 ver_stride;
+
+    // check format
+    if (avframe) {
+        enum AVPixelFormat swformat;
+        if(avframe->format != AV_PIX_FMT_DRM_PRIME) {
+            av_log(avctx, AV_LOG_ERROR, "RKMPPEncoder only support fmt DRM\n");
+            return AVERROR(EINVAL);
+        }
+        swformat    = ((AVHWFramesContext*)avframe->hw_frames_ctx->data)->sw_format;
+        av_log(avctx, AV_LOG_DEBUG, "hw_frames_ctx->data=%p sw_format=%d\n", avframe->hw_frames_ctx->data,
+            ((AVHWFramesContext*)avframe->hw_frames_ctx->data)->sw_format);
+        mppformat   = rkmpp_get_mppformat(swformat);
+        if (mppformat < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Unsupport av format %d\n", swformat);
+            return AVERROR(EINVAL);
+        }
+    }
+
+    ret = mpp_frame_init(&frame);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed init mpp frame on encoder (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+    mpp_frame_set_eos(frame, encoder->eos_reached);
+
+    if (avframe) {
+        AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor*)avframe->data[0];
+        AVDRMLayerDescriptor *layer = &desc->layers[0];
+
+        mpp_frame_set_pts(frame, avframe->pts);
+        mpp_frame_set_dts(frame, avframe->pkt_dts);
+        mpp_frame_set_width(frame, avframe->width);
+        mpp_frame_set_height(frame, avframe->height);
+        if (mppformat == MPP_FMT_YUV422_YUYV || mppformat == MPP_FMT_YUV422_UYVY) {
+            hor_stride = 2 * layer->planes[0].pitch;
+        } else {
+            // nv12 or yuv420p
+            hor_stride = layer->planes[0].pitch;
+        }
+        if (layer->nb_planes > 1)
+            ver_stride = layer->planes[1].offset / layer->planes[0].pitch;
+        else
+            ver_stride = avframe->height;
+
+        if (prep_cfg->hor_stride != hor_stride || prep_cfg->ver_stride != ver_stride) {
+            prep_cfg->change = MPP_ENC_PREP_CFG_CHANGE_INPUT;
+            prep_cfg->hor_stride = hor_stride;
+            prep_cfg->ver_stride = ver_stride;
+            ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_PREP_CFG, prep_cfg);
+            if (ret != MPP_OK) {
+                av_log(avctx, AV_LOG_ERROR, "Failed to set prep cfg on MPI (code = %d).\n", ret);
+                return AVERROR_UNKNOWN;
+            }
+        }
+
+        mpp_frame_set_hor_stride(frame, hor_stride/* /bpp */);
+        mpp_frame_set_ver_stride(frame, ver_stride);
+        mpp_frame_set_fmt(frame, mppformat);
+
+        memset(&info, 0, sizeof(info));
+        info.type   = MPP_BUFFER_TYPE_DRM;
+        info.size   = desc->objects[0].size;
+        info.fd     = desc->objects[0].fd;
+        ret = mpp_buffer_import(&buffer, &info);
+        if (ret != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to import buffer\n");
+            ret = AVERROR(EINVAL);
+            goto out;
+        }
+        mpp_frame_set_buffer(frame, buffer);
+    }
+
+    ctx = encoder->ctx;
+    mpi = encoder->mpi;
+    ret = mpi->poll(ctx, MPP_PORT_INPUT, MPP_POLL_BLOCK);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to poll task input (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto out;
+    }
+
+    ret = mpi->dequeue(ctx, MPP_PORT_INPUT, &task);
+    if (ret != MPP_OK || NULL == task) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to dequeue task input (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto out;
+    }
+
+    mpp_task_meta_set_frame (task, KEY_INPUT_FRAME, frame);
+    ret = mpi->enqueue(ctx, MPP_PORT_INPUT, task);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to enqueue task input (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto out;
+    }
+    *out_frame = frame;
+    frame = NULL;
+
+out:
+    if (buffer)
+        mpp_buffer_put(buffer);
+    if (frame)
+        mpp_frame_deinit(&frame);
+    return 0;
+}
+
+static int rkmpp_send_frame(AVCodecContext *avctx, const AVFrame *frame,
+                            MppFrame *mpp_frame)
+{
+    int ret;
+    RKMPPEncodeContext *rk_context = avctx->priv_data;
+    RKMPPEncoder *encoder = (RKMPPEncoder *)rk_context->encoder_ref->data;
+
+    if (!frame) {
+        av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
+        encoder->eos_reached = 1;
+        ret = rkmpp_queue_frame(avctx, encoder, NULL, NULL, mpp_frame);
+        if (ret)
+            av_log(avctx, AV_LOG_ERROR, "Failed to send EOS to encoder (code = %d)\n", ret);
+        return ret;
+    }
+
+    if (frame->pict_type == AV_PICTURE_TYPE_I) {
+        ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_IDR_FRAME, NULL);
+        if (ret != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to set IDR frame on MPI (code = %d).\n", ret);
+            return AVERROR_UNKNOWN;
+        }
+    }
+    ret = rkmpp_queue_frame(avctx, encoder, (MppEncPrepCfg *)rk_context->prep_cfg, frame, mpp_frame);
+    if (ret && ret != AVERROR(EAGAIN))
+        av_log(avctx, AV_LOG_ERROR, "Failed to send frame to encoder (code = %d)\n", ret);
+
+    return ret;
+}
+
+static void rkmpp_release_packet(void *opaque, uint8_t *data)
+{
+    RKMPPPacketContext *pkt_ctx = (RKMPPPacketContext *)opaque;
+
+    mpp_packet_deinit(&pkt_ctx->packet);
+    av_buffer_unref(&pkt_ctx->encoder_ref);
+    av_free(pkt_ctx);
+}
+
+static int rkmpp_receive_packet(AVCodecContext *avctx, AVPacket *pkt,
+                                MppFrame *mpp_frame)
+{
+    int ret;
+    RKMPPEncodeContext *rk_context = avctx->priv_data;
+    RKMPPEncoder *encoder = (RKMPPEncoder *)rk_context->encoder_ref->data;
+    MppCtx ctx = encoder->ctx;
+    MppApi *mpi = encoder->mpi;
+    MppTask task = NULL;
+    MppPacket packet = NULL;
+
+    ret = mpi->poll(ctx, MPP_PORT_OUTPUT, MPP_POLL_BLOCK);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to poll task output (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpi->dequeue(ctx, MPP_PORT_OUTPUT, &task);
+    if (ret || NULL == task) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to dequeue task output (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    if (task) {
+        mpp_task_meta_get_packet(task, KEY_OUTPUT_PACKET, &packet);
+        ret = mpi->enqueue(ctx, MPP_PORT_OUTPUT, task);
+        if (ret != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to enqueue task output (ret = %d)\n", ret);
+            ret = AVERROR_UNKNOWN;
+            goto fail;
+        }
+    }
+
+    if (packet) {
+        RKMPPPacketContext *pkt_ctx;
+        MppMeta meta = NULL;
+        int keyframe = 0;
+
+        if (mpp_packet_get_eos(packet)) {
+            av_log(avctx, AV_LOG_DEBUG, "Received a EOS packet.\n");
+            if (encoder->eos_reached) {
+                ret = AVERROR_EOF;
+                goto fail;
+            }
+        }
+        pkt_ctx = av_mallocz(sizeof(*pkt_ctx));
+        if (!pkt_ctx) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        pkt_ctx->packet = packet;
+        pkt_ctx->encoder_ref = av_buffer_ref(rk_context->encoder_ref);
+
+        // TODO: outside need fd from mppbuffer?
+        pkt->data = mpp_packet_get_data(packet);
+        pkt->size = mpp_packet_get_length(packet);
+        pkt->buf = av_buffer_create((uint8_t*)pkt->data, pkt->size,
+            rkmpp_release_packet, pkt_ctx, AV_BUFFER_FLAG_READONLY);
+        if (!pkt->buf) {
+            av_buffer_unref(&pkt_ctx->encoder_ref);
+            av_free(pkt_ctx);
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        pkt->pts = mpp_packet_get_pts(packet);
+        pkt->dts = mpp_packet_get_dts(packet);
+        if (pkt->pts <= 0)
+            pkt->pts = pkt->dts;
+        if (pkt->dts <= 0)
+            pkt->dts = pkt->pts;
+        meta = mpp_packet_get_meta(packet);
+        if (meta)
+            mpp_meta_get_s32(meta, KEY_OUTPUT_INTRA, &keyframe);
+        if (keyframe)
+            pkt->flags |= AV_PKT_FLAG_KEY;
+
+        packet = NULL;
+    }
+
+fail:
+    if (packet)
+        mpp_packet_deinit(&packet);
+    if (*mpp_frame) {
+        mpp_frame_deinit(mpp_frame);
+        *mpp_frame = NULL;
+    }
+    return ret;
+}
+
+int avrkmpp_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
+                              const AVFrame *frame, int *got_packet)
+{
+    int ret;
+    MppFrame mpp_frame = NULL;
+
+    ret = rkmpp_send_frame(avctx, frame, &mpp_frame);
+    if (ret)
+        return ret;
+
+    ret = rkmpp_receive_packet(avctx, pkt, &mpp_frame);
+    av_assert0(mpp_frame == NULL);
+    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
+        *got_packet = 0;
+    } else if (ret) {
+        return ret;
+    } else {
+        *got_packet = 1;
+    }
+
+    return 0;
+}
diff --git a/libavrkmpp/version.c b/libavrkmpp/version.c
new file mode 100644
index 0000000..28764be
--- /dev/null
+++ b/libavrkmpp/version.c
@@ -0,0 +1,22 @@
+#include "config.h"
+#include "avrkmpp.h"
+#include "version.h"
+
+#include "libavutil/ffversion.h"
+const char avrkmpp_ffversion[] = "FFmpeg version " FFMPEG_VERSION;
+
+unsigned avrkmpp_version(void)
+{
+    return LIBAVRKMPP_VERSION_INT;
+}
+
+const char *avrkmpp_configuration(void)
+{
+    return FFMPEG_CONFIGURATION;
+}
+
+const char *avrkmpp_license(void)
+{
+#define LICENSE_PREFIX "libavrkmpp license: "
+    return &LICENSE_PREFIX FFMPEG_LICENSE[sizeof(LICENSE_PREFIX) - 1];
+}
diff --git a/libavrkmpp/version.h b/libavrkmpp/version.h
new file mode 100644
index 0000000..d2cf39d
--- /dev/null
+++ b/libavrkmpp/version.h
@@ -0,0 +1,26 @@
+#ifndef AVRKMPP_VERSION_H
+#define AVRKMPP_VERSION_H
+
+/**
+ * @file
+ * Libavrkmpp version macros
+ */
+
+#include "libavutil/version.h"
+
+#include "version_major.h"
+
+#define LIBAVRKMPP_VERSION_MINOR 0
+#define LIBAVRKMPP_VERSION_MICRO 1
+
+#define LIBAVRKMPP_VERSION_INT AV_VERSION_INT(LIBAVRKMPP_VERSION_MAJOR, \
+                                               LIBAVRKMPP_VERSION_MINOR, \
+                                               LIBAVRKMPP_VERSION_MICRO)
+#define LIBAVRKMPP_VERSION     AV_VERSION(LIBAVRKMPP_VERSION_MAJOR, \
+                                           LIBAVRKMPP_VERSION_MINOR, \
+                                           LIBAVRKMPP_VERSION_MICRO)
+#define LIBAVRKMPP_BUILD       LIBAVRKMPP_VERSION_INT
+
+#define LIBAVRKMPP_IDENT       "avrkmpp" AV_STRINGIFY(LIBAVRKMPP_VERSION)
+
+#endif /* AVRKMPP_VERSION_H */
diff --git a/libavrkmpp/version_major.h b/libavrkmpp/version_major.h
new file mode 100644
index 0000000..1984a2b
--- /dev/null
+++ b/libavrkmpp/version_major.h
@@ -0,0 +1,11 @@
+#ifndef AVRKMPP_VERSION_MAJOR_H
+#define AVRKMPP_VERSION_MAJOR_H
+
+/**
+ * @file
+ * Libavrkmpp version macros
+ */
+
+#define LIBAVRKMPP_VERSION_MAJOR  1
+
+#endif /* AVRKMPP_VERSION_MAJOR_H */
diff --git a/libavrkmpp/vf_scale_rga.c b/libavrkmpp/vf_scale_rga.c
new file mode 100644
index 0000000..2db3ffa
--- /dev/null
+++ b/libavrkmpp/vf_scale_rga.c
@@ -0,0 +1,426 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+/**
+ * @file
+ * Rockchip RGA based scale filter
+ * @author: jjm2473 (jjm2473 at gmail.com)
+ */
+
+#include <drm_fourcc.h>
+
+#include <string.h>
+#include "libavutil/opt.h"
+#include "libavutil/pixdesc.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_drm.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/parseutils.h"
+
+#include "formats.h"
+#include "internal.h"
+#include "scale_eval.h"
+#include "video.h"
+
+#include "avrkmpp.h"
+
+#include <rga/rga.h>
+
+#ifndef DRM_FORMAT_NV12_10
+#define DRM_FORMAT_NV12_10 fourcc_code('N', 'A', '1', '2')
+#endif
+
+#define RGA_SW_USE_IMAGE_ALLOC
+
+typedef struct RGAFrameContext {
+    AVBufferRef *frame_group_ref;
+    MppBuffer buffer;
+} RGAFrameContext;
+
+static int ff_rga_vpp_config_output(AVFilterLink *outlink)
+{
+    AVFilterContext *avctx = outlink->src;
+    AVFilterLink *inlink   = avctx->inputs[0];
+    ScaleRGAContext *ctx   = avctx->priv;
+    rga_rect_t *rect = &ctx->output;
+    AVHWFramesContext *output_frames;
+    int err;
+
+    ctx->hwframes_ref = av_hwframe_ctx_alloc(ctx->device_ref);
+    if (!ctx->hwframes_ref) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to create HW frame context "
+               "for output.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    output_frames = (AVHWFramesContext*)ctx->hwframes_ref->data;
+
+    output_frames->format    = AV_PIX_FMT_DRM_PRIME;
+    output_frames->sw_format = AV_PIX_FMT_NV12;
+    output_frames->width     = rect->width;
+    output_frames->height    = rect->height;
+
+    err = av_hwframe_ctx_init(ctx->hwframes_ref);
+    if (err < 0) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to initialise RGA frame "
+               "context for output: %d\n", err);
+        goto fail;
+    }
+
+    outlink->hw_frames_ctx = av_buffer_ref(ctx->hwframes_ref);
+    if (!outlink->hw_frames_ctx) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    if (!inlink->hw_frames_ctx) {
+        if (!(ctx->sw_frame = av_frame_alloc())) {
+            err = AVERROR(ENOMEM);
+            goto fail;
+        }
+
+        ctx->sw_frame->format = inlink->format;
+        ctx->sw_frame->width  = FFALIGN(inlink->w, 2);
+        ctx->sw_frame->height = FFALIGN(inlink->h, 2);
+#ifdef RGA_SW_USE_IMAGE_ALLOC
+        if ((err = av_image_alloc(ctx->sw_frame->data, ctx->sw_frame->linesize, 
+            ctx->sw_frame->width, ctx->sw_frame->height, inlink->format, 32)) < 0)
+            goto fail;
+#else
+        if ((err = av_frame_get_buffer(ctx->sw_frame, 0)) < 0)
+            goto fail;
+
+        /* avoid plane padding */
+        if ((err = av_image_fill_pointers(ctx->sw_frame->data, ctx->sw_frame->format, 
+                    FFALIGN(ctx->sw_frame->height, 32),
+                    ctx->sw_frame->buf[0]->data, ctx->sw_frame->linesize)) < 0)
+            goto fail;
+#endif
+
+    }
+
+    return 0;
+
+fail:
+    av_frame_free(&ctx->sw_frame);
+    av_buffer_unref(&ctx->hwframes_ref);
+    return err;
+}
+
+static uint32_t ff_null_get_rgaformat(enum AVPixelFormat pix_fmt)
+{
+    switch (pix_fmt) {
+    case AV_PIX_FMT_YUV420P:       return RK_FORMAT_YCbCr_420_P;
+    case AV_PIX_FMT_NV12:          return RK_FORMAT_YCbCr_420_SP;
+    case AV_PIX_FMT_P010:          return RK_FORMAT_YCbCr_420_SP_10B;
+    case AV_PIX_FMT_NV16:          return RK_FORMAT_YCbCr_422_SP;
+    case AV_PIX_FMT_YUYV422:       return RK_FORMAT_YUYV_422;
+    case AV_PIX_FMT_UYVY422:       return RK_FORMAT_UYVY_422;
+    default:                       return RK_FORMAT_UNKNOWN;
+    }
+}
+
+static float get_bpp_from_rga_format(uint32_t rga_fmt) {
+    switch (rga_fmt) {
+    case RK_FORMAT_YCbCr_420_P:
+    case RK_FORMAT_YCbCr_420_SP:
+      return 1.5;
+    case RK_FORMAT_YCbCr_420_SP_10B:
+    case RK_FORMAT_YCbCr_422_SP:
+    case RK_FORMAT_YUYV_422:
+    case RK_FORMAT_UYVY_422:
+      return 2.0;
+    default:
+      av_log(NULL, AV_LOG_WARNING, "unknown RGA format %d\n", rga_fmt);
+      return 2.0;
+    }
+}
+
+int avrkmpp_scale_rga_config_output(AVFilterLink *outlink)
+{
+    AVFilterLink *inlink     = outlink->src->inputs[0];
+    AVFilterContext *avctx   = outlink->src;
+    ScaleRGAContext *ctx   = avctx->priv;
+    rga_rect_t *rect = &ctx->output;
+    int err;
+
+    rect->width = rect->width >> 1 << 1;
+    rect->height = rect->height >> 1 << 1;
+    av_log(ctx, AV_LOG_DEBUG, "Final output video size w:%d h:%d\n", rect->width, rect->height);
+
+    // wstride = width * (bit_depth >> 3), but we always use YUV420P, bit_depth=8
+    rect->wstride = FFALIGN(rect->width, 16);
+    rect->hstride = rect->height;
+    rect->xoffset = 0;
+    rect->yoffset = 0;
+
+    outlink->w = rect->width;
+    outlink->h = rect->height;
+    outlink->format = AV_PIX_FMT_DRM_PRIME;
+
+    av_buffer_unref(&ctx->hwframes_ref);
+
+    ctx->passthrough = 0;
+    if (inlink->hw_frames_ctx && outlink->w == inlink->w && outlink->h == inlink->h &&
+            ((AVHWFramesContext*)inlink->hw_frames_ctx->data)->sw_format == AV_PIX_FMT_NV12) {
+        av_log(ctx, AV_LOG_VERBOSE, "Passthrough frames.\n");
+        ctx->passthrough = 1;
+        outlink->hw_frames_ctx = av_buffer_ref(inlink->hw_frames_ctx);
+        if (!outlink->hw_frames_ctx)
+            return AVERROR(ENOMEM);
+    } else if ((err = ff_rga_vpp_config_output(outlink)) < 0) {
+        return err;
+    }
+    rect->format = ff_null_get_rgaformat(AV_PIX_FMT_NV12);
+    rect->size = rect->wstride * rect->hstride * get_bpp_from_rga_format(rect->format);
+
+    return 0;
+}
+
+static void rga_release_frame(void *opaque, uint8_t *data)
+{
+    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
+    RGAFrameContext *framecontext = (RGAFrameContext *)opaque;
+    MppBuffer buffer = framecontext->buffer;
+    av_free(desc);
+    mpp_buffer_put(buffer);
+    av_buffer_unref(&framecontext->frame_group_ref);
+    av_free(framecontext);
+}
+
+static uint32_t rga_get_drmformat(uint32_t rga_fmt) {
+    switch (rga_fmt) {
+    case RK_FORMAT_YCbCr_420_SP:        return DRM_FORMAT_NV12;
+    case RK_FORMAT_YCbCr_420_SP_10B:    return DRM_FORMAT_NV12_10;
+    case RK_FORMAT_YCbCr_422_SP:        return DRM_FORMAT_NV16;
+    case RK_FORMAT_YUYV_422:            return DRM_FORMAT_YUYV;
+    case RK_FORMAT_UYVY_422:            return DRM_FORMAT_UYVY;
+    default:                            return 0;
+    }
+}
+
+int avrkmpp_scale_rga_filter_frame(AVFilterLink *inlink, AVFrame *input_frame, AVFrame **output_frame0)
+{
+
+    AVFilterContext *avctx   = inlink->dst;
+    AVFilterLink *outlink    = avctx->outputs[0];
+    ScaleRGAContext *ctx   = avctx->priv;
+    rga_rect_t *rect = &ctx->output;
+    AVFrame *output_frame    = NULL;
+    int err;
+    MppBuffer buffer = NULL;
+    AVDRMFrameDescriptor *desc;
+    AVDRMLayerDescriptor *layer;
+    AVBufferRef *frame_group_ref;
+    RGAFrameContext *framecontext = NULL;
+    rga_info_t src_info = {0};
+    rga_info_t dst_info = {0};
+
+    if (ctx->passthrough) {
+        *output_frame0 = input_frame;
+        return 0;
+    }
+
+    if (inlink->hw_frames_ctx) {
+        desc = (AVDRMFrameDescriptor*)input_frame->data[0];
+        layer = &desc->layers[0];
+        rga_set_rect(&src_info.rect, 0, 0, input_frame->width >> 1 << 1, input_frame->height >> 1 << 1, 
+            layer->planes[0].pitch, 
+            layer->nb_planes > 1?(layer->planes[1].offset / layer->planes[0].pitch):input_frame->height,
+            ff_null_get_rgaformat(((AVHWFramesContext*)input_frame->hw_frames_ctx->data)->sw_format));
+        src_info.fd = desc->objects[0].fd;
+    } else {
+        char *src_y = input_frame->data[0];
+        char *src_u = input_frame->data[1];
+        int y_pitch = input_frame->linesize[0];
+        int src_height = (src_u - src_y) / y_pitch;
+        if (src_height < 0 || (src_height & 1) || (y_pitch & 1) || src_y + (src_height * y_pitch) != src_u) {
+            src_y = ctx->sw_frame->data[0];
+            src_u = ctx->sw_frame->data[1];
+            y_pitch = ctx->sw_frame->linesize[0];
+            src_height = (src_u - src_y) / y_pitch;
+
+            if ((err = av_frame_copy(ctx->sw_frame, input_frame)) < 0)
+                goto fail;
+
+            if ((err = av_frame_copy_props(ctx->sw_frame, input_frame)) < 0)
+                goto fail;
+        }
+        src_info.virAddr = src_y;
+        rga_set_rect(&src_info.rect, 0, 0, input_frame->width >> 1 << 1, input_frame->height >> 1 << 1,
+            y_pitch, src_height, ff_null_get_rgaformat(ctx->sw_frame->format));
+    }
+    src_info.mmuFlag = 1;
+
+    frame_group_ref = av_buffer_ref(ctx->frame_group_ref);
+    if (!frame_group_ref) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+    err = mpp_buffer_get(ctx->frame_group, &buffer, rect->size);
+    if (err) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to get buffer for input frame ret %d\n", err);
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+    dst_info.fd = mpp_buffer_get_fd(buffer);
+    dst_info.mmuFlag = 1;
+    memcpy(&dst_info.rect, rect, sizeof(rga_rect_t));
+
+    if ((err = c_RkRgaBlit(&src_info, &dst_info, NULL)) < 0) {
+        av_log(ctx, AV_LOG_ERROR, "RGA failed (code = %d)\n", err);
+        err = AVERROR(EINVAL);
+        goto fail;
+    }
+
+    desc = av_mallocz(sizeof(AVDRMFrameDescriptor));
+    if (!desc) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    desc->nb_objects = 1;
+    desc->objects[0].fd = mpp_buffer_get_fd(buffer);
+    desc->objects[0].size = mpp_buffer_get_size(buffer);
+
+    desc->nb_layers = 1;
+    layer = &desc->layers[0];
+    layer->format = rga_get_drmformat(rect->format);
+    layer->nb_planes = 2;
+
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset = 0;
+    layer->planes[0].pitch = rect->wstride;
+
+    layer->planes[1].object_index = 0;
+    layer->planes[1].offset = layer->planes[0].pitch * rect->hstride;
+    layer->planes[1].pitch = layer->planes[0].pitch;
+
+    // frame group needs to be closed only when all frames have been released.
+    framecontext = (RGAFrameContext *)av_mallocz(sizeof(RGAFrameContext));
+
+    if (!framecontext) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+    framecontext->frame_group_ref = frame_group_ref;
+    framecontext->buffer = buffer;
+
+    output_frame = av_frame_alloc();
+    if (!output_frame) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    err = av_frame_copy_props(output_frame, input_frame);
+    if (err < 0)
+        goto fail;
+
+    // setup general frame fields
+    output_frame->format           = AV_PIX_FMT_DRM_PRIME;
+    output_frame->width            = rect->width;
+    output_frame->height           = rect->height;
+
+    output_frame->data[0]  = (uint8_t *)desc;
+    output_frame->buf[0]   = av_buffer_create((uint8_t *)desc, sizeof(*desc), rga_release_frame,
+                                       framecontext, AV_BUFFER_FLAG_READONLY);
+
+    if (!output_frame->buf[0]) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    output_frame->hw_frames_ctx = av_buffer_ref(outlink->hw_frames_ctx);
+    if (!output_frame->hw_frames_ctx) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    av_frame_free(&input_frame);
+
+    *output_frame0 = output_frame;
+    return 0;
+
+fail:
+    av_frame_free(&output_frame);
+    if (framecontext)
+        av_free(framecontext);
+    av_free(desc);
+    mpp_buffer_put(buffer);
+    if (frame_group_ref)
+        av_buffer_unref(&frame_group_ref);
+    av_frame_free(&input_frame);
+    return err;
+}
+
+static void rga_release_frame_group(void *opaque, uint8_t *data)
+{
+    MppBufferGroup fg = (MppBufferGroup)opaque;
+    mpp_buffer_group_put(fg);
+}
+
+av_cold int avrkmpp_scale_rga_init(AVFilterContext *avctx)
+{
+    int ret;
+    ScaleRGAContext *ctx   = avctx->priv;
+
+    if (ret = mpp_buffer_group_get_internal(&ctx->frame_group, MPP_BUFFER_TYPE_DRM | MPP_BUFFER_FLAGS_DMA32)) {
+        av_log(ctx, AV_LOG_ERROR, "Failed to get buffer group (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    ctx->frame_group_ref = av_buffer_create(NULL, 0, rga_release_frame_group,
+                                               (void *)ctx->frame_group, AV_BUFFER_FLAG_READONLY);
+    if (!ctx->frame_group_ref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    ctx->output.format = RK_FORMAT_UNKNOWN;
+
+    ctx->device_ref = av_hwdevice_ctx_alloc(AV_HWDEVICE_TYPE_DRM);
+    if (!ctx->device_ref) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    ret = av_hwdevice_ctx_init(ctx->device_ref);
+    if (ret < 0)
+        goto fail;
+
+    return 0;
+fail:
+
+    av_buffer_unref(&ctx->device_ref);
+    mpp_buffer_group_put(ctx->frame_group);
+    return ret;
+}
+
+void avrkmpp_scale_rga_uninit(AVFilterContext *avctx)
+{
+    ScaleRGAContext *ctx   = avctx->priv;
+    if (ctx->sw_frame) {
+#ifdef RGA_SW_USE_IMAGE_ALLOC
+        av_freep(&ctx->sw_frame->data[0]);
+#endif
+        av_frame_free(&ctx->sw_frame);
+    }
+    av_buffer_unref(&ctx->frame_group_ref);
+    av_buffer_unref(&ctx->hwframes_ref);
+    av_buffer_unref(&ctx->device_ref);
+}
diff --git a/libavutil/Makefile b/libavutil/Makefile
index 9435a0b..3d9c07a 100644
--- a/libavutil/Makefile
+++ b/libavutil/Makefile
@@ -201,7 +201,7 @@ OBJS-$(!CONFIG_VULKAN)                  += hwcontext_stub.o
 OBJS += $(COMPAT_OBJS:%=../compat/%)
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES)            += avutilres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES)           += avutilres.o
 
 SKIPHEADERS                            += objc.h
 SKIPHEADERS-$(HAVE_CUDA_H)             += hwcontext_cuda.h
diff --git a/libavutil/buffer.c b/libavutil/buffer.c
index 54590be..e4562a7 100644
--- a/libavutil/buffer.c
+++ b/libavutil/buffer.c
@@ -341,9 +341,6 @@ static void pool_release_buffer(void *opaque, uint8_t *data)
     BufferPoolEntry *buf = opaque;
     AVBufferPool *pool = buf->pool;
 
-    if(CONFIG_MEMORY_POISONING)
-        memset(buf->data, FF_MEMORY_POISON, pool->size);
-
     ff_mutex_lock(&pool->mutex);
     buf->next = pool->pool;
     pool->pool = buf;
diff --git a/libavutil/frame.c b/libavutil/frame.c
index 4c16488..de4ad1f 100644
--- a/libavutil/frame.c
+++ b/libavutil/frame.c
@@ -59,7 +59,12 @@ static void get_frame_defaults(AVFrame *frame)
     frame->pts                   =
     frame->pkt_dts               = AV_NOPTS_VALUE;
     frame->best_effort_timestamp = AV_NOPTS_VALUE;
+    frame->duration            = 0;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
     frame->pkt_duration        = 0;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     frame->pkt_pos             = -1;
     frame->pkt_size            = -1;
     frame->time_base           = (AVRational){ 0, 1 };
@@ -283,6 +288,7 @@ static int frame_copy_props(AVFrame *dst, const AVFrame *src, int force_copy)
     dst->crop_left              = src->crop_left;
     dst->crop_right             = src->crop_right;
     dst->pts                    = src->pts;
+    dst->duration               = src->duration;
     dst->repeat_pict            = src->repeat_pict;
     dst->interlaced_frame       = src->interlaced_frame;
     dst->top_field_first        = src->top_field_first;
@@ -292,7 +298,11 @@ static int frame_copy_props(AVFrame *dst, const AVFrame *src, int force_copy)
     dst->pkt_dts                = src->pkt_dts;
     dst->pkt_pos                = src->pkt_pos;
     dst->pkt_size               = src->pkt_size;
+#if FF_API_PKT_DURATION
+FF_DISABLE_DEPRECATION_WARNINGS
     dst->pkt_duration           = src->pkt_duration;
+FF_ENABLE_DEPRECATION_WARNINGS
+#endif
     dst->time_base              = src->time_base;
     dst->reordered_opaque       = src->reordered_opaque;
     dst->quality                = src->quality;
@@ -542,9 +552,6 @@ int av_frame_make_writable(AVFrame *frame)
     AVFrame tmp;
     int ret;
 
-    if (!frame->buf[0])
-        return AVERROR(EINVAL);
-
     if (av_frame_is_writable(frame))
         return 0;
 
diff --git a/libavutil/frame.h b/libavutil/frame.h
index 33fac20..6d9563b 100644
--- a/libavutil/frame.h
+++ b/libavutil/frame.h
@@ -604,13 +604,18 @@ typedef struct AVFrame {
      */
     int64_t pkt_pos;
 
+#if FF_API_PKT_DURATION
     /**
      * duration of the corresponding packet, expressed in
      * AVStream->time_base units, 0 if unknown.
      * - encoding: unused
      * - decoding: Read by user.
+     *
+     * @deprecated use duration instead
      */
+    attribute_deprecated
     int64_t pkt_duration;
+#endif
 
     /**
      * metadata.
@@ -702,6 +707,11 @@ typedef struct AVFrame {
      * Channel layout of the audio data.
      */
     AVChannelLayout ch_layout;
+
+    /**
+     * Duration of the frame, in the same units as pts. 0 if unknown.
+     */
+    int64_t duration;
 } AVFrame;
 
 
@@ -818,7 +828,8 @@ int av_frame_is_writable(AVFrame *frame);
  * Ensure that the frame data is writable, avoiding data copy if possible.
  *
  * Do nothing if the frame is writable, allocate new buffers and copy the data
- * if it is not.
+ * if it is not. Non-refcounted frames behave as non-writable, i.e. a copy
+ * is always made.
  *
  * @return 0 on success, a negative AVERROR on error.
  *
diff --git a/libavutil/hwcontext_d3d11va.c b/libavutil/hwcontext_d3d11va.c
index 1bc8b6c..363ec6a 100644
--- a/libavutil/hwcontext_d3d11va.c
+++ b/libavutil/hwcontext_d3d11va.c
@@ -86,6 +86,9 @@ static const struct {
 } supported_formats[] = {
     { DXGI_FORMAT_NV12,         AV_PIX_FMT_NV12 },
     { DXGI_FORMAT_P010,         AV_PIX_FMT_P010 },
+    { DXGI_FORMAT_B8G8R8A8_UNORM,    AV_PIX_FMT_BGRA },
+    { DXGI_FORMAT_R10G10B10A2_UNORM, AV_PIX_FMT_X2BGR10 },
+    { DXGI_FORMAT_R16G16B16A16_FLOAT, AV_PIX_FMT_RGBAF16 },
     // Special opaque formats. The pix_fmt is merely a place holder, as the
     // opaque format cannot be accessed directly.
     { DXGI_FORMAT_420_OPAQUE,   AV_PIX_FMT_YUV420P },
@@ -287,6 +290,10 @@ static int d3d11va_frames_init(AVHWFramesContext *ctx)
             av_log(ctx, AV_LOG_ERROR, "User-provided texture has mismatching parameters\n");
             return AVERROR(EINVAL);
         }
+
+        ctx->initial_pool_size = texDesc2.ArraySize;
+        hwctx->BindFlags = texDesc2.BindFlags;
+        hwctx->MiscFlags = texDesc2.MiscFlags;
     } else if (!(texDesc.BindFlags & D3D11_BIND_RENDER_TARGET) && texDesc.ArraySize > 0) {
         hr = ID3D11Device_CreateTexture2D(device_hwctx->device, &texDesc, NULL, &hwctx->texture);
         if (FAILED(hr)) {
@@ -408,6 +415,7 @@ static int d3d11va_transfer_data(AVHWFramesContext *ctx, AVFrame *dst,
     D3D11_TEXTURE2D_DESC desc;
     D3D11_MAPPED_SUBRESOURCE map;
     HRESULT hr;
+    int res;
 
     if (frame->hw_frames_ctx->data != (uint8_t *)ctx || other->format != ctx->sw_format)
         return AVERROR(EINVAL);
@@ -416,7 +424,7 @@ static int d3d11va_transfer_data(AVHWFramesContext *ctx, AVFrame *dst,
 
     if (!s->staging_texture) {
         ID3D11Texture2D_GetDesc((ID3D11Texture2D *)texture, &desc);
-        int res = d3d11va_create_staging_texture(ctx, desc.Format);
+        res = d3d11va_create_staging_texture(ctx, desc.Format);
         if (res < 0)
             return res;
     }
diff --git a/libavutil/hwcontext_opencl.c b/libavutil/hwcontext_opencl.c
index 32aec7d..247834a 100644
--- a/libavutil/hwcontext_opencl.c
+++ b/libavutil/hwcontext_opencl.c
@@ -47,7 +47,7 @@
 
 #if HAVE_OPENCL_VAAPI_INTEL_MEDIA
 #if CONFIG_LIBMFX
-#include <mfx/mfxstructures.h>
+#include <mfxstructures.h>
 #endif
 #include <va/va.h>
 #include <CL/cl_va_api_media_sharing_intel.h>
diff --git a/libavutil/hwcontext_qsv.c b/libavutil/hwcontext_qsv.c
index 56dffa1..510f422 100644
--- a/libavutil/hwcontext_qsv.c
+++ b/libavutil/hwcontext_qsv.c
@@ -20,7 +20,7 @@
 #include <stdint.h>
 #include <string.h>
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 #include "config.h"
 
@@ -49,12 +49,21 @@
 #include "pixdesc.h"
 #include "time.h"
 #include "imgutils.h"
+#include "avassert.h"
 
 #define QSV_VERSION_ATLEAST(MAJOR, MINOR)   \
     (MFX_VERSION_MAJOR > (MAJOR) ||         \
      MFX_VERSION_MAJOR == (MAJOR) && MFX_VERSION_MINOR >= (MINOR))
 
 #define MFX_IMPL_VIA_MASK(impl) (0x0f00 & (impl))
+#define QSV_ONEVPL       QSV_VERSION_ATLEAST(2, 0)
+#define QSV_HAVE_OPAQUE  !QSV_ONEVPL
+
+#if QSV_ONEVPL
+#include <mfxdispatcher.h>
+#else
+#define MFXUnload(a) do { } while(0)
+#endif
 
 typedef struct QSVDevicePriv {
     AVBufferRef *child_device_ctx;
@@ -86,11 +95,13 @@ typedef struct QSVFramesContext {
 
     // used in the frame allocator for non-opaque surfaces
     mfxMemId *mem_ids;
+#if QSV_HAVE_OPAQUE
     // used in the opaque alloc request for opaque surfaces
     mfxFrameSurface1 **surface_ptrs;
 
     mfxExtOpaqueSurfaceAlloc opaque_alloc;
     mfxExtBuffer *ext_buffers[1];
+#endif
     AVFrame realigned_upload_frame;
     AVFrame realigned_download_frame;
 } QSVFramesContext;
@@ -299,7 +310,9 @@ static void qsv_frames_uninit(AVHWFramesContext *ctx)
 #endif
 
     av_freep(&s->mem_ids);
+#if QSV_HAVE_OPAQUE
     av_freep(&s->surface_ptrs);
+#endif
     av_freep(&s->surfaces_internal);
     av_freep(&s->handle_pairs_internal);
     av_frame_unref(&s->realigned_upload_frame);
@@ -535,11 +548,17 @@ static int qsv_init_pool(AVHWFramesContext *ctx, uint32_t fourcc)
             return ret;
     }
 
+#if QSV_HAVE_OPAQUE
     if (!(frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME)) {
         ret = qsv_init_child_ctx(ctx);
         if (ret < 0)
             return ret;
     }
+#else
+    ret = qsv_init_child_ctx(ctx);
+    if (ret < 0)
+        return ret;
+#endif
 
     ctx->internal->pool_internal = av_buffer_pool_init2(sizeof(mfxFrameSurface1),
                                                         ctx, qsv_pool_alloc, NULL);
@@ -607,13 +626,443 @@ static mfxStatus frame_get_hdl(mfxHDL pthis, mfxMemId mid, mfxHDL *hdl)
     return MFX_ERR_NONE;
 }
 
+#if QSV_ONEVPL
+
+static int qsv_d3d11_update_config(void *ctx, mfxHDL handle, mfxConfig cfg)
+{
+#if CONFIG_D3D11VA
+    mfxStatus sts;
+    IDXGIAdapter *pDXGIAdapter;
+    DXGI_ADAPTER_DESC adapterDesc;
+    IDXGIDevice *pDXGIDevice = NULL;
+    HRESULT hr;
+    ID3D11Device *device = handle;
+    mfxVariant impl_value;
+
+    hr = ID3D11Device_QueryInterface(device, &IID_IDXGIDevice, (void**)&pDXGIDevice);
+    if (SUCCEEDED(hr)) {
+        hr = IDXGIDevice_GetAdapter(pDXGIDevice, &pDXGIAdapter);
+        if (FAILED(hr)) {
+            av_log(ctx, AV_LOG_ERROR, "Error IDXGIDevice_GetAdapter %d\n", hr);
+            goto fail;
+        }
+
+        hr = IDXGIAdapter_GetDesc(pDXGIAdapter, &adapterDesc);
+        if (FAILED(hr)) {
+            av_log(ctx, AV_LOG_ERROR, "Error IDXGIAdapter_GetDesc %d\n", hr);
+            goto fail;
+        }
+    } else {
+        av_log(ctx, AV_LOG_ERROR, "Error ID3D11Device_QueryInterface %d\n", hr);
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U16;
+    impl_value.Data.U16 = adapterDesc.DeviceId;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxExtendedDeviceId.DeviceID", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration"
+               "DeviceID property: %d.\n", sts);
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_PTR;
+    impl_value.Data.Ptr = &adapterDesc.AdapterLuid;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxExtendedDeviceId.DeviceLUID", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration"
+               "DeviceLUID property: %d.\n", sts);
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U32;
+    impl_value.Data.U32 = 0x0001;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxExtendedDeviceId.LUIDDeviceNodeMask", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration"
+               "LUIDDeviceNodeMask property: %d.\n", sts);
+        goto fail;
+    }
+
+    return 0;
+
+fail:
+#endif
+    return AVERROR_UNKNOWN;
+}
+
+static int qsv_d3d9_update_config(void *ctx, mfxHDL handle, mfxConfig cfg)
+{
+    int ret = AVERROR_UNKNOWN;
+#if CONFIG_DXVA2
+    mfxStatus sts;
+    IDirect3DDeviceManager9* devmgr = handle;
+    IDirect3DDevice9Ex *device = NULL;
+    HANDLE device_handle = 0;
+    IDirect3D9Ex *d3d9ex = NULL;
+    LUID luid;
+    D3DDEVICE_CREATION_PARAMETERS params;
+    HRESULT hr;
+    mfxVariant impl_value;
+
+    hr = IDirect3DDeviceManager9_OpenDeviceHandle(devmgr, &device_handle);
+    if (FAILED(hr)) {
+        av_log(ctx, AV_LOG_ERROR, "Error OpenDeviceHandle %d\n", hr);
+        goto fail;
+    }
+
+    hr = IDirect3DDeviceManager9_LockDevice(devmgr, device_handle, &device, TRUE);
+    if (FAILED(hr)) {
+        av_log(ctx, AV_LOG_ERROR, "Error LockDevice %d\n", hr);
+        goto fail;
+    }
+
+    hr = IDirect3DDevice9Ex_GetCreationParameters(device, &params);
+    if (FAILED(hr)) {
+        av_log(ctx, AV_LOG_ERROR, "Error IDirect3DDevice9_GetCreationParameters %d\n", hr);
+        goto unlock;
+    }
+
+    hr = IDirect3DDevice9Ex_GetDirect3D(device, &d3d9ex);
+    if (FAILED(hr)) {
+        av_log(ctx, AV_LOG_ERROR, "Error IDirect3DDevice9Ex_GetAdapterLUID %d\n", hr);
+        goto unlock;
+    }
+
+    hr = IDirect3D9Ex_GetAdapterLUID(d3d9ex, params.AdapterOrdinal, &luid);
+    if (FAILED(hr)) {
+        av_log(ctx, AV_LOG_ERROR, "Error IDirect3DDevice9Ex_GetAdapterLUID %d\n", hr);
+        goto unlock;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_PTR;
+    impl_value.Data.Ptr = &luid;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxExtendedDeviceId.DeviceLUID", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration"
+               "DeviceLUID property: %d.\n", sts);
+        goto unlock;
+    }
+
+    ret = 0;
+
+unlock:
+    IDirect3DDeviceManager9_UnlockDevice(devmgr, device_handle, FALSE);
+fail:
+#endif
+    return ret;
+}
+
+static int qsv_va_update_config(void *ctx, mfxHDL handle, mfxConfig cfg)
+{
+#if CONFIG_VAAPI
+#if VA_CHECK_VERSION(1, 15, 0)
+    mfxStatus sts;
+    VADisplay dpy = handle;
+    VAStatus vas;
+    VADisplayAttribute attr = {
+        .type = VADisplayPCIID,
+    };
+    mfxVariant impl_value;
+
+    vas = vaGetDisplayAttributes(dpy, &attr, 1);
+    if (vas == VA_STATUS_SUCCESS && attr.flags != VA_DISPLAY_ATTRIB_NOT_SUPPORTED) {
+        impl_value.Type = MFX_VARIANT_TYPE_U16;
+        impl_value.Data.U16 = (attr.value & 0xFFFF);
+        sts = MFXSetConfigFilterProperty(cfg,
+                                         (const mfxU8 *)"mfxExtendedDeviceId.DeviceID", impl_value);
+        if (sts != MFX_ERR_NONE) {
+            av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration"
+                   "DeviceID property: %d.\n", sts);
+            goto fail;
+        }
+    } else {
+        av_log(ctx, AV_LOG_ERROR, "libva: Failed to get device id from the driver. Please "
+               "consider to upgrade the driver to support VA-API 1.15.0\n");
+        goto fail;
+    }
+
+    return 0;
+
+fail:
+#else
+    av_log(ctx, AV_LOG_ERROR, "libva: This version of libva doesn't support retrieving "
+           "the device information from the driver. Please consider to upgrade libva to "
+           "support VA-API 1.15.0\n");
+#endif
+#endif
+    return AVERROR_UNKNOWN;
+}
+
+static int qsv_new_mfx_loader(void *ctx,
+                              mfxHDL handle,
+                              mfxHandleType handle_type,
+                              mfxIMPL implementation,
+                              mfxVersion *pver,
+                              void **ploader)
+{
+    mfxStatus sts;
+    mfxLoader loader = NULL;
+    mfxConfig cfg;
+    mfxVariant impl_value;
+
+    *ploader = NULL;
+    loader = MFXLoad();
+    if (!loader) {
+        av_log(ctx, AV_LOG_ERROR, "Error creating a MFX loader\n");
+        goto fail;
+    }
+
+    /* Create configurations for implementation */
+    cfg = MFXCreateConfig(loader);
+    if (!cfg) {
+        av_log(ctx, AV_LOG_ERROR, "Error creating a MFX configuration\n");
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U32;
+    impl_value.Data.U32 = (implementation == MFX_IMPL_SOFTWARE) ?
+        MFX_IMPL_TYPE_SOFTWARE : MFX_IMPL_TYPE_HARDWARE;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxImplDescription.Impl", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration "
+               "property: %d.\n", sts);
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U32;
+    impl_value.Data.U32 = pver->Version;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxImplDescription.ApiVersion.Version",
+                                     impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration "
+               "property: %d.\n", sts);
+        goto fail;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U16;
+    impl_value.Data.U16 = 0x8086; // Intel device only
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxExtendedDeviceId.VendorID", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration"
+               "VendorID property: %d.\n", sts);
+        goto fail;
+    }
+
+    if (MFX_HANDLE_VA_DISPLAY == handle_type) {
+        if (handle && qsv_va_update_config(ctx, handle, cfg))
+            goto fail;
+
+        impl_value.Data.U32 = MFX_ACCEL_MODE_VIA_VAAPI;
+    } else if (MFX_HANDLE_D3D9_DEVICE_MANAGER == handle_type) {
+        if (handle && qsv_d3d9_update_config(ctx, handle, cfg))
+            goto fail;
+
+        impl_value.Data.U32 = MFX_ACCEL_MODE_VIA_D3D9;
+    } else {
+        if (handle && qsv_d3d11_update_config(ctx, handle, cfg))
+            goto fail;
+
+        impl_value.Data.U32 = MFX_ACCEL_MODE_VIA_D3D11;
+    }
+
+    impl_value.Type = MFX_VARIANT_TYPE_U32;
+    sts = MFXSetConfigFilterProperty(cfg,
+                                     (const mfxU8 *)"mfxImplDescription.AccelerationMode", impl_value);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error adding a MFX configuration"
+               "AccelerationMode property: %d.\n", sts);
+        goto fail;
+    }
+
+    *ploader = loader;
+
+    return 0;
+
+fail:
+    if (loader)
+        MFXUnload(loader);
+
+    return AVERROR_UNKNOWN;
+}
+
+static int qsv_create_mfx_session_from_loader(void *ctx, mfxLoader loader, mfxSession *psession)
+{
+    mfxStatus sts;
+    mfxSession session = NULL;
+    uint32_t impl_idx = 0;
+    mfxVersion ver;
+
+    while (1) {
+        /* Enumerate all implementations */
+        mfxImplDescription *impl_desc;
+
+        sts = MFXEnumImplementations(loader, impl_idx,
+                                     MFX_IMPLCAPS_IMPLDESCSTRUCTURE,
+                                     (mfxHDL *)&impl_desc);
+        /* Failed to find an available implementation */
+        if (sts == MFX_ERR_NOT_FOUND)
+            break;
+        else if (sts != MFX_ERR_NONE) {
+            impl_idx++;
+            continue;
+        }
+
+        sts = MFXCreateSession(loader, impl_idx, &session);
+        MFXDispReleaseImplDescription(loader, impl_desc);
+        if (sts == MFX_ERR_NONE)
+            break;
+
+        impl_idx++;
+    }
+
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error creating a MFX session: %d.\n", sts);
+        goto fail;
+    }
+
+    sts = MFXQueryVersion(session, &ver);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error querying a MFX session: %d.\n", sts);
+        goto fail;
+    }
+
+    av_log(ctx, AV_LOG_VERBOSE, "Initialize MFX session: implementation "
+           "version is %d.%d\n", ver.Major, ver.Minor);
+
+    *psession = session;
+
+    return 0;
+
+fail:
+    if (session)
+        MFXClose(session);
+
+    return AVERROR_UNKNOWN;
+}
+
+static int qsv_create_mfx_session(void *ctx,
+                                  mfxHDL handle,
+                                  mfxHandleType handle_type,
+                                  mfxIMPL implementation,
+                                  mfxVersion *pver,
+                                  mfxSession *psession,
+                                  void **ploader)
+{
+    mfxLoader loader = NULL;
+
+    av_log(ctx, AV_LOG_VERBOSE,
+           "Use Intel(R) oneVPL to create MFX session, API version is "
+           "%d.%d, the required implementation version is %d.%d\n",
+           MFX_VERSION_MAJOR, MFX_VERSION_MINOR, pver->Major, pver->Minor);
+
+    if (handle_type != MFX_HANDLE_VA_DISPLAY &&
+        handle_type != MFX_HANDLE_D3D9_DEVICE_MANAGER &&
+        handle_type != MFX_HANDLE_D3D11_DEVICE) {
+        av_log(ctx, AV_LOG_ERROR,
+               "Invalid MFX device handle type\n");
+        return AVERROR(EXDEV);
+    }
+
+    *psession = NULL;
+
+    if (!*ploader) {
+        if (qsv_new_mfx_loader(ctx, handle, handle_type, implementation, pver, (void **)&loader))
+            goto fail;
+
+        av_assert0(loader);
+    } else
+        loader = *ploader;      // Use the input mfxLoader to create mfx session
+
+    if (qsv_create_mfx_session_from_loader(ctx, loader, psession))
+        goto fail;
+
+    if (!*ploader)
+        *ploader = loader;
+
+    return 0;
+
+fail:
+    if (!*ploader && loader)
+        MFXUnload(loader);
+
+    return AVERROR_UNKNOWN;
+}
+
+#else
+
+static int qsv_create_mfx_session(void *ctx,
+                                  mfxHDL handle,
+                                  mfxHandleType handle_type,
+                                  mfxIMPL implementation,
+                                  mfxVersion *pver,
+                                  mfxSession *psession,
+                                  void **ploader)
+{
+    mfxVersion ver;
+    mfxStatus sts;
+    mfxSession session = NULL;
+
+    av_log(ctx, AV_LOG_VERBOSE,
+           "Use Intel(R) Media SDK to create MFX session, API version is "
+           "%d.%d, the required implementation version is %d.%d\n",
+           MFX_VERSION_MAJOR, MFX_VERSION_MINOR, pver->Major, pver->Minor);
+
+    *ploader = NULL;
+    *psession = NULL;
+    ver = *pver;
+    sts = MFXInit(implementation, &ver, &session);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error initializing an MFX session: "
+               "%d.\n", sts);
+        goto fail;
+    }
+
+    sts = MFXQueryVersion(session, &ver);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error querying an MFX session: "
+               "%d.\n", sts);
+        goto fail;
+    }
+
+    av_log(ctx, AV_LOG_VERBOSE, "Initialize MFX session: implementation "
+           "version is %d.%d\n", ver.Major, ver.Minor);
+
+    MFXClose(session);
+
+    sts = MFXInit(implementation, &ver, &session);
+    if (sts != MFX_ERR_NONE) {
+        av_log(ctx, AV_LOG_ERROR, "Error initializing an MFX session: "
+               "%d.\n", sts);
+        goto fail;
+    }
+
+    *psession = session;
+
+    return 0;
+
+fail:
+    if (session)
+        MFXClose(session);
+
+    return AVERROR_UNKNOWN;
+}
+
+#endif
+
 static int qsv_init_internal_session(AVHWFramesContext *ctx,
                                      mfxSession *session, int upload)
 {
-    QSVFramesContext              *s = ctx->internal->priv;
     AVQSVFramesContext *frames_hwctx = ctx->hwctx;
     QSVDeviceContext   *device_priv  = ctx->device_ctx->internal->priv;
-    int opaque = !!(frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
+    int opaque = 0;
 
     mfxFrameAllocator frame_allocator = {
         .pthis  = ctx,
@@ -626,37 +1075,52 @@ static int qsv_init_internal_session(AVHWFramesContext *ctx,
 
     mfxVideoParam par;
     mfxStatus err;
+    int                   ret = AVERROR_UNKNOWN;
+    AVQSVDeviceContext *hwctx = ctx->device_ctx->hwctx;
+    /* hwctx->loader is non-NULL for oneVPL user and NULL for non-oneVPL user */
+    void             **loader = &hwctx->loader;
 
-    err = MFXInit(device_priv->impl, &device_priv->ver, session);
-    if (err != MFX_ERR_NONE) {
-        av_log(ctx, AV_LOG_ERROR, "Error initializing an internal session\n");
-        return AVERROR_UNKNOWN;
-    }
+#if QSV_HAVE_OPAQUE
+    QSVFramesContext              *s = ctx->internal->priv;
+    opaque = !!(frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
+#endif
+
+    ret = qsv_create_mfx_session(ctx, device_priv->handle, device_priv->handle_type,
+                                 device_priv->impl, &device_priv->ver, session, loader);
+    if (ret)
+        goto fail;
 
     if (device_priv->handle) {
         err = MFXVideoCORE_SetHandle(*session, device_priv->handle_type,
                                      device_priv->handle);
-        if (err != MFX_ERR_NONE)
-            return AVERROR_UNKNOWN;
+        if (err != MFX_ERR_NONE) {
+            ret = AVERROR_UNKNOWN;
+            goto fail;
+        }
     }
 
     if (!opaque) {
         err = MFXVideoCORE_SetFrameAllocator(*session, &frame_allocator);
-        if (err != MFX_ERR_NONE)
-            return AVERROR_UNKNOWN;
+        if (err != MFX_ERR_NONE) {
+            ret = AVERROR_UNKNOWN;
+            goto fail;
+        }
     }
 
     memset(&par, 0, sizeof(par));
 
-    if (opaque) {
+    if (!opaque) {
+        par.IOPattern = upload ? MFX_IOPATTERN_OUT_VIDEO_MEMORY :
+                                 MFX_IOPATTERN_IN_VIDEO_MEMORY;
+    }
+#if QSV_HAVE_OPAQUE
+    else {
         par.ExtParam    = s->ext_buffers;
         par.NumExtParam = FF_ARRAY_ELEMS(s->ext_buffers);
         par.IOPattern   = upload ? MFX_IOPATTERN_OUT_OPAQUE_MEMORY :
                                    MFX_IOPATTERN_IN_OPAQUE_MEMORY;
-    } else {
-        par.IOPattern = upload ? MFX_IOPATTERN_OUT_VIDEO_MEMORY :
-                                 MFX_IOPATTERN_IN_VIDEO_MEMORY;
     }
+#endif
 
     par.IOPattern |= upload ? MFX_IOPATTERN_IN_SYSTEM_MEMORY :
                               MFX_IOPATTERN_OUT_SYSTEM_MEMORY;
@@ -676,11 +1140,20 @@ static int qsv_init_internal_session(AVHWFramesContext *ctx,
     if (err != MFX_ERR_NONE) {
         av_log(ctx, AV_LOG_VERBOSE, "Error opening the internal VPP session."
                "Surface upload/download will not be possible\n");
-        MFXClose(*session);
-        *session = NULL;
+
+        ret = AVERROR_UNKNOWN;
+        goto fail;
     }
 
     return 0;
+
+fail:
+    if (*session)
+        MFXClose(*session);
+
+    *session = NULL;
+
+    return ret;
 }
 
 static int qsv_frames_init(AVHWFramesContext *ctx)
@@ -688,11 +1161,15 @@ static int qsv_frames_init(AVHWFramesContext *ctx)
     QSVFramesContext              *s = ctx->internal->priv;
     AVQSVFramesContext *frames_hwctx = ctx->hwctx;
 
-    int opaque = !!(frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
+    int opaque = 0;
 
     uint32_t fourcc;
     int i, ret;
 
+#if QSV_HAVE_OPAQUE
+    opaque = !!(frames_hwctx->frame_type & MFX_MEMTYPE_OPAQUE_FRAME);
+#endif
+
     fourcc = qsv_fourcc_from_pix_fmt(ctx->sw_format);
     if (!fourcc) {
         av_log(ctx, AV_LOG_ERROR, "Unsupported pixel format\n");
@@ -707,7 +1184,16 @@ static int qsv_frames_init(AVHWFramesContext *ctx)
         }
     }
 
-    if (opaque) {
+    if (!opaque) {
+        s->mem_ids = av_calloc(frames_hwctx->nb_surfaces, sizeof(*s->mem_ids));
+        if (!s->mem_ids)
+            return AVERROR(ENOMEM);
+
+        for (i = 0; i < frames_hwctx->nb_surfaces; i++)
+            s->mem_ids[i] = frames_hwctx->surfaces[i].Data.MemId;
+    }
+#if QSV_HAVE_OPAQUE
+    else {
         s->surface_ptrs = av_calloc(frames_hwctx->nb_surfaces,
                                     sizeof(*s->surface_ptrs));
         if (!s->surface_ptrs)
@@ -726,14 +1212,8 @@ static int qsv_frames_init(AVHWFramesContext *ctx)
         s->opaque_alloc.Header.BufferSz = sizeof(s->opaque_alloc);
 
         s->ext_buffers[0] = (mfxExtBuffer*)&s->opaque_alloc;
-    } else {
-        s->mem_ids = av_calloc(frames_hwctx->nb_surfaces, sizeof(*s->mem_ids));
-        if (!s->mem_ids)
-            return AVERROR(ENOMEM);
-
-        for (i = 0; i < frames_hwctx->nb_surfaces; i++)
-            s->mem_ids[i] = frames_hwctx->surfaces[i].Data.MemId;
     }
+#endif
 
     s->session_download = NULL;
     s->session_upload   = NULL;
@@ -1430,6 +1910,8 @@ static void qsv_device_free(AVHWDeviceContext *ctx)
     if (hwctx->session)
         MFXClose(hwctx->session);
 
+    if (hwctx->loader)
+        MFXUnload(hwctx->loader);
     av_buffer_unref(&priv->child_device_ctx);
     av_freep(&priv);
 }
@@ -1519,34 +2001,10 @@ static int qsv_device_derive_from_child(AVHWDeviceContext *ctx,
         goto fail;
     }
 
-    err = MFXInit(implementation, &ver, &hwctx->session);
-    if (err != MFX_ERR_NONE) {
-        av_log(ctx, AV_LOG_ERROR, "Error initializing an MFX session: "
-               "%d.\n", err);
-        ret = AVERROR_UNKNOWN;
+    ret = qsv_create_mfx_session(ctx, handle, handle_type, implementation, &ver,
+                                 &hwctx->session, &hwctx->loader);
+    if (ret)
         goto fail;
-    }
-
-    err = MFXQueryVersion(hwctx->session, &ver);
-    if (err != MFX_ERR_NONE) {
-        av_log(ctx, AV_LOG_ERROR, "Error querying an MFX session: %d.\n", err);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
-
-    av_log(ctx, AV_LOG_VERBOSE,
-           "Initialize MFX session: API version is %d.%d, implementation version is %d.%d\n",
-           MFX_VERSION_MAJOR, MFX_VERSION_MINOR, ver.Major, ver.Minor);
-
-    MFXClose(hwctx->session);
-
-    err = MFXInit(implementation, &ver, &hwctx->session);
-    if (err != MFX_ERR_NONE) {
-        av_log(ctx, AV_LOG_ERROR,
-               "Error initializing an MFX session: %d.\n", err);
-        ret = AVERROR_UNKNOWN;
-        goto fail;
-    }
 
     err = MFXVideoCORE_SetHandle(hwctx->session, handle_type, handle);
     if (err != MFX_ERR_NONE) {
@@ -1561,6 +2019,12 @@ static int qsv_device_derive_from_child(AVHWDeviceContext *ctx,
 fail:
     if (hwctx->session)
         MFXClose(hwctx->session);
+
+    if (hwctx->loader)
+        MFXUnload(hwctx->loader);
+
+    hwctx->session = NULL;
+    hwctx->loader = NULL;
     return ret;
 }
 
@@ -1603,6 +2067,16 @@ static int qsv_device_create(AVHWDeviceContext *ctx, const char *device,
         }
     } else if (CONFIG_VAAPI) {
         child_device_type = AV_HWDEVICE_TYPE_VAAPI;
+#if QSV_ONEVPL
+    } else if (CONFIG_D3D11VA) {  // Use D3D11 by default if d3d11va is enabled
+        av_log(ctx, AV_LOG_VERBOSE,
+               "Defaulting child_device_type to AV_HWDEVICE_TYPE_D3D11VA for oneVPL."
+               "Please explicitly set child device type via \"-init_hw_device\" "
+               "option if needed.\n");
+        child_device_type = AV_HWDEVICE_TYPE_D3D11VA;
+    } else if (CONFIG_DXVA2) {
+        child_device_type = AV_HWDEVICE_TYPE_DXVA2;
+#else
     } else if (CONFIG_DXVA2) {
         av_log(NULL, AV_LOG_WARNING,
                 "WARNING: defaulting child_device_type to AV_HWDEVICE_TYPE_DXVA2 for compatibility "
@@ -1611,6 +2085,7 @@ static int qsv_device_create(AVHWDeviceContext *ctx, const char *device,
         child_device_type = AV_HWDEVICE_TYPE_DXVA2;
     } else if (CONFIG_D3D11VA) {
         child_device_type = AV_HWDEVICE_TYPE_D3D11VA;
+#endif
     } else {
         av_log(ctx, AV_LOG_ERROR, "No supported child device type is enabled\n");
         return AVERROR(ENOSYS);
@@ -1637,6 +2112,13 @@ static int qsv_device_create(AVHWDeviceContext *ctx, const char *device,
 #endif
 #if CONFIG_DXVA2
     case AV_HWDEVICE_TYPE_DXVA2:
+#if QSV_ONEVPL
+        {
+            av_log(ctx, AV_LOG_VERBOSE,
+                   "d3d11va is not available or child device type is set to dxva2 "
+                   "explicitly for oneVPL.\n");
+        }
+#endif
         break;
 #endif
     default:
diff --git a/libavutil/hwcontext_qsv.h b/libavutil/hwcontext_qsv.h
index b98d611..e2dba8a 100644
--- a/libavutil/hwcontext_qsv.h
+++ b/libavutil/hwcontext_qsv.h
@@ -19,7 +19,7 @@
 #ifndef AVUTIL_HWCONTEXT_QSV_H
 #define AVUTIL_HWCONTEXT_QSV_H
 
-#include <mfx/mfxvideo.h>
+#include <mfxvideo.h>
 
 /**
  * @file
@@ -34,6 +34,17 @@
  */
 typedef struct AVQSVDeviceContext {
     mfxSession session;
+    /**
+     * The mfxLoader handle used for mfxSession creation
+     *
+     * This field is only available for oneVPL user. For non-oneVPL user, this
+     * field must be set to NULL.
+     *
+     * Filled by the user before calling av_hwdevice_ctx_init() and should be
+     * cast to mfxLoader handle. Deallocating the AVHWDeviceContext will always
+     * release this interface.
+     */
+    void *loader;
 } AVQSVDeviceContext;
 
 /**
diff --git a/libavutil/hwcontext_vaapi.c b/libavutil/hwcontext_vaapi.c
index c3a98bc..2ee5145 100644
--- a/libavutil/hwcontext_vaapi.c
+++ b/libavutil/hwcontext_vaapi.c
@@ -125,6 +125,7 @@ static const VAAPIFormatDescriptor vaapi_format_map[] = {
     MAP(411P, YUV411,  YUV411P, 0),
     MAP(422V, YUV422,  YUV440P, 0),
     MAP(444P, YUV444,  YUV444P, 0),
+    MAP(AYUV, YUV444,  VUYA,    0),
     MAP(Y800, YUV400,  GRAY8,   0),
 #ifdef VA_FOURCC_P010
     MAP(P010, YUV420_10BPP, P010, 0),
diff --git a/libavutil/hwcontext_videotoolbox.h b/libavutil/hwcontext_videotoolbox.h
index b6bdcf2..25dde85 100644
--- a/libavutil/hwcontext_videotoolbox.h
+++ b/libavutil/hwcontext_videotoolbox.h
@@ -23,6 +23,7 @@
 
 #include <VideoToolbox/VideoToolbox.h>
 
+#include "frame.h"
 #include "pixfmt.h"
 
 /**
diff --git a/libavutil/loongarch/loongson_intrinsics.h b/libavutil/loongarch/loongson_intrinsics.h
index eb25686..6425551 100644
--- a/libavutil/loongarch/loongson_intrinsics.h
+++ b/libavutil/loongarch/loongson_intrinsics.h
@@ -89,6 +89,11 @@
 
 #ifdef __loongarch_sx
 #include <lsxintrin.h>
+
+/* __lsx_vldx() from lsxintrin.h does not accept a const void*;
+ * remove the following once it does. */
+#define LSX_VLDX(cptr, stride) __lsx_vldx((void*)(cptr), (stride))
+
 /*
  * =============================================================================
  * Description : Dot product & addition of byte vector elements
@@ -716,6 +721,11 @@ static inline __m128i __lsx_vclip255_w(__m128i _in) {
 
 #ifdef __loongarch_asx
 #include <lasxintrin.h>
+
+/* __lasx_xvldx() in lasxintrin.h does not accept a const void*;
+ * remove the following once it does. */
+#define LASX_XVLDX(ptr, stride) __lasx_xvldx((void*)ptr, stride)
+
 /*
  * =============================================================================
  * Description : Dot product of byte vector elements
diff --git a/libavutil/opt.c b/libavutil/opt.c
index 8ffb104..a3940f4 100644
--- a/libavutil/opt.c
+++ b/libavutil/opt.c
@@ -1329,17 +1329,18 @@ FF_ENABLE_DEPRECATION_WARNINGS
                 av_log(av_log_obj, AV_LOG_INFO, "%-12s ", "");
                 break;
         }
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_ENCODING_PARAM) ? 'E' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_DECODING_PARAM) ? 'D' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_FILTERING_PARAM)? 'F' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_VIDEO_PARAM   ) ? 'V' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_AUDIO_PARAM   ) ? 'A' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_SUBTITLE_PARAM) ? 'S' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_EXPORT)         ? 'X' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_READONLY)       ? 'R' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_BSF_PARAM)      ? 'B' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_RUNTIME_PARAM)  ? 'T' : '.');
-        av_log(av_log_obj, AV_LOG_INFO, "%c", (opt->flags & AV_OPT_FLAG_DEPRECATED)     ? 'P' : '.');
+        av_log(av_log_obj, AV_LOG_INFO, "%c%c%c%c%c%c%c%c%c%c%c",
+               (opt->flags & AV_OPT_FLAG_ENCODING_PARAM)  ? 'E' : '.',
+               (opt->flags & AV_OPT_FLAG_DECODING_PARAM)  ? 'D' : '.',
+               (opt->flags & AV_OPT_FLAG_FILTERING_PARAM) ? 'F' : '.',
+               (opt->flags & AV_OPT_FLAG_VIDEO_PARAM)     ? 'V' : '.',
+               (opt->flags & AV_OPT_FLAG_AUDIO_PARAM)     ? 'A' : '.',
+               (opt->flags & AV_OPT_FLAG_SUBTITLE_PARAM)  ? 'S' : '.',
+               (opt->flags & AV_OPT_FLAG_EXPORT)          ? 'X' : '.',
+               (opt->flags & AV_OPT_FLAG_READONLY)        ? 'R' : '.',
+               (opt->flags & AV_OPT_FLAG_BSF_PARAM)       ? 'B' : '.',
+               (opt->flags & AV_OPT_FLAG_RUNTIME_PARAM)   ? 'T' : '.',
+               (opt->flags & AV_OPT_FLAG_DEPRECATED)      ? 'P' : '.');
 
         if (opt->help)
             av_log(av_log_obj, AV_LOG_INFO, " %s", opt->help);
diff --git a/libavutil/pixdesc.c b/libavutil/pixdesc.c
index 6e57a82..f7558ff 100644
--- a/libavutil/pixdesc.c
+++ b/libavutil/pixdesc.c
@@ -2491,6 +2491,47 @@ static const AVPixFmtDescriptor av_pix_fmt_descriptors[AV_PIX_FMT_NB] = {
         },
         .flags = AV_PIX_FMT_FLAG_PLANAR,
     },
+    [AV_PIX_FMT_VUYA] = {
+        .name = "vuya",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 4, 2, 0, 8 },        /* Y */
+            { 0, 4, 1, 0, 8 },        /* U */
+            { 0, 4, 0, 0, 8 },        /* V */
+            { 0, 4, 3, 0, 8 },        /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_ALPHA,
+    },
+    [AV_PIX_FMT_RGBAF16BE] = {
+        .name = "rgbaf16be",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 8, 0, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 4, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_BE | AV_PIX_FMT_FLAG_RGB |
+                 AV_PIX_FMT_FLAG_ALPHA | AV_PIX_FMT_FLAG_FLOAT,
+    },
+    [AV_PIX_FMT_RGBAF16LE] = {
+        .name = "rgbaf16le",
+        .nb_components = 4,
+        .log2_chroma_w = 0,
+        .log2_chroma_h = 0,
+        .comp = {
+            { 0, 8, 0, 0, 16 },       /* R */
+            { 0, 8, 2, 0, 16 },       /* G */
+            { 0, 8, 4, 0, 16 },       /* B */
+            { 0, 8, 6, 0, 16 },       /* A */
+        },
+        .flags = AV_PIX_FMT_FLAG_RGB | AV_PIX_FMT_FLAG_ALPHA |
+                 AV_PIX_FMT_FLAG_FLOAT,
+    },
 };
 
 static const char * const color_range_names[] = {
diff --git a/libavutil/pixfmt.h b/libavutil/pixfmt.h
index 2d3927c..86c9bde 100644
--- a/libavutil/pixfmt.h
+++ b/libavutil/pixfmt.h
@@ -367,6 +367,11 @@ enum AVPixelFormat {
     AV_PIX_FMT_P416BE,      ///< interleaved chroma YUV 4:4:4, 48bpp, big-endian
     AV_PIX_FMT_P416LE,      ///< interleaved chroma YUV 4:4:4, 48bpp, little-endian
 
+    AV_PIX_FMT_VUYA,        ///< packed VUYA 4:4:4, 32bpp, VUYAVUYA...
+
+    AV_PIX_FMT_RGBAF16BE,   ///< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., big-endian
+    AV_PIX_FMT_RGBAF16LE,   ///< IEEE-754 half precision packed RGBA 16:16:16:16, 64bpp, RGBARGBA..., little-endian
+
     AV_PIX_FMT_NB         ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
 };
 
@@ -464,6 +469,8 @@ enum AVPixelFormat {
 #define AV_PIX_FMT_P216       AV_PIX_FMT_NE(P216BE, P216LE)
 #define AV_PIX_FMT_P416       AV_PIX_FMT_NE(P416BE, P416LE)
 
+#define AV_PIX_FMT_RGBAF16    AV_PIX_FMT_NE(RGBAF16BE, RGBAF16LE)
+
 /**
   * Chromaticity coordinates of the source primaries.
   * These values match the ones defined by ISO/IEC 23091-2_2019 subclause 8.1 and ITU-T H.273.
diff --git a/libavutil/tests/.gitignore b/libavutil/tests/.gitignore
index 8789591..919010e 100644
--- a/libavutil/tests/.gitignore
+++ b/libavutil/tests/.gitignore
@@ -9,7 +9,6 @@
 /bprint
 /camellia
 /cast5
-/channel_layout
 /color_utils
 /cpu
 /cpu_init
diff --git a/libavutil/tests/pixfmt_best.c b/libavutil/tests/pixfmt_best.c
index 53f7264..de53baf 100644
--- a/libavutil/tests/pixfmt_best.c
+++ b/libavutil/tests/pixfmt_best.c
@@ -91,6 +91,7 @@ int main(void)
     TEST(AV_PIX_FMT_YUVA420P,  AV_PIX_FMT_YUV420P);
     TEST(AV_PIX_FMT_YUVA422P,  AV_PIX_FMT_YUV422P);
     TEST(AV_PIX_FMT_YUVA444P,  AV_PIX_FMT_YUV444P);
+    TEST(AV_PIX_FMT_VUYA,      AV_PIX_FMT_YUV444P);
     TEST(AV_PIX_FMT_AYUV64,    AV_PIX_FMT_YUV444P16);
     TEST(AV_PIX_FMT_RGBA,      AV_PIX_FMT_RGB24);
     TEST(AV_PIX_FMT_ABGR,      AV_PIX_FMT_RGB24);
diff --git a/libavutil/tx.c b/libavutil/tx.c
index 4cc3a98..e6fcf9f 100644
--- a/libavutil/tx.c
+++ b/libavutil/tx.c
@@ -44,7 +44,6 @@ int ff_tx_gen_compound_mapping(AVTXContext *s, int n, int m)
     int *in_map, *out_map;
     const int inv = s->inv;
     const int len = n*m;    /* Will not be equal to s->len for MDCTs */
-    const int mdct = TYPE_IS(MDCT, s->type);
     int m_inv, n_inv;
 
     /* Make sure the numbers are coprime */
@@ -63,8 +62,7 @@ int ff_tx_gen_compound_mapping(AVTXContext *s, int n, int m)
     /* Ruritanian map for input, CRT map for output, can be swapped */
     for (int j = 0; j < m; j++) {
         for (int i = 0; i < n; i++) {
-            /* Shifted by 1 to simplify MDCTs */
-            in_map[j*n + i] = ((i*m + j*n) % len) << mdct;
+            in_map[j*n + i] = (i*m + j*n) % len;
             out_map[(i*m*m_inv + j*n*n_inv) % len] = i*m + j;
         }
     }
diff --git a/libavutil/tx_priv.h b/libavutil/tx_priv.h
index c9eda44..e6b0326 100644
--- a/libavutil/tx_priv.h
+++ b/libavutil/tx_priv.h
@@ -297,10 +297,13 @@ void ff_tx_init_tabs_float (int len);
 void ff_tx_init_tabs_double(int len);
 void ff_tx_init_tabs_int32 (int len);
 
-/* Typed init function to initialize an MDCT exptab in a context. */
-int  ff_tx_mdct_gen_exp_float (AVTXContext *s);
-int  ff_tx_mdct_gen_exp_double(AVTXContext *s);
-int  ff_tx_mdct_gen_exp_int32 (AVTXContext *s);
+/* Typed init function to initialize an MDCT exptab in a context.
+ * If pre_tab is set, duplicates the entire table, with the first
+ * copy being shuffled according to pre_tab, and the second copy
+ * being the original. */
+int ff_tx_mdct_gen_exp_float (AVTXContext *s, int *pre_tab);
+int ff_tx_mdct_gen_exp_double(AVTXContext *s, int *pre_tab);
+int ff_tx_mdct_gen_exp_int32 (AVTXContext *s, int *pre_tab);
 
 /* Lists of codelets */
 extern const FFTXCodelet * const ff_tx_codelet_list_float_c       [];
diff --git a/libavutil/tx_template.c b/libavutil/tx_template.c
index 1e43545..35b61fa 100644
--- a/libavutil/tx_template.c
+++ b/libavutil/tx_template.c
@@ -948,7 +948,7 @@ static av_cold int TX_NAME(ff_tx_mdct_sr_init)(AVTXContext *s,
                                                const void *scale)
 {
     int ret;
-    FFTXCodeletOptions sub_opts = { .invert_lookup = 0 };
+    FFTXCodeletOptions sub_opts = { .invert_lookup = inv };
 
     s->scale_d = *((SCALE_TYPE *)scale);
     s->scale_f = s->scale_d;
@@ -961,9 +961,14 @@ static av_cold int TX_NAME(ff_tx_mdct_sr_init)(AVTXContext *s,
                                 inv, scale)))
         return ret;
 
-    if ((ret = TX_TAB(ff_tx_mdct_gen_exp)(s)))
+    if ((ret = TX_TAB(ff_tx_mdct_gen_exp)(s, inv ? s->sub->map : NULL)))
         return ret;
 
+    /* Saves a multiply in a hot path. */
+    if (inv)
+        for (int i = 0; i < (s->len >> 1); i++)
+            s->sub->map[i] <<= 1;
+
     return 0;
 }
 
@@ -1020,12 +1025,14 @@ static void TX_NAME(ff_tx_mdct_sr_inv)(AVTXContext *s, void *_dst, void *_src,
     in2 = src + ((len2*2) - 1) * stride;
 
     for (int i = 0; i < len2; i++) {
-        TXComplex tmp = { in2[-2*i*stride], in1[2*i*stride] };
-        CMUL3(z[sub_map[i]], tmp, exp[i]);
+        int k = sub_map[i];
+        TXComplex tmp = { in2[-k*stride], in1[k*stride] };
+        CMUL3(z[i], tmp, exp[i]);
     }
 
     s->fn[0](&s->sub[0], z, z, sizeof(TXComplex));
 
+    exp += len2;
     for (int i = 0; i < len4; i++) {
         const int i0 = len4 + i, i1 = len4 - i - 1;
         TXComplex src1 = { z[i1].im, z[i1].re };
@@ -1141,9 +1148,13 @@ static av_cold int TX_NAME(ff_tx_mdct_pfa_init)(AVTXContext *s,
     if ((ret = ff_tx_gen_compound_mapping(s, cd->factors[0], sub_len)))
         return ret;
 
-    if ((ret = TX_TAB(ff_tx_mdct_gen_exp)(s)))
+    if ((ret = TX_TAB(ff_tx_mdct_gen_exp)(s, inv ? s->map : NULL)))
         return ret;
 
+    /* Saves multiplies in loops. */
+    for (int i = 0; i < len; i++)
+        s->map[i] <<= 1;
+
     if (!(s->tmp = av_malloc(len*sizeof(*s->tmp))))
         return AVERROR(ENOMEM);
 
@@ -1160,6 +1171,7 @@ static void TX_NAME(ff_tx_mdct_pfa_##N##xM_inv)(AVTXContext *s, void *_dst,    \
     TXComplex *z = _dst, *exp = s->exp;                                        \
     const TXSample *src = _src, *in1, *in2;                                    \
     const int len4 = s->len >> 2;                                              \
+    const int len2 = s->len >> 1;                                              \
     const int m = s->sub->len;                                                 \
     const int *in_map = s->map, *out_map = in_map + N*m;                       \
     const int *sub_map = s->sub->map;                                          \
@@ -1168,13 +1180,15 @@ static void TX_NAME(ff_tx_mdct_pfa_##N##xM_inv)(AVTXContext *s, void *_dst,    \
     in1 = src;                                                                 \
     in2 = src + ((N*m*2) - 1) * stride;                                        \
                                                                                \
-    for (int i = 0; i < m; i++) {                                              \
+    for (int i = 0; i < len2; i += N) {                                        \
         for (int j = 0; j < N; j++) {                                          \
-            const int k = in_map[i*N + j];                                     \
+            const int k = in_map[j];                                           \
             TXComplex tmp = { in2[-k*stride], in1[k*stride] };                 \
-            CMUL3(fft##N##in[j], tmp, exp[k >> 1]);                            \
+            CMUL3(fft##N##in[j], tmp, exp[j]);                                 \
         }                                                                      \
-        fft##N(s->tmp + sub_map[i], fft##N##in, m);                            \
+        fft##N(s->tmp + *(sub_map++), fft##N##in, m);                          \
+        exp += N;                                                              \
+        in_map += N;                                                           \
     }                                                                          \
                                                                                \
     for (int i = 0; i < N; i++)                                                \
@@ -1405,22 +1419,32 @@ static const FFTXCodelet TX_NAME(ff_tx_rdft_c2r_def) = {
     .prio       = FF_TX_PRIO_BASE,
 };
 
-int TX_TAB(ff_tx_mdct_gen_exp)(AVTXContext *s)
+int TX_TAB(ff_tx_mdct_gen_exp)(AVTXContext *s, int *pre_tab)
 {
+    int off = 0;
     int len4 = s->len >> 1;
     double scale = s->scale_d;
     const double theta = (scale < 0 ? len4 : 0) + 1.0/8.0;
+    size_t alloc = pre_tab ? 2*len4 : len4;
 
-    if (!(s->exp = av_malloc_array(len4, sizeof(*s->exp))))
+    if (!(s->exp = av_malloc_array(alloc, sizeof(*s->exp))))
         return AVERROR(ENOMEM);
 
     scale = sqrt(fabs(scale));
+
+    if (pre_tab)
+        off = len4;
+
     for (int i = 0; i < len4; i++) {
         const double alpha = M_PI_2 * (i + theta) / len4;
-        s->exp[i].re = RESCALE(cos(alpha) * scale);
-        s->exp[i].im = RESCALE(sin(alpha) * scale);
+        s->exp[off + i] = (TXComplex){ RESCALE(cos(alpha) * scale),
+                                       RESCALE(sin(alpha) * scale) };
     }
 
+    if (pre_tab)
+        for (int i = 0; i < len4; i++)
+            s->exp[i] = s->exp[len4 + pre_tab[i]];
+
     return 0;
 }
 
diff --git a/libavutil/version.h b/libavutil/version.h
index 87178e9..0566192 100644
--- a/libavutil/version.h
+++ b/libavutil/version.h
@@ -79,8 +79,8 @@
  */
 
 #define LIBAVUTIL_VERSION_MAJOR  57
-#define LIBAVUTIL_VERSION_MINOR  28
-#define LIBAVUTIL_VERSION_MICRO 100
+#define LIBAVUTIL_VERSION_MINOR  33
+#define LIBAVUTIL_VERSION_MICRO 101
 
 #define LIBAVUTIL_VERSION_INT   AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, \
                                                LIBAVUTIL_VERSION_MINOR, \
@@ -114,6 +114,7 @@
 #define FF_API_XVMC                     (LIBAVUTIL_VERSION_MAJOR < 58)
 #define FF_API_OLD_CHANNEL_LAYOUT       (LIBAVUTIL_VERSION_MAJOR < 58)
 #define FF_API_AV_FOPEN_UTF8            (LIBAVUTIL_VERSION_MAJOR < 58)
+#define FF_API_PKT_DURATION             (LIBAVUTIL_VERSION_MAJOR < 58)
 
 /**
  * @}
diff --git a/libavutil/x86/tx_float.asm b/libavutil/x86/tx_float.asm
index 21f99d3..191af7d 100644
--- a/libavutil/x86/tx_float.asm
+++ b/libavutil/x86/tx_float.asm
@@ -1044,7 +1044,7 @@ ALIGN 16
     add lutq, (mmsize/2)*8
 %endif
     cmp tgtq, 64
-    je .deinterleave
+    je .64pt_deint
 
     SPLIT_RADIX_COMBINE_64
 
@@ -1190,9 +1190,6 @@ FFT_SPLIT_RADIX_DEF 131072
 ; Final synthesis + deinterleaving code
 ;===============================================================================
 .deinterleave:
-    cmp lenq, 64
-    je .64pt_deint
-
     imul tmpq, lenq, 2
     lea lutq, [4*lenq + tmpq]
 
diff --git a/libpostproc/Makefile b/libpostproc/Makefile
index d3f3b27..77c2b6b 100644
--- a/libpostproc/Makefile
+++ b/libpostproc/Makefile
@@ -10,4 +10,4 @@ OBJS = postprocess.o           \
        version.o               \
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES) += postprocres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES) += postprocres.o
diff --git a/libpostproc/version.h b/libpostproc/version.h
index 397f3f7..c258957 100644
--- a/libpostproc/version.h
+++ b/libpostproc/version.h
@@ -30,7 +30,7 @@
 
 #include "version_major.h"
 
-#define LIBPOSTPROC_VERSION_MINOR   6
+#define LIBPOSTPROC_VERSION_MINOR   7
 #define LIBPOSTPROC_VERSION_MICRO 100
 
 #define LIBPOSTPROC_VERSION_INT AV_VERSION_INT(LIBPOSTPROC_VERSION_MAJOR, \
diff --git a/libswresample/Makefile b/libswresample/Makefile
index dc80027..8b9a0fe 100644
--- a/libswresample/Makefile
+++ b/libswresample/Makefile
@@ -22,6 +22,6 @@ OBJS-$(CONFIG_LIBSOXR) += soxr_resample.o
 SHLIBOBJS              += log2_tab.o
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES) += swresampleres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES) += swresampleres.o
 
 TESTPROGS = swresample
diff --git a/libswresample/swresample.c b/libswresample/swresample.c
index 601e691..9b77ef6 100644
--- a/libswresample/swresample.c
+++ b/libswresample/swresample.c
@@ -385,8 +385,8 @@ av_cold int swr_init(struct SwrContext *s){
         goto fail;
     }
 
-    av_channel_layout_describe(&s->out_ch_layout, l2, sizeof(l2));
 #if FF_API_OLD_CHANNEL_LAYOUT
+    av_channel_layout_describe(&s->out_ch_layout, l1, sizeof(l1));
     if (s->out_ch_layout.order != AV_CHANNEL_ORDER_UNSPEC && s->out.ch_count != s->out_ch_layout.nb_channels) {
         av_log(s, AV_LOG_ERROR, "Output channel layout %s mismatches specified channel count %d\n", l2, s->out.ch_count);
         ret = AVERROR(EINVAL);
diff --git a/libswresample/version.h b/libswresample/version.h
index 7e5c58e..66bac2f 100644
--- a/libswresample/version.h
+++ b/libswresample/version.h
@@ -30,7 +30,7 @@
 
 #include "version_major.h"
 
-#define LIBSWRESAMPLE_VERSION_MINOR   7
+#define LIBSWRESAMPLE_VERSION_MINOR   8
 #define LIBSWRESAMPLE_VERSION_MICRO 100
 
 #define LIBSWRESAMPLE_VERSION_INT  AV_VERSION_INT(LIBSWRESAMPLE_VERSION_MAJOR, \
diff --git a/libswscale/Makefile b/libswscale/Makefile
index 8e95f74..4c950e6 100644
--- a/libswscale/Makefile
+++ b/libswscale/Makefile
@@ -25,7 +25,7 @@ OBJS = alphablend.o                                     \
 SHLIBOBJS                    += log2_tab.o
 
 # Windows resource file
-SLIBOBJS-$(HAVE_GNU_WINDRES) += swscaleres.o
+SHLIBOBJS-$(HAVE_GNU_WINDRES) += swscaleres.o
 
 TESTPROGS = colorspace                                                  \
             floatimg_cmp                                                \
diff --git a/libswscale/aarch64/hscale.S b/libswscale/aarch64/hscale.S
index b7b21b7..a16d3dc 100644
--- a/libswscale/aarch64/hscale.S
+++ b/libswscale/aarch64/hscale.S
@@ -91,6 +91,113 @@ function ff_hscale8to15_X8_neon, export=1
         ret
 endfunc
 
+function ff_hscale8to15_X4_neon, export=1
+// x0  SwsContext *c (not used)
+// x1  int16_t *dst
+// w2  int dstW
+// x3  const uint8_t *src
+// x4  const int16_t *filter
+// x5  const int32_t *filterPos
+// w6  int filterSize
+
+// This function for filter sizes that are 4 mod 8. In other words, anything that's 0 mod 4 but not
+// 0 mod 8. It also assumes that dstW is 0 mod 4.
+
+        lsl                 w7, w6, #1                  // w7 = filterSize * 2
+1:
+        ldp                 w8, w9,  [x5]               // filterPos[idx + 0], [idx + 1]
+        ldp                 w10, w11, [x5, #8]          // filterPos[idx + 2], [idx + 3]
+
+        movi                v16.2d, #0                  // initialize accumulator for idx + 0
+        movi                v17.2d, #0                  // initialize accumulator for idx + 1
+        movi                v18.2d, #0                  // initialize accumulator for idx + 2
+        movi                v19.2d, #0                  // initialize accumulator for idx + 3
+
+        mov                 x12, x4                     // filter pointer for idx + 0
+        add                 x13, x4, x7                 // filter pointer for idx + 1
+        add                 x8, x3, w8, uxtw            // srcp + filterPos[idx + 0]
+        add                 x9, x3, w9, uxtw            // srcp + filterPos[idx + 1]
+
+        add                 x14, x13, x7                // filter pointer for idx + 2
+        add                 x10, x3, w10, uxtw          // srcp + filterPos[idx + 2]
+        add                 x11, x3, w11, uxtw          // srcp + filterPos[idx + 3]
+
+        mov                 w0, w6                      // copy filterSize to a temp register, w0
+        add                 x5, x5, #16                 // advance the filterPos pointer
+        add                 x15, x14, x7                // filter pointer for idx + 3
+        mov                 x16, xzr                    // temp register for offsetting filter pointers
+
+2:
+        // This section loops over 8-wide chunks of filter size
+        ldr                 d4, [x8], #8                // load 8 bytes from srcp for idx + 0
+        ldr                 q0, [x12, x16]              // load 8 values, 16 bytes from filter for idx + 0
+
+        ldr                 d5, [x9], #8                // load 8 bytes from srcp for idx + 1
+        ldr                 q1, [x13, x16]              // load 8 values, 16 bytes from filter for idx + 1
+
+        uxtl                v4.8h, v4.8b                // unsigned extend long for idx + 0
+        uxtl                v5.8h, v5.8b                // unsigned extend long for idx + 1
+
+        ldr                 d6, [x10], #8               // load 8 bytes from srcp for idx + 2
+        ldr                 q2, [x14, x16]              // load 8 values, 16 bytes from filter for idx + 2
+
+        smlal               v16.4s, v0.4h, v4.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 0
+        smlal               v17.4s, v1.4h, v5.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 1
+
+        ldr                 d7, [x11], #8               // load 8 bytes from srcp for idx + 3
+        ldr                 q3, [x15, x16]              // load 8 values, 16 bytes from filter for idx + 3
+
+        sub                 w0, w0, #8                  // decrement the remaining filterSize counter
+        smlal2              v16.4s, v0.8h, v4.8h        // val += src[srcPos + j + 4..7] * filter[fs * i + j + 4..7], idx + 0
+        smlal2              v17.4s, v1.8h, v5.8h        // val += src[srcPos + j + 4..7] * filter[fs * i + j + 4..7], idx + 1
+        uxtl                v6.8h, v6.8b                // unsigned extend long for idx + 2
+        uxtl                v7.8h, v7.8b                // unsigned extend long for idx + 3
+        smlal               v18.4s, v2.4h, v6.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 2
+        smlal               v19.4s, v3.4h, v7.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 3
+
+        cmp                 w0, #8                      // are there at least 8 more elements in filter to consume?
+        add                 x16, x16, #16               // advance the offsetting register for filter values
+
+        smlal2              v18.4s, v2.8h, v6.8h        // val += src[srcPos + j + 4..7] * filter[fs * i + j + 4..7], idx + 2
+        smlal2              v19.4s, v3.8h, v7.8h        // val += src[srcPos + j + 4..7] * filter[fs * i + j + 4..7], idx + 3
+
+        b.ge                2b                          // branch back to inner loop
+
+        // complete the remaining 4 filter elements
+        sub                 x17, x7, #8                 // calculate the offset of the filter pointer for the remaining 4 elements
+
+        ldr                 s4, [x8]                    // load 4 bytes from srcp for idx + 0
+        ldr                 d0, [x12, x17]              // load 4 values, 8 bytes from filter for idx + 0
+        ldr                 s5, [x9]                    // load 4 bytes from srcp for idx + 1
+        ldr                 d1, [x13, x17]              // load 4 values, 8 bytes from filter for idx + 1
+
+        uxtl                v4.8h, v4.8b                // unsigned extend long for idx + 0
+        uxtl                v5.8h, v5.8b                // unsigned extend long for idx + 1
+
+        ldr                 s6, [x10]                   // load 4 bytes from srcp for idx + 2
+        ldr                 d2, [x14, x17]              // load 4 values, 8 bytes from filter for idx + 2
+        smlal               v16.4s, v0.4h, v4.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 0
+        smlal               v17.4s, v1.4h, v5.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 1
+        ldr                 s7, [x11]                   // load 4 bytes from srcp for idx + 3
+        ldr                 d3, [x15, x17]              // load 4 values, 8 bytes from filter for idx + 3
+
+        uxtl                v6.8h, v6.8b                // unsigned extend long for idx + 2
+        uxtl                v7.8h, v7.8b                // unsigned extend long for idx + 3
+        addp                v16.4s, v16.4s, v17.4s      // horizontal pair adding for idx 0,1
+        smlal               v18.4s, v2.4h, v6.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 2
+        smlal               v19.4s, v3.4h, v7.4h        // val += src[srcPos + j + 0..3] * filter[fs * i + j + 0..3], idx + 3
+
+        addp                v18.4s, v18.4s, v19.4s      // horizontal pair adding for idx 2,3
+        addp                v16.4s, v16.4s, v18.4s      // final horizontal pair adding producing one vector with results for idx = 0..3
+
+        subs                w2, w2, #4                  // dstW -= 4
+        sqshrn              v0.4h, v16.4s, #7           // shift and clip the 2x16-bit final values
+        st1                 {v0.4h}, [x1], #8           // write to destination idx 0..3
+        add                 x4, x4, x7, lsl #2          // filter += (filterSize*2) * 4
+        b.gt                1b                          // loop until end of line
+        ret
+endfunc
+
 function ff_hscale8to15_4_neon, export=1
 // x0  SwsContext *c (not used)
 // x1  int16_t *dst
diff --git a/libswscale/aarch64/output.S b/libswscale/aarch64/output.S
index af71de6..b8a2818 100644
--- a/libswscale/aarch64/output.S
+++ b/libswscale/aarch64/output.S
@@ -21,29 +21,48 @@
 #include "libavutil/aarch64/asm.S"
 
 function ff_yuv2planeX_8_neon, export=1
+// x0 - const int16_t *filter,
+// x1 - int filterSize,
+// x2 - const int16_t **src,
+// x3 - uint8_t *dest,
+// w4 - int dstW,
+// x5 - const uint8_t *dither,
+// w6 - int offset
+
         ld1                 {v0.8B}, [x5]                   // load 8x8-bit dither
+        and                 w6, w6, #7
         cbz                 w6, 1f                          // check if offsetting present
         ext                 v0.8B, v0.8B, v0.8B, #3         // honor offsetting which can be 0 or 3 only
 1:      uxtl                v0.8H, v0.8B                    // extend dither to 16-bit
         ushll               v1.4S, v0.4H, #12               // extend dither to 32-bit with left shift by 12 (part 1)
         ushll2              v2.4S, v0.8H, #12               // extend dither to 32-bit with left shift by 12 (part 2)
+        cmp                 w1, #8                          // if filterSize == 8, branch to specialized version
+        b.eq                6f
+        cmp                 w1, #4                          // if filterSize == 4, branch to specialized version
+        b.eq                8f
+        cmp                 w1, #2                          // if filterSize == 2, branch to specialized version
+        b.eq                10f
+
+// The filter size does not match of the of specialized implementations. It is either even or odd. If it is even
+// then use the first section below.
         mov                 x7, #0                          // i = 0
+        tbnz                w1, #0, 4f                      // if filterSize % 2 != 0 branch to specialized version
+// fs % 2 == 0
 2:      mov                 v3.16B, v1.16B                  // initialize accumulator part 1 with dithering value
         mov                 v4.16B, v2.16B                  // initialize accumulator part 2 with dithering value
         mov                 w8, w1                          // tmpfilterSize = filterSize
         mov                 x9, x2                          // srcp    = src
         mov                 x10, x0                         // filterp = filter
 3:      ldp                 x11, x12, [x9], #16             // get 2 pointers: src[j] and src[j+1]
+        ldr                 s7, [x10], #4                   // read 2x16-bit coeff X and Y at filter[j] and filter[j+1]
         add                 x11, x11, x7, lsl #1            // &src[j  ][i]
         add                 x12, x12, x7, lsl #1            // &src[j+1][i]
         ld1                 {v5.8H}, [x11]                  // read 8x16-bit @ src[j  ][i + {0..7}]: A,B,C,D,E,F,G,H
         ld1                 {v6.8H}, [x12]                  // read 8x16-bit @ src[j+1][i + {0..7}]: I,J,K,L,M,N,O,P
-        ld1r                {v7.8H}, [x10], #2              // read 1x16-bit coeff X at filter[j  ] and duplicate across lanes
-        ld1r                {v16.8H}, [x10], #2             // read 1x16-bit coeff Y at filter[j+1] and duplicate across lanes
-        smlal               v3.4S, v5.4H, v7.4H             // val0 += {A,B,C,D} * X
-        smlal2              v4.4S, v5.8H, v7.8H             // val1 += {E,F,G,H} * X
-        smlal               v3.4S, v6.4H, v16.4H            // val0 += {I,J,K,L} * Y
-        smlal2              v4.4S, v6.8H, v16.8H            // val1 += {M,N,O,P} * Y
+        smlal               v3.4S, v5.4H, v7.H[0]           // val0 += {A,B,C,D} * X
+        smlal2              v4.4S, v5.8H, v7.H[0]           // val1 += {E,F,G,H} * X
+        smlal               v3.4S, v6.4H, v7.H[1]           // val0 += {I,J,K,L} * Y
+        smlal2              v4.4S, v6.8H, v7.H[1]           // val1 += {M,N,O,P} * Y
         subs                w8, w8, #2                      // tmpfilterSize -= 2
         b.gt                3b                              // loop until filterSize consumed
 
@@ -55,4 +74,161 @@ function ff_yuv2planeX_8_neon, export=1
         add                 x7, x7, #8                      // i += 8
         b.gt                2b                              // loop until width consumed
         ret
+
+// If filter size is odd (most likely == 1), then use this section.
+// fs % 2 != 0
+4:      mov                 v3.16B, v1.16B                  // initialize accumulator part 1 with dithering value
+        mov                 v4.16B, v2.16B                  // initialize accumulator part 2 with dithering value
+        mov                 w8, w1                          // tmpfilterSize = filterSize
+        mov                 x9, x2                          // srcp    = src
+        mov                 x10, x0                         // filterp = filter
+5:      ldr                 x11, [x9], #8                   // get 1 pointer: src[j]
+        ldr                 h6, [x10], #2                   // read 1 16 bit coeff X at filter[j]
+        add                 x11, x11, x7, lsl #1            // &src[j  ][i]
+        ld1                 {v5.8H}, [x11]                  // read 8x16-bit @ src[j  ][i + {0..7}]: A,B,C,D,E,F,G,H
+        smlal               v3.4S, v5.4H, v6.H[0]           // val0 += {A,B,C,D} * X
+        smlal2              v4.4S, v5.8H, v6.H[0]           // val1 += {E,F,G,H} * X
+        subs                w8, w8, #1                      // tmpfilterSize -= 2
+        b.gt                5b                              // loop until filterSize consumed
+
+        sqshrun             v3.4h, v3.4s, #16               // clip16(val0>>16)
+        sqshrun2            v3.8h, v4.4s, #16               // clip16(val1>>16)
+        uqshrn              v3.8b, v3.8h, #3                // clip8(val>>19)
+        st1                 {v3.8b}, [x3], #8               // write to destination
+        subs                w4, w4, #8                      // dstW -= 8
+        add                 x7, x7, #8                      // i += 8
+        b.gt                4b                              // loop until width consumed
+        ret
+
+6:      // fs=8
+        ldp                 x5, x6, [x2]                    // load 2 pointers: src[j  ] and src[j+1]
+        ldp                 x7, x9, [x2, #16]               // load 2 pointers: src[j+2] and src[j+3]
+        ldp                 x10, x11, [x2, #32]             // load 2 pointers: src[j+4] and src[j+5]
+        ldp                 x12, x13, [x2, #48]             // load 2 pointers: src[j+6] and src[j+7]
+
+        // load 8x16-bit values for filter[j], where j=0..7
+        ld1                 {v6.8H}, [x0]
+7:
+        mov                 v3.16B, v1.16B                  // initialize accumulator part 1 with dithering value
+        mov                 v4.16B, v2.16B                  // initialize accumulator part 2 with dithering value
+
+        ld1                 {v24.8H}, [x5], #16             // load 8x16-bit values for src[j + 0][i + {0..7}]
+        ld1                 {v25.8H}, [x6], #16             // load 8x16-bit values for src[j + 1][i + {0..7}]
+        ld1                 {v26.8H}, [x7], #16             // load 8x16-bit values for src[j + 2][i + {0..7}]
+        ld1                 {v27.8H}, [x9], #16             // load 8x16-bit values for src[j + 3][i + {0..7}]
+        ld1                 {v28.8H}, [x10], #16            // load 8x16-bit values for src[j + 4][i + {0..7}]
+        ld1                 {v29.8H}, [x11], #16            // load 8x16-bit values for src[j + 5][i + {0..7}]
+        ld1                 {v30.8H}, [x12], #16            // load 8x16-bit values for src[j + 6][i + {0..7}]
+        ld1                 {v31.8H}, [x13], #16            // load 8x16-bit values for src[j + 7][i + {0..7}]
+
+        smlal               v3.4S, v24.4H, v6.H[0]          // val0 += src[0][i + {0..3}] * filter[0]
+        smlal2              v4.4S, v24.8H, v6.H[0]          // val1 += src[0][i + {4..7}] * filter[0]
+        smlal               v3.4S, v25.4H, v6.H[1]          // val0 += src[1][i + {0..3}] * filter[1]
+        smlal2              v4.4S, v25.8H, v6.H[1]          // val1 += src[1][i + {4..7}] * filter[1]
+        smlal               v3.4S, v26.4H, v6.H[2]          // val0 += src[2][i + {0..3}] * filter[2]
+        smlal2              v4.4S, v26.8H, v6.H[2]          // val1 += src[2][i + {4..7}] * filter[2]
+        smlal               v3.4S, v27.4H, v6.H[3]          // val0 += src[3][i + {0..3}] * filter[3]
+        smlal2              v4.4S, v27.8H, v6.H[3]          // val1 += src[3][i + {4..7}] * filter[3]
+        smlal               v3.4S, v28.4H, v6.H[4]          // val0 += src[4][i + {0..3}] * filter[4]
+        smlal2              v4.4S, v28.8H, v6.H[4]          // val1 += src[4][i + {4..7}] * filter[4]
+        smlal               v3.4S, v29.4H, v6.H[5]          // val0 += src[5][i + {0..3}] * filter[5]
+        smlal2              v4.4S, v29.8H, v6.H[5]          // val1 += src[5][i + {4..7}] * filter[5]
+        smlal               v3.4S, v30.4H, v6.H[6]          // val0 += src[6][i + {0..3}] * filter[6]
+        smlal2              v4.4S, v30.8H, v6.H[6]          // val1 += src[6][i + {4..7}] * filter[6]
+        smlal               v3.4S, v31.4H, v6.H[7]          // val0 += src[7][i + {0..3}] * filter[7]
+        smlal2              v4.4S, v31.8H, v6.H[7]          // val1 += src[7][i + {4..7}] * filter[7]
+
+        sqshrun             v3.4h, v3.4s, #16               // clip16(val0>>16)
+        sqshrun2            v3.8h, v4.4s, #16               // clip16(val1>>16)
+        uqshrn              v3.8b, v3.8h, #3                // clip8(val>>19)
+        subs                w4, w4, #8                      // dstW -= 8
+        st1                 {v3.8b}, [x3], #8               // write to destination
+        b.gt                7b                              // loop until width consumed
+        ret
+
+8:      // fs=4
+        ldp                 x5, x6, [x2]                    // load 2 pointers: src[j  ] and src[j+1]
+        ldp                 x7, x9, [x2, #16]               // load 2 pointers: src[j+2] and src[j+3]
+
+        // load 4x16-bit values for filter[j], where j=0..3 and replicated across lanes
+        ld1                 {v6.4H}, [x0]
+9:
+        mov                 v3.16B, v1.16B                  // initialize accumulator part 1 with dithering value
+        mov                 v4.16B, v2.16B                  // initialize accumulator part 2 with dithering value
+
+        ld1                 {v24.8H}, [x5], #16             // load 8x16-bit values for src[j + 0][i + {0..7}]
+        ld1                 {v25.8H}, [x6], #16             // load 8x16-bit values for src[j + 1][i + {0..7}]
+        ld1                 {v26.8H}, [x7], #16             // load 8x16-bit values for src[j + 2][i + {0..7}]
+        ld1                 {v27.8H}, [x9], #16             // load 8x16-bit values for src[j + 3][i + {0..7}]
+
+        smlal               v3.4S, v24.4H, v6.H[0]          // val0 += src[0][i + {0..3}] * filter[0]
+        smlal2              v4.4S, v24.8H, v6.H[0]          // val1 += src[0][i + {4..7}] * filter[0]
+        smlal               v3.4S, v25.4H, v6.H[1]          // val0 += src[1][i + {0..3}] * filter[1]
+        smlal2              v4.4S, v25.8H, v6.H[1]          // val1 += src[1][i + {4..7}] * filter[1]
+        smlal               v3.4S, v26.4H, v6.H[2]          // val0 += src[2][i + {0..3}] * filter[2]
+        smlal2              v4.4S, v26.8H, v6.H[2]          // val1 += src[2][i + {4..7}] * filter[2]
+        smlal               v3.4S, v27.4H, v6.H[3]          // val0 += src[3][i + {0..3}] * filter[3]
+        smlal2              v4.4S, v27.8H, v6.H[3]          // val1 += src[3][i + {4..7}] * filter[3]
+
+        sqshrun             v3.4h, v3.4s, #16               // clip16(val0>>16)
+        sqshrun2            v3.8h, v4.4s, #16               // clip16(val1>>16)
+        uqshrn              v3.8b, v3.8h, #3                // clip8(val>>19)
+        st1                 {v3.8b}, [x3], #8               // write to destination
+        subs                w4, w4, #8                      // dstW -= 8
+        b.gt                9b                              // loop until width consumed
+        ret
+
+10:     // fs=2
+        ldp                 x5, x6, [x2]                    // load 2 pointers: src[j  ] and src[j+1]
+
+        // load 2x16-bit values for filter[j], where j=0..1 and replicated across lanes
+        ldr                 s6, [x0]
+11:
+        mov                 v3.16B, v1.16B                  // initialize accumulator part 1 with dithering value
+        mov                 v4.16B, v2.16B                  // initialize accumulator part 2 with dithering value
+
+        ld1                 {v24.8H}, [x5], #16             // load 8x16-bit values for src[j + 0][i + {0..7}]
+        ld1                 {v25.8H}, [x6], #16             // load 8x16-bit values for src[j + 1][i + {0..7}]
+
+        smlal               v3.4S, v24.4H, v6.H[0]          // val0 += src[0][i + {0..3}] * filter[0]
+        smlal2              v4.4S, v24.8H, v6.H[0]          // val1 += src[0][i + {4..7}] * filter[0]
+        smlal               v3.4S, v25.4H, v6.H[1]          // val0 += src[1][i + {0..3}] * filter[1]
+        smlal2              v4.4S, v25.8H, v6.H[1]          // val1 += src[1][i + {4..7}] * filter[1]
+
+        sqshrun             v3.4h, v3.4s, #16               // clip16(val0>>16)
+        sqshrun2            v3.8h, v4.4s, #16               // clip16(val1>>16)
+        uqshrn              v3.8b, v3.8h, #3                // clip8(val>>19)
+        st1                 {v3.8b}, [x3], #8               // write to destination
+        subs                w4, w4, #8                      // dstW -= 8
+        b.gt                11b                             // loop until width consumed
+        ret
+endfunc
+
+function ff_yuv2plane1_8_neon, export=1
+// x0 - const int16_t *src,
+// x1 - uint8_t *dest,
+// w2 - int dstW,
+// x3 - const uint8_t *dither,
+// w4 - int offset
+        ld1                 {v0.8B}, [x3]                   // load 8x8-bit dither
+        and                 w4, w4, #7
+        cbz                 w4, 1f                          // check if offsetting present
+        ext                 v0.8B, v0.8B, v0.8B, #3         // honor offsetting which can be 0 or 3 only
+1:      uxtl                v0.8H, v0.8B                    // extend dither to 32-bit
+        uxtl                v1.4s, v0.4h
+        uxtl2               v2.4s, v0.8h
+2:
+        ld1                 {v3.8h}, [x0], #16              // read 8x16-bit @ src[j  ][i + {0..7}]: A,B,C,D,E,F,G,H
+        sxtl                v4.4s, v3.4h
+        sxtl2               v5.4s, v3.8h
+        add                 v4.4s, v4.4s, v1.4s
+        add                 v5.4s, v5.4s, v2.4s
+        sqshrun             v4.4h, v4.4s, #6
+        sqshrun2            v4.8h, v5.4s, #6
+
+        uqshrn              v3.8b, v4.8h, #1                // clip8(val>>7)
+        subs                w2, w2, #8                      // dstW -= 8
+        st1                 {v3.8b}, [x1], #8               // write to destination
+        b.gt                2b                              // loop until width consumed
+        ret
 endfunc
diff --git a/libswscale/aarch64/swscale.c b/libswscale/aarch64/swscale.c
index ab28be4..d1312c6 100644
--- a/libswscale/aarch64/swscale.c
+++ b/libswscale/aarch64/swscale.c
@@ -32,13 +32,20 @@ void ff_hscale ## from_bpc ## to ## to_bpc ## _ ## filter_n ## _ ## opt( \
     SCALE_FUNC(filter_n,  8, 15, opt);
 #define ALL_SCALE_FUNCS(opt) \
     SCALE_FUNCS(4, opt); \
-    SCALE_FUNCS(X8, opt)
+    SCALE_FUNCS(X8, opt); \
+    SCALE_FUNCS(X4, opt)
 
 ALL_SCALE_FUNCS(neon);
 
 void ff_yuv2planeX_8_neon(const int16_t *filter, int filterSize,
                           const int16_t **src, uint8_t *dest, int dstW,
                           const uint8_t *dither, int offset);
+void ff_yuv2plane1_8_neon(
+        const int16_t *src,
+        uint8_t *dest,
+        int dstW,
+        const uint8_t *dither,
+        int offset);
 
 #define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt) do {              \
     if (c->srcBpc == 8 && c->dstBpc <= 14) {                            \
@@ -47,13 +54,20 @@ void ff_yuv2planeX_8_neon(const int16_t *filter, int filterSize,
     }                                                                   \
 } while (0)
 
-#define ASSIGN_SCALE_FUNC(hscalefn, filtersize, opt)                    \
-  switch (filtersize) {                                                 \
-  case 4:  ASSIGN_SCALE_FUNC2(hscalefn, 4, opt); break;                 \
-  default: if (filtersize % 8 == 0)                                     \
-               ASSIGN_SCALE_FUNC2(hscalefn, X8, opt);                   \
-           break;                                                       \
-  }
+#define ASSIGN_SCALE_FUNC(hscalefn, filtersize, opt) do {               \
+    if (filtersize == 4)                                                \
+        ASSIGN_SCALE_FUNC2(hscalefn, 4, opt);                           \
+    else if (filtersize % 8 == 0)                                       \
+        ASSIGN_SCALE_FUNC2(hscalefn, X8, opt);                          \
+    else if (filtersize % 4 == 0 && filtersize % 8 != 0)                \
+        ASSIGN_SCALE_FUNC2(hscalefn, X4, opt);                          \
+} while (0)
+
+#define ASSIGN_VSCALE_FUNC(vscalefn, opt)                               \
+    switch (c->dstBpc) {                                                \
+    case 8: vscalefn = ff_yuv2plane1_8_  ## opt;  break;                \
+    default: break;                                                     \
+    }
 
 av_cold void ff_sws_init_swscale_aarch64(SwsContext *c)
 {
@@ -62,6 +76,7 @@ av_cold void ff_sws_init_swscale_aarch64(SwsContext *c)
     if (have_neon(cpu_flags)) {
         ASSIGN_SCALE_FUNC(c->hyScale, c->hLumFilterSize, neon);
         ASSIGN_SCALE_FUNC(c->hcScale, c->hChrFilterSize, neon);
+        ASSIGN_VSCALE_FUNC(c->yuv2plane1, neon);
         if (c->dstBpc == 8) {
             c->yuv2planeX = ff_yuv2planeX_8_neon;
         }
diff --git a/libswscale/input.c b/libswscale/input.c
index fe0c27d..68abc4d 100644
--- a/libswscale/input.c
+++ b/libswscale/input.c
@@ -650,6 +650,32 @@ static void read_ayuv64le_A_c(uint8_t *dst, const uint8_t *src, const uint8_t *u
         AV_WN16(dst + i * 2, AV_RL16(src + i * 8));
 }
 
+static void read_vuya_UV_c(uint8_t *dstU, uint8_t *dstV, const uint8_t *unused0, const uint8_t *src,
+                           const uint8_t *unused1, int width, uint32_t *unused2)
+{
+    int i;
+    for (i = 0; i < width; i++) {
+        dstU[i] = src[i * 4 + 1];
+        dstV[i] = src[i * 4];
+    }
+}
+
+static void read_vuya_Y_c(uint8_t *dst, const uint8_t *src, const uint8_t *unused0, const uint8_t *unused1, int width,
+                          uint32_t *unused2)
+{
+    int i;
+    for (i = 0; i < width; i++)
+        dst[i] = src[i * 4 + 2];
+}
+
+static void read_vuya_A_c(uint8_t *dst, const uint8_t *src, const uint8_t *unused0, const uint8_t *unused1, int width,
+                          uint32_t *unused2)
+{
+    int i;
+    for (i = 0; i < width; i++)
+        dst[i] = src[i * 4 + 3];
+}
+
 /* This is almost identical to the previous, end exists only because
  * yuy2ToY/UV)(dst, src + 1, ...) would have 100% unaligned accesses. */
 static void uyvyToY_c(uint8_t *dst, const uint8_t *src, const uint8_t *unused1, const uint8_t *unused2,  int width,
@@ -1101,6 +1127,7 @@ av_cold void ff_sws_init_input_funcs(SwsContext *c)
         c->chrToYV12 = uyvyToUV_c;
         break;
     case AV_PIX_FMT_NV12:
+    case AV_PIX_FMT_NV16:
     case AV_PIX_FMT_NV24:
         c->chrToYV12 = nv12ToUV_c;
         break;
@@ -1228,6 +1255,9 @@ av_cold void ff_sws_init_input_funcs(SwsContext *c)
         c->chrToYV12 = bswap16UV_c;
         break;
 #endif
+    case AV_PIX_FMT_VUYA:
+        c->chrToYV12 = read_vuya_UV_c;
+        break;
     case AV_PIX_FMT_AYUV64LE:
         c->chrToYV12 = read_ayuv64le_UV_c;
         break;
@@ -1590,6 +1620,9 @@ av_cold void ff_sws_init_input_funcs(SwsContext *c)
     case AV_PIX_FMT_YA16BE:
         c->lumToYV12 = read_ya16be_gray_c;
         break;
+    case AV_PIX_FMT_VUYA:
+        c->lumToYV12 = read_vuya_Y_c;
+        break;
     case AV_PIX_FMT_AYUV64LE:
         c->lumToYV12 = read_ayuv64le_Y_c;
         break;
@@ -1745,6 +1778,9 @@ av_cold void ff_sws_init_input_funcs(SwsContext *c)
         case AV_PIX_FMT_YA16BE:
             c->alpToYV12 = read_ya16be_alpha_c;
             break;
+        case AV_PIX_FMT_VUYA:
+            c->alpToYV12 = read_vuya_A_c;
+            break;
         case AV_PIX_FMT_AYUV64LE:
             c->alpToYV12 = read_ayuv64le_A_c;
             break;
diff --git a/libswscale/output.c b/libswscale/output.c
index 773f3ce..74f992a 100644
--- a/libswscale/output.c
+++ b/libswscale/output.c
@@ -2584,6 +2584,60 @@ yuv2ayuv64le_X_c(SwsContext *c, const int16_t *lumFilter,
     }
 }
 
+static void
+yuv2vuya_X_c(SwsContext *c, const int16_t *lumFilter,
+             const int16_t **lumSrc, int lumFilterSize,
+             const int16_t *chrFilter, const int16_t **chrUSrc,
+             const int16_t **chrVSrc, int chrFilterSize,
+             const int16_t **alpSrc, uint8_t *dest, int dstW, int y)
+{
+    int hasAlpha = !!alpSrc;
+    int i;
+
+    for (i = 0; i < dstW; i++) {
+        int j;
+        int Y = 1 << 18, U = 1 << 18;
+        int V = 1 << 18, A = 255;
+
+        for (j = 0; j < lumFilterSize; j++)
+            Y += lumSrc[j][i] * lumFilter[j];
+
+        for (j = 0; j < chrFilterSize; j++)
+            U += chrUSrc[j][i] * chrFilter[j];
+
+        for (j = 0; j < chrFilterSize; j++)
+            V += chrVSrc[j][i] * chrFilter[j];
+
+        Y >>= 19;
+        U >>= 19;
+        V >>= 19;
+
+        if (Y  & 0x100)
+            Y = av_clip_uint8(Y);
+        if (U  & 0x100)
+            U = av_clip_uint8(U);
+        if (V  & 0x100)
+            V = av_clip_uint8(V);
+
+        if (hasAlpha) {
+            A = 1 << 18;
+
+            for (j = 0; j < lumFilterSize; j++)
+                A += alpSrc[j][i] * lumFilter[j];
+
+            A >>= 19;
+
+            if (A & 0x100)
+                A = av_clip_uint8(A);
+        }
+
+        dest[4 * i    ] = V;
+        dest[4 * i + 1] = U;
+        dest[4 * i + 2] = Y;
+        dest[4 * i + 3] = A;
+    }
+}
+
 av_cold void ff_sws_init_output_funcs(SwsContext *c,
                                       yuv2planar1_fn *yuv2plane1,
                                       yuv2planarX_fn *yuv2planeX,
@@ -3086,5 +3140,8 @@ av_cold void ff_sws_init_output_funcs(SwsContext *c,
     case AV_PIX_FMT_AYUV64LE:
         *yuv2packedX = yuv2ayuv64le_X_c;
         break;
+    case AV_PIX_FMT_VUYA:
+        *yuv2packedX = yuv2vuya_X_c;
+        break;
     }
 }
diff --git a/libswscale/rgb2rgb.c b/libswscale/rgb2rgb.c
index b8be769..4f1ac9c 100644
--- a/libswscale/rgb2rgb.c
+++ b/libswscale/rgb2rgb.c
@@ -317,7 +317,7 @@ void rgb15tobgr15(const uint8_t *src, uint8_t *dst, int src_size)
 void rgb12tobgr12(const uint8_t *src, uint8_t *dst, int src_size)
 {
     uint16_t *d = (uint16_t *)dst;
-    uint16_t *s = (uint16_t *)src;
+    const uint16_t *s = (const uint16_t *)src;
     int i, num_pixels = src_size >> 1;
 
     for (i = 0; i < num_pixels; i++) {
@@ -331,7 +331,7 @@ void rgb48tobgr48_ ## need_bswap(const uint8_t *src,                    \
                                  uint8_t *dst, int src_size)            \
 {                                                                       \
     uint16_t *d = (uint16_t *)dst;                                      \
-    uint16_t *s = (uint16_t *)src;                                      \
+    const uint16_t *s = (const uint16_t *)src;                          \
     int i, num_pixels = src_size >> 1;                                  \
                                                                         \
     for (i = 0; i < num_pixels; i += 3) {                               \
@@ -349,7 +349,7 @@ void rgb64tobgr48_ ## need_bswap(const uint8_t *src,                    \
                                  uint8_t *dst, int src_size)            \
 {                                                                       \
     uint16_t *d = (uint16_t *)dst;                                      \
-    uint16_t *s = (uint16_t *)src;                                      \
+    const uint16_t *s = (const uint16_t *)src;                          \
     int i, num_pixels = src_size >> 3;                                  \
                                                                         \
     for (i = 0; i < num_pixels; i++) {                                  \
@@ -367,7 +367,7 @@ void rgb64to48_ ## need_bswap(const uint8_t *src,                       \
                               uint8_t *dst, int src_size)               \
 {                                                                       \
     uint16_t *d = (uint16_t *)dst;                                      \
-    uint16_t *s = (uint16_t *)src;                                      \
+    const uint16_t *s = (const uint16_t *)src;                          \
     int i, num_pixels = src_size >> 3;                                  \
                                                                         \
     for (i = 0; i < num_pixels; i++) {                                  \
@@ -385,7 +385,7 @@ void rgb48tobgr64_ ## need_bswap(const uint8_t *src,                    \
                                  uint8_t *dst, int src_size)            \
 {                                                                       \
     uint16_t *d = (uint16_t *)dst;                                      \
-    uint16_t *s = (uint16_t *)src;                                      \
+    const uint16_t *s = (const uint16_t *)src;                          \
     int i, num_pixels = src_size / 6;                                   \
                                                                         \
     for (i = 0; i < num_pixels; i++) {                                  \
@@ -404,7 +404,7 @@ void rgb48to64_ ## need_bswap(const uint8_t *src,                       \
                               uint8_t *dst, int src_size)               \
 {                                                                       \
     uint16_t *d = (uint16_t *)dst;                                      \
-    uint16_t *s = (uint16_t *)src;                                      \
+    const uint16_t *s = (const uint16_t *)src;                          \
     int i, num_pixels = src_size / 6;                                   \
                                                                         \
     for (i = 0; i < num_pixels; i++) {                                  \
diff --git a/libswscale/utils.c b/libswscale/utils.c
index cb4f5b5..34503e5 100644
--- a/libswscale/utils.c
+++ b/libswscale/utils.c
@@ -257,6 +257,8 @@ static const FormatEntry format_entries[] = {
     [AV_PIX_FMT_P216LE]      = { 1, 1 },
     [AV_PIX_FMT_P416BE]      = { 1, 1 },
     [AV_PIX_FMT_P416LE]      = { 1, 1 },
+    [AV_PIX_FMT_NV16]        = { 1, 1 },
+    [AV_PIX_FMT_VUYA]        = { 1, 1 },
 };
 
 int ff_shuffle_filter_coefficients(SwsContext *c, int *filterPos,
diff --git a/libswscale/version.h b/libswscale/version.h
index 4c6af26..3193562 100644
--- a/libswscale/version.h
+++ b/libswscale/version.h
@@ -28,8 +28,8 @@
 
 #include "version_major.h"
 
-#define LIBSWSCALE_VERSION_MINOR   7
-#define LIBSWSCALE_VERSION_MICRO 100
+#define LIBSWSCALE_VERSION_MINOR   8
+#define LIBSWSCALE_VERSION_MICRO 102
 
 #define LIBSWSCALE_VERSION_INT  AV_VERSION_INT(LIBSWSCALE_VERSION_MAJOR, \
                                                LIBSWSCALE_VERSION_MINOR, \
diff --git a/libswscale/x86/swscale.c b/libswscale/x86/swscale.c
index 628f121..32d4412 100644
--- a/libswscale/x86/swscale.c
+++ b/libswscale/x86/swscale.c
@@ -534,7 +534,8 @@ switch(c->dstBpc){ \
         ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2);
         ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, ,
                             HAVE_ALIGNED_STACK || ARCH_X86_64);
-        ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2);
+        if (!(c->flags & SWS_ACCURATE_RND))
+            ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2);
 
         switch (c->srcFormat) {
         case AV_PIX_FMT_YA8:
@@ -583,14 +584,15 @@ switch(c->dstBpc){ \
         ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4,
                             if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4,
                             HAVE_ALIGNED_STACK || ARCH_X86_64);
-        if (c->dstBpc == 16 && !isBE(c->dstFormat))
+        if (c->dstBpc == 16 && !isBE(c->dstFormat) && !(c->flags & SWS_ACCURATE_RND))
             c->yuv2plane1 = ff_yuv2plane1_16_sse4;
     }
 
     if (EXTERNAL_AVX(cpu_flags)) {
         ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, ,
                             HAVE_ALIGNED_STACK || ARCH_X86_64);
-        ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx);
+        if (!(c->flags & SWS_ACCURATE_RND))
+            ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx);
 
         switch (c->srcFormat) {
         case AV_PIX_FMT_YUYV422:
diff --git a/tests/api/api-h264-test.c b/tests/api/api-h264-test.c
index b9230c6..c89f1ba 100644
--- a/tests/api/api-h264-test.c
+++ b/tests/api/api-h264-test.c
@@ -154,7 +154,7 @@ static int video_decode_example(const char *input_filename)
                 return number_of_written_bytes;
             }
             printf("%d, %s, %s, %8"PRId64", %8d, 0x%08"PRIx32"\n", video_stream,
-                   av_ts2str(fr->pts), av_ts2str(fr->pkt_dts), fr->pkt_duration,
+                   av_ts2str(fr->pts), av_ts2str(fr->pkt_dts), fr->duration,
                    number_of_written_bytes, av_adler32_update(0, (const uint8_t*)byte_buffer, number_of_written_bytes));
 
             av_frame_unref(fr);
diff --git a/tests/api/api-seek-test.c b/tests/api/api-seek-test.c
index 696af9c..e86908e 100644
--- a/tests/api/api-seek-test.c
+++ b/tests/api/api-seek-test.c
@@ -156,7 +156,7 @@ static int compute_crc_of_packets(AVFormatContext *fmt_ctx, int video_stream,
             }
             av_frame_unref(fr);
         }
-    } while (result >= 0 && (no_seeking || (fr->pts + fr->pkt_duration <= ts_end)));
+    } while (result >= 0 && (no_seeking || (fr->pts + fr->duration <= ts_end)));
 
 finish:
     av_freep(&byte_buffer);
diff --git a/tests/checkasm/Makefile b/tests/checkasm/Makefile
index e869c70..1ac1704 100644
--- a/tests/checkasm/Makefile
+++ b/tests/checkasm/Makefile
@@ -3,7 +3,6 @@
 AVCODECOBJS-$(CONFIG_AUDIODSP)          += audiodsp.o
 AVCODECOBJS-$(CONFIG_BLOCKDSP)          += blockdsp.o
 AVCODECOBJS-$(CONFIG_BSWAPDSP)          += bswapdsp.o
-AVCODECOBJS-$(CONFIG_FLACDSP)           += flacdsp.o
 AVCODECOBJS-$(CONFIG_FMTCONVERT)        += fmtconvert.o
 AVCODECOBJS-$(CONFIG_G722DSP)           += g722dsp.o
 AVCODECOBJS-$(CONFIG_H264DSP)           += h264dsp.o
@@ -23,6 +22,7 @@ AVCODECOBJS-$(CONFIG_AAC_DECODER)       += aacpsdsp.o \
 AVCODECOBJS-$(CONFIG_ALAC_DECODER)      += alacdsp.o
 AVCODECOBJS-$(CONFIG_DCA_DECODER)       += synth_filter.o
 AVCODECOBJS-$(CONFIG_EXR_DECODER)       += exrdsp.o
+AVCODECOBJS-$(CONFIG_FLAC_DECODER)      += flacdsp.o
 AVCODECOBJS-$(CONFIG_HUFFYUV_DECODER)   += huffyuvdsp.o
 AVCODECOBJS-$(CONFIG_JPEG2000_DECODER)  += jpeg2000dsp.o
 AVCODECOBJS-$(CONFIG_OPUS_DECODER)      += opusdsp.o
diff --git a/tests/checkasm/checkasm.c b/tests/checkasm/checkasm.c
index 5ffcafb..e56fd38 100644
--- a/tests/checkasm/checkasm.c
+++ b/tests/checkasm/checkasm.c
@@ -96,7 +96,7 @@ static const struct {
     #if CONFIG_EXR_DECODER
         { "exrdsp", checkasm_check_exrdsp },
     #endif
-    #if CONFIG_FLACDSP
+    #if CONFIG_FLAC_DECODER
         { "flacdsp", checkasm_check_flacdsp },
     #endif
     #if CONFIG_FMTCONVERT
diff --git a/tests/checkasm/checkasm.h b/tests/checkasm/checkasm.h
index b601a98..d7645d3 100644
--- a/tests/checkasm/checkasm.h
+++ b/tests/checkasm/checkasm.h
@@ -230,8 +230,10 @@ typedef struct CheckasmPerf {
     ioctl(sysfd, PERF_EVENT_IOC_ENABLE, 0);             \
 } while (0)
 #define PERF_STOP(t) do {                               \
+    int ret;                                            \
     ioctl(sysfd, PERF_EVENT_IOC_DISABLE, 0);            \
-    read(sysfd, &t, sizeof(t));                         \
+    ret = read(sysfd, &t, sizeof(t));                   \
+    (void)ret;                                          \
 } while (0)
 #elif CONFIG_MACOS_KPERF
 #define PERF_START(t) t = ff_kperf_cycles()
diff --git a/tests/checkasm/flacdsp.c b/tests/checkasm/flacdsp.c
index 6cd8ac5..ef93df8 100644
--- a/tests/checkasm/flacdsp.c
+++ b/tests/checkasm/flacdsp.c
@@ -76,12 +76,12 @@ void checkasm_check_flacdsp(void)
     int i, j;
 
     for (i = 0; i < 2; i++) {
-        ff_flacdsp_init(&h, fmts[i].fmt, 2, 0);
+        ff_flacdsp_init(&h, fmts[i].fmt, 2);
         for (j = 0; j < 3; j++)
             if (check_func(h.decorrelate[j], "flac_decorrelate_%s_%d", names[j], fmts[i].bits))
                 check_decorrelate(&ref_dst, ref_src, &new_dst, new_src, 2, fmts[i].bits);
         for (j = 2; j <= MAX_CHANNELS; j += 2) {
-            ff_flacdsp_init(&h, fmts[i].fmt, j, 0);
+            ff_flacdsp_init(&h, fmts[i].fmt, j);
             if (check_func(h.decorrelate[0], "flac_decorrelate_indep%d_%d", j, fmts[i].bits))
                 check_decorrelate(&ref_dst, ref_src, &new_dst, new_src, j, fmts[i].bits);
         }
diff --git a/tests/checkasm/hevc_add_res.c b/tests/checkasm/hevc_add_res.c
index 0c896ad..f17d121 100644
--- a/tests/checkasm/hevc_add_res.c
+++ b/tests/checkasm/hevc_add_res.c
@@ -36,14 +36,14 @@
         }                                       \
     } while (0)
 
-#define randomize_buffers2(buf, size)             \
+#define randomize_buffers2(buf, size, mask)       \
     do {                                          \
         int j;                                    \
         for (j = 0; j < size; j++)                \
-            AV_WN16A(buf + j * 2, rnd() & 0x3FF); \
+            AV_WN16A(buf + j * 2, rnd() & mask); \
     } while (0)
 
-static void compare_add_res(int size, ptrdiff_t stride, int overflow_test)
+static void compare_add_res(int size, ptrdiff_t stride, int overflow_test, int mask)
 {
     LOCAL_ALIGNED_32(int16_t, res0, [32 * 32]);
     LOCAL_ALIGNED_32(int16_t, res1, [32 * 32]);
@@ -53,7 +53,7 @@ static void compare_add_res(int size, ptrdiff_t stride, int overflow_test)
     declare_func_emms(AV_CPU_FLAG_MMX, void, uint8_t *dst, int16_t *res, ptrdiff_t stride);
 
     randomize_buffers(res0, size);
-    randomize_buffers2(dst0, size);
+    randomize_buffers2(dst0, size, mask);
     if (overflow_test)
         res0[0] = 0x8000;
     memcpy(res1, res0, sizeof(*res0) * size);
@@ -69,6 +69,7 @@ static void compare_add_res(int size, ptrdiff_t stride, int overflow_test)
 static void check_add_res(HEVCDSPContext h, int bit_depth)
 {
     int i;
+    int mask = bit_depth == 8 ? 0xFFFF : bit_depth == 10 ? 0x03FF : 0x07FF;
 
     for (i = 2; i <= 5; i++) {
         int block_size = 1 << i;
@@ -76,9 +77,9 @@ static void check_add_res(HEVCDSPContext h, int bit_depth)
         ptrdiff_t stride = block_size << (bit_depth > 8);
 
         if (check_func(h.add_residual[i - 2], "hevc_add_res_%dx%d_%d", block_size, block_size, bit_depth)) {
-            compare_add_res(size, stride, 0);
+            compare_add_res(size, stride, 0, mask);
             // overflow test for res = -32768
-            compare_add_res(size, stride, 1);
+            compare_add_res(size, stride, 1, mask);
         }
     }
 }
@@ -87,7 +88,7 @@ void checkasm_check_hevc_add_res(void)
 {
     int bit_depth;
 
-    for (bit_depth = 8; bit_depth <= 10; bit_depth++) {
+    for (bit_depth = 8; bit_depth <= 12; bit_depth++) {
         HEVCDSPContext h;
 
         ff_hevc_dsp_init(&h, bit_depth);
diff --git a/tests/checkasm/motion.c b/tests/checkasm/motion.c
index 0112822..87b20d1 100644
--- a/tests/checkasm/motion.c
+++ b/tests/checkasm/motion.c
@@ -45,7 +45,7 @@ static void test_motion(const char *name, me_cmp_func test_func)
     /* motion estimation can look up to 17 bytes ahead */
     static const int look_ahead = 17;
 
-    int i, x, y, d1, d2;
+    int i, x, y, h, d1, d2;
     uint8_t *ptr;
 
     LOCAL_ALIGNED_16(uint8_t, img1, [WIDTH * HEIGHT]);
@@ -68,18 +68,21 @@ static void test_motion(const char *name, me_cmp_func test_func)
         for (i = 0; i < ITERATIONS; i++) {
             x = rnd() % (WIDTH - look_ahead);
             y = rnd() % (HEIGHT - look_ahead);
+            // Pick a random h between 4 and 16; pick an even value.
+            h = 4 + ((rnd() % (16 + 1 - 4)) & ~1);
 
             ptr = img2 + y * WIDTH + x;
-            d2 = call_ref(NULL, img1, ptr, WIDTH, 8);
-            d1 = call_new(NULL, img1, ptr, WIDTH, 8);
+            d2 = call_ref(NULL, img1, ptr, WIDTH, h);
+            d1 = call_new(NULL, img1, ptr, WIDTH, h);
 
             if (d1 != d2) {
                 fail();
-                printf("func: %s, x=%d y=%d, error: asm=%d c=%d\n", name, x, y, d1, d2);
+                printf("func: %s, x=%d y=%d h=%d, error: asm=%d c=%d\n", name, x, y, h, d1, d2);
                 break;
             }
         }
-        // benchmark with the final value of ptr
+        // Test with a fixed offset, for benchmark stability
+        ptr = img2 + 3 * WIDTH + 3;
         bench_new(NULL, img1, ptr, WIDTH, 8);
     }
 }
diff --git a/tests/checkasm/sw_scale.c b/tests/checkasm/sw_scale.c
index b643a47..cbe4460 100644
--- a/tests/checkasm/sw_scale.c
+++ b/tests/checkasm/sw_scale.c
@@ -35,40 +35,140 @@
             AV_WN32(buf + j, rnd());      \
     } while (0)
 
-// This reference function is the same approximate algorithm employed by the
-// SIMD functions
-static void ref_function(const int16_t *filter, int filterSize,
-                                                 const int16_t **src, uint8_t *dest, int dstW,
-                                                 const uint8_t *dither, int offset)
+static void yuv2planeX_8_ref(const int16_t *filter, int filterSize,
+                             const int16_t **src, uint8_t *dest, int dstW,
+                             const uint8_t *dither, int offset)
 {
-    int i, d;
-    d = ((filterSize - 1) * 8 + dither[0]) >> 4;
-    for ( i = 0; i < dstW; i++) {
-        int16_t val = d;
+    // This corresponds to the yuv2planeX_8_c function
+    int i;
+    for (i = 0; i < dstW; i++) {
+        int val = dither[(i + offset) & 7] << 12;
         int j;
-        union {
-            int val;
-            int16_t v[2];
-        } t;
-        for (j = 0; j < filterSize; j++){
-            t.val = (int)src[j][i + offset] * (int)filter[j];
-            val += t.v[1];
+        for (j = 0; j < filterSize; j++)
+            val += src[j][i] * filter[j];
+
+        dest[i]= av_clip_uint8(val >> 19);
+    }
+}
+
+static int cmp_off_by_n(const uint8_t *ref, const uint8_t *test, size_t n, int accuracy)
+{
+    for (size_t i = 0; i < n; i++) {
+        if (abs(ref[i] - test[i]) > accuracy)
+            return 1;
+    }
+    return 0;
+}
+
+static void print_data(uint8_t *p, size_t len, size_t offset)
+{
+    size_t i = 0;
+    for (; i < len; i++) {
+        if (i % 8 == 0) {
+            printf("0x%04zx: ", i+offset);
         }
-        dest[i]= av_clip_uint8(val>>3);
+        printf("0x%02x ", (uint32_t) p[i]);
+        if (i % 8 == 7) {
+            printf("\n");
+        }
+    }
+    if (i % 8 != 0) {
+        printf("\n");
     }
 }
 
-static void check_yuv2yuvX(void)
+static size_t show_differences(uint8_t *a, uint8_t *b, size_t len)
+{
+    for (size_t i = 0; i < len; i++) {
+        if (a[i] != b[i]) {
+            size_t offset_of_mismatch = i;
+            size_t offset;
+            if (i >= 8) i-=8;
+            offset = i & (~7);
+            printf("test a:\n");
+            print_data(&a[offset], 32, offset);
+            printf("\ntest b:\n");
+            print_data(&b[offset], 32, offset);
+            printf("\n");
+            return offset_of_mismatch;
+        }
+    }
+    return len;
+}
+
+static void check_yuv2yuv1(int accurate)
+{
+    struct SwsContext *ctx;
+    int osi, isi;
+    int dstW, offset;
+    size_t fail_offset;
+    const int input_sizes[] = {8, 24, 128, 144, 256, 512};
+    const int INPUT_SIZES = sizeof(input_sizes)/sizeof(input_sizes[0]);
+    #define LARGEST_INPUT_SIZE 512
+
+    const int offsets[] = {0, 3, 8, 11, 16, 19};
+    const int OFFSET_SIZES = sizeof(offsets)/sizeof(offsets[0]);
+    const char *accurate_str = (accurate) ? "accurate" : "approximate";
+
+    declare_func_emms(AV_CPU_FLAG_MMX, void,
+                      const int16_t *src, uint8_t *dest,
+                      int dstW, const uint8_t *dither, int offset);
+
+    LOCAL_ALIGNED_16(int16_t, src_pixels, [LARGEST_INPUT_SIZE]);
+    LOCAL_ALIGNED_16(uint8_t, dst0, [LARGEST_INPUT_SIZE]);
+    LOCAL_ALIGNED_16(uint8_t, dst1, [LARGEST_INPUT_SIZE]);
+    LOCAL_ALIGNED_8(uint8_t, dither, [8]);
+
+    randomize_buffers((uint8_t*)dither, 8);
+    randomize_buffers((uint8_t*)src_pixels, LARGEST_INPUT_SIZE * sizeof(int16_t));
+    ctx = sws_alloc_context();
+    if (accurate)
+        ctx->flags |= SWS_ACCURATE_RND;
+    if (sws_init_context(ctx, NULL, NULL) < 0)
+        fail();
+
+    ff_sws_init_scale(ctx);
+    for (isi = 0; isi < INPUT_SIZES; ++isi) {
+        dstW = input_sizes[isi];
+        for (osi = 0; osi < OFFSET_SIZES; osi++) {
+            offset = offsets[osi];
+            if (check_func(ctx->yuv2plane1, "yuv2yuv1_%d_%d_%s", offset, dstW, accurate_str)){
+                memset(dst0, 0, LARGEST_INPUT_SIZE * sizeof(dst0[0]));
+                memset(dst1, 0, LARGEST_INPUT_SIZE * sizeof(dst1[0]));
+
+                call_ref(src_pixels, dst0, dstW, dither, offset);
+                call_new(src_pixels, dst1, dstW, dither, offset);
+                if (cmp_off_by_n(dst0, dst1, dstW * sizeof(dst0[0]), accurate ? 0 : 2)) {
+                    fail();
+                    printf("failed: yuv2yuv1_%d_%di_%s\n", offset, dstW, accurate_str);
+                    fail_offset = show_differences(dst0, dst1, LARGEST_INPUT_SIZE * sizeof(dst0[0]));
+                    printf("failing values: src: 0x%04x dither: 0x%02x dst-c: %02x dst-asm: %02x\n",
+                            (int) src_pixels[fail_offset],
+                            (int) dither[(fail_offset + fail_offset) & 7],
+                            (int) dst0[fail_offset],
+                            (int) dst1[fail_offset]);
+                }
+                if(dstW == LARGEST_INPUT_SIZE)
+                    bench_new(src_pixels, dst1, dstW, dither, offset);
+            }
+        }
+    }
+    sws_freeContext(ctx);
+}
+
+static void check_yuv2yuvX(int accurate)
 {
     struct SwsContext *ctx;
     int fsi, osi, isi, i, j;
     int dstW;
 #define LARGEST_FILTER 16
-#define FILTER_SIZES 4
-    static const int filter_sizes[FILTER_SIZES] = {1, 4, 8, 16};
+    // ff_yuv2planeX_8_sse2 can't handle odd filter sizes
+    const int filter_sizes[] = {2, 4, 8, 16};
+    const int FILTER_SIZES = sizeof(filter_sizes)/sizeof(filter_sizes[0]);
 #define LARGEST_INPUT_SIZE 512
-#define INPUT_SIZES 6
-    static const int input_sizes[INPUT_SIZES] = {8, 24, 128, 144, 256, 512};
+    static const int input_sizes[] = {8, 24, 128, 144, 256, 512};
+    const int INPUT_SIZES = sizeof(input_sizes)/sizeof(input_sizes[0]);
+    const char *accurate_str = (accurate) ? "accurate" : "approximate";
 
     declare_func_emms(AV_CPU_FLAG_MMX, void, const int16_t *filter,
                       int filterSize, const int16_t **src, uint8_t *dest,
@@ -89,6 +189,8 @@ static void check_yuv2yuvX(void)
     randomize_buffers((uint8_t*)src_pixels, LARGEST_FILTER * LARGEST_INPUT_SIZE * sizeof(int16_t));
     randomize_buffers((uint8_t*)filter_coeff, LARGEST_FILTER * sizeof(int16_t));
     ctx = sws_alloc_context();
+    if (accurate)
+        ctx->flags |= SWS_ACCURATE_RND;
     if (sws_init_context(ctx, NULL, NULL) < 0)
         fail();
 
@@ -96,33 +198,37 @@ static void check_yuv2yuvX(void)
     for(isi = 0; isi < INPUT_SIZES; ++isi){
         dstW = input_sizes[isi];
         for(osi = 0; osi < 64; osi += 16){
-            for(fsi = 0; fsi < FILTER_SIZES; ++fsi){
+            if (dstW <= osi)
+                continue;
+            for (fsi = 0; fsi < FILTER_SIZES; ++fsi) {
                 src = av_malloc(sizeof(int16_t*) * filter_sizes[fsi]);
                 vFilterData = av_malloc((filter_sizes[fsi] + 2) * sizeof(union VFilterData));
                 memset(vFilterData, 0, (filter_sizes[fsi] + 2) * sizeof(union VFilterData));
-                for(i = 0; i < filter_sizes[fsi]; ++i){
+                for (i = 0; i < filter_sizes[fsi]; ++i) {
                     src[i] = &src_pixels[i * LARGEST_INPUT_SIZE];
-                    vFilterData[i].src = src[i];
+                    vFilterData[i].src = src[i] - osi;
                     for(j = 0; j < 4; ++j)
                         vFilterData[i].coeff[j + 4] = filter_coeff[i];
                 }
-                if (check_func(ctx->yuv2planeX, "yuv2yuvX_%d_%d_%d", filter_sizes[fsi], osi, dstW)){
+                if (check_func(ctx->yuv2planeX, "yuv2yuvX_%d_%d_%d_%s", filter_sizes[fsi], osi, dstW, accurate_str)){
+                    // use vFilterData for the mmx function
+                    const int16_t *filter = ctx->use_mmx_vfilter ? (const int16_t*)vFilterData : &filter_coeff[0];
                     memset(dst0, 0, LARGEST_INPUT_SIZE * sizeof(dst0[0]));
                     memset(dst1, 0, LARGEST_INPUT_SIZE * sizeof(dst1[0]));
 
-                    // The reference function is not the scalar function selected when mmx
-                    // is deactivated as the SIMD functions do not give the same result as
-                    // the scalar ones due to rounding. The SIMD functions are activated by
-                    // the flag SWS_ACCURATE_RND
-                    ref_function(&filter_coeff[0], filter_sizes[fsi], src, dst0, dstW - osi, dither, osi);
-                    // There's no point in calling new for the reference function
-                    if(ctx->use_mmx_vfilter){
-                        call_new((const int16_t*)vFilterData, filter_sizes[fsi], src, dst1, dstW - osi, dither, osi);
-                        if (memcmp(dst0, dst1, LARGEST_INPUT_SIZE * sizeof(dst0[0])))
-                            fail();
-                        if(dstW == LARGEST_INPUT_SIZE)
-                            bench_new((const int16_t*)vFilterData, filter_sizes[fsi], src, dst1, dstW - osi, dither, osi);
+                    // We can't use call_ref here, because we don't know if use_mmx_vfilter was set for that
+                    // function or not, so we can't pass it the parameters correctly.
+                    yuv2planeX_8_ref(&filter_coeff[0], filter_sizes[fsi], src, dst0, dstW - osi, dither, osi);
+
+                    call_new(filter, filter_sizes[fsi], src, dst1, dstW - osi, dither, osi);
+                    if (cmp_off_by_n(dst0, dst1, LARGEST_INPUT_SIZE * sizeof(dst0[0]), accurate ? 0 : 2)) {
+                        fail();
+                        printf("failed: yuv2yuvX_%d_%d_%d_%s\n", filter_sizes[fsi], osi, dstW, accurate_str);
+                        show_differences(dst0, dst1, LARGEST_INPUT_SIZE * sizeof(dst0[0]));
                     }
+                    if(dstW == LARGEST_INPUT_SIZE)
+                        bench_new((const int16_t*)vFilterData, filter_sizes[fsi], src, dst1, dstW - osi, dither, osi);
+
                 }
                 av_freep(&src);
                 av_freep(&vFilterData);
@@ -245,6 +351,10 @@ void checkasm_check_sw_scale(void)
 {
     check_hscale();
     report("hscale");
-    check_yuv2yuvX();
+    check_yuv2yuv1(0);
+    check_yuv2yuv1(1);
+    report("yuv2yuv1");
+    check_yuv2yuvX(0);
+    check_yuv2yuvX(1);
     report("yuv2yuvX");
 }
diff --git a/tests/fate/ffmpeg.mak b/tests/fate/ffmpeg.mak
index 94f5042..38a1ae7 100644
--- a/tests/fate/ffmpeg.mak
+++ b/tests/fate/ffmpeg.mak
@@ -99,6 +99,14 @@ FATE_SAMPLES_FFMPEG-$(call FILTERDEMDEC, AMIX ARESAMPLE SINE, RAWVIDEO, \
 fate-shortest: tests/data/vsynth_lena.yuv
 fate-shortest: CMD = framecrc -auto_conversion_filters -f lavfi -i "sine=3000:d=10" -f lavfi -i "sine=1000:d=1" -sws_flags +accurate_rnd+bitexact -fflags +bitexact -flags +bitexact -idct simple -f rawvideo -s 352x288 -pix_fmt yuv420p -i $(TARGET_PATH)/tests/data/vsynth_lena.yuv -filter_complex "[0:a:0][1:a:0]amix=inputs=2[audio]" -map 2:v:0 -map "[audio]" -sws_flags +accurate_rnd+bitexact -fflags +bitexact -flags +bitexact -idct simple -dct fastint -qscale 10 -threads 1 -c:v mpeg4 -c:a ac3_fixed -shortest
 
+# test interleaving video with a sparse subtitle stream
+FATE_SAMPLES_FFMPEG-$(call ALLYES, COLOR_FILTER, VOBSUB_DEMUXER, MATROSKA_DEMUXER,, \
+                           RAWVIDEO_ENCODER, MATROSKA_MUXER, FRAMECRC_MUXER) += fate-shortest-sub
+fate-shortest-sub: CMD = enc_dec                                                                      \
+        vobsub $(TARGET_SAMPLES)/sub/vobsub.idx matroska                                              \
+        "-filter_complex 'color=s=1x1:rate=1:duration=400' -pix_fmt rgb24 -allow_raw_vfw 1 -c:s copy -c:v rawvideo"  \
+        framecrc "-map 0 -c copy -shortest -shortest_buf_duration 40"
+
 # Basic test for fix_sub_duration, which calculates duration based on the
 # following subtitle's pts.
 FATE_SAMPLES_FFMPEG-$(call FILTERDEMDECENCMUX, MOVIE, MPEGVIDEO, \
diff --git a/tests/fate/filter-video.mak b/tests/fate/filter-video.mak
index faed832..372c70b 100644
--- a/tests/fate/filter-video.mak
+++ b/tests/fate/filter-video.mak
@@ -641,11 +641,17 @@ FATE_METADATA_FILTER-$(call ALLYES, $(SCDET_DEPS)) += fate-filter-metadata-scdet
 fate-filter-metadata-scdet: SRC = $(TARGET_SAMPLES)/svq3/Vertical400kbit.sorenson3.mov
 fate-filter-metadata-scdet: CMD = run $(FILTER_METADATA_COMMAND) "sws_flags=+accurate_rnd+bitexact;movie='$(SRC)',scdet=s=1"
 
-CROPDETECT_DEPS = LAVFI_INDEV FILE_PROTOCOL MOVIE_FILTER CROPDETECT_FILTER \
+CROPDETECT_DEPS = LAVFI_INDEV FILE_PROTOCOL MOVIE_FILTER MOVIE_FILTER MESTIMATE_FILTER CROPDETECT_FILTER \
                   SCALE_FILTER MOV_DEMUXER H264_DECODER
 FATE_METADATA_FILTER-$(call ALLYES, $(CROPDETECT_DEPS)) += fate-filter-metadata-cropdetect
 fate-filter-metadata-cropdetect: SRC = $(TARGET_SAMPLES)/filter/cropdetect.mp4
 fate-filter-metadata-cropdetect: CMD = run $(FILTER_METADATA_COMMAND) "sws_flags=+accurate_rnd+bitexact;movie='$(SRC)',cropdetect=max_outliers=3"
+FATE_METADATA_FILTER-$(call ALLYES, $(CROPDETECT_DEPS)) += fate-filter-metadata-cropdetect1
+fate-filter-metadata-cropdetect1: SRC = $(TARGET_SAMPLES)/filter/cropdetect1.mp4
+fate-filter-metadata-cropdetect1: CMD = run $(FILTER_METADATA_COMMAND) "sws_flags=+accurate_rnd+bitexact;movie='$(SRC)',mestimate,cropdetect=mode=mvedges,metadata=mode=print"
+FATE_METADATA_FILTER-$(call ALLYES, $(CROPDETECT_DEPS)) += fate-filter-metadata-cropdetect2
+fate-filter-metadata-cropdetect2: SRC = $(TARGET_SAMPLES)/filter/cropdetect2.mp4
+fate-filter-metadata-cropdetect2: CMD = run $(FILTER_METADATA_COMMAND) "sws_flags=+accurate_rnd+bitexact;movie='$(SRC)',mestimate,cropdetect=mode=mvedges,metadata=mode=print"
 
 FREEZEDETECT_DEPS = LAVFI_INDEV MPTESTSRC_FILTER SCALE_FILTER FREEZEDETECT_FILTER
 FATE_METADATA_FILTER-$(call ALLYES, $(FREEZEDETECT_DEPS)) += fate-filter-metadata-freezedetect
diff --git a/tests/fate/hevc.mak b/tests/fate/hevc.mak
index 2f16e3a..6c1e744 100644
--- a/tests/fate/hevc.mak
+++ b/tests/fate/hevc.mak
@@ -141,6 +141,7 @@ HEVC_SAMPLES_8BIT =             \
     WPP_D_ericsson_MAIN_2       \
     WPP_E_ericsson_MAIN_2       \
     WPP_F_ericsson_MAIN_2       \
+    WPP_HIGH_TP_444_8BIT_RExt_Apple_2 \
 
 HEVC_SAMPLES_10BIT =            \
     DBLK_A_MAIN10_VIXS_3        \
diff --git a/tests/fate/image.mak b/tests/fate/image.mak
index fca4eaf..03e794d 100644
--- a/tests/fate/image.mak
+++ b/tests/fate/image.mak
@@ -392,6 +392,10 @@ fate-png-side-data: CMD = run ffprobe$(PROGSSUF)$(EXESUF) -show_frames \
 FATE_PNG_TRANSCODE-$(call TRANSCODE, PNG, IMAGE2 IMAGE_PNG_PIPE) += fate-png-icc
 fate-png-icc: CMD = transcode png_pipe $(TARGET_SAMPLES)/png1/lena-int_rgb24.png image2 "-c png" "" "-show_frames"
 
+FATE_PNG_PROBE-$(call ALLYES, LCMS2) += fate-png-icc-parse
+fate-png-icc-parse: CMD = run ffprobe$(PROGSSUF)$(EXESUF) -show_frames \
+    -flags2 icc_profiles $(TARGET_SAMPLES)/png1/lena-int_rgb24.png
+
 FATE_PNG-$(call DEMDEC, IMAGE2, PNG) += $(FATE_PNG)
 FATE_PNG_PROBE-$(call DEMDEC, IMAGE2, PNG) += $(FATE_PNG_PROBE)
 FATE_IMAGE_FRAMECRC += $(FATE_PNG-yes)
diff --git a/tests/fate/lavf-image.mak b/tests/fate/lavf-image.mak
index 6d61233..784c85a 100644
--- a/tests/fate/lavf-image.mak
+++ b/tests/fate/lavf-image.mak
@@ -43,6 +43,7 @@ FATE_LAVF_IMAGES-$(call LAVF_IMAGES,     SUNRAST) += sun
 FATE_LAVF_IMAGES-$(call LAVF_IMAGES,       TARGA) += tga
 FATE_LAVF_IMAGES-$(call LAVF_IMAGES,        TIFF) += tiff
 FATE_LAVF_IMAGES-$(call LAVF_IMAGES,         QOI) += qoi
+FATE_LAVF_IMAGES-$(call LAVF_IMAGES,        WBMP) += wbmp
 FATE_LAVF_IMAGES-$(call LAVF_IMAGES,         XBM) += xbm
 FATE_LAVF_IMAGES-$(call LAVF_IMAGES,         XWD) += xwd
 FATE_LAVF_IMAGES-$(call LAVF_IMAGES,         XWD) += rgba.xwd
diff --git a/tests/ref/fate/audiomatch-afconvert-16000-mono-he-m4a b/tests/ref/fate/audiomatch-afconvert-16000-mono-he-m4a
index f6f8df5..b8fd039 100644
--- a/tests/ref/fate/audiomatch-afconvert-16000-mono-he-m4a
+++ b/tests/ref/fate/audiomatch-afconvert-16000-mono-he-m4a
@@ -1 +1 @@
-presig: 481 postsig:223 c: 0.9835 lenerr:704
+presig: 1537 postsig:223 c: 0.9835 lenerr:1760
diff --git a/tests/ref/fate/audiomatch-afconvert-16000-stereo-he-m4a b/tests/ref/fate/audiomatch-afconvert-16000-stereo-he-m4a
index 9ba0ef2..b0381bf 100644
--- a/tests/ref/fate/audiomatch-afconvert-16000-stereo-he-m4a
+++ b/tests/ref/fate/audiomatch-afconvert-16000-stereo-he-m4a
@@ -1 +1 @@
-presig: 962 postsig:446 c: 0.9895 lenerr:1408
+presig: 3074 postsig:446 c: 0.9895 lenerr:3520
diff --git a/tests/ref/fate/audiomatch-afconvert-16000-stereo-he2-m4a b/tests/ref/fate/audiomatch-afconvert-16000-stereo-he2-m4a
index d4fc21b..0b16a52 100644
--- a/tests/ref/fate/audiomatch-afconvert-16000-stereo-he2-m4a
+++ b/tests/ref/fate/audiomatch-afconvert-16000-stereo-he2-m4a
@@ -1 +1 @@
-presig: 962 postsig:446 c: 0.9839 lenerr:1408
+presig: 3074 postsig:446 c: 0.9839 lenerr:3520
diff --git a/tests/ref/fate/audiomatch-afconvert-44100-mono-he-m4a b/tests/ref/fate/audiomatch-afconvert-44100-mono-he-m4a
index 0ad4911..34921ed 100644
--- a/tests/ref/fate/audiomatch-afconvert-44100-mono-he-m4a
+++ b/tests/ref/fate/audiomatch-afconvert-44100-mono-he-m4a
@@ -1 +1 @@
-presig: 962 postsig:822 c: 0.9911 lenerr:1784
+presig: 3074 postsig:822 c: 0.9911 lenerr:3896
diff --git a/tests/ref/fate/audiomatch-afconvert-44100-stereo-he-m4a b/tests/ref/fate/audiomatch-afconvert-44100-stereo-he-m4a
index ff5540b..3bab086 100644
--- a/tests/ref/fate/audiomatch-afconvert-44100-stereo-he-m4a
+++ b/tests/ref/fate/audiomatch-afconvert-44100-stereo-he-m4a
@@ -1 +1 @@
-presig: 1924 postsig:1644 c: 0.9890 lenerr:3568
+presig: 6148 postsig:1644 c: 0.9890 lenerr:7792
diff --git a/tests/ref/fate/audiomatch-afconvert-44100-stereo-he2-m4a b/tests/ref/fate/audiomatch-afconvert-44100-stereo-he2-m4a
index f8214cf..27341f5 100644
--- a/tests/ref/fate/audiomatch-afconvert-44100-stereo-he2-m4a
+++ b/tests/ref/fate/audiomatch-afconvert-44100-stereo-he2-m4a
@@ -1 +1 @@
-presig: 1924 postsig:1644 c: 0.9909 lenerr:3568
+presig: 6148 postsig:1644 c: 0.9909 lenerr:7792
diff --git a/tests/ref/fate/audiomatch-nero-16000-mono-he-m4a b/tests/ref/fate/audiomatch-nero-16000-mono-he-m4a
index 4ee764e..fb62ae0 100644
--- a/tests/ref/fate/audiomatch-nero-16000-mono-he-m4a
+++ b/tests/ref/fate/audiomatch-nero-16000-mono-he-m4a
@@ -1 +1 @@
-presig: -4 postsig:196 c: 0.9736 lenerr:192
+presig: 2332 postsig:196 c: 0.9736 lenerr:2528
diff --git a/tests/ref/fate/audiomatch-nero-16000-stereo-he-m4a b/tests/ref/fate/audiomatch-nero-16000-stereo-he-m4a
index cdc31c1..4a30bec 100644
--- a/tests/ref/fate/audiomatch-nero-16000-stereo-he-m4a
+++ b/tests/ref/fate/audiomatch-nero-16000-stereo-he-m4a
@@ -1 +1 @@
-presig: -8 postsig:392 c: 0.9777 lenerr:384
+presig: 4664 postsig:392 c: 0.9777 lenerr:5056
diff --git a/tests/ref/fate/audiomatch-nero-16000-stereo-he2-m4a b/tests/ref/fate/audiomatch-nero-16000-stereo-he2-m4a
index 74d5497..22aed2a 100644
--- a/tests/ref/fate/audiomatch-nero-16000-stereo-he2-m4a
+++ b/tests/ref/fate/audiomatch-nero-16000-stereo-he2-m4a
@@ -1 +1 @@
-presig: 2 postsig:2590 c: 0.9934 lenerr:2592
+presig: 5618 postsig:2590 c: 0.9934 lenerr:8208
diff --git a/tests/ref/fate/audiomatch-nero-44100-mono-he-m4a b/tests/ref/fate/audiomatch-nero-44100-mono-he-m4a
index b5dcd9d..66ebd92 100644
--- a/tests/ref/fate/audiomatch-nero-44100-mono-he-m4a
+++ b/tests/ref/fate/audiomatch-nero-44100-mono-he-m4a
@@ -1 +1 @@
-presig: 0 postsig:1336 c: 0.9973 lenerr:1336
+presig: 2336 postsig:1336 c: 0.9973 lenerr:3672
diff --git a/tests/ref/fate/audiomatch-nero-44100-stereo-he-m4a b/tests/ref/fate/audiomatch-nero-44100-stereo-he-m4a
index 42a87c0..a7d1d9f 100644
--- a/tests/ref/fate/audiomatch-nero-44100-stereo-he-m4a
+++ b/tests/ref/fate/audiomatch-nero-44100-stereo-he-m4a
@@ -1 +1 @@
-presig: -2 postsig:2674 c: 0.9986 lenerr:2672
+presig: 4670 postsig:2674 c: 0.9986 lenerr:7344
diff --git a/tests/ref/fate/audiomatch-nero-44100-stereo-he2-m4a b/tests/ref/fate/audiomatch-nero-44100-stereo-he2-m4a
index 3fa2cdb..4da8519 100644
--- a/tests/ref/fate/audiomatch-nero-44100-stereo-he2-m4a
+++ b/tests/ref/fate/audiomatch-nero-44100-stereo-he2-m4a
@@ -1 +1 @@
-presig: 2 postsig:782 c: 0.9980 lenerr:784
+presig: 5618 postsig:782 c: 0.9980 lenerr:6400
diff --git a/tests/ref/fate/copy-shortest1 b/tests/ref/fate/copy-shortest1
index 5038973..87bee4c 100644
--- a/tests/ref/fate/copy-shortest1
+++ b/tests/ref/fate/copy-shortest1
@@ -120,4 +120,3 @@
 0,      98304,      98304,     2048,    11182, e35a2ab846029effdbca0e43639717f2
 1,      85760,      85760,     1536,      418, cf52ea7fc69e4c5bc8f75b354dfe60af
 0,     100352,     100352,     2048,     1423, f480272c7d0b97834bc8ea36cceca61d
-1,      87296,      87296,     1536,      418, 78ab22657a1b6c8a0e5b8612ceb8081d
diff --git a/tests/ref/fate/copy-shortest2 b/tests/ref/fate/copy-shortest2
index 5038973..87bee4c 100644
--- a/tests/ref/fate/copy-shortest2
+++ b/tests/ref/fate/copy-shortest2
@@ -120,4 +120,3 @@
 0,      98304,      98304,     2048,    11182, e35a2ab846029effdbca0e43639717f2
 1,      85760,      85760,     1536,      418, cf52ea7fc69e4c5bc8f75b354dfe60af
 0,     100352,     100352,     2048,     1423, f480272c7d0b97834bc8ea36cceca61d
-1,      87296,      87296,     1536,      418, 78ab22657a1b6c8a0e5b8612ceb8081d
diff --git a/tests/ref/fate/exif-image-embedded b/tests/ref/fate/exif-image-embedded
index 11005fb..210d7b5 100644
--- a/tests/ref/fate/exif-image-embedded
+++ b/tests/ref/fate/exif-image-embedded
@@ -10,6 +10,8 @@ best_effort_timestamp=N/A
 best_effort_timestamp_time=N/A
 pkt_duration=N/A
 pkt_duration_time=N/A
+duration=N/A
+duration_time=N/A
 pkt_pos=N/A
 pkt_size=15760
 width=263
@@ -42,6 +44,8 @@ best_effort_timestamp=353600
 best_effort_timestamp_time=0.025057
 pkt_duration=15040
 pkt_duration_time=0.001066
+duration=15040
+duration_time=0.001066
 pkt_pos=16292
 pkt_size=417
 sample_fmt=fltp
@@ -61,6 +65,8 @@ best_effort_timestamp=368640
 best_effort_timestamp_time=0.026122
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=16709
 pkt_size=418
 sample_fmt=fltp
@@ -80,6 +86,8 @@ best_effort_timestamp=737280
 best_effort_timestamp_time=0.052245
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=17127
 pkt_size=418
 sample_fmt=fltp
@@ -99,6 +107,8 @@ best_effort_timestamp=1105920
 best_effort_timestamp_time=0.078367
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=17545
 pkt_size=418
 sample_fmt=fltp
@@ -118,6 +128,8 @@ best_effort_timestamp=1474560
 best_effort_timestamp_time=0.104490
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=17963
 pkt_size=418
 sample_fmt=fltp
@@ -137,6 +149,8 @@ best_effort_timestamp=1843200
 best_effort_timestamp_time=0.130612
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=18381
 pkt_size=418
 sample_fmt=fltp
@@ -156,6 +170,8 @@ best_effort_timestamp=2211840
 best_effort_timestamp_time=0.156735
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=18799
 pkt_size=418
 sample_fmt=fltp
@@ -175,6 +191,8 @@ best_effort_timestamp=2580480
 best_effort_timestamp_time=0.182857
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=19217
 pkt_size=418
 sample_fmt=fltp
@@ -194,6 +212,8 @@ best_effort_timestamp=2949120
 best_effort_timestamp_time=0.208980
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=19635
 pkt_size=418
 sample_fmt=fltp
@@ -213,6 +233,8 @@ best_effort_timestamp=3317760
 best_effort_timestamp_time=0.235102
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=20053
 pkt_size=418
 sample_fmt=fltp
@@ -232,6 +254,8 @@ best_effort_timestamp=3686400
 best_effort_timestamp_time=0.261224
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=20471
 pkt_size=418
 sample_fmt=fltp
@@ -251,6 +275,8 @@ best_effort_timestamp=4055040
 best_effort_timestamp_time=0.287347
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=20889
 pkt_size=418
 sample_fmt=fltp
@@ -270,6 +296,8 @@ best_effort_timestamp=4423680
 best_effort_timestamp_time=0.313469
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=21307
 pkt_size=418
 sample_fmt=fltp
@@ -289,6 +317,8 @@ best_effort_timestamp=4792320
 best_effort_timestamp_time=0.339592
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=21725
 pkt_size=418
 sample_fmt=fltp
@@ -308,6 +338,8 @@ best_effort_timestamp=5160960
 best_effort_timestamp_time=0.365714
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=22143
 pkt_size=418
 sample_fmt=fltp
@@ -327,6 +359,8 @@ best_effort_timestamp=5529600
 best_effort_timestamp_time=0.391837
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=22561
 pkt_size=418
 sample_fmt=fltp
@@ -346,6 +380,8 @@ best_effort_timestamp=5898240
 best_effort_timestamp_time=0.417959
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=22979
 pkt_size=418
 sample_fmt=fltp
@@ -365,6 +401,8 @@ best_effort_timestamp=6266880
 best_effort_timestamp_time=0.444082
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=23397
 pkt_size=418
 sample_fmt=fltp
@@ -384,6 +422,8 @@ best_effort_timestamp=6635520
 best_effort_timestamp_time=0.470204
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=23815
 pkt_size=418
 sample_fmt=fltp
@@ -403,6 +443,8 @@ best_effort_timestamp=7004160
 best_effort_timestamp_time=0.496327
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=24233
 pkt_size=418
 sample_fmt=fltp
@@ -422,6 +464,8 @@ best_effort_timestamp=7372800
 best_effort_timestamp_time=0.522449
 pkt_duration=368640
 pkt_duration_time=0.026122
+duration=368640
+duration_time=0.026122
 pkt_pos=24651
 pkt_size=418
 sample_fmt=fltp
diff --git a/tests/ref/fate/exif-image-jpg b/tests/ref/fate/exif-image-jpg
index b942fc5..2d5fe18 100644
--- a/tests/ref/fate/exif-image-jpg
+++ b/tests/ref/fate/exif-image-jpg
@@ -10,6 +10,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1
 pkt_duration_time=0.040000
+duration=1
+duration_time=0.040000
 pkt_pos=N/A
 pkt_size=46095
 width=400
@@ -27,30 +29,30 @@ color_space=bt470bg
 color_primaries=unknown
 color_transfer=unknown
 chroma_location=center
-TAG:ImageDescription=
+TAG:ImageDescription=                               
 TAG:Make=Canon
 TAG:Model=Canon PowerShot SX200 IS
 TAG:Orientation=    1
-TAG:XResolution=    180:1
-TAG:YResolution=    180:1
+TAG:XResolution=    180:1      
+TAG:YResolution=    180:1      
 TAG:ResolutionUnit=    2
 TAG:DateTime=2013:07:18 13:12:03
 TAG:YCbCrPositioning=    2
-TAG:ExposureTime=      1:1250
-TAG:FNumber=     40:10
+TAG:ExposureTime=      1:1250   
+TAG:FNumber=     40:10     
 TAG:ISOSpeedRatings=  160
 TAG:ExifVersion= 48,  50,  50,  49
 TAG:DateTimeOriginal=2013:07:18 13:12:03
 TAG:DateTimeDigitized=2013:07:18 13:12:03
 TAG:ComponentsConfiguration=  1,   2,   3,   0
-TAG:CompressedBitsPerPixel=      3:1
-TAG:ShutterSpeedValue=    329:32
-TAG:ApertureValue=    128:32
-TAG:ExposureBiasValue=      0:3
-TAG:MaxApertureValue=    113:32
+TAG:CompressedBitsPerPixel=      3:1      
+TAG:ShutterSpeedValue=    329:32     
+TAG:ApertureValue=    128:32     
+TAG:ExposureBiasValue=      0:3      
+TAG:MaxApertureValue=    113:32     
 TAG:MeteringMode=    5
 TAG:Flash=   16
-TAG:FocalLength=   5000:1000
+TAG:FocalLength=   5000:1000   
 TAG:MakerNote=
  25,   0,   1,   0,   3,   0,  48,   0,   0,   0,  28,   4,   0,   0,   2,   0
   3,   0,   4,   0,   0,   0, 124,   4,   0,   0,   3,   0,   3,   0,   4,   0
@@ -219,14 +221,14 @@ TAG:GPSLatitudeRef=R98
 TAG:GPSLatitude= 48,  49,  48,  48
 TAG:0x1001= 4000
 TAG:0x1002= 2248
-TAG:FocalPlaneXResolution=4000000:244
-TAG:FocalPlaneYResolution=2248000:183
+TAG:FocalPlaneXResolution=4000000:244    
+TAG:FocalPlaneYResolution=2248000:183    
 TAG:FocalPlaneResolutionUnit=    2
 TAG:SensingMethod=    2
 TAG:FileSource=  3
 TAG:CustomRendered=    0
 TAG:ExposureMode=    0
 TAG:WhiteBalance=    0
-TAG:DigitalZoomRatio=   4000:4000
+TAG:DigitalZoomRatio=   4000:4000   
 TAG:SceneCaptureType=    0
 [/FRAME]
diff --git a/tests/ref/fate/exif-image-tiff b/tests/ref/fate/exif-image-tiff
index 30be91b..e447a46 100644
--- a/tests/ref/fate/exif-image-tiff
+++ b/tests/ref/fate/exif-image-tiff
@@ -10,6 +10,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1
 pkt_duration_time=0.040000
+duration=1
+duration_time=0.040000
 pkt_pos=0
 pkt_size=67604
 width=200
diff --git a/tests/ref/fate/exif-image-webp b/tests/ref/fate/exif-image-webp
index f78ffc9..477986c 100644
--- a/tests/ref/fate/exif-image-webp
+++ b/tests/ref/fate/exif-image-webp
@@ -10,6 +10,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1
 pkt_duration_time=0.040000
+duration=1
+duration_time=0.040000
 pkt_pos=0
 pkt_size=39276
 width=400
@@ -27,30 +29,30 @@ color_space=bt470bg
 color_primaries=unknown
 color_transfer=unknown
 chroma_location=unspecified
-TAG:ImageDescription=
+TAG:ImageDescription=                               
 TAG:Make=Canon
 TAG:Model=Canon PowerShot SX200 IS
 TAG:Orientation=    1
-TAG:XResolution=    180:1
-TAG:YResolution=    180:1
+TAG:XResolution=    180:1      
+TAG:YResolution=    180:1      
 TAG:ResolutionUnit=    2
 TAG:DateTime=2013:07:18 13:12:03
 TAG:YCbCrPositioning=    2
-TAG:ExposureTime=      1:1250
-TAG:FNumber=     40:10
+TAG:ExposureTime=      1:1250   
+TAG:FNumber=     40:10     
 TAG:ISOSpeedRatings=  160
 TAG:ExifVersion= 48,  50,  50,  49
 TAG:DateTimeOriginal=2013:07:18 13:12:03
 TAG:DateTimeDigitized=2013:07:18 13:12:03
 TAG:ComponentsConfiguration=  1,   2,   3,   0
-TAG:CompressedBitsPerPixel=      3:1
-TAG:ShutterSpeedValue=    329:32
-TAG:ApertureValue=    128:32
-TAG:ExposureBiasValue=      0:3
-TAG:MaxApertureValue=    113:32
+TAG:CompressedBitsPerPixel=      3:1      
+TAG:ShutterSpeedValue=    329:32     
+TAG:ApertureValue=    128:32     
+TAG:ExposureBiasValue=      0:3      
+TAG:MaxApertureValue=    113:32     
 TAG:MeteringMode=    5
 TAG:Flash=   16
-TAG:FocalLength=   5000:1000
+TAG:FocalLength=   5000:1000   
 TAG:MakerNote=
  25,   0,   1,   0,   3,   0,  48,   0,   0,   0,  28,   4,   0,   0,   2,   0
   3,   0,   4,   0,   0,   0, 124,   4,   0,   0,   3,   0,   3,   0,   4,   0
@@ -219,14 +221,14 @@ TAG:GPSLatitudeRef=R98
 TAG:GPSLatitude= 48,  49,  48,  48
 TAG:0x1001= 4000
 TAG:0x1002= 2248
-TAG:FocalPlaneXResolution=4000000:244
-TAG:FocalPlaneYResolution=2248000:183
+TAG:FocalPlaneXResolution=4000000:244    
+TAG:FocalPlaneYResolution=2248000:183    
 TAG:FocalPlaneResolutionUnit=    2
 TAG:SensingMethod=    2
 TAG:FileSource=  3
 TAG:CustomRendered=    0
 TAG:ExposureMode=    0
 TAG:WhiteBalance=    0
-TAG:DigitalZoomRatio=   4000:4000
+TAG:DigitalZoomRatio=   4000:4000   
 TAG:SceneCaptureType=    0
 [/FRAME]
diff --git a/tests/ref/fate/ffprobe_compact b/tests/ref/fate/ffprobe_compact
index 9117770..5374bfc 100644
--- a/tests/ref/fate/ffprobe_compact
+++ b/tests/ref/fate/ffprobe_compact
@@ -1,31 +1,31 @@
 packet|codec_type=audio|stream_index=0|pts=0|pts_time=0.000000|dts=0|dts_time=0.000000|duration=1024|duration_time=0.023220|size=2048|pos=669|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=0|pkt_dts_time=0.000000|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=1024|pkt_duration_time=0.023220|pkt_pos=669|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=0|pkt_dts_time=0.000000|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=1024|pkt_duration_time=0.023220|duration=1024|duration_time=0.023220|pkt_pos=669|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
 packet|codec_type=video|stream_index=1|pts=0|pts_time=0.000000|dts=0|dts_time=0.000000|duration=2048|duration_time=0.040000|size=230400|pos=2744|flags=K_
-frame|media_type=video|stream_index=1|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=0|pkt_dts_time=0.000000|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=2744|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=1|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=0|pkt_dts_time=0.000000|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=2744|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 packet|codec_type=video|stream_index=2|pts=0|pts_time=0.000000|dts=0|dts_time=0.000000|duration=2048|duration_time=0.040000|size=30000|pos=233165|flags=K_
-frame|media_type=video|stream_index=2|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=0|pkt_dts_time=0.000000|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=233165|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=2|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=0|pkt_dts_time=0.000000|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=233165|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 packet|codec_type=audio|stream_index=0|pts=1024|pts_time=0.023220|dts=1024|dts_time=0.023220|duration=1024|duration_time=0.023220|size=2048|pos=263170|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=1024|pts_time=0.023220|pkt_dts=1024|pkt_dts_time=0.023220|best_effort_timestamp=1024|best_effort_timestamp_time=0.023220|pkt_duration=1024|pkt_duration_time=0.023220|pkt_pos=263170|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=1024|pts_time=0.023220|pkt_dts=1024|pkt_dts_time=0.023220|best_effort_timestamp=1024|best_effort_timestamp_time=0.023220|pkt_duration=1024|pkt_duration_time=0.023220|duration=1024|duration_time=0.023220|pkt_pos=263170|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
 packet|codec_type=video|stream_index=1|pts=2048|pts_time=0.040000|dts=2048|dts_time=0.040000|duration=2048|duration_time=0.040000|size=230400|pos=265248|flags=K_
-frame|media_type=video|stream_index=1|key_frame=1|pts=2048|pts_time=0.040000|pkt_dts=2048|pkt_dts_time=0.040000|best_effort_timestamp=2048|best_effort_timestamp_time=0.040000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=265248|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=1|key_frame=1|pts=2048|pts_time=0.040000|pkt_dts=2048|pkt_dts_time=0.040000|best_effort_timestamp=2048|best_effort_timestamp_time=0.040000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=265248|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 packet|codec_type=video|stream_index=2|pts=2048|pts_time=0.040000|dts=2048|dts_time=0.040000|duration=2048|duration_time=0.040000|size=30000|pos=495672|flags=K_
-frame|media_type=video|stream_index=2|key_frame=1|pts=2048|pts_time=0.040000|pkt_dts=2048|pkt_dts_time=0.040000|best_effort_timestamp=2048|best_effort_timestamp_time=0.040000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=495672|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=2|key_frame=1|pts=2048|pts_time=0.040000|pkt_dts=2048|pkt_dts_time=0.040000|best_effort_timestamp=2048|best_effort_timestamp_time=0.040000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=495672|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 packet|codec_type=audio|stream_index=0|pts=2048|pts_time=0.046440|dts=2048|dts_time=0.046440|duration=1024|duration_time=0.023220|size=2048|pos=525677|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=2048|pts_time=0.046440|pkt_dts=2048|pkt_dts_time=0.046440|best_effort_timestamp=2048|best_effort_timestamp_time=0.046440|pkt_duration=1024|pkt_duration_time=0.023220|pkt_pos=525677|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=2048|pts_time=0.046440|pkt_dts=2048|pkt_dts_time=0.046440|best_effort_timestamp=2048|best_effort_timestamp_time=0.046440|pkt_duration=1024|pkt_duration_time=0.023220|duration=1024|duration_time=0.023220|pkt_pos=525677|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=3072|pts_time=0.069660|dts=3072|dts_time=0.069660|duration=1024|duration_time=0.023220|size=2048|pos=527748|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=3072|pts_time=0.069660|pkt_dts=3072|pkt_dts_time=0.069660|best_effort_timestamp=3072|best_effort_timestamp_time=0.069660|pkt_duration=1024|pkt_duration_time=0.023220|pkt_pos=527748|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=3072|pts_time=0.069660|pkt_dts=3072|pkt_dts_time=0.069660|best_effort_timestamp=3072|best_effort_timestamp_time=0.069660|pkt_duration=1024|pkt_duration_time=0.023220|duration=1024|duration_time=0.023220|pkt_pos=527748|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
 packet|codec_type=video|stream_index=1|pts=4096|pts_time=0.080000|dts=4096|dts_time=0.080000|duration=2048|duration_time=0.040000|size=230400|pos=529826|flags=K_
-frame|media_type=video|stream_index=1|key_frame=1|pts=4096|pts_time=0.080000|pkt_dts=4096|pkt_dts_time=0.080000|best_effort_timestamp=4096|best_effort_timestamp_time=0.080000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=529826|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=1|key_frame=1|pts=4096|pts_time=0.080000|pkt_dts=4096|pkt_dts_time=0.080000|best_effort_timestamp=4096|best_effort_timestamp_time=0.080000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=529826|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 packet|codec_type=video|stream_index=2|pts=4096|pts_time=0.080000|dts=4096|dts_time=0.080000|duration=2048|duration_time=0.040000|size=30000|pos=760250|flags=K_
-frame|media_type=video|stream_index=2|key_frame=1|pts=4096|pts_time=0.080000|pkt_dts=4096|pkt_dts_time=0.080000|best_effort_timestamp=4096|best_effort_timestamp_time=0.080000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=760250|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=2|key_frame=1|pts=4096|pts_time=0.080000|pkt_dts=4096|pkt_dts_time=0.080000|best_effort_timestamp=4096|best_effort_timestamp_time=0.080000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=760250|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 packet|codec_type=audio|stream_index=0|pts=4096|pts_time=0.092880|dts=4096|dts_time=0.092880|duration=1024|duration_time=0.023220|size=2048|pos=790255|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=4096|pts_time=0.092880|pkt_dts=4096|pkt_dts_time=0.092880|best_effort_timestamp=4096|best_effort_timestamp_time=0.092880|pkt_duration=1024|pkt_duration_time=0.023220|pkt_pos=790255|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=4096|pts_time=0.092880|pkt_dts=4096|pkt_dts_time=0.092880|best_effort_timestamp=4096|best_effort_timestamp_time=0.092880|pkt_duration=1024|pkt_duration_time=0.023220|duration=1024|duration_time=0.023220|pkt_pos=790255|pkt_size=2048|sample_fmt=s16|nb_samples=1024|channels=1|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=5120|pts_time=0.116100|dts=5120|dts_time=0.116100|duration=393|duration_time=0.008912|size=786|pos=792326|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=5120|pts_time=0.116100|pkt_dts=5120|pkt_dts_time=0.116100|best_effort_timestamp=5120|best_effort_timestamp_time=0.116100|pkt_duration=393|pkt_duration_time=0.008912|pkt_pos=792326|pkt_size=786|sample_fmt=s16|nb_samples=393|channels=1|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=5120|pts_time=0.116100|pkt_dts=5120|pkt_dts_time=0.116100|best_effort_timestamp=5120|best_effort_timestamp_time=0.116100|pkt_duration=393|pkt_duration_time=0.008912|duration=393|duration_time=0.008912|pkt_pos=792326|pkt_size=786|sample_fmt=s16|nb_samples=393|channels=1|channel_layout=unknown
 packet|codec_type=video|stream_index=1|pts=6144|pts_time=0.120000|dts=6144|dts_time=0.120000|duration=2048|duration_time=0.040000|size=230400|pos=793142|flags=K_
-frame|media_type=video|stream_index=1|key_frame=1|pts=6144|pts_time=0.120000|pkt_dts=6144|pkt_dts_time=0.120000|best_effort_timestamp=6144|best_effort_timestamp_time=0.120000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=793142|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=1|key_frame=1|pts=6144|pts_time=0.120000|pkt_dts=6144|pkt_dts_time=0.120000|best_effort_timestamp=6144|best_effort_timestamp_time=0.120000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=793142|pkt_size=230400|width=320|height=240|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 packet|codec_type=video|stream_index=2|pts=6144|pts_time=0.120000|dts=6144|dts_time=0.120000|duration=2048|duration_time=0.040000|size=30000|pos=1023566|flags=K_
-frame|media_type=video|stream_index=2|key_frame=1|pts=6144|pts_time=0.120000|pkt_dts=6144|pkt_dts_time=0.120000|best_effort_timestamp=6144|best_effort_timestamp_time=0.120000|pkt_duration=2048|pkt_duration_time=0.040000|pkt_pos=1023566|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
+frame|media_type=video|stream_index=2|key_frame=1|pts=6144|pts_time=0.120000|pkt_dts=6144|pkt_dts_time=0.120000|best_effort_timestamp=6144|best_effort_timestamp_time=0.120000|pkt_duration=2048|pkt_duration_time=0.040000|duration=2048|duration_time=0.040000|pkt_pos=1023566|pkt_size=30000|width=100|height=100|pix_fmt=rgb24|sample_aspect_ratio=1:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=unknown|color_space=unknown|color_primaries=unknown|color_transfer=unknown|chroma_location=unspecified
 stream|index=0|codec_name=pcm_s16le|profile=unknown|codec_type=audio|codec_tag_string=PSD[16]|codec_tag=0x10445350|sample_fmt=s16|sample_rate=44100|channels=1|channel_layout=unknown|bits_per_sample=16|id=N/A|r_frame_rate=0/0|avg_frame_rate=0/0|time_base=1/44100|start_pts=0|start_time=0.000000|duration_ts=N/A|duration=N/A|bit_rate=705600|max_bit_rate=N/A|bits_per_raw_sample=N/A|nb_frames=N/A|nb_read_frames=6|nb_read_packets=6|disposition:default=0|disposition:dub=0|disposition:original=0|disposition:comment=0|disposition:lyrics=0|disposition:karaoke=0|disposition:forced=0|disposition:hearing_impaired=0|disposition:visual_impaired=0|disposition:clean_effects=0|disposition:attached_pic=0|disposition:timed_thumbnails=0|disposition:captions=0|disposition:descriptions=0|disposition:metadata=0|disposition:dependent=0|disposition:still_image=0|tag:E=mc|tag:encoder=Lavc pcm_s16le
 stream|index=1|codec_name=rawvideo|profile=unknown|codec_type=video|codec_tag_string=RGB[24]|codec_tag=0x18424752|width=320|height=240|coded_width=320|coded_height=240|closed_captions=0|film_grain=0|has_b_frames=0|sample_aspect_ratio=1:1|display_aspect_ratio=4:3|pix_fmt=rgb24|level=-99|color_range=unknown|color_space=unknown|color_transfer=unknown|color_primaries=unknown|chroma_location=unspecified|field_order=unknown|refs=1|id=N/A|r_frame_rate=25/1|avg_frame_rate=25/1|time_base=1/51200|start_pts=0|start_time=0.000000|duration_ts=N/A|duration=N/A|bit_rate=N/A|max_bit_rate=N/A|bits_per_raw_sample=N/A|nb_frames=N/A|nb_read_frames=4|nb_read_packets=4|disposition:default=1|disposition:dub=0|disposition:original=0|disposition:comment=0|disposition:lyrics=0|disposition:karaoke=0|disposition:forced=0|disposition:hearing_impaired=0|disposition:visual_impaired=0|disposition:clean_effects=0|disposition:attached_pic=0|disposition:timed_thumbnails=0|disposition:captions=0|disposition:descriptions=0|disposition:metadata=0|disposition:dependent=0|disposition:still_image=0|tag:title=foobar|tag:duration_ts=field-and-tags-conflict-attempt|tag:encoder=Lavc rawvideo
 stream|index=2|codec_name=rawvideo|profile=unknown|codec_type=video|codec_tag_string=RGB[24]|codec_tag=0x18424752|width=100|height=100|coded_width=100|coded_height=100|closed_captions=0|film_grain=0|has_b_frames=0|sample_aspect_ratio=1:1|display_aspect_ratio=1:1|pix_fmt=rgb24|level=-99|color_range=unknown|color_space=unknown|color_transfer=unknown|color_primaries=unknown|chroma_location=unspecified|field_order=unknown|refs=1|id=N/A|r_frame_rate=25/1|avg_frame_rate=25/1|time_base=1/51200|start_pts=0|start_time=0.000000|duration_ts=N/A|duration=N/A|bit_rate=N/A|max_bit_rate=N/A|bits_per_raw_sample=N/A|nb_frames=N/A|nb_read_frames=4|nb_read_packets=4|disposition:default=0|disposition:dub=0|disposition:original=0|disposition:comment=0|disposition:lyrics=0|disposition:karaoke=0|disposition:forced=0|disposition:hearing_impaired=0|disposition:visual_impaired=0|disposition:clean_effects=0|disposition:attached_pic=0|disposition:timed_thumbnails=0|disposition:captions=0|disposition:descriptions=0|disposition:metadata=0|disposition:dependent=0|disposition:still_image=0|tag:encoder=Lavc rawvideo
diff --git a/tests/ref/fate/ffprobe_csv b/tests/ref/fate/ffprobe_csv
index fd6bb24..7af4db7 100644
--- a/tests/ref/fate/ffprobe_csv
+++ b/tests/ref/fate/ffprobe_csv
@@ -1,31 +1,31 @@
 packet,audio,0,0,0.000000,0,0.000000,1024,0.023220,2048,669,K_
-frame,audio,0,1,0,0.000000,0,0.000000,0,0.000000,1024,0.023220,669,2048,s16,1024,1,unknown
+frame,audio,0,1,0,0.000000,0,0.000000,0,0.000000,1024,0.023220,1024,0.023220,669,2048,s16,1024,1,unknown
 packet,video,1,0,0.000000,0,0.000000,2048,0.040000,230400,2744,K_
-frame,video,1,1,0,0.000000,0,0.000000,0,0.000000,2048,0.040000,2744,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,1,1,0,0.000000,0,0.000000,0,0.000000,2048,0.040000,2048,0.040000,2744,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 packet,video,2,0,0.000000,0,0.000000,2048,0.040000,30000,233165,K_
-frame,video,2,1,0,0.000000,0,0.000000,0,0.000000,2048,0.040000,233165,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,2,1,0,0.000000,0,0.000000,0,0.000000,2048,0.040000,2048,0.040000,233165,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 packet,audio,0,1024,0.023220,1024,0.023220,1024,0.023220,2048,263170,K_
-frame,audio,0,1,1024,0.023220,1024,0.023220,1024,0.023220,1024,0.023220,263170,2048,s16,1024,1,unknown
+frame,audio,0,1,1024,0.023220,1024,0.023220,1024,0.023220,1024,0.023220,1024,0.023220,263170,2048,s16,1024,1,unknown
 packet,video,1,2048,0.040000,2048,0.040000,2048,0.040000,230400,265248,K_
-frame,video,1,1,2048,0.040000,2048,0.040000,2048,0.040000,2048,0.040000,265248,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,1,1,2048,0.040000,2048,0.040000,2048,0.040000,2048,0.040000,2048,0.040000,265248,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 packet,video,2,2048,0.040000,2048,0.040000,2048,0.040000,30000,495672,K_
-frame,video,2,1,2048,0.040000,2048,0.040000,2048,0.040000,2048,0.040000,495672,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,2,1,2048,0.040000,2048,0.040000,2048,0.040000,2048,0.040000,2048,0.040000,495672,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 packet,audio,0,2048,0.046440,2048,0.046440,1024,0.023220,2048,525677,K_
-frame,audio,0,1,2048,0.046440,2048,0.046440,2048,0.046440,1024,0.023220,525677,2048,s16,1024,1,unknown
+frame,audio,0,1,2048,0.046440,2048,0.046440,2048,0.046440,1024,0.023220,1024,0.023220,525677,2048,s16,1024,1,unknown
 packet,audio,0,3072,0.069660,3072,0.069660,1024,0.023220,2048,527748,K_
-frame,audio,0,1,3072,0.069660,3072,0.069660,3072,0.069660,1024,0.023220,527748,2048,s16,1024,1,unknown
+frame,audio,0,1,3072,0.069660,3072,0.069660,3072,0.069660,1024,0.023220,1024,0.023220,527748,2048,s16,1024,1,unknown
 packet,video,1,4096,0.080000,4096,0.080000,2048,0.040000,230400,529826,K_
-frame,video,1,1,4096,0.080000,4096,0.080000,4096,0.080000,2048,0.040000,529826,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,1,1,4096,0.080000,4096,0.080000,4096,0.080000,2048,0.040000,2048,0.040000,529826,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 packet,video,2,4096,0.080000,4096,0.080000,2048,0.040000,30000,760250,K_
-frame,video,2,1,4096,0.080000,4096,0.080000,4096,0.080000,2048,0.040000,760250,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,2,1,4096,0.080000,4096,0.080000,4096,0.080000,2048,0.040000,2048,0.040000,760250,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 packet,audio,0,4096,0.092880,4096,0.092880,1024,0.023220,2048,790255,K_
-frame,audio,0,1,4096,0.092880,4096,0.092880,4096,0.092880,1024,0.023220,790255,2048,s16,1024,1,unknown
+frame,audio,0,1,4096,0.092880,4096,0.092880,4096,0.092880,1024,0.023220,1024,0.023220,790255,2048,s16,1024,1,unknown
 packet,audio,0,5120,0.116100,5120,0.116100,393,0.008912,786,792326,K_
-frame,audio,0,1,5120,0.116100,5120,0.116100,5120,0.116100,393,0.008912,792326,786,s16,393,1,unknown
+frame,audio,0,1,5120,0.116100,5120,0.116100,5120,0.116100,393,0.008912,393,0.008912,792326,786,s16,393,1,unknown
 packet,video,1,6144,0.120000,6144,0.120000,2048,0.040000,230400,793142,K_
-frame,video,1,1,6144,0.120000,6144,0.120000,6144,0.120000,2048,0.040000,793142,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,1,1,6144,0.120000,6144,0.120000,6144,0.120000,2048,0.040000,2048,0.040000,793142,230400,320,240,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 packet,video,2,6144,0.120000,6144,0.120000,2048,0.040000,30000,1023566,K_
-frame,video,2,1,6144,0.120000,6144,0.120000,6144,0.120000,2048,0.040000,1023566,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
+frame,video,2,1,6144,0.120000,6144,0.120000,6144,0.120000,2048,0.040000,2048,0.040000,1023566,30000,100,100,rgb24,1:1,I,0,0,0,0,0,unknown,unknown,unknown,unknown,unspecified
 stream,0,pcm_s16le,unknown,audio,PSD[16],0x10445350,s16,44100,1,unknown,16,N/A,0/0,0/0,1/44100,0,0.000000,N/A,N/A,705600,N/A,N/A,N/A,6,6,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,mc,Lavc pcm_s16le
 stream,1,rawvideo,unknown,video,RGB[24],0x18424752,320,240,320,240,0,0,0,1:1,4:3,rgb24,-99,unknown,unknown,unknown,unknown,unspecified,unknown,1,N/A,25/1,25/1,1/51200,0,0.000000,N/A,N/A,N/A,N/A,N/A,N/A,4,4,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,foobar,field-and-tags-conflict-attempt,Lavc rawvideo
 stream,2,rawvideo,unknown,video,RGB[24],0x18424752,100,100,100,100,0,0,0,1:1,1:1,rgb24,-99,unknown,unknown,unknown,unknown,unspecified,unknown,1,N/A,25/1,25/1,1/51200,0,0.000000,N/A,N/A,N/A,N/A,N/A,N/A,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,Lavc rawvideo
diff --git a/tests/ref/fate/ffprobe_default b/tests/ref/fate/ffprobe_default
index d3d90fa..f296fc0 100644
--- a/tests/ref/fate/ffprobe_default
+++ b/tests/ref/fate/ffprobe_default
@@ -23,6 +23,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=669
 pkt_size=2048
 sample_fmt=s16
@@ -55,6 +57,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=2744
 pkt_size=230400
 width=320
@@ -98,6 +102,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=233165
 pkt_size=30000
 width=100
@@ -141,6 +147,8 @@ best_effort_timestamp=1024
 best_effort_timestamp_time=0.023220
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=263170
 pkt_size=2048
 sample_fmt=s16
@@ -173,6 +181,8 @@ best_effort_timestamp=2048
 best_effort_timestamp_time=0.040000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=265248
 pkt_size=230400
 width=320
@@ -216,6 +226,8 @@ best_effort_timestamp=2048
 best_effort_timestamp_time=0.040000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=495672
 pkt_size=30000
 width=100
@@ -259,6 +271,8 @@ best_effort_timestamp=2048
 best_effort_timestamp_time=0.046440
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=525677
 pkt_size=2048
 sample_fmt=s16
@@ -291,6 +305,8 @@ best_effort_timestamp=3072
 best_effort_timestamp_time=0.069660
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=527748
 pkt_size=2048
 sample_fmt=s16
@@ -323,6 +339,8 @@ best_effort_timestamp=4096
 best_effort_timestamp_time=0.080000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=529826
 pkt_size=230400
 width=320
@@ -366,6 +384,8 @@ best_effort_timestamp=4096
 best_effort_timestamp_time=0.080000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=760250
 pkt_size=30000
 width=100
@@ -409,6 +429,8 @@ best_effort_timestamp=4096
 best_effort_timestamp_time=0.092880
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=790255
 pkt_size=2048
 sample_fmt=s16
@@ -441,6 +463,8 @@ best_effort_timestamp=5120
 best_effort_timestamp_time=0.116100
 pkt_duration=393
 pkt_duration_time=0.008912
+duration=393
+duration_time=0.008912
 pkt_pos=792326
 pkt_size=786
 sample_fmt=s16
@@ -473,6 +497,8 @@ best_effort_timestamp=6144
 best_effort_timestamp_time=0.120000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=793142
 pkt_size=230400
 width=320
@@ -516,6 +542,8 @@ best_effort_timestamp=6144
 best_effort_timestamp_time=0.120000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=1023566
 pkt_size=30000
 width=100
diff --git a/tests/ref/fate/ffprobe_flat b/tests/ref/fate/ffprobe_flat
index e77dec6..655c0fe 100644
--- a/tests/ref/fate/ffprobe_flat
+++ b/tests/ref/fate/ffprobe_flat
@@ -20,6 +20,8 @@ packets_and_frames.frame.0.best_effort_timestamp=0
 packets_and_frames.frame.0.best_effort_timestamp_time="0.000000"
 packets_and_frames.frame.0.pkt_duration=1024
 packets_and_frames.frame.0.pkt_duration_time="0.023220"
+packets_and_frames.frame.0.duration=1024
+packets_and_frames.frame.0.duration_time="0.023220"
 packets_and_frames.frame.0.pkt_pos="669"
 packets_and_frames.frame.0.pkt_size="2048"
 packets_and_frames.frame.0.sample_fmt="s16"
@@ -48,6 +50,8 @@ packets_and_frames.frame.1.best_effort_timestamp=0
 packets_and_frames.frame.1.best_effort_timestamp_time="0.000000"
 packets_and_frames.frame.1.pkt_duration=2048
 packets_and_frames.frame.1.pkt_duration_time="0.040000"
+packets_and_frames.frame.1.duration=2048
+packets_and_frames.frame.1.duration_time="0.040000"
 packets_and_frames.frame.1.pkt_pos="2744"
 packets_and_frames.frame.1.pkt_size="230400"
 packets_and_frames.frame.1.width=320
@@ -87,6 +91,8 @@ packets_and_frames.frame.2.best_effort_timestamp=0
 packets_and_frames.frame.2.best_effort_timestamp_time="0.000000"
 packets_and_frames.frame.2.pkt_duration=2048
 packets_and_frames.frame.2.pkt_duration_time="0.040000"
+packets_and_frames.frame.2.duration=2048
+packets_and_frames.frame.2.duration_time="0.040000"
 packets_and_frames.frame.2.pkt_pos="233165"
 packets_and_frames.frame.2.pkt_size="30000"
 packets_and_frames.frame.2.width=100
@@ -126,6 +132,8 @@ packets_and_frames.frame.3.best_effort_timestamp=1024
 packets_and_frames.frame.3.best_effort_timestamp_time="0.023220"
 packets_and_frames.frame.3.pkt_duration=1024
 packets_and_frames.frame.3.pkt_duration_time="0.023220"
+packets_and_frames.frame.3.duration=1024
+packets_and_frames.frame.3.duration_time="0.023220"
 packets_and_frames.frame.3.pkt_pos="263170"
 packets_and_frames.frame.3.pkt_size="2048"
 packets_and_frames.frame.3.sample_fmt="s16"
@@ -154,6 +162,8 @@ packets_and_frames.frame.4.best_effort_timestamp=2048
 packets_and_frames.frame.4.best_effort_timestamp_time="0.040000"
 packets_and_frames.frame.4.pkt_duration=2048
 packets_and_frames.frame.4.pkt_duration_time="0.040000"
+packets_and_frames.frame.4.duration=2048
+packets_and_frames.frame.4.duration_time="0.040000"
 packets_and_frames.frame.4.pkt_pos="265248"
 packets_and_frames.frame.4.pkt_size="230400"
 packets_and_frames.frame.4.width=320
@@ -193,6 +203,8 @@ packets_and_frames.frame.5.best_effort_timestamp=2048
 packets_and_frames.frame.5.best_effort_timestamp_time="0.040000"
 packets_and_frames.frame.5.pkt_duration=2048
 packets_and_frames.frame.5.pkt_duration_time="0.040000"
+packets_and_frames.frame.5.duration=2048
+packets_and_frames.frame.5.duration_time="0.040000"
 packets_and_frames.frame.5.pkt_pos="495672"
 packets_and_frames.frame.5.pkt_size="30000"
 packets_and_frames.frame.5.width=100
@@ -232,6 +244,8 @@ packets_and_frames.frame.6.best_effort_timestamp=2048
 packets_and_frames.frame.6.best_effort_timestamp_time="0.046440"
 packets_and_frames.frame.6.pkt_duration=1024
 packets_and_frames.frame.6.pkt_duration_time="0.023220"
+packets_and_frames.frame.6.duration=1024
+packets_and_frames.frame.6.duration_time="0.023220"
 packets_and_frames.frame.6.pkt_pos="525677"
 packets_and_frames.frame.6.pkt_size="2048"
 packets_and_frames.frame.6.sample_fmt="s16"
@@ -260,6 +274,8 @@ packets_and_frames.frame.7.best_effort_timestamp=3072
 packets_and_frames.frame.7.best_effort_timestamp_time="0.069660"
 packets_and_frames.frame.7.pkt_duration=1024
 packets_and_frames.frame.7.pkt_duration_time="0.023220"
+packets_and_frames.frame.7.duration=1024
+packets_and_frames.frame.7.duration_time="0.023220"
 packets_and_frames.frame.7.pkt_pos="527748"
 packets_and_frames.frame.7.pkt_size="2048"
 packets_and_frames.frame.7.sample_fmt="s16"
@@ -288,6 +304,8 @@ packets_and_frames.frame.8.best_effort_timestamp=4096
 packets_and_frames.frame.8.best_effort_timestamp_time="0.080000"
 packets_and_frames.frame.8.pkt_duration=2048
 packets_and_frames.frame.8.pkt_duration_time="0.040000"
+packets_and_frames.frame.8.duration=2048
+packets_and_frames.frame.8.duration_time="0.040000"
 packets_and_frames.frame.8.pkt_pos="529826"
 packets_and_frames.frame.8.pkt_size="230400"
 packets_and_frames.frame.8.width=320
@@ -327,6 +345,8 @@ packets_and_frames.frame.9.best_effort_timestamp=4096
 packets_and_frames.frame.9.best_effort_timestamp_time="0.080000"
 packets_and_frames.frame.9.pkt_duration=2048
 packets_and_frames.frame.9.pkt_duration_time="0.040000"
+packets_and_frames.frame.9.duration=2048
+packets_and_frames.frame.9.duration_time="0.040000"
 packets_and_frames.frame.9.pkt_pos="760250"
 packets_and_frames.frame.9.pkt_size="30000"
 packets_and_frames.frame.9.width=100
@@ -366,6 +386,8 @@ packets_and_frames.frame.10.best_effort_timestamp=4096
 packets_and_frames.frame.10.best_effort_timestamp_time="0.092880"
 packets_and_frames.frame.10.pkt_duration=1024
 packets_and_frames.frame.10.pkt_duration_time="0.023220"
+packets_and_frames.frame.10.duration=1024
+packets_and_frames.frame.10.duration_time="0.023220"
 packets_and_frames.frame.10.pkt_pos="790255"
 packets_and_frames.frame.10.pkt_size="2048"
 packets_and_frames.frame.10.sample_fmt="s16"
@@ -394,6 +416,8 @@ packets_and_frames.frame.11.best_effort_timestamp=5120
 packets_and_frames.frame.11.best_effort_timestamp_time="0.116100"
 packets_and_frames.frame.11.pkt_duration=393
 packets_and_frames.frame.11.pkt_duration_time="0.008912"
+packets_and_frames.frame.11.duration=393
+packets_and_frames.frame.11.duration_time="0.008912"
 packets_and_frames.frame.11.pkt_pos="792326"
 packets_and_frames.frame.11.pkt_size="786"
 packets_and_frames.frame.11.sample_fmt="s16"
@@ -422,6 +446,8 @@ packets_and_frames.frame.12.best_effort_timestamp=6144
 packets_and_frames.frame.12.best_effort_timestamp_time="0.120000"
 packets_and_frames.frame.12.pkt_duration=2048
 packets_and_frames.frame.12.pkt_duration_time="0.040000"
+packets_and_frames.frame.12.duration=2048
+packets_and_frames.frame.12.duration_time="0.040000"
 packets_and_frames.frame.12.pkt_pos="793142"
 packets_and_frames.frame.12.pkt_size="230400"
 packets_and_frames.frame.12.width=320
@@ -461,6 +487,8 @@ packets_and_frames.frame.13.best_effort_timestamp=6144
 packets_and_frames.frame.13.best_effort_timestamp_time="0.120000"
 packets_and_frames.frame.13.pkt_duration=2048
 packets_and_frames.frame.13.pkt_duration_time="0.040000"
+packets_and_frames.frame.13.duration=2048
+packets_and_frames.frame.13.duration_time="0.040000"
 packets_and_frames.frame.13.pkt_pos="1023566"
 packets_and_frames.frame.13.pkt_size="30000"
 packets_and_frames.frame.13.width=100
diff --git a/tests/ref/fate/ffprobe_ini b/tests/ref/fate/ffprobe_ini
index cff7d96..58f508f 100644
--- a/tests/ref/fate/ffprobe_ini
+++ b/tests/ref/fate/ffprobe_ini
@@ -25,6 +25,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=669
 pkt_size=2048
 sample_fmt=s16
@@ -57,6 +59,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=2744
 pkt_size=230400
 width=320
@@ -100,6 +104,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=233165
 pkt_size=30000
 width=100
@@ -143,6 +149,8 @@ best_effort_timestamp=1024
 best_effort_timestamp_time=0.023220
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=263170
 pkt_size=2048
 sample_fmt=s16
@@ -175,6 +183,8 @@ best_effort_timestamp=2048
 best_effort_timestamp_time=0.040000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=265248
 pkt_size=230400
 width=320
@@ -218,6 +228,8 @@ best_effort_timestamp=2048
 best_effort_timestamp_time=0.040000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=495672
 pkt_size=30000
 width=100
@@ -261,6 +273,8 @@ best_effort_timestamp=2048
 best_effort_timestamp_time=0.046440
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=525677
 pkt_size=2048
 sample_fmt=s16
@@ -293,6 +307,8 @@ best_effort_timestamp=3072
 best_effort_timestamp_time=0.069660
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=527748
 pkt_size=2048
 sample_fmt=s16
@@ -325,6 +341,8 @@ best_effort_timestamp=4096
 best_effort_timestamp_time=0.080000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=529826
 pkt_size=230400
 width=320
@@ -368,6 +386,8 @@ best_effort_timestamp=4096
 best_effort_timestamp_time=0.080000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=760250
 pkt_size=30000
 width=100
@@ -411,6 +431,8 @@ best_effort_timestamp=4096
 best_effort_timestamp_time=0.092880
 pkt_duration=1024
 pkt_duration_time=0.023220
+duration=1024
+duration_time=0.023220
 pkt_pos=790255
 pkt_size=2048
 sample_fmt=s16
@@ -443,6 +465,8 @@ best_effort_timestamp=5120
 best_effort_timestamp_time=0.116100
 pkt_duration=393
 pkt_duration_time=0.008912
+duration=393
+duration_time=0.008912
 pkt_pos=792326
 pkt_size=786
 sample_fmt=s16
@@ -475,6 +499,8 @@ best_effort_timestamp=6144
 best_effort_timestamp_time=0.120000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=793142
 pkt_size=230400
 width=320
@@ -518,6 +544,8 @@ best_effort_timestamp=6144
 best_effort_timestamp_time=0.120000
 pkt_duration=2048
 pkt_duration_time=0.040000
+duration=2048
+duration_time=0.040000
 pkt_pos=1023566
 pkt_size=30000
 width=100
diff --git a/tests/ref/fate/ffprobe_json b/tests/ref/fate/ffprobe_json
index 9816700..2e8b39f 100644
--- a/tests/ref/fate/ffprobe_json
+++ b/tests/ref/fate/ffprobe_json
@@ -27,6 +27,8 @@
             "best_effort_timestamp_time": "0.000000",
             "pkt_duration": 1024,
             "pkt_duration_time": "0.023220",
+            "duration": 1024,
+            "duration_time": "0.023220",
             "pkt_pos": "669",
             "pkt_size": "2048",
             "sample_fmt": "s16",
@@ -60,6 +62,8 @@
             "best_effort_timestamp_time": "0.000000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "2744",
             "pkt_size": "230400",
             "width": 320,
@@ -100,6 +104,8 @@
             "best_effort_timestamp_time": "0.000000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "233165",
             "pkt_size": "30000",
             "width": 100,
@@ -140,6 +146,8 @@
             "best_effort_timestamp_time": "0.023220",
             "pkt_duration": 1024,
             "pkt_duration_time": "0.023220",
+            "duration": 1024,
+            "duration_time": "0.023220",
             "pkt_pos": "263170",
             "pkt_size": "2048",
             "sample_fmt": "s16",
@@ -173,6 +181,8 @@
             "best_effort_timestamp_time": "0.040000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "265248",
             "pkt_size": "230400",
             "width": 320,
@@ -213,6 +223,8 @@
             "best_effort_timestamp_time": "0.040000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "495672",
             "pkt_size": "30000",
             "width": 100,
@@ -253,6 +265,8 @@
             "best_effort_timestamp_time": "0.046440",
             "pkt_duration": 1024,
             "pkt_duration_time": "0.023220",
+            "duration": 1024,
+            "duration_time": "0.023220",
             "pkt_pos": "525677",
             "pkt_size": "2048",
             "sample_fmt": "s16",
@@ -286,6 +300,8 @@
             "best_effort_timestamp_time": "0.069660",
             "pkt_duration": 1024,
             "pkt_duration_time": "0.023220",
+            "duration": 1024,
+            "duration_time": "0.023220",
             "pkt_pos": "527748",
             "pkt_size": "2048",
             "sample_fmt": "s16",
@@ -319,6 +335,8 @@
             "best_effort_timestamp_time": "0.080000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "529826",
             "pkt_size": "230400",
             "width": 320,
@@ -359,6 +377,8 @@
             "best_effort_timestamp_time": "0.080000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "760250",
             "pkt_size": "30000",
             "width": 100,
@@ -399,6 +419,8 @@
             "best_effort_timestamp_time": "0.092880",
             "pkt_duration": 1024,
             "pkt_duration_time": "0.023220",
+            "duration": 1024,
+            "duration_time": "0.023220",
             "pkt_pos": "790255",
             "pkt_size": "2048",
             "sample_fmt": "s16",
@@ -432,6 +454,8 @@
             "best_effort_timestamp_time": "0.116100",
             "pkt_duration": 393,
             "pkt_duration_time": "0.008912",
+            "duration": 393,
+            "duration_time": "0.008912",
             "pkt_pos": "792326",
             "pkt_size": "786",
             "sample_fmt": "s16",
@@ -465,6 +489,8 @@
             "best_effort_timestamp_time": "0.120000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "793142",
             "pkt_size": "230400",
             "width": 320,
@@ -505,6 +531,8 @@
             "best_effort_timestamp_time": "0.120000",
             "pkt_duration": 2048,
             "pkt_duration_time": "0.040000",
+            "duration": 2048,
+            "duration_time": "0.040000",
             "pkt_pos": "1023566",
             "pkt_size": "30000",
             "width": 100,
diff --git a/tests/ref/fate/ffprobe_xml b/tests/ref/fate/ffprobe_xml
index 4f702bc..e515265 100644
--- a/tests/ref/fate/ffprobe_xml
+++ b/tests/ref/fate/ffprobe_xml
@@ -2,33 +2,33 @@
 <ffprobe>
     <packets_and_frames>
         <packet codec_type="audio" stream_index="0" pts="0" pts_time="0.000000" dts="0" dts_time="0.000000" duration="1024" duration_time="0.023220" size="2048" pos="669" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="669" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="669" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="0" pts_time="0.000000" dts="0" dts_time="0.000000" duration="2048" duration_time="0.040000" size="230400" pos="2744" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="2744" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="2744" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="0" pts_time="0.000000" dts="0" dts_time="0.000000" duration="2048" duration_time="0.040000" size="30000" pos="233165" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="233165" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="233165" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="audio" stream_index="0" pts="1024" pts_time="0.023220" dts="1024" dts_time="0.023220" duration="1024" duration_time="0.023220" size="2048" pos="263170" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="1024" pts_time="0.023220" pkt_dts="1024" pkt_dts_time="0.023220" best_effort_timestamp="1024" best_effort_timestamp_time="0.023220" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="263170" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="1024" pts_time="0.023220" pkt_dts="1024" pkt_dts_time="0.023220" best_effort_timestamp="1024" best_effort_timestamp_time="0.023220" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="263170" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="2048" pts_time="0.040000" dts="2048" dts_time="0.040000" duration="2048" duration_time="0.040000" size="230400" pos="265248" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="265248" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="265248" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="2048" pts_time="0.040000" dts="2048" dts_time="0.040000" duration="2048" duration_time="0.040000" size="30000" pos="495672" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="495672" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="495672" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="audio" stream_index="0" pts="2048" pts_time="0.046440" dts="2048" dts_time="0.046440" duration="1024" duration_time="0.023220" size="2048" pos="525677" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="2048" pts_time="0.046440" pkt_dts="2048" pkt_dts_time="0.046440" best_effort_timestamp="2048" best_effort_timestamp_time="0.046440" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="525677" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="2048" pts_time="0.046440" pkt_dts="2048" pkt_dts_time="0.046440" best_effort_timestamp="2048" best_effort_timestamp_time="0.046440" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="525677" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="audio" stream_index="0" pts="3072" pts_time="0.069660" dts="3072" dts_time="0.069660" duration="1024" duration_time="0.023220" size="2048" pos="527748" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="3072" pts_time="0.069660" pkt_dts="3072" pkt_dts_time="0.069660" best_effort_timestamp="3072" best_effort_timestamp_time="0.069660" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="527748" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="3072" pts_time="0.069660" pkt_dts="3072" pkt_dts_time="0.069660" best_effort_timestamp="3072" best_effort_timestamp_time="0.069660" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="527748" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="4096" pts_time="0.080000" dts="4096" dts_time="0.080000" duration="2048" duration_time="0.040000" size="230400" pos="529826" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="529826" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="529826" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="4096" pts_time="0.080000" dts="4096" dts_time="0.080000" duration="2048" duration_time="0.040000" size="30000" pos="760250" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="760250" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="760250" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="audio" stream_index="0" pts="4096" pts_time="0.092880" dts="4096" dts_time="0.092880" duration="1024" duration_time="0.023220" size="2048" pos="790255" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="4096" pts_time="0.092880" pkt_dts="4096" pkt_dts_time="0.092880" best_effort_timestamp="4096" best_effort_timestamp_time="0.092880" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="790255" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="4096" pts_time="0.092880" pkt_dts="4096" pkt_dts_time="0.092880" best_effort_timestamp="4096" best_effort_timestamp_time="0.092880" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="790255" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="audio" stream_index="0" pts="5120" pts_time="0.116100" dts="5120" dts_time="0.116100" duration="393" duration_time="0.008912" size="786" pos="792326" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="5120" pts_time="0.116100" pkt_dts="5120" pkt_dts_time="0.116100" best_effort_timestamp="5120" best_effort_timestamp_time="0.116100" pkt_duration="393" pkt_duration_time="0.008912" pkt_pos="792326" pkt_size="786" sample_fmt="s16" nb_samples="393" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="5120" pts_time="0.116100" pkt_dts="5120" pkt_dts_time="0.116100" best_effort_timestamp="5120" best_effort_timestamp_time="0.116100" pkt_duration="393" pkt_duration_time="0.008912" duration="393" duration_time="0.008912" pkt_pos="792326" pkt_size="786" sample_fmt="s16" nb_samples="393" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="6144" pts_time="0.120000" dts="6144" dts_time="0.120000" duration="2048" duration_time="0.040000" size="230400" pos="793142" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="793142" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="793142" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="6144" pts_time="0.120000" dts="6144" dts_time="0.120000" duration="2048" duration_time="0.040000" size="30000" pos="1023566" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="1023566" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="1023566" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
     </packets_and_frames>
 
     <streams>
diff --git a/tests/ref/fate/ffprobe_xsd b/tests/ref/fate/ffprobe_xsd
index 62d011a..f1fac9a 100644
--- a/tests/ref/fate/ffprobe_xsd
+++ b/tests/ref/fate/ffprobe_xsd
@@ -2,33 +2,33 @@
 <ffprobe:ffprobe xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:ffprobe="http://www.ffmpeg.org/schema/ffprobe" xsi:schemaLocation="http://www.ffmpeg.org/schema/ffprobe ffprobe.xsd">
     <packets_and_frames>
         <packet codec_type="audio" stream_index="0" pts="0" pts_time="0.000000" dts="0" dts_time="0.000000" duration="1024" duration_time="0.023220" size="2048" pos="669" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="669" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="669" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="0" pts_time="0.000000" dts="0" dts_time="0.000000" duration="2048" duration_time="0.040000" size="230400" pos="2744" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="2744" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="2744" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="0" pts_time="0.000000" dts="0" dts_time="0.000000" duration="2048" duration_time="0.040000" size="30000" pos="233165" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="233165" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="0" pts_time="0.000000" pkt_dts="0" pkt_dts_time="0.000000" best_effort_timestamp="0" best_effort_timestamp_time="0.000000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="233165" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="audio" stream_index="0" pts="1024" pts_time="0.023220" dts="1024" dts_time="0.023220" duration="1024" duration_time="0.023220" size="2048" pos="263170" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="1024" pts_time="0.023220" pkt_dts="1024" pkt_dts_time="0.023220" best_effort_timestamp="1024" best_effort_timestamp_time="0.023220" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="263170" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="1024" pts_time="0.023220" pkt_dts="1024" pkt_dts_time="0.023220" best_effort_timestamp="1024" best_effort_timestamp_time="0.023220" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="263170" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="2048" pts_time="0.040000" dts="2048" dts_time="0.040000" duration="2048" duration_time="0.040000" size="230400" pos="265248" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="265248" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="265248" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="2048" pts_time="0.040000" dts="2048" dts_time="0.040000" duration="2048" duration_time="0.040000" size="30000" pos="495672" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="495672" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="2048" pts_time="0.040000" pkt_dts="2048" pkt_dts_time="0.040000" best_effort_timestamp="2048" best_effort_timestamp_time="0.040000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="495672" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="audio" stream_index="0" pts="2048" pts_time="0.046440" dts="2048" dts_time="0.046440" duration="1024" duration_time="0.023220" size="2048" pos="525677" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="2048" pts_time="0.046440" pkt_dts="2048" pkt_dts_time="0.046440" best_effort_timestamp="2048" best_effort_timestamp_time="0.046440" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="525677" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="2048" pts_time="0.046440" pkt_dts="2048" pkt_dts_time="0.046440" best_effort_timestamp="2048" best_effort_timestamp_time="0.046440" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="525677" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="audio" stream_index="0" pts="3072" pts_time="0.069660" dts="3072" dts_time="0.069660" duration="1024" duration_time="0.023220" size="2048" pos="527748" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="3072" pts_time="0.069660" pkt_dts="3072" pkt_dts_time="0.069660" best_effort_timestamp="3072" best_effort_timestamp_time="0.069660" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="527748" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="3072" pts_time="0.069660" pkt_dts="3072" pkt_dts_time="0.069660" best_effort_timestamp="3072" best_effort_timestamp_time="0.069660" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="527748" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="4096" pts_time="0.080000" dts="4096" dts_time="0.080000" duration="2048" duration_time="0.040000" size="230400" pos="529826" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="529826" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="529826" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="4096" pts_time="0.080000" dts="4096" dts_time="0.080000" duration="2048" duration_time="0.040000" size="30000" pos="760250" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="760250" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="4096" pts_time="0.080000" pkt_dts="4096" pkt_dts_time="0.080000" best_effort_timestamp="4096" best_effort_timestamp_time="0.080000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="760250" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="audio" stream_index="0" pts="4096" pts_time="0.092880" dts="4096" dts_time="0.092880" duration="1024" duration_time="0.023220" size="2048" pos="790255" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="4096" pts_time="0.092880" pkt_dts="4096" pkt_dts_time="0.092880" best_effort_timestamp="4096" best_effort_timestamp_time="0.092880" pkt_duration="1024" pkt_duration_time="0.023220" pkt_pos="790255" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="4096" pts_time="0.092880" pkt_dts="4096" pkt_dts_time="0.092880" best_effort_timestamp="4096" best_effort_timestamp_time="0.092880" pkt_duration="1024" pkt_duration_time="0.023220" duration="1024" duration_time="0.023220" pkt_pos="790255" pkt_size="2048" sample_fmt="s16" nb_samples="1024" channels="1"/>
         <packet codec_type="audio" stream_index="0" pts="5120" pts_time="0.116100" dts="5120" dts_time="0.116100" duration="393" duration_time="0.008912" size="786" pos="792326" flags="K_"/>
-        <frame media_type="audio" stream_index="0" key_frame="1" pts="5120" pts_time="0.116100" pkt_dts="5120" pkt_dts_time="0.116100" best_effort_timestamp="5120" best_effort_timestamp_time="0.116100" pkt_duration="393" pkt_duration_time="0.008912" pkt_pos="792326" pkt_size="786" sample_fmt="s16" nb_samples="393" channels="1"/>
+        <frame media_type="audio" stream_index="0" key_frame="1" pts="5120" pts_time="0.116100" pkt_dts="5120" pkt_dts_time="0.116100" best_effort_timestamp="5120" best_effort_timestamp_time="0.116100" pkt_duration="393" pkt_duration_time="0.008912" duration="393" duration_time="0.008912" pkt_pos="792326" pkt_size="786" sample_fmt="s16" nb_samples="393" channels="1"/>
         <packet codec_type="video" stream_index="1" pts="6144" pts_time="0.120000" dts="6144" dts_time="0.120000" duration="2048" duration_time="0.040000" size="230400" pos="793142" flags="K_"/>
-        <frame media_type="video" stream_index="1" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="793142" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="1" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="793142" pkt_size="230400" width="320" height="240" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
         <packet codec_type="video" stream_index="2" pts="6144" pts_time="0.120000" dts="6144" dts_time="0.120000" duration="2048" duration_time="0.040000" size="30000" pos="1023566" flags="K_"/>
-        <frame media_type="video" stream_index="2" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" pkt_pos="1023566" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
+        <frame media_type="video" stream_index="2" key_frame="1" pts="6144" pts_time="0.120000" pkt_dts="6144" pkt_dts_time="0.120000" best_effort_timestamp="6144" best_effort_timestamp_time="0.120000" pkt_duration="2048" pkt_duration_time="0.040000" duration="2048" duration_time="0.040000" pkt_pos="1023566" pkt_size="30000" width="100" height="100" pix_fmt="rgb24" sample_aspect_ratio="1:1" pict_type="I" coded_picture_number="0" display_picture_number="0" interlaced_frame="0" top_field_first="0" repeat_pict="0"/>
     </packets_and_frames>
 
     <streams>
diff --git a/tests/ref/fate/filter-metadata-cropdetect b/tests/ref/fate/filter-metadata-cropdetect
index e7c03ea..f3e1865 100644
--- a/tests/ref/fate/filter-metadata-cropdetect
+++ b/tests/ref/fate/filter-metadata-cropdetect
@@ -1,32 +1,33 @@
-pts=0
+pts=0|
+
 pts=400
-pts=800|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=1200|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=1600|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=2000|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=2400|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=2800|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=3200|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=3600|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=4000|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=4400|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=4800|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=5200|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=5600|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=6000|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=6400|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=6800|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=7200|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=7600|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=8000|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=8400|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=8800|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=9200|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=9600|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=10000|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=10400|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=10800|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=11200|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=11600|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=12000|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
-pts=12400|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.y=68
+pts=800|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=1200|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=1600|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=2000|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=2400|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=2800|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=3200|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=3600|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=4000|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=4400|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=4800|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=5200|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=5600|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=6000|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=6400|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=6800|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=7200|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=7600|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=8000|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=8400|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=8800|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=9200|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=9600|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=10000|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=10400|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=10800|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=11200|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=11600|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=12000|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
+pts=12400|tag:lavfi.cropdetect.x=0|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=719|tag:lavfi.cropdetect.y1=61|tag:lavfi.cropdetect.y2=424|tag:lavfi.cropdetect.w=720|tag:lavfi.cropdetect.h=352|tag:lavfi.cropdetect.y=68
diff --git a/tests/ref/fate/filter-metadata-cropdetect1 b/tests/ref/fate/filter-metadata-cropdetect1
new file mode 100644
index 0000000..78fbefd
--- /dev/null
+++ b/tests/ref/fate/filter-metadata-cropdetect1
@@ -0,0 +1,11 @@
+pts=0|
+
+pts=1001|
+
+pts=2002|tag:lavfi.cropdetect.x=20|tag:lavfi.cropdetect.x1=20|tag:lavfi.cropdetect.x2=851|tag:lavfi.cropdetect.y1=311|tag:lavfi.cropdetect.y2=601|tag:lavfi.cropdetect.w=832|tag:lavfi.cropdetect.h=288|tag:lavfi.cropdetect.y=314|
+pts=3003|tag:lavfi.cropdetect.x=22|tag:lavfi.cropdetect.x1=20|tag:lavfi.cropdetect.x2=885|tag:lavfi.cropdetect.y1=311|tag:lavfi.cropdetect.y2=621|tag:lavfi.cropdetect.w=864|tag:lavfi.cropdetect.h=304|tag:lavfi.cropdetect.y=316|
+pts=4004|tag:lavfi.cropdetect.x=4|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=885|tag:lavfi.cropdetect.y1=115|tag:lavfi.cropdetect.y2=621|tag:lavfi.cropdetect.w=880|tag:lavfi.cropdetect.h=496|tag:lavfi.cropdetect.y=122|
+pts=5005|tag:lavfi.cropdetect.x=22|tag:lavfi.cropdetect.x1=20|tag:lavfi.cropdetect.x2=885|tag:lavfi.cropdetect.y1=311|tag:lavfi.cropdetect.y2=621|tag:lavfi.cropdetect.w=864|tag:lavfi.cropdetect.h=304|tag:lavfi.cropdetect.y=316|
+pts=6006|tag:lavfi.cropdetect.x=4|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=885|tag:lavfi.cropdetect.y1=115|tag:lavfi.cropdetect.y2=621|tag:lavfi.cropdetect.w=880|tag:lavfi.cropdetect.h=496|tag:lavfi.cropdetect.y=122|
+pts=7007|tag:lavfi.cropdetect.x=4|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=885|tag:lavfi.cropdetect.y1=115|tag:lavfi.cropdetect.y2=621|tag:lavfi.cropdetect.w=880|tag:lavfi.cropdetect.h=496|tag:lavfi.cropdetect.y=122|
+pts=8008|tag:lavfi.cropdetect.x=4|tag:lavfi.cropdetect.x1=0|tag:lavfi.cropdetect.x2=885|tag:lavfi.cropdetect.y1=115|tag:lavfi.cropdetect.y2=621|tag:lavfi.cropdetect.w=880|tag:lavfi.cropdetect.h=496|tag:lavfi.cropdetect.y=122|
diff --git a/tests/ref/fate/filter-metadata-cropdetect2 b/tests/ref/fate/filter-metadata-cropdetect2
new file mode 100644
index 0000000..e58f007
--- /dev/null
+++ b/tests/ref/fate/filter-metadata-cropdetect2
@@ -0,0 +1,12 @@
+pts=0|
+
+
+pts=512|
+
+pts=1024|tag:lavfi.cropdetect.x=22|tag:lavfi.cropdetect.x1=21|tag:lavfi.cropdetect.x2=1221|tag:lavfi.cropdetect.y1=15|tag:lavfi.cropdetect.y2=1116|tag:lavfi.cropdetect.w=1200|tag:lavfi.cropdetect.h=1088|tag:lavfi.cropdetect.y=22|
+pts=1536|tag:lavfi.cropdetect.x=24|tag:lavfi.cropdetect.x1=21|tag:lavfi.cropdetect.x2=1257|tag:lavfi.cropdetect.y1=15|tag:lavfi.cropdetect.y2=1116|tag:lavfi.cropdetect.w=1232|tag:lavfi.cropdetect.h=1088|tag:lavfi.cropdetect.y=22|
+pts=2048|tag:lavfi.cropdetect.x=22|tag:lavfi.cropdetect.x1=21|tag:lavfi.cropdetect.x2=1221|tag:lavfi.cropdetect.y1=15|tag:lavfi.cropdetect.y2=1116|tag:lavfi.cropdetect.w=1200|tag:lavfi.cropdetect.h=1088|tag:lavfi.cropdetect.y=22|
+pts=2560|tag:lavfi.cropdetect.x=22|tag:lavfi.cropdetect.x1=21|tag:lavfi.cropdetect.x2=1221|tag:lavfi.cropdetect.y1=15|tag:lavfi.cropdetect.y2=1116|tag:lavfi.cropdetect.w=1200|tag:lavfi.cropdetect.h=1088|tag:lavfi.cropdetect.y=22|
+pts=3072|tag:lavfi.cropdetect.x=28|tag:lavfi.cropdetect.x1=21|tag:lavfi.cropdetect.x2=817|tag:lavfi.cropdetect.y1=15|tag:lavfi.cropdetect.y2=937|tag:lavfi.cropdetect.w=784|tag:lavfi.cropdetect.h=912|tag:lavfi.cropdetect.y=22|
+pts=3584|tag:lavfi.cropdetect.x=28|tag:lavfi.cropdetect.x1=21|tag:lavfi.cropdetect.x2=817|tag:lavfi.cropdetect.y1=38|tag:lavfi.cropdetect.y2=937|tag:lavfi.cropdetect.w=784|tag:lavfi.cropdetect.h=896|tag:lavfi.cropdetect.y=40|
+pts=4096|tag:lavfi.cropdetect.x=28|tag:lavfi.cropdetect.x1=21|tag:lavfi.cropdetect.x2=817|tag:lavfi.cropdetect.y1=15|tag:lavfi.cropdetect.y2=937|tag:lavfi.cropdetect.w=784|tag:lavfi.cropdetect.h=912|tag:lavfi.cropdetect.y=22|
diff --git a/tests/ref/fate/filter-metadata-freezedetect b/tests/ref/fate/filter-metadata-freezedetect
index 47d9739..ffa2f39 100644
--- a/tests/ref/fate/filter-metadata-freezedetect
+++ b/tests/ref/fate/filter-metadata-freezedetect
@@ -151,7 +151,7 @@ pts=149
 pts=150
 pts=151
 pts=152
-pts=153|tag:lavfi.freezedetect.freeze_start=4.12|tag:lavfi.freezedetect.freeze_duration=2|tag:lavfi.freezedetect.freeze_end=6.12
+pts=153|tag:lavfi.freezedetect.freeze_duration=2|tag:lavfi.freezedetect.freeze_start=4.12|tag:lavfi.freezedetect.freeze_end=6.12
 pts=154
 pts=155
 pts=156
@@ -202,7 +202,7 @@ pts=200
 pts=201
 pts=202
 pts=203
-pts=204|tag:lavfi.freezedetect.freeze_start=6.16|tag:lavfi.freezedetect.freeze_duration=2|tag:lavfi.freezedetect.freeze_end=8.16
+pts=204|tag:lavfi.freezedetect.freeze_duration=2|tag:lavfi.freezedetect.freeze_start=6.16|tag:lavfi.freezedetect.freeze_end=8.16
 pts=205
 pts=206
 pts=207
diff --git a/tests/ref/fate/filter-metadata-scdet b/tests/ref/fate/filter-metadata-scdet
index b699911..ca5dbaa 100644
--- a/tests/ref/fate/filter-metadata-scdet
+++ b/tests/ref/fate/filter-metadata-scdet
@@ -1,11 +1,11 @@
-pts=1620|tag:lavfi.scd.mafd=60.175|tag:lavfi.scd.score=59.252|tag:lavfi.scd.time=2.7
-pts=4140|tag:lavfi.scd.mafd=44.209|tag:lavfi.scd.score=36.070|tag:lavfi.scd.time=6.9
-pts=5800|tag:lavfi.scd.mafd=55.819|tag:lavfi.scd.score=55.819|tag:lavfi.scd.time=9.66667
-pts=6720|tag:lavfi.scd.mafd=22.505|tag:lavfi.scd.score=18.580|tag:lavfi.scd.time=11.2
-pts=8160|tag:lavfi.scd.mafd=49.444|tag:lavfi.scd.score=49.240|tag:lavfi.scd.time=13.6
-pts=9760|tag:lavfi.scd.mafd=51.801|tag:lavfi.scd.score=51.497|tag:lavfi.scd.time=16.2667
-pts=14080|tag:lavfi.scd.mafd=34.337|tag:lavfi.scd.score=34.165|tag:lavfi.scd.time=23.4667
-pts=15700|tag:lavfi.scd.mafd=58.315|tag:lavfi.scd.score=58.310|tag:lavfi.scd.time=26.1667
-pts=18500|tag:lavfi.scd.mafd=19.603|tag:lavfi.scd.score=16.504|tag:lavfi.scd.time=30.8333
-pts=20040|tag:lavfi.scd.mafd=19.060|tag:lavfi.scd.score=13.764|tag:lavfi.scd.time=33.4
-pts=21760|tag:lavfi.scd.mafd=64.551|tag:lavfi.scd.score=64.451|tag:lavfi.scd.time=36.2667
+pts=1620|tag:lavfi.scd.score=59.252|tag:lavfi.scd.mafd=60.175|tag:lavfi.scd.time=2.7
+pts=4140|tag:lavfi.scd.score=36.070|tag:lavfi.scd.mafd=44.209|tag:lavfi.scd.time=6.9
+pts=5800|tag:lavfi.scd.score=55.819|tag:lavfi.scd.mafd=55.819|tag:lavfi.scd.time=9.66667
+pts=6720|tag:lavfi.scd.score=18.580|tag:lavfi.scd.mafd=22.505|tag:lavfi.scd.time=11.2
+pts=8160|tag:lavfi.scd.score=49.240|tag:lavfi.scd.mafd=49.444|tag:lavfi.scd.time=13.6
+pts=9760|tag:lavfi.scd.score=51.497|tag:lavfi.scd.mafd=51.801|tag:lavfi.scd.time=16.2667
+pts=14080|tag:lavfi.scd.score=34.165|tag:lavfi.scd.mafd=34.337|tag:lavfi.scd.time=23.4667
+pts=15700|tag:lavfi.scd.score=58.310|tag:lavfi.scd.mafd=58.315|tag:lavfi.scd.time=26.1667
+pts=18500|tag:lavfi.scd.score=16.504|tag:lavfi.scd.mafd=19.603|tag:lavfi.scd.time=30.8333
+pts=20040|tag:lavfi.scd.score=13.764|tag:lavfi.scd.mafd=19.060|tag:lavfi.scd.time=33.4
+pts=21760|tag:lavfi.scd.score=64.451|tag:lavfi.scd.mafd=64.551|tag:lavfi.scd.time=36.2667
diff --git a/tests/ref/fate/filter-metadata-signalstats-yuv420p b/tests/ref/fate/filter-metadata-signalstats-yuv420p
index c5b3fbf..a42acc8 100644
--- a/tests/ref/fate/filter-metadata-signalstats-yuv420p
+++ b/tests/ref/fate/filter-metadata-signalstats-yuv420p
@@ -1 +1 @@
-pts=0|tag:lavfi.signalstats.YMIN=235|tag:lavfi.signalstats.YLOW=235|tag:lavfi.signalstats.YAVG=235|tag:lavfi.signalstats.YHIGH=235|tag:lavfi.signalstats.YMAX=235|tag:lavfi.signalstats.UMIN=128|tag:lavfi.signalstats.ULOW=128|tag:lavfi.signalstats.UAVG=128|tag:lavfi.signalstats.UHIGH=128|tag:lavfi.signalstats.UMAX=128|tag:lavfi.signalstats.VMIN=128|tag:lavfi.signalstats.VLOW=128|tag:lavfi.signalstats.VAVG=128|tag:lavfi.signalstats.VHIGH=128|tag:lavfi.signalstats.VMAX=128|tag:lavfi.signalstats.SATMIN=0|tag:lavfi.signalstats.SATLOW=0|tag:lavfi.signalstats.SATAVG=0|tag:lavfi.signalstats.SATHIGH=0|tag:lavfi.signalstats.SATMAX=0|tag:lavfi.signalstats.HUEMED=180|tag:lavfi.signalstats.HUEAVG=180|tag:lavfi.signalstats.YDIF=0|tag:lavfi.signalstats.UDIF=0|tag:lavfi.signalstats.VDIF=0|tag:lavfi.signalstats.YBITDEPTH=6|tag:lavfi.signalstats.UBITDEPTH=1|tag:lavfi.signalstats.VBITDEPTH=1
+pts=0|tag:lavfi.signalstats.UBITDEPTH=1|tag:lavfi.signalstats.YMIN=235|tag:lavfi.signalstats.YLOW=235|tag:lavfi.signalstats.YAVG=235|tag:lavfi.signalstats.YHIGH=235|tag:lavfi.signalstats.YMAX=235|tag:lavfi.signalstats.UMIN=128|tag:lavfi.signalstats.ULOW=128|tag:lavfi.signalstats.UAVG=128|tag:lavfi.signalstats.UHIGH=128|tag:lavfi.signalstats.UMAX=128|tag:lavfi.signalstats.VMIN=128|tag:lavfi.signalstats.VLOW=128|tag:lavfi.signalstats.VAVG=128|tag:lavfi.signalstats.VHIGH=128|tag:lavfi.signalstats.VMAX=128|tag:lavfi.signalstats.SATMIN=0|tag:lavfi.signalstats.SATLOW=0|tag:lavfi.signalstats.SATAVG=0|tag:lavfi.signalstats.SATHIGH=0|tag:lavfi.signalstats.SATMAX=0|tag:lavfi.signalstats.HUEMED=180|tag:lavfi.signalstats.HUEAVG=180|tag:lavfi.signalstats.YDIF=0|tag:lavfi.signalstats.UDIF=0|tag:lavfi.signalstats.VDIF=0|tag:lavfi.signalstats.YBITDEPTH=6|tag:lavfi.signalstats.VBITDEPTH=1
diff --git a/tests/ref/fate/filter-metadata-signalstats-yuv420p10 b/tests/ref/fate/filter-metadata-signalstats-yuv420p10
index 93d3ca2..1e5afd0 100644
--- a/tests/ref/fate/filter-metadata-signalstats-yuv420p10
+++ b/tests/ref/fate/filter-metadata-signalstats-yuv420p10
@@ -1 +1 @@
-pts=0|tag:lavfi.signalstats.YMIN=943|tag:lavfi.signalstats.YLOW=943|tag:lavfi.signalstats.YAVG=943|tag:lavfi.signalstats.YHIGH=943|tag:lavfi.signalstats.YMAX=943|tag:lavfi.signalstats.UMIN=514|tag:lavfi.signalstats.ULOW=514|tag:lavfi.signalstats.UAVG=514|tag:lavfi.signalstats.UHIGH=514|tag:lavfi.signalstats.UMAX=514|tag:lavfi.signalstats.VMIN=514|tag:lavfi.signalstats.VLOW=514|tag:lavfi.signalstats.VAVG=514|tag:lavfi.signalstats.VHIGH=514|tag:lavfi.signalstats.VMAX=514|tag:lavfi.signalstats.SATMIN=2|tag:lavfi.signalstats.SATLOW=2|tag:lavfi.signalstats.SATAVG=2|tag:lavfi.signalstats.SATHIGH=2|tag:lavfi.signalstats.SATMAX=2|tag:lavfi.signalstats.HUEMED=225|tag:lavfi.signalstats.HUEAVG=225|tag:lavfi.signalstats.YDIF=0|tag:lavfi.signalstats.UDIF=0|tag:lavfi.signalstats.VDIF=0|tag:lavfi.signalstats.YBITDEPTH=8|tag:lavfi.signalstats.UBITDEPTH=2|tag:lavfi.signalstats.VBITDEPTH=2
+pts=0|tag:lavfi.signalstats.UBITDEPTH=2|tag:lavfi.signalstats.YMIN=943|tag:lavfi.signalstats.YLOW=943|tag:lavfi.signalstats.YAVG=943|tag:lavfi.signalstats.YHIGH=943|tag:lavfi.signalstats.YMAX=943|tag:lavfi.signalstats.UMIN=514|tag:lavfi.signalstats.ULOW=514|tag:lavfi.signalstats.UAVG=514|tag:lavfi.signalstats.UHIGH=514|tag:lavfi.signalstats.UMAX=514|tag:lavfi.signalstats.VMIN=514|tag:lavfi.signalstats.VLOW=514|tag:lavfi.signalstats.VAVG=514|tag:lavfi.signalstats.VHIGH=514|tag:lavfi.signalstats.VMAX=514|tag:lavfi.signalstats.SATMIN=2|tag:lavfi.signalstats.SATLOW=2|tag:lavfi.signalstats.SATAVG=2|tag:lavfi.signalstats.SATHIGH=2|tag:lavfi.signalstats.SATMAX=2|tag:lavfi.signalstats.HUEMED=225|tag:lavfi.signalstats.HUEAVG=225|tag:lavfi.signalstats.YDIF=0|tag:lavfi.signalstats.UDIF=0|tag:lavfi.signalstats.VDIF=0|tag:lavfi.signalstats.YBITDEPTH=8|tag:lavfi.signalstats.VBITDEPTH=2
diff --git a/tests/ref/fate/filter-pixdesc-nv16 b/tests/ref/fate/filter-pixdesc-nv16
new file mode 100644
index 0000000..4c4587c
--- /dev/null
+++ b/tests/ref/fate/filter-pixdesc-nv16
@@ -0,0 +1 @@
+pixdesc-nv16        cbbc5d904b8eebad3705a325c3ec5734
diff --git a/tests/ref/fate/filter-pixdesc-vuya b/tests/ref/fate/filter-pixdesc-vuya
new file mode 100644
index 0000000..660922e
--- /dev/null
+++ b/tests/ref/fate/filter-pixdesc-vuya
@@ -0,0 +1 @@
+pixdesc-vuya        acf482aa1a27ed6166a3673cc5920a22
diff --git a/tests/ref/fate/filter-pixfmts-copy b/tests/ref/fate/filter-pixfmts-copy
index f06fa15..93dd611 100644
--- a/tests/ref/fate/filter-pixfmts-copy
+++ b/tests/ref/fate/filter-pixfmts-copy
@@ -56,6 +56,7 @@ grayf32le           fb6ea85bfbc8cd21c51fc0e110197294
 monob               8b04f859fee6a0be856be184acd7a0b5
 monow               54d16d2c01abfd72ecdb5e51e283937c
 nv12                8e24feb2c544dc26a20047a71e4c27aa
+nv16                22b1916c0694c4e2979bab8eb71f3d6b
 nv21                335d85c9af6110f26ae9e187a82ed2cf
 nv24                f30fc8d0ac40af69e119ea919a314572
 nv42                29a212f70f8780fe0eb99abcae81894d
@@ -88,6 +89,7 @@ rgba                b6e1b441c365e03b5ffdf9b7b68d9a0c
 rgba64be            ae2ae04b5efedca3505f47c4dd6ea6ea
 rgba64le            b91e1d77f799eb92241a2d2d28437b15
 uyvy422             3bcf3c80047592f2211fae3260b1b65d
+vuya                3d5e934651cae1ce334001cb1829ad22
 x2bgr10le           550c0d190cf695afa4eaacb644db6b75
 x2rgb10le           c1e3ac21be04a16bb157b22784524520
 xyz12be             a1ef56bf746d71f59669c28e48fc8450
diff --git a/tests/ref/fate/filter-pixfmts-crop b/tests/ref/fate/filter-pixfmts-crop
index 8b26ab9..739b997 100644
--- a/tests/ref/fate/filter-pixfmts-crop
+++ b/tests/ref/fate/filter-pixfmts-crop
@@ -54,6 +54,7 @@ gray9le             4d1932d4968a248584f5e39c25f1dd43
 grayf32be           cf40ec06a8abe54852b7f85a00549eec
 grayf32le           b672526c9da9c8959ab881f242f6890a
 nv12                92cda427f794374731ec0321ee00caac
+nv16                3264b16aaae554c21f052102b491c13b
 nv21                1bcfc197f4fb95de85ba58182d8d2f69
 nv24                514c8f12082f0737e558778cbe7de258
 nv42                ece9baae1c5de579dac2c66a89e08ef3
@@ -85,6 +86,7 @@ rgb8                9b364a8f112ad9459fec47a51cc03b30
 rgba                9488ac85abceaf99a9309eac5a87697e
 rgba64be            89910046972ab3c68e2a348302cc8ca9
 rgba64le            fea8ebfc869b52adf353778f29eac7a7
+vuya                76578a705ff3a37559653c1289bd03dd
 x2bgr10le           84de725b85662c362862820dc4a309aa
 x2rgb10le           f4265aca7a67dbfa9354370098ca6f33
 xyz12be             cb4571f9aaa7b59f999ef327276104b7
diff --git a/tests/ref/fate/filter-pixfmts-field b/tests/ref/fate/filter-pixfmts-field
index c4838d1..e08161b 100644
--- a/tests/ref/fate/filter-pixfmts-field
+++ b/tests/ref/fate/filter-pixfmts-field
@@ -56,6 +56,7 @@ grayf32le           6b856bdbf2a2bfcd2bc7d50f109daaf0
 monob               2129cc72a484d7e10a44de9117aa9f80
 monow               03d783611d265cae78293f88ea126ea1
 nv12                16f7a46708ef25ebd0b72e47920cc11e
+nv16                34f36b03f5fccf4eac147b26bbc0a5e5
 nv21                7294574037cc7f9373ef5695d8ebe809
 nv24                3b100fb527b64ee2b2d7120da573faf5
 nv42                1841ce853152d86b27c130f319ea0db2
@@ -88,6 +89,7 @@ rgba                ee616262ca6d67b7ecfba4b36c602ce3
 rgba64be            23c8c0edaabe3eaec89ce69633fb0048
 rgba64le            dfdba4de4a7cac9abf08852666c341d3
 uyvy422             1c49e44ab3f060e85fc4a3a9464f045e
+vuya                f72bcf29d75cd143d0c565f7cc49119a
 x2bgr10le           dbe21538d7cb1744914f6bd46ec09b55
 x2rgb10le           a18bc4ae5274e0a8cca9137ecd50c677
 xyz12be             d2fa69ec91d3ed862f2dac3f8e7a3437
diff --git a/tests/ref/fate/filter-pixfmts-fieldorder b/tests/ref/fate/filter-pixfmts-fieldorder
index 32c06ba..de5c4fe 100644
--- a/tests/ref/fate/filter-pixfmts-fieldorder
+++ b/tests/ref/fate/filter-pixfmts-fieldorder
@@ -53,6 +53,7 @@ gray9be             ec877f5bcf0ea275a6f36c12cc9adf11
 gray9le             fba944fde7923d5089f4f52d12988b9e
 grayf32be           1aa7960131f880c54fe3c77f13448674
 grayf32le           4029ac9d197f255794c1b9e416520fc7
+nv16                085deb984ab986eb5cc961fe265e30c0
 nv24                4fdbef26042c77f012df114e666efdb2
 nv42                59608290fece913e6b7d61edf581a529
 p210be              ca2ce2c25db43dcd14729b2a72a7c604
@@ -79,6 +80,7 @@ rgba                1fdf872a087a32cd35b80cc7be399578
 rgba64be            5598f44514d122b9a57c5c92c20bbc61
 rgba64le            b34e6e30621ae579519a2d91a96a0acf
 uyvy422             75de70e31c435dde878002d3f22b238a
+vuya                a3891d4168ff208948fd0b3ba0910495
 x2bgr10le           86474d84f26c5c51d6f75bf7e1de8da8
 x2rgb10le           cdf6a9e8a8d081aa768c6ae2e6221676
 xyz12be             15f5cda71de5fef9cec5e75e3833b6bc
diff --git a/tests/ref/fate/filter-pixfmts-hflip b/tests/ref/fate/filter-pixfmts-hflip
index 4d3efe3..b0f6754 100644
--- a/tests/ref/fate/filter-pixfmts-hflip
+++ b/tests/ref/fate/filter-pixfmts-hflip
@@ -54,6 +54,7 @@ gray9le             424fc581947bc8c357c9ec5e3c1c04d1
 grayf32be           a69add7bbf892a71fe81b3b75982dbe2
 grayf32le           4563e176a35dc8a8a07e0829fad5eb88
 nv12                801e58f1be5fd0b5bc4bf007c604b0b4
+nv16                06ba714cb8b220c203f5898ef39abf93
 nv21                9f10dfff8963dc327d3395af21f0554f
 nv24                f0c5b2f42970f8d4003621d8857a872f
 nv42                4dcf9aec82b110712b396a8b365dcb13
@@ -85,6 +86,7 @@ rgb8                68a3a575badadd9e4f90226209f11699
 rgba                51961c723ea6707e0a410cd3f21f15d3
 rgba64be            c910444019f4cfbf4d995227af55da8d
 rgba64le            0c810d8b3a6bca10321788e1cb145340
+vuya                7e530261e7ac4eae4fd616fd7572d0b8
 x2bgr10le           827cc659f29378e00c5a7d2c0ada8f9a
 x2rgb10le           d4a8189b65395a88d0a38a7053f3359f
 xyz12be             25f90259ff8a226befdaec3dfe82996e
diff --git a/tests/ref/fate/filter-pixfmts-il b/tests/ref/fate/filter-pixfmts-il
index 4623f24..04efcb8 100644
--- a/tests/ref/fate/filter-pixfmts-il
+++ b/tests/ref/fate/filter-pixfmts-il
@@ -56,6 +56,7 @@ grayf32le           8bf3d295c3ffd53da0e06d0702e7c1ca
 monob               faba75df28033ba7ce3d82ff2a99ee68
 monow               6e9cfb8d3a344c5f0c3e1d5e1297e580
 nv12                3c3ba9b1b4c4dfff09c26f71b51dd146
+nv16                355d055f91793a171302021b3fc486b0
 nv21                ab586d8781246b5a32d8760a61db9797
 nv24                554153c71d142e3fd8e40b7dcaaec229
 nv42                d699724c8deaeb4f87faf2766512eec3
@@ -87,6 +88,7 @@ rgba                625d8f4bd39c4bdbf61eb5e4713aecc9
 rgba64be            db70d33aa6c06f3e0a1c77bd11284261
 rgba64le            a8a2daae04374a27219bc1c890204007
 uyvy422             d6ee3ca43356d08c392382b24b22cda5
+vuya                b9deab5ba249dd608b709c09255a4932
 x2bgr10le           135acaff8318cf9861bb0f7849a9e5e9
 x2rgb10le           517fb186f523dc7cdc5c5c6967cfbe94
 xyz12be             7c7d54c55f136cbbc50b18029f3be0b3
diff --git a/tests/ref/fate/filter-pixfmts-null b/tests/ref/fate/filter-pixfmts-null
index f06fa15..93dd611 100644
--- a/tests/ref/fate/filter-pixfmts-null
+++ b/tests/ref/fate/filter-pixfmts-null
@@ -56,6 +56,7 @@ grayf32le           fb6ea85bfbc8cd21c51fc0e110197294
 monob               8b04f859fee6a0be856be184acd7a0b5
 monow               54d16d2c01abfd72ecdb5e51e283937c
 nv12                8e24feb2c544dc26a20047a71e4c27aa
+nv16                22b1916c0694c4e2979bab8eb71f3d6b
 nv21                335d85c9af6110f26ae9e187a82ed2cf
 nv24                f30fc8d0ac40af69e119ea919a314572
 nv42                29a212f70f8780fe0eb99abcae81894d
@@ -88,6 +89,7 @@ rgba                b6e1b441c365e03b5ffdf9b7b68d9a0c
 rgba64be            ae2ae04b5efedca3505f47c4dd6ea6ea
 rgba64le            b91e1d77f799eb92241a2d2d28437b15
 uyvy422             3bcf3c80047592f2211fae3260b1b65d
+vuya                3d5e934651cae1ce334001cb1829ad22
 x2bgr10le           550c0d190cf695afa4eaacb644db6b75
 x2rgb10le           c1e3ac21be04a16bb157b22784524520
 xyz12be             a1ef56bf746d71f59669c28e48fc8450
diff --git a/tests/ref/fate/filter-pixfmts-pad b/tests/ref/fate/filter-pixfmts-pad
index a30658b..0f00aff 100644
--- a/tests/ref/fate/filter-pixfmts-pad
+++ b/tests/ref/fate/filter-pixfmts-pad
@@ -22,6 +22,7 @@ gray14le            6d6b293b5d50944c5aa422245987c78e
 gray16le            2734ce1793a2216c5be30816689cd2fe
 gray9le             f8f3dfe31ca5fcba828285bceefdab9a
 nv12                381574979cb04be10c9168540310afad
+nv16                d3a50501d2ea8535489fd5ec49e7866d
 nv21                0fdeb2cdd56cf5a7147dc273456fa217
 nv24                193b9eadcc06ad5081609f76249b3e47
 nv42                1738ad3c31c6c16e17679f5b09ce4677
@@ -34,6 +35,7 @@ p416le              fa4e023d0bf4b03b0ffef3d4d35abf7e
 rgb0                0984eb985dabbe757ed6beb53db84eff
 rgb24               17f9e2e0c609009acaf2175c42d4a2a5
 rgba                b157c90191463d34fb3ce77b36c96386
+vuya                44368c0a758ee68e24ce976e3b1b8535
 xyz12le             23dadbbba70b2925ce75fb8ba8080ba3
 ya16le              8dbfcb586abf626da7d1aca887a581b9
 ya8                 495daaca2dcb4f7aeba7652768b41ced
diff --git a/tests/ref/fate/filter-pixfmts-scale b/tests/ref/fate/filter-pixfmts-scale
index 43074b8..f4822f5 100644
--- a/tests/ref/fate/filter-pixfmts-scale
+++ b/tests/ref/fate/filter-pixfmts-scale
@@ -56,6 +56,7 @@ grayf32le           2ff1b84023e820307b1ba7a9550115bc
 monob               f01cb0b623357387827902d9d0963435
 monow               35c68b86c226d6990b2dcb573a05ff6b
 nv12                b118d24a3653fe66e5d9e079033aef79
+nv16                68e757396b62b84aad657274b8f6ce15
 nv21                c74bb1c10dbbdee8a1f682b194486c4d
 nv24                2aa6e805bf6d4179ed8d7dea37d75db3
 nv42                80714d1eb2d8bcaeab3abc3124df1abd
@@ -88,6 +89,7 @@ rgba                85bb5d03cea1c6e8002ced3373904336
 rgba64be            ee73e57923af984b31cc7795d13929da
 rgba64le            783d2779adfafe3548bdb671ec0de69e
 uyvy422             aeb4ba4f9f003ae21f6d18089198244f
+vuya                ffa817e283bf6a0b6fba21b07523ccaa
 x2bgr10le           d57b9a99033cc7b65ddd111578f2d385
 x2rgb10le           d56bdb23fa6a8e12a0b4394987f89935
 xyz12be             c7ba8345998c0141ddc079cdd29b1a40
diff --git a/tests/ref/fate/filter-pixfmts-transpose b/tests/ref/fate/filter-pixfmts-transpose
index 922666c..b3f2d5c 100644
--- a/tests/ref/fate/filter-pixfmts-transpose
+++ b/tests/ref/fate/filter-pixfmts-transpose
@@ -80,6 +80,7 @@ rgb8                c90feb30c3c9391ef5f470209d7b7a15
 rgba                4d76a9542143752a4ac30f82f88f68f1
 rgba64be            a60041217f4c0cd796d19d3940a12a41
 rgba64le            ad47197774858858ae7b0c177dffa459
+vuya                9ece18a345beb17cd19e09e443eca4bf
 x2bgr10le           4aa774b6d8f6d446a64f1f288e5c97eb
 x2rgb10le           09cb1d98fe17ad8a6d9d3bec97ddc845
 xyz12be             68e5cba640f6e4ef72dff950e88b5342
diff --git a/tests/ref/fate/filter-pixfmts-vflip b/tests/ref/fate/filter-pixfmts-vflip
index 3a53bb5..9081ce4 100644
--- a/tests/ref/fate/filter-pixfmts-vflip
+++ b/tests/ref/fate/filter-pixfmts-vflip
@@ -56,6 +56,7 @@ grayf32le           8e6c048a5b3b8b26d3a5ddfce255f3f6
 monob               7810c4857822ccfc844d78f5e803269a
 monow               90a947bfcd5f2261e83b577f48ec57b1
 nv12                261ebe585ae2aa4e70d39a10c1679294
+nv16                f20f3448c900847aaff74429196f5a00
 nv21                2909feacd27bebb080c8e0fa41795269
 nv24                334420b9d3df84499d2ca16bb66eed2b
 nv42                ba4063e2795c17fea3c8a646b01fd1f5
@@ -88,6 +89,7 @@ rgba                c1a5908572737f2ae1e5d8218af65f4b
 rgba64be            17e6273323b5779b5f3f775f150c1011
 rgba64le            48f45b10503b7dd140329c3dd0d54c98
 uyvy422             3a237e8376264e0cfa78f8a3fdadec8a
+vuya                fb849f76e56181e005c31fce75d7038c
 x2bgr10le           795b66a5fc83cd2cf300aae51c230f80
 x2rgb10le           262c502230cf3724f8e2cf4737f18a42
 xyz12be             810644e008deb231850d779aaa27cc7e
diff --git a/tests/ref/fate/flcl1905 b/tests/ref/fate/flcl1905
index d702139..59cee95 100644
--- a/tests/ref/fate/flcl1905
+++ b/tests/ref/fate/flcl1905
@@ -1,192 +1,192 @@
 packet|codec_type=audio|stream_index=0|pts=0|pts_time=0.000000|dts=0|dts_time=0.000000|duration=22528|duration_time=0.510839|size=4092|pos=56|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=56|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=56|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=22528|pts_time=0.510839|dts=22528|dts_time=0.510839|duration=22528|duration_time=0.510839|size=4092|pos=4148|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=22528|pts_time=0.510839|pkt_dts=22528|pkt_dts_time=0.510839|best_effort_timestamp=22528|best_effort_timestamp_time=0.510839|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=4148|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=22528|pts_time=0.510839|pkt_dts=22528|pkt_dts_time=0.510839|best_effort_timestamp=22528|best_effort_timestamp_time=0.510839|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=4148|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=45056|pts_time=1.021678|dts=45056|dts_time=1.021678|duration=22528|duration_time=0.510839|size=4092|pos=8240|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=45056|pts_time=1.021678|pkt_dts=45056|pkt_dts_time=1.021678|best_effort_timestamp=45056|best_effort_timestamp_time=1.021678|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=8240|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=45056|pts_time=1.021678|pkt_dts=45056|pkt_dts_time=1.021678|best_effort_timestamp=45056|best_effort_timestamp_time=1.021678|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=8240|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=67584|pts_time=1.532517|dts=67584|dts_time=1.532517|duration=22528|duration_time=0.510839|size=4092|pos=12332|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=67584|pts_time=1.532517|pkt_dts=67584|pkt_dts_time=1.532517|best_effort_timestamp=67584|best_effort_timestamp_time=1.532517|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=12332|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=67584|pts_time=1.532517|pkt_dts=67584|pkt_dts_time=1.532517|best_effort_timestamp=67584|best_effort_timestamp_time=1.532517|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=12332|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=90112|pts_time=2.043356|dts=90112|dts_time=2.043356|duration=22528|duration_time=0.510839|size=4092|pos=16424|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=90112|pts_time=2.043356|pkt_dts=90112|pkt_dts_time=2.043356|best_effort_timestamp=90112|best_effort_timestamp_time=2.043356|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=16424|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=90112|pts_time=2.043356|pkt_dts=90112|pkt_dts_time=2.043356|best_effort_timestamp=90112|best_effort_timestamp_time=2.043356|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=16424|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=112640|pts_time=2.554195|dts=112640|dts_time=2.554195|duration=22528|duration_time=0.510839|size=4092|pos=20516|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=112640|pts_time=2.554195|pkt_dts=112640|pkt_dts_time=2.554195|best_effort_timestamp=112640|best_effort_timestamp_time=2.554195|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=20516|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=112640|pts_time=2.554195|pkt_dts=112640|pkt_dts_time=2.554195|best_effort_timestamp=112640|best_effort_timestamp_time=2.554195|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=20516|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=135168|pts_time=3.065034|dts=135168|dts_time=3.065034|duration=22528|duration_time=0.510839|size=4092|pos=24608|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=135168|pts_time=3.065034|pkt_dts=135168|pkt_dts_time=3.065034|best_effort_timestamp=135168|best_effort_timestamp_time=3.065034|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=24608|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=135168|pts_time=3.065034|pkt_dts=135168|pkt_dts_time=3.065034|best_effort_timestamp=135168|best_effort_timestamp_time=3.065034|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=24608|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=157696|pts_time=3.575873|dts=157696|dts_time=3.575873|duration=22528|duration_time=0.510839|size=4092|pos=28700|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=157696|pts_time=3.575873|pkt_dts=157696|pkt_dts_time=3.575873|best_effort_timestamp=157696|best_effort_timestamp_time=3.575873|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=28700|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=157696|pts_time=3.575873|pkt_dts=157696|pkt_dts_time=3.575873|best_effort_timestamp=157696|best_effort_timestamp_time=3.575873|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=28700|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=180224|pts_time=4.086712|dts=180224|dts_time=4.086712|duration=22528|duration_time=0.510839|size=4092|pos=32792|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=180224|pts_time=4.086712|pkt_dts=180224|pkt_dts_time=4.086712|best_effort_timestamp=180224|best_effort_timestamp_time=4.086712|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=32792|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=180224|pts_time=4.086712|pkt_dts=180224|pkt_dts_time=4.086712|best_effort_timestamp=180224|best_effort_timestamp_time=4.086712|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=32792|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=202752|pts_time=4.597551|dts=202752|dts_time=4.597551|duration=22528|duration_time=0.510839|size=4092|pos=36884|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=202752|pts_time=4.597551|pkt_dts=202752|pkt_dts_time=4.597551|best_effort_timestamp=202752|best_effort_timestamp_time=4.597551|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=36884|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=202752|pts_time=4.597551|pkt_dts=202752|pkt_dts_time=4.597551|best_effort_timestamp=202752|best_effort_timestamp_time=4.597551|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=36884|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=225280|pts_time=5.108390|dts=225280|dts_time=5.108390|duration=22528|duration_time=0.510839|size=4092|pos=40976|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=225280|pts_time=5.108390|pkt_dts=225280|pkt_dts_time=5.108390|best_effort_timestamp=225280|best_effort_timestamp_time=5.108390|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=40976|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=225280|pts_time=5.108390|pkt_dts=225280|pkt_dts_time=5.108390|best_effort_timestamp=225280|best_effort_timestamp_time=5.108390|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=40976|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=247808|pts_time=5.619229|dts=247808|dts_time=5.619229|duration=22528|duration_time=0.510839|size=4092|pos=45068|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=247808|pts_time=5.619229|pkt_dts=247808|pkt_dts_time=5.619229|best_effort_timestamp=247808|best_effort_timestamp_time=5.619229|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=45068|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=247808|pts_time=5.619229|pkt_dts=247808|pkt_dts_time=5.619229|best_effort_timestamp=247808|best_effort_timestamp_time=5.619229|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=45068|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=270336|pts_time=6.130068|dts=270336|dts_time=6.130068|duration=22528|duration_time=0.510839|size=4092|pos=49160|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=270336|pts_time=6.130068|pkt_dts=270336|pkt_dts_time=6.130068|best_effort_timestamp=270336|best_effort_timestamp_time=6.130068|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=49160|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=270336|pts_time=6.130068|pkt_dts=270336|pkt_dts_time=6.130068|best_effort_timestamp=270336|best_effort_timestamp_time=6.130068|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=49160|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=292864|pts_time=6.640907|dts=292864|dts_time=6.640907|duration=22528|duration_time=0.510839|size=4092|pos=53252|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=292864|pts_time=6.640907|pkt_dts=292864|pkt_dts_time=6.640907|best_effort_timestamp=292864|best_effort_timestamp_time=6.640907|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=53252|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=292864|pts_time=6.640907|pkt_dts=292864|pkt_dts_time=6.640907|best_effort_timestamp=292864|best_effort_timestamp_time=6.640907|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=53252|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=315392|pts_time=7.151746|dts=315392|dts_time=7.151746|duration=22528|duration_time=0.510839|size=4092|pos=57344|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=315392|pts_time=7.151746|pkt_dts=315392|pkt_dts_time=7.151746|best_effort_timestamp=315392|best_effort_timestamp_time=7.151746|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=57344|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=315392|pts_time=7.151746|pkt_dts=315392|pkt_dts_time=7.151746|best_effort_timestamp=315392|best_effort_timestamp_time=7.151746|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=57344|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=337920|pts_time=7.662585|dts=337920|dts_time=7.662585|duration=22528|duration_time=0.510839|size=4092|pos=61436|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=337920|pts_time=7.662585|pkt_dts=337920|pkt_dts_time=7.662585|best_effort_timestamp=337920|best_effort_timestamp_time=7.662585|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|pkt_pos=61436|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=337920|pts_time=7.662585|pkt_dts=337920|pkt_dts_time=7.662585|best_effort_timestamp=337920|best_effort_timestamp_time=7.662585|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=4092|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=3720|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=3348|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=2976|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=2604|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=2232|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=1860|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=1488|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=1116|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=744|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=22528|pkt_duration_time=0.510839|duration=22528|duration_time=0.510839|pkt_pos=61436|pkt_size=372|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
 packet|codec_type=audio|stream_index=0|pts=360448|pts_time=8.173424|dts=360448|dts_time=8.173424|duration=44|duration_time=0.000998|size=8|pos=65528|flags=K_
-frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=N/A|pkt_duration_time=N/A|pkt_pos=N/A|pkt_size=0|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
+frame|media_type=audio|stream_index=0|key_frame=1|pts=N/A|pts_time=N/A|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=N/A|best_effort_timestamp_time=N/A|pkt_duration=N/A|pkt_duration_time=N/A|duration=N/A|duration_time=N/A|pkt_pos=N/A|pkt_size=0|sample_fmt=fltp|nb_samples=2048|channels=2|channel_layout=unknown
diff --git a/tests/ref/fate/flv-add_keyframe_index b/tests/ref/fate/flv-add_keyframe_index
index 39c4bed..6549170 100644
--- a/tests/ref/fate/flv-add_keyframe_index
+++ b/tests/ref/fate/flv-add_keyframe_index
@@ -1,4 +1,4 @@
-5f38d76da3ed4a5be06ca604c53666f2 *tests/data/fate/flv-add_keyframe_index.flv
+9f3d6de74f3329651a4c515c20cea00f *tests/data/fate/flv-add_keyframe_index.flv
 630192 tests/data/fate/flv-add_keyframe_index.flv
 #tb 0: 1/1000
 #media_type 0: video
diff --git a/tests/ref/fate/h264-dts_5frames b/tests/ref/fate/h264-dts_5frames
index 8c6e48d..ef54d5d 100644
--- a/tests/ref/fate/h264-dts_5frames
+++ b/tests/ref/fate/h264-dts_5frames
@@ -10,6 +10,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=166
 pkt_duration_time=0.166000
+duration=166
+duration_time=0.166000
 pkt_pos=651
 pkt_size=14428
 width=512
@@ -40,6 +42,8 @@ best_effort_timestamp=167
 best_effort_timestamp_time=0.167000
 pkt_duration=166
 pkt_duration_time=0.166000
+duration=166
+duration_time=0.166000
 pkt_pos=15085
 pkt_size=11
 width=512
@@ -70,6 +74,8 @@ best_effort_timestamp=333
 best_effort_timestamp_time=0.333000
 pkt_duration=166
 pkt_duration_time=0.166000
+duration=166
+duration_time=0.166000
 pkt_pos=15102
 pkt_size=11
 width=512
@@ -100,6 +106,8 @@ best_effort_timestamp=500
 best_effort_timestamp_time=0.500000
 pkt_duration=166
 pkt_duration_time=0.166000
+duration=166
+duration_time=0.166000
 pkt_pos=15119
 pkt_size=11
 width=512
@@ -130,6 +138,8 @@ best_effort_timestamp=667
 best_effort_timestamp_time=0.667000
 pkt_duration=166
 pkt_duration_time=0.166000
+duration=166
+duration_time=0.166000
 pkt_pos=15136
 pkt_size=11
 width=512
diff --git a/tests/ref/fate/hevc-conformance-WPP_HIGH_TP_444_8BIT_RExt_Apple_2 b/tests/ref/fate/hevc-conformance-WPP_HIGH_TP_444_8BIT_RExt_Apple_2
new file mode 100644
index 0000000..fcb1d28
--- /dev/null
+++ b/tests/ref/fate/hevc-conformance-WPP_HIGH_TP_444_8BIT_RExt_Apple_2
@@ -0,0 +1,8 @@
+#tb 0: 1/25
+#media_type 0: video
+#codec_id 0: rawvideo
+#dimensions 0: 1024x768
+#sar 0: 0/1
+0,          0,          0,        1,  1179648, 0x78e55a69
+0,          1,          1,        1,  1179648, 0x5babb3cb
+0,          2,          2,        1,  1179648, 0x65935648
diff --git a/tests/ref/fate/imgutils b/tests/ref/fate/imgutils
index b23d1b4..01c9877 100644
--- a/tests/ref/fate/imgutils
+++ b/tests/ref/fate/imgutils
@@ -246,3 +246,6 @@ p216be          planes: 2, linesizes: 128 128   0   0, plane_sizes:  6144  6144
 p216le          planes: 2, linesizes: 128 128   0   0, plane_sizes:  6144  6144     0     0, plane_offsets:  6144     0     0, total_size: 12288
 p416be          planes: 2, linesizes: 128 256   0   0, plane_sizes:  6144 12288     0     0, plane_offsets:  6144     0     0, total_size: 18432
 p416le          planes: 2, linesizes: 128 256   0   0, plane_sizes:  6144 12288     0     0, plane_offsets:  6144     0     0, total_size: 18432
+vuya            planes: 1, linesizes: 256   0   0   0, plane_sizes: 12288     0     0     0, plane_offsets:     0     0     0, total_size: 12288
+rgbaf16be       planes: 1, linesizes: 512   0   0   0, plane_sizes: 24576     0     0     0, plane_offsets:     0     0     0, total_size: 24576
+rgbaf16le       planes: 1, linesizes: 512   0   0   0, plane_sizes: 24576     0     0     0, plane_offsets:     0     0     0, total_size: 24576
diff --git a/tests/ref/fate/jpg-icc b/tests/ref/fate/jpg-icc
index 2201465..a0a33e0 100644
--- a/tests/ref/fate/jpg-icc
+++ b/tests/ref/fate/jpg-icc
@@ -18,6 +18,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1
 pkt_duration_time=0.040000
+duration=1
+duration_time=0.040000
 pkt_pos=0
 pkt_size=11010
 width=128
diff --git a/tests/ref/fate/matroska-flac-extradata-update b/tests/ref/fate/matroska-flac-extradata-update
index e8812f5..d581492 100644
--- a/tests/ref/fate/matroska-flac-extradata-update
+++ b/tests/ref/fate/matroska-flac-extradata-update
@@ -1,8 +1,8 @@
-732446e97bae29037ff0cd9963d4ac08 *tests/data/fate/matroska-flac-extradata-update.matroska
-1987 tests/data/fate/matroska-flac-extradata-update.matroska
-#extradata 0:       34, 0x7acb09e7
-#extradata 1:       34, 0x7acb09e7
-#extradata 2:       34, 0x443402dd
+28bc0ded5dc520d955caf29db80d35da *tests/data/fate/matroska-flac-extradata-update.matroska
+1795 tests/data/fate/matroska-flac-extradata-update.matroska
+#extradata 0:       34, 0x93650c81
+#extradata 1:       34, 0x93650c81
+#extradata 2:       34, 0x93650c81
 #tb 0: 1/1000
 #media_type 0: audio
 #codec_id 0: flac
@@ -42,9 +42,3 @@
 0,        672,        672,       96,       26, 0x50dd042e
 1,        672,        672,       96,       26, 0x50dd042e
 2,        672,        672,       96,       26, 0x50dd042e
-0,        768,        768,       96,       26, 0x53de0499
-1,        768,        768,       96,       26, 0x53de0499
-0,        864,        864,       96,       26, 0x53df04b4
-1,        864,        864,       96,       26, 0x53df04b4
-0,        960,        960,       42,       26, 0x5740044b
-1,        960,        960,       42,       26, 0x5740044b
diff --git a/tests/ref/fate/mkv-1242 b/tests/ref/fate/mkv-1242
index e025701..1d1a227 100644
--- a/tests/ref/fate/mkv-1242
+++ b/tests/ref/fate/mkv-1242
@@ -42,6 +42,3 @@
 1,        383,        383,       21,      325, 0xcd7a9fd6
 1,        404,        404,       22,      359, 0x6edeb91c
 1,        426,        426,       21,      333, 0xb8999fb7
-1,        447,        447,       21,      317, 0xf2589e1a
-1,        468,        468,       21,      319, 0x82ed9572
-1,        489,        489,       22,      473, 0xea54e696
diff --git a/tests/ref/fate/mov-zombie b/tests/ref/fate/mov-zombie
index 798f47a..a019565 100644
--- a/tests/ref/fate/mov-zombie
+++ b/tests/ref/fate/mov-zombie
@@ -1,197 +1,197 @@
 packet|codec_type=video|stream_index=0|pts=0|pts_time=0.000000|dts=-3004|dts_time=-0.033378|duration=3003|duration_time=0.033367|size=4133|pos=11309|flags=K_
 packet|codec_type=video|stream_index=0|pts=5440|pts_time=0.060444|dts=-567|dts_time=-0.006300|duration=3003|duration_time=0.033367|size=1077|pos=15442|flags=__
-frame|media_type=video|stream_index=0|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=-567|pkt_dts_time=-0.006300|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=11309|pkt_size=4133|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=1|pts=0|pts_time=0.000000|pkt_dts=-567|pkt_dts_time=-0.006300|best_effort_timestamp=0|best_effort_timestamp_time=0.000000|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=11309|pkt_size=4133|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=I|coded_picture_number=0|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=2437|pts_time=0.027078|dts=2436|dts_time=0.027067|duration=3003|duration_time=0.033367|size=355|pos=16519|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=2437|pts_time=0.027078|pkt_dts=2436|pkt_dts_time=0.027067|best_effort_timestamp=2437|best_effort_timestamp_time=0.027078|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=16519|pkt_size=355|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=2|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=2437|pts_time=0.027078|pkt_dts=2436|pkt_dts_time=0.027067|best_effort_timestamp=2437|best_effort_timestamp_time=0.027078|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=16519|pkt_size=355|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=2|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=11446|pts_time=0.127178|dts=5439|dts_time=0.060433|duration=3003|duration_time=0.033367|size=1110|pos=16874|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=5440|pts_time=0.060444|pkt_dts=5439|pkt_dts_time=0.060433|best_effort_timestamp=5440|best_effort_timestamp_time=0.060444|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=15442|pkt_size=1077|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=1|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=5440|pts_time=0.060444|pkt_dts=5439|pkt_dts_time=0.060433|best_effort_timestamp=5440|best_effort_timestamp_time=0.060444|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=15442|pkt_size=1077|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=1|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=8443|pts_time=0.093811|dts=8442|dts_time=0.093800|duration=3003|duration_time=0.033367|size=430|pos=17984|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=8443|pts_time=0.093811|pkt_dts=8442|pkt_dts_time=0.093800|best_effort_timestamp=8443|best_effort_timestamp_time=0.093811|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=17984|pkt_size=430|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=4|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=8443|pts_time=0.093811|pkt_dts=8442|pkt_dts_time=0.093800|best_effort_timestamp=8443|best_effort_timestamp_time=0.093811|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=17984|pkt_size=430|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=4|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=17452|pts_time=0.193911|dts=11445|dts_time=0.127167|duration=3003|duration_time=0.033367|size=1485|pos=18414|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=11446|pts_time=0.127178|pkt_dts=11445|pkt_dts_time=0.127167|best_effort_timestamp=11446|best_effort_timestamp_time=0.127178|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=16874|pkt_size=1110|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=3|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=11446|pts_time=0.127178|pkt_dts=11445|pkt_dts_time=0.127167|best_effort_timestamp=11446|best_effort_timestamp_time=0.127178|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=16874|pkt_size=1110|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=3|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=14449|pts_time=0.160544|dts=14448|dts_time=0.160533|duration=3003|duration_time=0.033367|size=1005|pos=19899|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=14449|pts_time=0.160544|pkt_dts=14448|pkt_dts_time=0.160533|best_effort_timestamp=14449|best_effort_timestamp_time=0.160544|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=19899|pkt_size=1005|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=6|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=14449|pts_time=0.160544|pkt_dts=14448|pkt_dts_time=0.160533|best_effort_timestamp=14449|best_effort_timestamp_time=0.160544|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=19899|pkt_size=1005|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=6|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=23458|pts_time=0.260644|dts=17451|dts_time=0.193900|duration=3003|duration_time=0.033367|size=1976|pos=20904|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=17452|pts_time=0.193911|pkt_dts=17451|pkt_dts_time=0.193900|best_effort_timestamp=17452|best_effort_timestamp_time=0.193911|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=18414|pkt_size=1485|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=5|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=17452|pts_time=0.193911|pkt_dts=17451|pkt_dts_time=0.193900|best_effort_timestamp=17452|best_effort_timestamp_time=0.193911|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=18414|pkt_size=1485|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=5|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=20455|pts_time=0.227278|dts=20454|dts_time=0.227267|duration=3003|duration_time=0.033367|size=904|pos=22880|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=20455|pts_time=0.227278|pkt_dts=20454|pkt_dts_time=0.227267|best_effort_timestamp=20455|best_effort_timestamp_time=0.227278|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=22880|pkt_size=904|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=8|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=20455|pts_time=0.227278|pkt_dts=20454|pkt_dts_time=0.227267|best_effort_timestamp=20455|best_effort_timestamp_time=0.227278|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=22880|pkt_size=904|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=8|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=29464|pts_time=0.327378|dts=23457|dts_time=0.260633|duration=3003|duration_time=0.033367|size=1254|pos=23784|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=23458|pts_time=0.260644|pkt_dts=23457|pkt_dts_time=0.260633|best_effort_timestamp=23458|best_effort_timestamp_time=0.260644|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=20904|pkt_size=1976|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=7|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=23458|pts_time=0.260644|pkt_dts=23457|pkt_dts_time=0.260633|best_effort_timestamp=23458|best_effort_timestamp_time=0.260644|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=20904|pkt_size=1976|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=7|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=26461|pts_time=0.294011|dts=26460|dts_time=0.294000|duration=3003|duration_time=0.033367|size=700|pos=25038|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=26461|pts_time=0.294011|pkt_dts=26460|pkt_dts_time=0.294000|best_effort_timestamp=26461|best_effort_timestamp_time=0.294011|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=25038|pkt_size=700|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=10|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=26461|pts_time=0.294011|pkt_dts=26460|pkt_dts_time=0.294000|best_effort_timestamp=26461|best_effort_timestamp_time=0.294011|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=25038|pkt_size=700|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=10|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=35470|pts_time=0.394111|dts=29463|dts_time=0.327367|duration=3003|duration_time=0.033367|size=1311|pos=25738|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=29464|pts_time=0.327378|pkt_dts=29463|pkt_dts_time=0.327367|best_effort_timestamp=29464|best_effort_timestamp_time=0.327378|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=23784|pkt_size=1254|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=9|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=29464|pts_time=0.327378|pkt_dts=29463|pkt_dts_time=0.327367|best_effort_timestamp=29464|best_effort_timestamp_time=0.327378|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=23784|pkt_size=1254|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=9|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=32467|pts_time=0.360744|dts=32466|dts_time=0.360733|duration=3003|duration_time=0.033367|size=631|pos=27049|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=32467|pts_time=0.360744|pkt_dts=32466|pkt_dts_time=0.360733|best_effort_timestamp=32467|best_effort_timestamp_time=0.360744|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=27049|pkt_size=631|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=12|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=32467|pts_time=0.360744|pkt_dts=32466|pkt_dts_time=0.360733|best_effort_timestamp=32467|best_effort_timestamp_time=0.360744|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=27049|pkt_size=631|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=12|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=41476|pts_time=0.460844|dts=35469|dts_time=0.394100|duration=3003|duration_time=0.033367|size=1296|pos=27680|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=35470|pts_time=0.394111|pkt_dts=35469|pkt_dts_time=0.394100|best_effort_timestamp=35470|best_effort_timestamp_time=0.394111|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=25738|pkt_size=1311|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=11|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=35470|pts_time=0.394111|pkt_dts=35469|pkt_dts_time=0.394100|best_effort_timestamp=35470|best_effort_timestamp_time=0.394111|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=25738|pkt_size=1311|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=11|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=38473|pts_time=0.427478|dts=38472|dts_time=0.427467|duration=3003|duration_time=0.033367|size=466|pos=28976|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=38473|pts_time=0.427478|pkt_dts=38472|pkt_dts_time=0.427467|best_effort_timestamp=38473|best_effort_timestamp_time=0.427478|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=28976|pkt_size=466|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=14|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=38473|pts_time=0.427478|pkt_dts=38472|pkt_dts_time=0.427467|best_effort_timestamp=38473|best_effort_timestamp_time=0.427478|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=28976|pkt_size=466|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=14|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=47482|pts_time=0.527578|dts=41475|dts_time=0.460833|duration=3003|duration_time=0.033367|size=1638|pos=29442|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=41476|pts_time=0.460844|pkt_dts=41475|pkt_dts_time=0.460833|best_effort_timestamp=41476|best_effort_timestamp_time=0.460844|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=27680|pkt_size=1296|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=13|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=41476|pts_time=0.460844|pkt_dts=41475|pkt_dts_time=0.460833|best_effort_timestamp=41476|best_effort_timestamp_time=0.460844|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=27680|pkt_size=1296|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=13|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=44479|pts_time=0.494211|dts=44478|dts_time=0.494200|duration=3003|duration_time=0.033367|size=907|pos=31080|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=44479|pts_time=0.494211|pkt_dts=44478|pkt_dts_time=0.494200|best_effort_timestamp=44479|best_effort_timestamp_time=0.494211|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=31080|pkt_size=907|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=16|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=44479|pts_time=0.494211|pkt_dts=44478|pkt_dts_time=0.494200|best_effort_timestamp=44479|best_effort_timestamp_time=0.494211|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=31080|pkt_size=907|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=16|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=53488|pts_time=0.594311|dts=47481|dts_time=0.527567|duration=3003|duration_time=0.033367|size=1362|pos=31987|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=47482|pts_time=0.527578|pkt_dts=47481|pkt_dts_time=0.527567|best_effort_timestamp=47482|best_effort_timestamp_time=0.527578|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=29442|pkt_size=1638|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=15|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=47482|pts_time=0.527578|pkt_dts=47481|pkt_dts_time=0.527567|best_effort_timestamp=47482|best_effort_timestamp_time=0.527578|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=29442|pkt_size=1638|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=15|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=50485|pts_time=0.560944|dts=50484|dts_time=0.560933|duration=3003|duration_time=0.033367|size=682|pos=33349|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=50485|pts_time=0.560944|pkt_dts=50484|pkt_dts_time=0.560933|best_effort_timestamp=50485|best_effort_timestamp_time=0.560944|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=33349|pkt_size=682|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=18|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=50485|pts_time=0.560944|pkt_dts=50484|pkt_dts_time=0.560933|best_effort_timestamp=50485|best_effort_timestamp_time=0.560944|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=33349|pkt_size=682|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=18|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=59494|pts_time=0.661044|dts=53487|dts_time=0.594300|duration=3003|duration_time=0.033367|size=2917|pos=34031|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=53488|pts_time=0.594311|pkt_dts=53487|pkt_dts_time=0.594300|best_effort_timestamp=53488|best_effort_timestamp_time=0.594311|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=31987|pkt_size=1362|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=17|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=53488|pts_time=0.594311|pkt_dts=53487|pkt_dts_time=0.594300|best_effort_timestamp=53488|best_effort_timestamp_time=0.594311|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=31987|pkt_size=1362|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=17|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=56491|pts_time=0.627678|dts=56490|dts_time=0.627667|duration=3003|duration_time=0.033367|size=1174|pos=36948|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=56491|pts_time=0.627678|pkt_dts=56490|pkt_dts_time=0.627667|best_effort_timestamp=56491|best_effort_timestamp_time=0.627678|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=36948|pkt_size=1174|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=20|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=56491|pts_time=0.627678|pkt_dts=56490|pkt_dts_time=0.627667|best_effort_timestamp=56491|best_effort_timestamp_time=0.627678|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=36948|pkt_size=1174|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=20|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=65500|pts_time=0.727778|dts=59493|dts_time=0.661033|duration=3003|duration_time=0.033367|size=1748|pos=38122|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=59494|pts_time=0.661044|pkt_dts=59493|pkt_dts_time=0.661033|best_effort_timestamp=59494|best_effort_timestamp_time=0.661044|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=34031|pkt_size=2917|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=19|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=59494|pts_time=0.661044|pkt_dts=59493|pkt_dts_time=0.661033|best_effort_timestamp=59494|best_effort_timestamp_time=0.661044|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=34031|pkt_size=2917|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=19|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=62497|pts_time=0.694411|dts=62496|dts_time=0.694400|duration=3003|duration_time=0.033367|size=926|pos=39870|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=62497|pts_time=0.694411|pkt_dts=62496|pkt_dts_time=0.694400|best_effort_timestamp=62497|best_effort_timestamp_time=0.694411|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=39870|pkt_size=926|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=22|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=62497|pts_time=0.694411|pkt_dts=62496|pkt_dts_time=0.694400|best_effort_timestamp=62497|best_effort_timestamp_time=0.694411|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=39870|pkt_size=926|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=22|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=68503|pts_time=0.761144|dts=65499|dts_time=0.727767|duration=3003|duration_time=0.033367|size=918|pos=40796|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=65500|pts_time=0.727778|pkt_dts=65499|pkt_dts_time=0.727767|best_effort_timestamp=65500|best_effort_timestamp_time=0.727778|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=38122|pkt_size=1748|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=21|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=65500|pts_time=0.727778|pkt_dts=65499|pkt_dts_time=0.727767|best_effort_timestamp=65500|best_effort_timestamp_time=0.727778|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=38122|pkt_size=1748|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=21|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=71506|pts_time=0.794511|dts=68502|dts_time=0.761133|duration=3003|duration_time=0.033367|size=3846|pos=41714|flags=K_
-frame|media_type=video|stream_index=0|key_frame=0|pts=68503|pts_time=0.761144|pkt_dts=68502|pkt_dts_time=0.761133|best_effort_timestamp=68503|best_effort_timestamp_time=0.761144|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=40796|pkt_size=918|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=23|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=68503|pts_time=0.761144|pkt_dts=68502|pkt_dts_time=0.761133|best_effort_timestamp=68503|best_effort_timestamp_time=0.761144|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=40796|pkt_size=918|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=23|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=77512|pts_time=0.861244|dts=71505|dts_time=0.794500|duration=3003|duration_time=0.033367|size=1932|pos=45560|flags=__
-frame|media_type=video|stream_index=0|key_frame=1|pts=71506|pts_time=0.794511|pkt_dts=71505|pkt_dts_time=0.794500|best_effort_timestamp=71506|best_effort_timestamp_time=0.794511|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=41714|pkt_size=3846|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=I|coded_picture_number=24|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=1|pts=71506|pts_time=0.794511|pkt_dts=71505|pkt_dts_time=0.794500|best_effort_timestamp=71506|best_effort_timestamp_time=0.794511|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=41714|pkt_size=3846|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=I|coded_picture_number=24|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=74509|pts_time=0.827878|dts=74508|dts_time=0.827867|duration=3003|duration_time=0.033367|size=1159|pos=47492|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=74509|pts_time=0.827878|pkt_dts=74508|pkt_dts_time=0.827867|best_effort_timestamp=74509|best_effort_timestamp_time=0.827878|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=47492|pkt_size=1159|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=26|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=74509|pts_time=0.827878|pkt_dts=74508|pkt_dts_time=0.827867|best_effort_timestamp=74509|best_effort_timestamp_time=0.827878|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=47492|pkt_size=1159|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=26|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=83518|pts_time=0.927978|dts=77511|dts_time=0.861233|duration=3003|duration_time=0.033367|size=1522|pos=48651|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=77512|pts_time=0.861244|pkt_dts=77511|pkt_dts_time=0.861233|best_effort_timestamp=77512|best_effort_timestamp_time=0.861244|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=45560|pkt_size=1932|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=25|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=77512|pts_time=0.861244|pkt_dts=77511|pkt_dts_time=0.861233|best_effort_timestamp=77512|best_effort_timestamp_time=0.861244|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=45560|pkt_size=1932|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=25|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=80515|pts_time=0.894611|dts=80514|dts_time=0.894600|duration=3003|duration_time=0.033367|size=719|pos=50173|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=80515|pts_time=0.894611|pkt_dts=80514|pkt_dts_time=0.894600|best_effort_timestamp=80515|best_effort_timestamp_time=0.894611|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=50173|pkt_size=719|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=28|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=80515|pts_time=0.894611|pkt_dts=80514|pkt_dts_time=0.894600|best_effort_timestamp=80515|best_effort_timestamp_time=0.894611|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=50173|pkt_size=719|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=28|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=89524|pts_time=0.994711|dts=83517|dts_time=0.927967|duration=3003|duration_time=0.033367|size=1700|pos=50892|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=83518|pts_time=0.927978|pkt_dts=83517|pkt_dts_time=0.927967|best_effort_timestamp=83518|best_effort_timestamp_time=0.927978|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=48651|pkt_size=1522|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=27|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=83518|pts_time=0.927978|pkt_dts=83517|pkt_dts_time=0.927967|best_effort_timestamp=83518|best_effort_timestamp_time=0.927978|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=48651|pkt_size=1522|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=27|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=86521|pts_time=0.961344|dts=86520|dts_time=0.961333|duration=3003|duration_time=0.033367|size=1099|pos=52592|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=86521|pts_time=0.961344|pkt_dts=86520|pkt_dts_time=0.961333|best_effort_timestamp=86521|best_effort_timestamp_time=0.961344|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=52592|pkt_size=1099|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=30|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=86521|pts_time=0.961344|pkt_dts=86520|pkt_dts_time=0.961333|best_effort_timestamp=86521|best_effort_timestamp_time=0.961344|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=52592|pkt_size=1099|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=30|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=95530|pts_time=1.061444|dts=89523|dts_time=0.994700|duration=3003|duration_time=0.033367|size=2558|pos=53691|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=89524|pts_time=0.994711|pkt_dts=89523|pkt_dts_time=0.994700|best_effort_timestamp=89524|best_effort_timestamp_time=0.994711|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=50892|pkt_size=1700|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=29|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=89524|pts_time=0.994711|pkt_dts=89523|pkt_dts_time=0.994700|best_effort_timestamp=89524|best_effort_timestamp_time=0.994711|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=50892|pkt_size=1700|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=29|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=92527|pts_time=1.028078|dts=92526|dts_time=1.028067|duration=3003|duration_time=0.033367|size=1008|pos=56249|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=92527|pts_time=1.028078|pkt_dts=92526|pkt_dts_time=1.028067|best_effort_timestamp=92527|best_effort_timestamp_time=1.028078|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=56249|pkt_size=1008|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=32|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=92527|pts_time=1.028078|pkt_dts=92526|pkt_dts_time=1.028067|best_effort_timestamp=92527|best_effort_timestamp_time=1.028078|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=56249|pkt_size=1008|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=32|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=101536|pts_time=1.128178|dts=95529|dts_time=1.061433|duration=3003|duration_time=0.033367|size=1236|pos=57257|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=95530|pts_time=1.061444|pkt_dts=95529|pkt_dts_time=1.061433|best_effort_timestamp=95530|best_effort_timestamp_time=1.061444|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=53691|pkt_size=2558|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=31|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=95530|pts_time=1.061444|pkt_dts=95529|pkt_dts_time=1.061433|best_effort_timestamp=95530|best_effort_timestamp_time=1.061444|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=53691|pkt_size=2558|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=31|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=98533|pts_time=1.094811|dts=98532|dts_time=1.094800|duration=3003|duration_time=0.033367|size=607|pos=58493|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=98533|pts_time=1.094811|pkt_dts=98532|pkt_dts_time=1.094800|best_effort_timestamp=98533|best_effort_timestamp_time=1.094811|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=58493|pkt_size=607|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=34|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=98533|pts_time=1.094811|pkt_dts=98532|pkt_dts_time=1.094800|best_effort_timestamp=98533|best_effort_timestamp_time=1.094811|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=58493|pkt_size=607|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=34|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=107542|pts_time=1.194911|dts=101535|dts_time=1.128167|duration=3003|duration_time=0.033367|size=1883|pos=59100|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=101536|pts_time=1.128178|pkt_dts=101535|pkt_dts_time=1.128167|best_effort_timestamp=101536|best_effort_timestamp_time=1.128178|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=57257|pkt_size=1236|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=33|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=101536|pts_time=1.128178|pkt_dts=101535|pkt_dts_time=1.128167|best_effort_timestamp=101536|best_effort_timestamp_time=1.128178|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=57257|pkt_size=1236|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=33|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=104539|pts_time=1.161544|dts=104538|dts_time=1.161533|duration=3003|duration_time=0.033367|size=893|pos=60983|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=104539|pts_time=1.161544|pkt_dts=104538|pkt_dts_time=1.161533|best_effort_timestamp=104539|best_effort_timestamp_time=1.161544|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=60983|pkt_size=893|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=36|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=104539|pts_time=1.161544|pkt_dts=104538|pkt_dts_time=1.161533|best_effort_timestamp=104539|best_effort_timestamp_time=1.161544|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=60983|pkt_size=893|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=36|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=113548|pts_time=1.261644|dts=107541|dts_time=1.194900|duration=3003|duration_time=0.033367|size=1305|pos=61876|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=107542|pts_time=1.194911|pkt_dts=107541|pkt_dts_time=1.194900|best_effort_timestamp=107542|best_effort_timestamp_time=1.194911|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=59100|pkt_size=1883|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=35|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=107542|pts_time=1.194911|pkt_dts=107541|pkt_dts_time=1.194900|best_effort_timestamp=107542|best_effort_timestamp_time=1.194911|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=59100|pkt_size=1883|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=35|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=110545|pts_time=1.228278|dts=110544|dts_time=1.228267|duration=3003|duration_time=0.033367|size=472|pos=63181|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=110545|pts_time=1.228278|pkt_dts=110544|pkt_dts_time=1.228267|best_effort_timestamp=110545|best_effort_timestamp_time=1.228278|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=63181|pkt_size=472|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=38|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=110545|pts_time=1.228278|pkt_dts=110544|pkt_dts_time=1.228267|best_effort_timestamp=110545|best_effort_timestamp_time=1.228278|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=63181|pkt_size=472|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=38|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=119554|pts_time=1.328378|dts=113547|dts_time=1.261633|duration=3003|duration_time=0.033367|size=1411|pos=63653|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=113548|pts_time=1.261644|pkt_dts=113547|pkt_dts_time=1.261633|best_effort_timestamp=113548|best_effort_timestamp_time=1.261644|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=61876|pkt_size=1305|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=37|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=113548|pts_time=1.261644|pkt_dts=113547|pkt_dts_time=1.261633|best_effort_timestamp=113548|best_effort_timestamp_time=1.261644|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=61876|pkt_size=1305|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=37|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=116551|pts_time=1.295011|dts=116550|dts_time=1.295000|duration=3003|duration_time=0.033367|size=616|pos=65064|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=116551|pts_time=1.295011|pkt_dts=116550|pkt_dts_time=1.295000|best_effort_timestamp=116551|best_effort_timestamp_time=1.295011|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=65064|pkt_size=616|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=40|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=116551|pts_time=1.295011|pkt_dts=116550|pkt_dts_time=1.295000|best_effort_timestamp=116551|best_effort_timestamp_time=1.295011|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=65064|pkt_size=616|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=40|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=125560|pts_time=1.395111|dts=119553|dts_time=1.328367|duration=3003|duration_time=0.033367|size=1291|pos=65680|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=119554|pts_time=1.328378|pkt_dts=119553|pkt_dts_time=1.328367|best_effort_timestamp=119554|best_effort_timestamp_time=1.328378|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=63653|pkt_size=1411|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=39|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=119554|pts_time=1.328378|pkt_dts=119553|pkt_dts_time=1.328367|best_effort_timestamp=119554|best_effort_timestamp_time=1.328378|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=63653|pkt_size=1411|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=39|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=122557|pts_time=1.361744|dts=122556|dts_time=1.361733|duration=3003|duration_time=0.033367|size=470|pos=66971|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=122557|pts_time=1.361744|pkt_dts=122556|pkt_dts_time=1.361733|best_effort_timestamp=122557|best_effort_timestamp_time=1.361744|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=66971|pkt_size=470|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=42|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=122557|pts_time=1.361744|pkt_dts=122556|pkt_dts_time=1.361733|best_effort_timestamp=122557|best_effort_timestamp_time=1.361744|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=66971|pkt_size=470|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=42|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=131566|pts_time=1.461844|dts=125559|dts_time=1.395100|duration=3003|duration_time=0.033367|size=1977|pos=67441|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=125560|pts_time=1.395111|pkt_dts=125559|pkt_dts_time=1.395100|best_effort_timestamp=125560|best_effort_timestamp_time=1.395111|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=65680|pkt_size=1291|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=41|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=125560|pts_time=1.395111|pkt_dts=125559|pkt_dts_time=1.395100|best_effort_timestamp=125560|best_effort_timestamp_time=1.395111|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=65680|pkt_size=1291|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=41|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=128563|pts_time=1.428478|dts=128562|dts_time=1.428467|duration=3003|duration_time=0.033367|size=436|pos=69418|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=128563|pts_time=1.428478|pkt_dts=128562|pkt_dts_time=1.428467|best_effort_timestamp=128563|best_effort_timestamp_time=1.428478|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=69418|pkt_size=436|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=44|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=128563|pts_time=1.428478|pkt_dts=128562|pkt_dts_time=1.428467|best_effort_timestamp=128563|best_effort_timestamp_time=1.428478|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=69418|pkt_size=436|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=44|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=137572|pts_time=1.528578|dts=131565|dts_time=1.461833|duration=3003|duration_time=0.033367|size=2566|pos=69854|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=131566|pts_time=1.461844|pkt_dts=131565|pkt_dts_time=1.461833|best_effort_timestamp=131566|best_effort_timestamp_time=1.461844|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=67441|pkt_size=1977|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=43|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=131566|pts_time=1.461844|pkt_dts=131565|pkt_dts_time=1.461833|best_effort_timestamp=131566|best_effort_timestamp_time=1.461844|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=67441|pkt_size=1977|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=43|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=134569|pts_time=1.495211|dts=134568|dts_time=1.495200|duration=3003|duration_time=0.033367|size=886|pos=72420|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=134569|pts_time=1.495211|pkt_dts=134568|pkt_dts_time=1.495200|best_effort_timestamp=134569|best_effort_timestamp_time=1.495211|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=72420|pkt_size=886|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=46|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=134569|pts_time=1.495211|pkt_dts=134568|pkt_dts_time=1.495200|best_effort_timestamp=134569|best_effort_timestamp_time=1.495211|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=72420|pkt_size=886|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=46|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=140575|pts_time=1.561944|dts=137571|dts_time=1.528567|duration=3003|duration_time=0.033367|size=1330|pos=73306|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=137572|pts_time=1.528578|pkt_dts=137571|pkt_dts_time=1.528567|best_effort_timestamp=137572|best_effort_timestamp_time=1.528578|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=69854|pkt_size=2566|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=45|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=137572|pts_time=1.528578|pkt_dts=137571|pkt_dts_time=1.528567|best_effort_timestamp=137572|best_effort_timestamp_time=1.528578|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=69854|pkt_size=2566|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=45|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=143578|pts_time=1.595311|dts=140574|dts_time=1.561933|duration=3003|duration_time=0.033367|size=2227|pos=74636|flags=K_
-frame|media_type=video|stream_index=0|key_frame=0|pts=140575|pts_time=1.561944|pkt_dts=140574|pkt_dts_time=1.561933|best_effort_timestamp=140575|best_effort_timestamp_time=1.561944|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=73306|pkt_size=1330|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=47|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=140575|pts_time=1.561944|pkt_dts=140574|pkt_dts_time=1.561933|best_effort_timestamp=140575|best_effort_timestamp_time=1.561944|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=73306|pkt_size=1330|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=47|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=149584|pts_time=1.662044|dts=143577|dts_time=1.595300|duration=3003|duration_time=0.033367|size=2210|pos=76863|flags=__
-frame|media_type=video|stream_index=0|key_frame=1|pts=143578|pts_time=1.595311|pkt_dts=143577|pkt_dts_time=1.595300|best_effort_timestamp=143578|best_effort_timestamp_time=1.595311|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=74636|pkt_size=2227|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=I|coded_picture_number=48|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=1|pts=143578|pts_time=1.595311|pkt_dts=143577|pkt_dts_time=1.595300|best_effort_timestamp=143578|best_effort_timestamp_time=1.595311|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=74636|pkt_size=2227|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=I|coded_picture_number=48|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=146581|pts_time=1.628678|dts=146580|dts_time=1.628667|duration=3003|duration_time=0.033367|size=1498|pos=79073|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=146581|pts_time=1.628678|pkt_dts=146580|pkt_dts_time=1.628667|best_effort_timestamp=146581|best_effort_timestamp_time=1.628678|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=79073|pkt_size=1498|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=50|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=146581|pts_time=1.628678|pkt_dts=146580|pkt_dts_time=1.628667|best_effort_timestamp=146581|best_effort_timestamp_time=1.628678|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=79073|pkt_size=1498|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=50|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=155590|pts_time=1.728778|dts=149583|dts_time=1.662033|duration=3003|duration_time=0.033367|size=1721|pos=80571|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=149584|pts_time=1.662044|pkt_dts=149583|pkt_dts_time=1.662033|best_effort_timestamp=149584|best_effort_timestamp_time=1.662044|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=76863|pkt_size=2210|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=49|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=149584|pts_time=1.662044|pkt_dts=149583|pkt_dts_time=1.662033|best_effort_timestamp=149584|best_effort_timestamp_time=1.662044|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=76863|pkt_size=2210|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=49|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=152587|pts_time=1.695411|dts=152586|dts_time=1.695400|duration=3003|duration_time=0.033367|size=1238|pos=82292|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=152587|pts_time=1.695411|pkt_dts=152586|pkt_dts_time=1.695400|best_effort_timestamp=152587|best_effort_timestamp_time=1.695411|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=82292|pkt_size=1238|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=52|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=152587|pts_time=1.695411|pkt_dts=152586|pkt_dts_time=1.695400|best_effort_timestamp=152587|best_effort_timestamp_time=1.695411|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=82292|pkt_size=1238|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=52|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=161596|pts_time=1.795511|dts=155589|dts_time=1.728767|duration=3003|duration_time=0.033367|size=1753|pos=83530|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=155590|pts_time=1.728778|pkt_dts=155589|pkt_dts_time=1.728767|best_effort_timestamp=155590|best_effort_timestamp_time=1.728778|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=80571|pkt_size=1721|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=51|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=155590|pts_time=1.728778|pkt_dts=155589|pkt_dts_time=1.728767|best_effort_timestamp=155590|best_effort_timestamp_time=1.728778|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=80571|pkt_size=1721|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=51|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=158593|pts_time=1.762144|dts=158592|dts_time=1.762133|duration=3003|duration_time=0.033367|size=1014|pos=85283|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=158593|pts_time=1.762144|pkt_dts=158592|pkt_dts_time=1.762133|best_effort_timestamp=158593|best_effort_timestamp_time=1.762144|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=85283|pkt_size=1014|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=54|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=158593|pts_time=1.762144|pkt_dts=158592|pkt_dts_time=1.762133|best_effort_timestamp=158593|best_effort_timestamp_time=1.762144|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=85283|pkt_size=1014|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=54|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=167602|pts_time=1.862244|dts=161595|dts_time=1.795500|duration=3003|duration_time=0.033367|size=2408|pos=86297|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=161596|pts_time=1.795511|pkt_dts=161595|pkt_dts_time=1.795500|best_effort_timestamp=161596|best_effort_timestamp_time=1.795511|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=83530|pkt_size=1753|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=53|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=161596|pts_time=1.795511|pkt_dts=161595|pkt_dts_time=1.795500|best_effort_timestamp=161596|best_effort_timestamp_time=1.795511|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=83530|pkt_size=1753|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=53|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=164599|pts_time=1.828878|dts=164598|dts_time=1.828867|duration=3003|duration_time=0.033367|size=1727|pos=88705|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=164599|pts_time=1.828878|pkt_dts=164598|pkt_dts_time=1.828867|best_effort_timestamp=164599|best_effort_timestamp_time=1.828878|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=88705|pkt_size=1727|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=56|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=164599|pts_time=1.828878|pkt_dts=164598|pkt_dts_time=1.828867|best_effort_timestamp=164599|best_effort_timestamp_time=1.828878|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=88705|pkt_size=1727|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=56|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=173608|pts_time=1.928978|dts=167601|dts_time=1.862233|duration=3003|duration_time=0.033367|size=1504|pos=90432|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=167602|pts_time=1.862244|pkt_dts=167601|pkt_dts_time=1.862233|best_effort_timestamp=167602|best_effort_timestamp_time=1.862244|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=86297|pkt_size=2408|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=55|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=167602|pts_time=1.862244|pkt_dts=167601|pkt_dts_time=1.862233|best_effort_timestamp=167602|best_effort_timestamp_time=1.862244|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=86297|pkt_size=2408|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=55|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=170605|pts_time=1.895611|dts=170604|dts_time=1.895600|duration=3003|duration_time=0.033367|size=957|pos=91936|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=170605|pts_time=1.895611|pkt_dts=170604|pkt_dts_time=1.895600|best_effort_timestamp=170605|best_effort_timestamp_time=1.895611|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=91936|pkt_size=957|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=58|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=170605|pts_time=1.895611|pkt_dts=170604|pkt_dts_time=1.895600|best_effort_timestamp=170605|best_effort_timestamp_time=1.895611|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=91936|pkt_size=957|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=58|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=179614|pts_time=1.995711|dts=173607|dts_time=1.928967|duration=3003|duration_time=0.033367|size=1890|pos=92893|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=173608|pts_time=1.928978|pkt_dts=173607|pkt_dts_time=1.928967|best_effort_timestamp=173608|best_effort_timestamp_time=1.928978|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=90432|pkt_size=1504|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=57|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=173608|pts_time=1.928978|pkt_dts=173607|pkt_dts_time=1.928967|best_effort_timestamp=173608|best_effort_timestamp_time=1.928978|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=90432|pkt_size=1504|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=57|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=176611|pts_time=1.962344|dts=176610|dts_time=1.962333|duration=3003|duration_time=0.033367|size=1239|pos=94783|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=176611|pts_time=1.962344|pkt_dts=176610|pkt_dts_time=1.962333|best_effort_timestamp=176611|best_effort_timestamp_time=1.962344|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=94783|pkt_size=1239|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=60|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=176611|pts_time=1.962344|pkt_dts=176610|pkt_dts_time=1.962333|best_effort_timestamp=176611|best_effort_timestamp_time=1.962344|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=94783|pkt_size=1239|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=60|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=185620|pts_time=2.062444|dts=179613|dts_time=1.995700|duration=3003|duration_time=0.033367|size=1856|pos=96022|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=179614|pts_time=1.995711|pkt_dts=179613|pkt_dts_time=1.995700|best_effort_timestamp=179614|best_effort_timestamp_time=1.995711|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=92893|pkt_size=1890|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=59|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=179614|pts_time=1.995711|pkt_dts=179613|pkt_dts_time=1.995700|best_effort_timestamp=179614|best_effort_timestamp_time=1.995711|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=92893|pkt_size=1890|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=59|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=182617|pts_time=2.029078|dts=182616|dts_time=2.029067|duration=3003|duration_time=0.033367|size=1302|pos=97878|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=182617|pts_time=2.029078|pkt_dts=182616|pkt_dts_time=2.029067|best_effort_timestamp=182617|best_effort_timestamp_time=2.029078|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=97878|pkt_size=1302|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=62|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=182617|pts_time=2.029078|pkt_dts=182616|pkt_dts_time=2.029067|best_effort_timestamp=182617|best_effort_timestamp_time=2.029078|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=97878|pkt_size=1302|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=62|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=191626|pts_time=2.129178|dts=185619|dts_time=2.062433|duration=3003|duration_time=0.033367|size=1666|pos=99180|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=185620|pts_time=2.062444|pkt_dts=185619|pkt_dts_time=2.062433|best_effort_timestamp=185620|best_effort_timestamp_time=2.062444|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=96022|pkt_size=1856|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=61|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=185620|pts_time=2.062444|pkt_dts=185619|pkt_dts_time=2.062433|best_effort_timestamp=185620|best_effort_timestamp_time=2.062444|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=96022|pkt_size=1856|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=61|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=188623|pts_time=2.095811|dts=188622|dts_time=2.095800|duration=3003|duration_time=0.033367|size=974|pos=100846|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=188623|pts_time=2.095811|pkt_dts=188622|pkt_dts_time=2.095800|best_effort_timestamp=188623|best_effort_timestamp_time=2.095811|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=100846|pkt_size=974|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=64|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=188623|pts_time=2.095811|pkt_dts=188622|pkt_dts_time=2.095800|best_effort_timestamp=188623|best_effort_timestamp_time=2.095811|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=100846|pkt_size=974|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=B|coded_picture_number=64|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 packet|codec_type=video|stream_index=0|pts=197632|pts_time=2.195911|dts=191625|dts_time=2.129167|duration=3003|duration_time=0.033367|size=580|pos=101820|flags=__
-frame|media_type=video|stream_index=0|key_frame=0|pts=191626|pts_time=2.129178|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=191626|best_effort_timestamp_time=2.129178|pkt_duration=3003|pkt_duration_time=0.033367|pkt_pos=99180|pkt_size=1666|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=63|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
+frame|media_type=video|stream_index=0|key_frame=0|pts=191626|pts_time=2.129178|pkt_dts=N/A|pkt_dts_time=N/A|best_effort_timestamp=191626|best_effort_timestamp_time=2.129178|pkt_duration=3003|pkt_duration_time=0.033367|duration=3003|duration_time=0.033367|pkt_pos=99180|pkt_size=1666|width=160|height=240|pix_fmt=yuv420p|sample_aspect_ratio=2:1|pict_type=P|coded_picture_number=63|display_picture_number=0|interlaced_frame=0|top_field_first=0|repeat_pict=0|color_range=tv|color_space=smpte170m|color_primaries=smpte170m|color_transfer=bt709|chroma_location=topleft|side_data|side_data_type=H.26[45] User Data Unregistered SEI message
 
 stream|index=0|codec_name=h264|profile=77|codec_type=video|codec_tag_string=avc1|codec_tag=0x31637661|width=160|height=240|coded_width=160|coded_height=240|closed_captions=0|film_grain=0|has_b_frames=1|sample_aspect_ratio=2:1|display_aspect_ratio=4:3|pix_fmt=yuv420p|level=12|color_range=tv|color_space=smpte170m|color_transfer=bt709|color_primaries=smpte170m|chroma_location=topleft|field_order=progressive|refs=2|is_avc=true|nal_length_size=4|id=0x1|r_frame_rate=30000/1001|avg_frame_rate=6372000/212521|time_base=1/90000|start_pts=0|start_time=0.000000|duration_ts=2125200|duration=23.613333|bit_rate=333874|max_bit_rate=N/A|bits_per_raw_sample=8|nb_frames=708|nb_read_frames=65|nb_read_packets=66|extradata_size=34|disposition:default=1|disposition:dub=0|disposition:original=0|disposition:comment=0|disposition:lyrics=0|disposition:karaoke=0|disposition:forced=0|disposition:hearing_impaired=0|disposition:visual_impaired=0|disposition:clean_effects=0|disposition:attached_pic=0|disposition:timed_thumbnails=0|disposition:captions=0|disposition:descriptions=0|disposition:metadata=0|disposition:dependent=0|disposition:still_image=0|tag:creation_time=2008-05-12T20:59:27.000000Z|tag:language=eng|tag:handler_name=Apple Video Media Handler|tag:vendor_id=appl|tag:encoder=H.264|side_data|side_data_type=Display Matrix|displaymatrix=\n00000000:       131072           0           0\n00000001:            0       65536           0\n00000002:            0           0  1073741824\n|rotation=0
diff --git a/tests/ref/fate/pixfmt_best b/tests/ref/fate/pixfmt_best
index 5f51e2d..1da1846 100644
--- a/tests/ref/fate/pixfmt_best
+++ b/tests/ref/fate/pixfmt_best
@@ -1 +1 @@
-73 tests passed, 0 tests failed.
+74 tests passed, 0 tests failed.
diff --git a/tests/ref/fate/png-icc b/tests/ref/fate/png-icc
index 542bb76..92fa0e5 100644
--- a/tests/ref/fate/png-icc
+++ b/tests/ref/fate/png-icc
@@ -18,6 +18,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1
 pkt_duration_time=0.040000
+duration=1
+duration_time=0.040000
 pkt_pos=0
 pkt_size=49397
 width=128
diff --git a/tests/ref/fate/png-icc-parse b/tests/ref/fate/png-icc-parse
new file mode 100644
index 0000000..18bb18a
--- /dev/null
+++ b/tests/ref/fate/png-icc-parse
@@ -0,0 +1,48 @@
+[FRAME]
+media_type=video
+stream_index=0
+key_frame=1
+pts=0
+pts_time=0.000000
+pkt_dts=0
+pkt_dts_time=0.000000
+best_effort_timestamp=0
+best_effort_timestamp_time=0.000000
+pkt_duration=1
+pkt_duration_time=0.040000
+duration=1
+duration_time=0.040000
+pkt_pos=0
+pkt_size=40194
+width=128
+height=128
+pix_fmt=rgb24
+sample_aspect_ratio=1:1
+pict_type=I
+coded_picture_number=0
+display_picture_number=0
+interlaced_frame=1
+top_field_first=0
+repeat_pict=0
+color_range=pc
+color_space=unknown
+color_primaries=bt709
+color_transfer=iec61966-2-1
+chroma_location=unspecified
+[SIDE_DATA]
+side_data_type=ICC profile
+name=Photoshop ICC profile
+size=3144
+[/SIDE_DATA]
+[SIDE_DATA]
+side_data_type=Mastering display metadata
+red_x=63999/100000
+red_y=33001/100000
+green_x=30000/100000
+green_y=60000/100000
+blue_x=15000/100000
+blue_y=5999/100000
+white_point_x=31269/100000
+white_point_y=32899/100000
+[/SIDE_DATA]
+[/FRAME]
diff --git a/tests/ref/fate/png-side-data b/tests/ref/fate/png-side-data
index a4c307f..f40f14f 100644
--- a/tests/ref/fate/png-side-data
+++ b/tests/ref/fate/png-side-data
@@ -10,6 +10,8 @@ best_effort_timestamp=0
 best_effort_timestamp_time=0.000000
 pkt_duration=1
 pkt_duration_time=0.040000
+duration=1
+duration_time=0.040000
 pkt_pos=0
 pkt_size=40194
 width=128
diff --git a/tests/ref/fate/shortest-sub b/tests/ref/fate/shortest-sub
new file mode 100644
index 0000000..0da4ba2
--- /dev/null
+++ b/tests/ref/fate/shortest-sub
@@ -0,0 +1,4 @@
+145b9b48d56f9c966bf41657f7569954 *tests/data/fate/shortest-sub.matroska
+139232 tests/data/fate/shortest-sub.matroska
+876ac3fa52e467050ab843969d4cf343 *tests/data/fate/shortest-sub.out.framecrc
+stddev:11541.12 PSNR: 15.08 MAXDIFF:22854 bytes:     2591/    23735
diff --git a/tests/ref/fate/sws-pixdesc-query b/tests/ref/fate/sws-pixdesc-query
index 76104bc..f79d99e 100644
--- a/tests/ref/fate/sws-pixdesc-query
+++ b/tests/ref/fate/sws-pixdesc-query
@@ -21,6 +21,8 @@ is16BPS:
   rgb48le
   rgba64be
   rgba64le
+  rgbaf16be
+  rgbaf16le
   ya16be
   ya16le
   yuv420p16be
@@ -157,6 +159,7 @@ isBE:
   rgb555be
   rgb565be
   rgba64be
+  rgbaf16be
   x2bgr10be
   x2rgb10be
   xyz12be
@@ -215,6 +218,7 @@ isYUV:
   p416le
   uyvy422
   uyyvyy411
+  vuya
   xyz12be
   xyz12le
   y210be
@@ -478,6 +482,8 @@ isRGB:
   rgb8
   rgba64be
   rgba64le
+  rgbaf16be
+  rgbaf16le
   x2bgr10be
   x2bgr10le
   x2rgb10be
@@ -628,6 +634,8 @@ AnyRGB:
   rgb8
   rgba64be
   rgba64le
+  rgbaf16be
+  rgbaf16le
   x2bgr10be
   x2bgr10le
   x2rgb10be
@@ -654,6 +662,9 @@ ALPHA:
   rgb32_1
   rgba64be
   rgba64le
+  rgbaf16be
+  rgbaf16le
+  vuya
   ya16be
   ya16le
   ya8
@@ -737,8 +748,11 @@ Packed:
   rgb8
   rgba64be
   rgba64le
+  rgbaf16be
+  rgbaf16le
   uyvy422
   uyyvyy411
+  vuya
   x2bgr10be
   x2bgr10le
   x2rgb10be
@@ -915,6 +929,8 @@ PackedRGB:
   rgb8
   rgba64be
   rgba64le
+  rgbaf16be
+  rgbaf16le
   x2bgr10be
   x2bgr10le
   x2rgb10be
@@ -967,5 +983,6 @@ DataInHighBits:
 SwappedChroma:
   nv21
   nv42
+  vuya
   yvyu422
 
diff --git a/tests/ref/fate/wmv8-x8intra b/tests/ref/fate/wmv8-x8intra
index c9ed273..8802d03 100644
--- a/tests/ref/fate/wmv8-x8intra
+++ b/tests/ref/fate/wmv8-x8intra
@@ -7,21 +7,21 @@
 0,          3,          3,        1,   115200, 0x8911d86f
 0,          4,          4,        1,   115200, 0x7c5dd82e
 0,          5,          5,        1,   115200, 0x7c5ed82e
-0,         30,         30,        1,   115200, 0xd323d838
-0,         31,         31,        1,   115200, 0x6e7479ab
-0,         32,         32,        1,   115200, 0x14674bf6
-0,         33,         33,        1,   115200, 0x074c2e3d
-0,         34,         34,        1,   115200, 0x9b3025ef
-0,         35,         35,        1,   115200, 0x76882dae
-0,         36,         36,        1,   115200, 0xedf3421b
-0,         37,         37,        1,   115200, 0xb5378486
-0,         38,         38,        1,   115200, 0xc4a53420
-0,         39,         39,        1,   115200, 0x559cb60f
-0,         40,         40,        1,   115200, 0xcc034ddd
-0,         41,         41,        1,   115200, 0xb77b7779
-0,         42,         42,        1,   115200, 0x0ad9c3e6
-0,         43,         43,        1,   115200, 0x4e673027
-0,         44,         44,        1,   115200, 0x54717979
+0,         30,         30,        1,   115200, 0x03fbd838
+0,         31,         31,        1,   115200, 0x37c879b2
+0,         32,         32,        1,   115200, 0xd5994bfc
+0,         33,         33,        1,   115200, 0x4b662e3e
+0,         34,         34,        1,   115200, 0x2f1925ea
+0,         35,         35,        1,   115200, 0xc5912db0
+0,         36,         36,        1,   115200, 0x76c4421f
+0,         37,         37,        1,   115200, 0x5cc8848b
+0,         38,         38,        1,   115200, 0x75e63425
+0,         39,         39,        1,   115200, 0x1a29b620
+0,         40,         40,        1,   115200, 0x60c64de9
+0,         41,         41,        1,   115200, 0xc7ac7783
+0,         42,         42,        1,   115200, 0xb056c3ee
+0,         43,         43,        1,   115200, 0xa57d3030
+0,         44,         44,        1,   115200, 0x2864797c
 0,         45,         45,        1,   115200, 0xf9e557c9
 0,         46,         46,        1,   115200, 0xbdcf6358
 0,         47,         47,        1,   115200, 0xd55c7bb7
@@ -82,156 +82,156 @@
 0,        102,        102,        1,   115200, 0x78bb8f95
 0,        103,        103,        1,   115200, 0x9c71d03f
 0,        104,        104,        1,   115200, 0xbe5db887
-0,        105,        105,        1,   115200, 0xa88e00d0
-0,        106,        106,        1,   115200, 0xc7b50827
-0,        107,        107,        1,   115200, 0xf9155ed3
-0,        108,        108,        1,   115200, 0x8dd72d44
-0,        109,        109,        1,   115200, 0xee38183a
-0,        110,        110,        1,   115200, 0xea2b6329
-0,        111,        111,        1,   115200, 0xf556c2b3
-0,        112,        112,        1,   115200, 0x90edebf9
-0,        113,        113,        1,   115200, 0x4f440fdf
-0,        114,        114,        1,   115200, 0xfdec7a9d
-0,        115,        115,        1,   115200, 0xc7927952
-0,        116,        116,        1,   115200, 0xdd475704
-0,        117,        117,        1,   115200, 0x974a61a5
-0,        118,        118,        1,   115200, 0xbf2b785e
-0,        119,        119,        1,   115200, 0x5de451fa
-0,        120,        120,        1,   115200, 0x3fac503e
-0,        121,        121,        1,   115200, 0xc6785643
-0,        122,        122,        1,   115200, 0xe6666254
-0,        123,        123,        1,   115200, 0x1a05130c
-0,        124,        124,        1,   115200, 0x082cea5d
-0,        125,        125,        1,   115200, 0x473ef142
-0,        126,        126,        1,   115200, 0x9769a776
-0,        127,        127,        1,   115200, 0xe6e841af
-0,        128,        128,        1,   115200, 0xa44c8d1e
-0,        129,        129,        1,   115200, 0xd03d641b
-0,        130,        130,        1,   115200, 0x3aea3c9e
-0,        131,        131,        1,   115200, 0x09efcf21
-0,        132,        132,        1,   115200, 0xeeb6ff64
-0,        133,        133,        1,   115200, 0xa310af6f
-0,        134,        134,        1,   115200, 0x2488519e
-0,        135,        135,        1,   115200, 0x48e1febf
-0,        136,        136,        1,   115200, 0x76d00513
-0,        137,        137,        1,   115200, 0xa28eda81
-0,        138,        138,        1,   115200, 0xc2cbdcae
-0,        139,        139,        1,   115200, 0xd976c9b2
-0,        140,        140,        1,   115200, 0xb0abebab
-0,        141,        141,        1,   115200, 0x32be4765
-0,        142,        142,        1,   115200, 0xc0a36b11
-0,        143,        143,        1,   115200, 0xb6d1d47f
-0,        144,        144,        1,   115200, 0xab7954a6
-0,        145,        145,        1,   115200, 0xc485789c
-0,        146,        146,        1,   115200, 0xa07101b6
-0,        147,        147,        1,   115200, 0x6297780a
-0,        148,        148,        1,   115200, 0xf550ba94
-0,        149,        149,        1,   115200, 0x9b77f994
-0,        150,        150,        1,   115200, 0xb0e870ad
-0,        151,        151,        1,   115200, 0x2dd89b0b
-0,        152,        152,        1,   115200, 0x36dcfe2f
-0,        153,        153,        1,   115200, 0x3e5e1a8f
-0,        154,        154,        1,   115200, 0xb8394740
-0,        155,        155,        1,   115200, 0xbfc852fc
-0,        156,        156,        1,   115200, 0x5b3f8aa2
-0,        157,        157,        1,   115200, 0xc29d8e3a
-0,        158,        158,        1,   115200, 0x7300abd8
-0,        159,        159,        1,   115200, 0xd1dd7a3b
-0,        160,        160,        1,   115200, 0xe5978f39
-0,        161,        161,        1,   115200, 0x235c6b8d
-0,        162,        162,        1,   115200, 0xec1b5805
-0,        163,        163,        1,   115200, 0x16d23946
-0,        164,        164,        1,   115200, 0xa8de1cf4
-0,        165,        165,        1,   115200, 0x5e730512
-0,        166,        166,        1,   115200, 0x1250feed
-0,        167,        167,        1,   115200, 0x0928c190
-0,        168,        168,        1,   115200, 0xa25d9e5c
-0,        169,        169,        1,   115200, 0x921068ea
-0,        170,        170,        1,   115200, 0x2c974ddb
-0,        171,        171,        1,   115200, 0x35ae4d75
-0,        172,        172,        1,   115200, 0xec0c6469
-0,        173,        173,        1,   115200, 0x22704fad
-0,        174,        174,        1,   115200, 0x0a9a5aed
-0,        175,        175,        1,   115200, 0x45192f2f
-0,        176,        176,        1,   115200, 0xc07b39f4
-0,        177,        177,        1,   115200, 0x32c60215
-0,        178,        178,        1,   115200, 0xda65035e
-0,        179,        179,        1,   115200, 0x99d0cd81
-0,        180,        180,        1,   115200, 0xd08ca5e3
-0,        181,        181,        1,   115200, 0x82cdad17
-0,        182,        182,        1,   115200, 0x2587a420
-0,        183,        183,        1,   115200, 0x85cba73d
-0,        184,        184,        1,   115200, 0x4677bf89
-0,        185,        185,        1,   115200, 0x84c2e034
-0,        186,        186,        1,   115200, 0xd343066c
-0,        187,        187,        1,   115200, 0xdec716a1
-0,        188,        188,        1,   115200, 0x93c04f5d
-0,        189,        189,        1,   115200, 0xce126ac4
-0,        190,        190,        1,   115200, 0xa20098c5
-0,        191,        191,        1,   115200, 0x9a4ca711
-0,        192,        192,        1,   115200, 0xfae9c154
-0,        193,        193,        1,   115200, 0xb34cc431
-0,        194,        194,        1,   115200, 0x923cdec2
-0,        195,        195,        1,   115200, 0x60ffdfe8
-0,        196,        196,        1,   115200, 0xa3e6f9f2
-0,        197,        197,        1,   115200, 0x374f0a47
-0,        198,        198,        1,   115200, 0x8fb228f1
-0,        199,        199,        1,   115200, 0x4c1a24bf
-0,        200,        200,        1,   115200, 0x768a52d1
-0,        201,        201,        1,   115200, 0x5bf77025
-0,        202,        202,        1,   115200, 0x6ca67c2a
-0,        203,        203,        1,   115200, 0x107ca3e9
-0,        204,        204,        1,   115200, 0x4abeda93
-0,        205,        205,        1,   115200, 0x750be9ff
-0,        206,        206,        1,   115200, 0x28c5eee3
-0,        207,        207,        1,   115200, 0xa1b0e4b2
-0,        208,        208,        1,   115200, 0x2ae7f33d
-0,        209,        209,        1,   115200, 0xf29cdae0
-0,        210,        210,        1,   115200, 0xd470f9ed
-0,        211,        211,        1,   115200, 0x2d22f832
-0,        212,        212,        1,   115200, 0xc5b91780
-0,        213,        213,        1,   115200, 0x3d8e4151
-0,        214,        214,        1,   115200, 0x459f58e0
-0,        215,        215,        1,   115200, 0x8dc198fe
-0,        216,        216,        1,   115200, 0x2479f579
-0,        217,        217,        1,   115200, 0xc2040c21
-0,        218,        218,        1,   115200, 0x39ad60d5
-0,        219,        219,        1,   115200, 0x9329dd37
-0,        220,        220,        1,   115200, 0xa08807da
-0,        221,        221,        1,   115200, 0xbf514cd1
-0,        222,        222,        1,   115200, 0x8b66a779
-0,        223,        223,        1,   115200, 0x865ebff5
-0,        224,        224,        1,   115200, 0x5967074c
-0,        225,        225,        1,   115200, 0xd5521f60
-0,        226,        226,        1,   115200, 0x462c329c
-0,        227,        227,        1,   115200, 0xbefd36fb
-0,        228,        228,        1,   115200, 0x6f58403b
-0,        229,        229,        1,   115200, 0xe4af2fac
-0,        230,        230,        1,   115200, 0x46453662
-0,        231,        231,        1,   115200, 0x72cc59e8
-0,        232,        232,        1,   115200, 0xd6c67f8e
-0,        233,        233,        1,   115200, 0xd35674a7
-0,        234,        234,        1,   115200, 0x65785ddb
-0,        235,        235,        1,   115200, 0xfd7958aa
-0,        236,        236,        1,   115200, 0x93e45607
-0,        237,        237,        1,   115200, 0x196a4fa5
-0,        238,        238,        1,   115200, 0xe33a5dac
-0,        239,        239,        1,   115200, 0x4e66904a
-0,        240,        240,        1,   115200, 0xc1e3a50a
-0,        241,        241,        1,   115200, 0xa685b351
-0,        242,        242,        1,   115200, 0xee2fdeb7
-0,        243,        243,        1,   115200, 0x189cefdd
-0,        244,        244,        1,   115200, 0xbdf90506
-0,        245,        245,        1,   115200, 0xe72c23d2
-0,        246,        246,        1,   115200, 0xa3f65e7b
-0,        247,        247,        1,   115200, 0x8bc67eee
-0,        248,        248,        1,   115200, 0xd305d09b
-0,        249,        249,        1,   115200, 0xc521eba5
-0,        250,        250,        1,   115200, 0x16cf161f
-0,        251,        251,        1,   115200, 0x2ce322b5
-0,        252,        252,        1,   115200, 0x57ce82b4
-0,        253,        253,        1,   115200, 0x8da896b9
-0,        254,        254,        1,   115200, 0xc16ad590
+0,        105,        105,        1,   115200, 0x125900d0
+0,        106,        106,        1,   115200, 0x916408eb
+0,        107,        107,        1,   115200, 0xe45b5f5a
+0,        108,        108,        1,   115200, 0x94222dc4
+0,        109,        109,        1,   115200, 0xba6018b4
+0,        110,        110,        1,   115200, 0xe64b63f7
+0,        111,        111,        1,   115200, 0x2a6ac35c
+0,        112,        112,        1,   115200, 0xb899ed0d
+0,        113,        113,        1,   115200, 0xefcc1111
+0,        114,        114,        1,   115200, 0x67a57bbe
+0,        115,        115,        1,   115200, 0x48877a83
+0,        116,        116,        1,   115200, 0xf83d57ca
+0,        117,        117,        1,   115200, 0x80a6625f
+0,        118,        118,        1,   115200, 0x984f78e4
+0,        119,        119,        1,   115200, 0xd0c7524d
+0,        120,        120,        1,   115200, 0x60475044
+0,        121,        121,        1,   115200, 0xce495653
+0,        122,        122,        1,   115200, 0x05956238
+0,        123,        123,        1,   115200, 0x1ede12ce
+0,        124,        124,        1,   115200, 0x5ecfea25
+0,        125,        125,        1,   115200, 0x533ff0cc
+0,        126,        126,        1,   115200, 0x0900a711
+0,        127,        127,        1,   115200, 0x0ff44124
+0,        128,        128,        1,   115200, 0x96298cc0
+0,        129,        129,        1,   115200, 0xd2a063ab
+0,        130,        130,        1,   115200, 0xe9c63c2f
+0,        131,        131,        1,   115200, 0x0991ceda
+0,        132,        132,        1,   115200, 0x089aff4e
+0,        133,        133,        1,   115200, 0xabe4af7e
+0,        134,        134,        1,   115200, 0xd7ba5162
+0,        135,        135,        1,   115200, 0xb3adfe6d
+0,        136,        136,        1,   115200, 0xb04604c9
+0,        137,        137,        1,   115200, 0xdef1da1b
+0,        138,        138,        1,   115200, 0x25ffdc48
+0,        139,        139,        1,   115200, 0x8b7ac975
+0,        140,        140,        1,   115200, 0xaa21eb49
+0,        141,        141,        1,   115200, 0x5ffc46cc
+0,        142,        142,        1,   115200, 0x73616a99
+0,        143,        143,        1,   115200, 0xabfad3f5
+0,        144,        144,        1,   115200, 0x11d45466
+0,        145,        145,        1,   115200, 0xc123788b
+0,        146,        146,        1,   115200, 0xa58d01e0
+0,        147,        147,        1,   115200, 0x72137847
+0,        148,        148,        1,   115200, 0x25b9baa9
+0,        149,        149,        1,   115200, 0x1d5bf9d6
+0,        150,        150,        1,   115200, 0x6bab7161
+0,        151,        151,        1,   115200, 0x59789be2
+0,        152,        152,        1,   115200, 0x2784ff18
+0,        153,        153,        1,   115200, 0x05901bec
+0,        154,        154,        1,   115200, 0x5a8648be
+0,        155,        155,        1,   115200, 0x048854c1
+0,        156,        156,        1,   115200, 0x5d2b8c69
+0,        157,        157,        1,   115200, 0x951d8fe6
+0,        158,        158,        1,   115200, 0x5118ad8c
+0,        159,        159,        1,   115200, 0x6d417bdd
+0,        160,        160,        1,   115200, 0x59c590d3
+0,        161,        161,        1,   115200, 0x7c826d1a
+0,        162,        162,        1,   115200, 0xa87659cd
+0,        163,        163,        1,   115200, 0xe0893b19
+0,        164,        164,        1,   115200, 0x73531ead
+0,        165,        165,        1,   115200, 0x7bdf0697
+0,        166,        166,        1,   115200, 0xd3de0067
+0,        167,        167,        1,   115200, 0xcf29c29b
+0,        168,        168,        1,   115200, 0xda299edb
+0,        169,        169,        1,   115200, 0x0e766935
+0,        170,        170,        1,   115200, 0x29f34e91
+0,        171,        171,        1,   115200, 0x85524e53
+0,        172,        172,        1,   115200, 0x13796542
+0,        173,        173,        1,   115200, 0x78bc5073
+0,        174,        174,        1,   115200, 0xf4b05c51
+0,        175,        175,        1,   115200, 0x12ac3079
+0,        176,        176,        1,   115200, 0xf5bf3b45
+0,        177,        177,        1,   115200, 0x1a9103a7
+0,        178,        178,        1,   115200, 0x3b5904aa
+0,        179,        179,        1,   115200, 0x5d4fce7c
+0,        180,        180,        1,   115200, 0x3239a6fa
+0,        181,        181,        1,   115200, 0xd7ffae3a
+0,        182,        182,        1,   115200, 0xc687a51d
+0,        183,        183,        1,   115200, 0xc5a5a871
+0,        184,        184,        1,   115200, 0x40a4c09a
+0,        185,        185,        1,   115200, 0xd905e0c1
+0,        186,        186,        1,   115200, 0x0cea06c3
+0,        187,        187,        1,   115200, 0x87961734
+0,        188,        188,        1,   115200, 0x79bb502e
+0,        189,        189,        1,   115200, 0x3a606c03
+0,        190,        190,        1,   115200, 0x7eea99f7
+0,        191,        191,        1,   115200, 0x8a13a800
+0,        192,        192,        1,   115200, 0x4793c238
+0,        193,        193,        1,   115200, 0xa305c503
+0,        194,        194,        1,   115200, 0x5e4bdf82
+0,        195,        195,        1,   115200, 0x0165e148
+0,        196,        196,        1,   115200, 0x175afb1f
+0,        197,        197,        1,   115200, 0xfb710b4e
+0,        198,        198,        1,   115200, 0x8074299f
+0,        199,        199,        1,   115200, 0xb9bd2576
+0,        200,        200,        1,   115200, 0x0d135337
+0,        201,        201,        1,   115200, 0xe53e706a
+0,        202,        202,        1,   115200, 0x57627bd2
+0,        203,        203,        1,   115200, 0xfa13a336
+0,        204,        204,        1,   115200, 0x1c47d9c4
+0,        205,        205,        1,   115200, 0x9f44e929
+0,        206,        206,        1,   115200, 0xfd15ee4d
+0,        207,        207,        1,   115200, 0x0a43e426
+0,        208,        208,        1,   115200, 0x1413f2d1
+0,        209,        209,        1,   115200, 0x89eadaa0
+0,        210,        210,        1,   115200, 0x01b4f9c7
+0,        211,        211,        1,   115200, 0x0883f7f9
+0,        212,        212,        1,   115200, 0xd5f81739
+0,        213,        213,        1,   115200, 0x637d40c8
+0,        214,        214,        1,   115200, 0x211d5850
+0,        215,        215,        1,   115200, 0xb0319873
+0,        216,        216,        1,   115200, 0x90e9f518
+0,        217,        217,        1,   115200, 0x70f40bd3
+0,        218,        218,        1,   115200, 0x8f646061
+0,        219,        219,        1,   115200, 0x1f50dc9d
+0,        220,        220,        1,   115200, 0x3c810751
+0,        221,        221,        1,   115200, 0x79e44c66
+0,        222,        222,        1,   115200, 0x6c9fa6b6
+0,        223,        223,        1,   115200, 0x9211bf3f
+0,        224,        224,        1,   115200, 0xfbe70678
+0,        225,        225,        1,   115200, 0xab9d1e8f
+0,        226,        226,        1,   115200, 0xf54f31dc
+0,        227,        227,        1,   115200, 0xe6963636
+0,        228,        228,        1,   115200, 0x58ac3f43
+0,        229,        229,        1,   115200, 0x4d382f03
+0,        230,        230,        1,   115200, 0xaa663672
+0,        231,        231,        1,   115200, 0xbbf559c8
+0,        232,        232,        1,   115200, 0x6c567f1e
+0,        233,        233,        1,   115200, 0x59817491
+0,        234,        234,        1,   115200, 0xba715dc2
+0,        235,        235,        1,   115200, 0x299f5882
+0,        236,        236,        1,   115200, 0x139455d5
+0,        237,        237,        1,   115200, 0x37e74fb1
+0,        238,        238,        1,   115200, 0x4f005ddc
+0,        239,        239,        1,   115200, 0xc90e8fcb
+0,        240,        240,        1,   115200, 0x22e4a47a
+0,        241,        241,        1,   115200, 0xa974b2d2
+0,        242,        242,        1,   115200, 0xfab7de51
+0,        243,        243,        1,   115200, 0xa9a7ef13
+0,        244,        244,        1,   115200, 0x8ddd0464
+0,        245,        245,        1,   115200, 0xd314232a
+0,        246,        246,        1,   115200, 0x1fba5db0
+0,        247,        247,        1,   115200, 0x52387e64
+0,        248,        248,        1,   115200, 0xc58ed032
+0,        249,        249,        1,   115200, 0xefabeb35
+0,        250,        250,        1,   115200, 0x002315c1
+0,        251,        251,        1,   115200, 0x124721f7
+0,        252,        252,        1,   115200, 0xc24981e9
+0,        253,        253,        1,   115200, 0xa1f795f0
+0,        254,        254,        1,   115200, 0xc01fd535
 0,        255,        255,        1,   115200, 0x8cdbe729
 0,        256,        256,        1,   115200, 0x69eafd96
 0,        257,        257,        1,   115200, 0xd9e40a03
@@ -320,160 +320,160 @@
 0,        340,        340,        1,   115200, 0x82179a82
 0,        341,        341,        1,   115200, 0xf8865f3d
 0,        342,        342,        1,   115200, 0xa5fb7b80
-0,        343,        343,        1,   115200, 0x9aebc04d
-0,        344,        344,        1,   115200, 0x44c705fc
-0,        345,        345,        1,   115200, 0xd322add3
-0,        346,        346,        1,   115200, 0xf4230b76
-0,        347,        347,        1,   115200, 0xaa915069
-0,        348,        348,        1,   115200, 0x518d53d8
-0,        349,        349,        1,   115200, 0xefa7d909
-0,        350,        350,        1,   115200, 0x803c3c0e
-0,        351,        351,        1,   115200, 0x5650bc0a
-0,        352,        352,        1,   115200, 0x8b34ecab
-0,        353,        353,        1,   115200, 0x975c4976
-0,        354,        354,        1,   115200, 0x700e3cb4
-0,        355,        355,        1,   115200, 0xef27a4ec
-0,        356,        356,        1,   115200, 0x2b953936
-0,        357,        357,        1,   115200, 0xcf9b4956
-0,        358,        358,        1,   115200, 0xae4a8eba
-0,        359,        359,        1,   115200, 0xf8821144
-0,        360,        360,        1,   115200, 0x97c2402c
-0,        361,        361,        1,   115200, 0x209b7bb3
-0,        362,        362,        1,   115200, 0xd22fff2c
-0,        363,        363,        1,   115200, 0xe85b4f16
-0,        364,        364,        1,   115200, 0x0659f318
-0,        365,        365,        1,   115200, 0x6e2bff98
-0,        366,        366,        1,   115200, 0xc6626f2f
-0,        367,        367,        1,   115200, 0x123138e2
-0,        368,        368,        1,   115200, 0x69e680ab
-0,        369,        369,        1,   115200, 0xe4d7cd1d
-0,        370,        370,        1,   115200, 0x4ca10d47
-0,        371,        371,        1,   115200, 0x633a4c39
-0,        372,        372,        1,   115200, 0x64ded292
-0,        373,        373,        1,   115200, 0x88d2df42
-0,        374,        374,        1,   115200, 0x998f4c63
-0,        375,        375,        1,   115200, 0x753c76f9
-0,        376,        376,        1,   115200, 0x9d7ba0a6
-0,        377,        377,        1,   115200, 0x68798da5
-0,        378,        378,        1,   115200, 0xb5b18bc3
-0,        379,        379,        1,   115200, 0x20245e49
-0,        380,        380,        1,   115200, 0xf15d4b8f
-0,        381,        381,        1,   115200, 0x17f83b69
-0,        382,        382,        1,   115200, 0xcc545783
-0,        383,        383,        1,   115200, 0x3dad530e
-0,        384,        384,        1,   115200, 0x6b465c94
-0,        385,        385,        1,   115200, 0xbc5f3831
-0,        386,        386,        1,   115200, 0x1b2f042d
-0,        387,        387,        1,   115200, 0xaec391ac
-0,        388,        388,        1,   115200, 0x99fa8b2a
-0,        389,        389,        1,   115200, 0xf78d3524
-0,        390,        390,        1,   115200, 0xe6255a24
-0,        391,        391,        1,   115200, 0x253542c6
-0,        392,        392,        1,   115200, 0xfab05365
-0,        393,        393,        1,   115200, 0x406a3749
-0,        394,        394,        1,   115200, 0xaf0f3935
-0,        395,        395,        1,   115200, 0x0d9ff780
-0,        396,        396,        1,   115200, 0xfadcfc15
-0,        397,        397,        1,   115200, 0x8267d5ad
-0,        398,        398,        1,   115200, 0xd705d250
-0,        399,        399,        1,   115200, 0x18f9d1f2
-0,        400,        400,        1,   115200, 0xd92bc045
-0,        401,        401,        1,   115200, 0x439b9ca0
-0,        402,        402,        1,   115200, 0xcb80a14c
-0,        403,        403,        1,   115200, 0xee887f49
-0,        404,        404,        1,   115200, 0xfba297eb
-0,        405,        405,        1,   115200, 0x0e2f744b
-0,        406,        406,        1,   115200, 0xaa227aa7
-0,        407,        407,        1,   115200, 0xd7bc6fff
-0,        408,        408,        1,   115200, 0x295c91cf
-0,        409,        409,        1,   115200, 0xc5678733
-0,        410,        410,        1,   115200, 0xc8d49120
-0,        411,        411,        1,   115200, 0xb14e90b9
-0,        412,        412,        1,   115200, 0x6a09acab
-0,        413,        413,        1,   115200, 0xb9aec358
-0,        414,        414,        1,   115200, 0xeb3695b2
-0,        415,        415,        1,   115200, 0xc5bebd62
-0,        416,        416,        1,   115200, 0x2d6b1a3f
-0,        417,        417,        1,   115200, 0x92986f49
-0,        418,        418,        1,   115200, 0x00c37cf9
-0,        419,        419,        1,   115200, 0x5a4d87a6
-0,        420,        420,        1,   115200, 0xe87888a2
-0,        421,        421,        1,   115200, 0x4ab18d6d
-0,        422,        422,        1,   115200, 0xcb84880b
-0,        423,        423,        1,   115200, 0x82458848
-0,        424,        424,        1,   115200, 0x11b477dc
-0,        425,        425,        1,   115200, 0x56d876d3
-0,        426,        426,        1,   115200, 0xf5297ceb
-0,        427,        427,        1,   115200, 0x47357713
-0,        428,        428,        1,   115200, 0xede562df
-0,        429,        429,        1,   115200, 0xabf42d38
-0,        430,        430,        1,   115200, 0xea9225c8
-0,        431,        431,        1,   115200, 0x79ce1cb4
-0,        432,        432,        1,   115200, 0x0cd418b4
-0,        433,        433,        1,   115200, 0x6f7c118e
-0,        434,        434,        1,   115200, 0xbbbc0fa4
-0,        435,        435,        1,   115200, 0x890514e6
-0,        436,        436,        1,   115200, 0x9c4d0e7d
-0,        437,        437,        1,   115200, 0x56260e76
-0,        438,        438,        1,   115200, 0x7dc80258
-0,        439,        439,        1,   115200, 0xa990f5a3
-0,        440,        440,        1,   115200, 0x2174e913
-0,        441,        441,        1,   115200, 0x8296e674
-0,        442,        442,        1,   115200, 0x9e28e3b4
-0,        443,        443,        1,   115200, 0x404ce72b
-0,        444,        444,        1,   115200, 0xc7cbf4ec
-0,        445,        445,        1,   115200, 0x5ce0f5a1
-0,        446,        446,        1,   115200, 0x88dbf7c7
-0,        447,        447,        1,   115200, 0x26daf35a
-0,        448,        448,        1,   115200, 0x5cfdfe63
-0,        449,        449,        1,   115200, 0xdd40fb9b
-0,        450,        450,        1,   115200, 0x5b8df20f
-0,        451,        451,        1,   115200, 0x4f2ce5ac
-0,        452,        452,        1,   115200, 0xc9d0e0c2
-0,        453,        453,        1,   115200, 0x51c7e2a6
-0,        454,        454,        1,   115200, 0xb3bae109
-0,        455,        455,        1,   115200, 0xbd85e5b2
-0,        456,        456,        1,   115200, 0x1fbbdfd1
-0,        457,        457,        1,   115200, 0x3665dfd0
-0,        458,        458,        1,   115200, 0xcd29d50c
-0,        459,        459,        1,   115200, 0xedd1c6bc
-0,        460,        460,        1,   115200, 0xebc2d072
-0,        461,        461,        1,   115200, 0xe2e5fbbd
-0,        462,        462,        1,   115200, 0x616a13dc
-0,        463,        463,        1,   115200, 0xf64f1efc
-0,        464,        464,        1,   115200, 0x5356235f
-0,        465,        465,        1,   115200, 0xafc032d5
-0,        466,        466,        1,   115200, 0xaa034420
-0,        467,        467,        1,   115200, 0x007e0afa
-0,        468,        468,        1,   115200, 0x077ad5c8
-0,        469,        469,        1,   115200, 0x8fc815b8
-0,        470,        470,        1,   115200, 0x95b85990
-0,        471,        471,        1,   115200, 0x46f5899f
-0,        472,        472,        1,   115200, 0x1e37cd82
-0,        473,        473,        1,   115200, 0x3ce90bfd
-0,        474,        474,        1,   115200, 0xbb95bd1d
-0,        475,        475,        1,   115200, 0xd4aa9ba8
-0,        476,        476,        1,   115200, 0x0e761649
-0,        477,        477,        1,   115200, 0x49ad7886
-0,        478,        478,        1,   115200, 0x2f4184df
-0,        479,        479,        1,   115200, 0x80b906ee
-0,        480,        480,        1,   115200, 0x62405100
-0,        481,        481,        1,   115200, 0x3ece13b5
-0,        482,        482,        1,   115200, 0x3abd4cfc
-0,        483,        483,        1,   115200, 0x91b418e3
-0,        484,        484,        1,   115200, 0xde1ce68e
-0,        485,        485,        1,   115200, 0xfc47f912
-0,        486,        486,        1,   115200, 0x5b380a6f
-0,        487,        487,        1,   115200, 0x8f35c3c0
-0,        488,        488,        1,   115200, 0xb26dc220
-0,        489,        489,        1,   115200, 0x3d5bbfce
-0,        490,        490,        1,   115200, 0xa1f9bee6
-0,        491,        491,        1,   115200, 0xa87dcd24
-0,        492,        492,        1,   115200, 0x9374cb71
-0,        493,        493,        1,   115200, 0x0c7ccbd0
-0,        494,        494,        1,   115200, 0x9a16cc49
-0,        495,        495,        1,   115200, 0x4df0c28b
-0,        496,        496,        1,   115200, 0xb5b8b866
-0,        497,        497,        1,   115200, 0xafcc1019
-0,        510,        510,        1,   115200, 0x623b0ff3
-0,        512,        512,        1,   115200, 0x1d6f10b5
+0,        343,        343,        1,   115200, 0xf2a9c04d
+0,        344,        344,        1,   115200, 0x2b4005ea
+0,        345,        345,        1,   115200, 0xcec6ad14
+0,        346,        346,        1,   115200, 0x1c040afc
+0,        347,        347,        1,   115200, 0x164c4fd5
+0,        348,        348,        1,   115200, 0x5bcc5385
+0,        349,        349,        1,   115200, 0x7f7ed8d3
+0,        350,        350,        1,   115200, 0x48ab3c54
+0,        351,        351,        1,   115200, 0xd5debbfb
+0,        352,        352,        1,   115200, 0x720ded36
+0,        353,        353,        1,   115200, 0x3ae44a00
+0,        354,        354,        1,   115200, 0xfa893d68
+0,        355,        355,        1,   115200, 0xc833a619
+0,        356,        356,        1,   115200, 0xa3583b05
+0,        357,        357,        1,   115200, 0xffed4aed
+0,        358,        358,        1,   115200, 0x3757904a
+0,        359,        359,        1,   115200, 0x2f09122d
+0,        360,        360,        1,   115200, 0xcc9f40d6
+0,        361,        361,        1,   115200, 0xb8287bfb
+0,        362,        362,        1,   115200, 0x5f62ff06
+0,        363,        363,        1,   115200, 0x76b04f67
+0,        364,        364,        1,   115200, 0xa9e6f352
+0,        365,        365,        1,   115200, 0xc0e6001f
+0,        366,        366,        1,   115200, 0x19bc6f22
+0,        367,        367,        1,   115200, 0x0dbe3871
+0,        368,        368,        1,   115200, 0x413c8035
+0,        369,        369,        1,   115200, 0x8c28cc8d
+0,        370,        370,        1,   115200, 0xdd7f0cda
+0,        371,        371,        1,   115200, 0xf6f14c0c
+0,        372,        372,        1,   115200, 0x23bbd27b
+0,        373,        373,        1,   115200, 0xa8b8df03
+0,        374,        374,        1,   115200, 0xadb14c5a
+0,        375,        375,        1,   115200, 0xb5ca76f0
+0,        376,        376,        1,   115200, 0xea38a095
+0,        377,        377,        1,   115200, 0x60218deb
+0,        378,        378,        1,   115200, 0x947e8c0f
+0,        379,        379,        1,   115200, 0x6afe5ed1
+0,        380,        380,        1,   115200, 0x139f4c22
+0,        381,        381,        1,   115200, 0x5e4c3c2d
+0,        382,        382,        1,   115200, 0x86df5833
+0,        383,        383,        1,   115200, 0x824e538a
+0,        384,        384,        1,   115200, 0xebf25d19
+0,        385,        385,        1,   115200, 0x229438ae
+0,        386,        386,        1,   115200, 0xde5e0494
+0,        387,        387,        1,   115200, 0x63399194
+0,        388,        388,        1,   115200, 0x1f048b80
+0,        389,        389,        1,   115200, 0x0774357a
+0,        390,        390,        1,   115200, 0xddd75a69
+0,        391,        391,        1,   115200, 0x6d054339
+0,        392,        392,        1,   115200, 0xd0995428
+0,        393,        393,        1,   115200, 0x607a37eb
+0,        394,        394,        1,   115200, 0xa704399c
+0,        395,        395,        1,   115200, 0x0d7ff8b8
+0,        396,        396,        1,   115200, 0x5b20fd4e
+0,        397,        397,        1,   115200, 0x7cbad667
+0,        398,        398,        1,   115200, 0xe217d35f
+0,        399,        399,        1,   115200, 0x3ff6d303
+0,        400,        400,        1,   115200, 0x5aa4c0e4
+0,        401,        401,        1,   115200, 0x2d779d91
+0,        402,        402,        1,   115200, 0x7097a25d
+0,        403,        403,        1,   115200, 0x57c5809d
+0,        404,        404,        1,   115200, 0x0fe0997e
+0,        405,        405,        1,   115200, 0xd81d75a9
+0,        406,        406,        1,   115200, 0x30a87cc0
+0,        407,        407,        1,   115200, 0x22a971b6
+0,        408,        408,        1,   115200, 0x9f849351
+0,        409,        409,        1,   115200, 0xa1218894
+0,        410,        410,        1,   115200, 0xefdd92a8
+0,        411,        411,        1,   115200, 0xe0559201
+0,        412,        412,        1,   115200, 0x07ebade6
+0,        413,        413,        1,   115200, 0xe0c2c425
+0,        414,        414,        1,   115200, 0x92159752
+0,        415,        415,        1,   115200, 0x048fbe24
+0,        416,        416,        1,   115200, 0x8a051ae9
+0,        417,        417,        1,   115200, 0xed466ff3
+0,        418,        418,        1,   115200, 0x11157da7
+0,        419,        419,        1,   115200, 0x1f958850
+0,        420,        420,        1,   115200, 0x1e488948
+0,        421,        421,        1,   115200, 0x8c538e13
+0,        422,        422,        1,   115200, 0x26d188b1
+0,        423,        423,        1,   115200, 0x903b88e8
+0,        424,        424,        1,   115200, 0x04ed7882
+0,        425,        425,        1,   115200, 0x58d17772
+0,        426,        426,        1,   115200, 0x37c67d8c
+0,        427,        427,        1,   115200, 0x6c2677b4
+0,        428,        428,        1,   115200, 0xc0a763ba
+0,        429,        429,        1,   115200, 0xce242e3c
+0,        430,        430,        1,   115200, 0xcd0c26d9
+0,        431,        431,        1,   115200, 0x4cf81d8a
+0,        432,        432,        1,   115200, 0xb5a61995
+0,        433,        433,        1,   115200, 0xb4bb1276
+0,        434,        434,        1,   115200, 0x085210a6
+0,        435,        435,        1,   115200, 0x4cf215b4
+0,        436,        436,        1,   115200, 0xe78d0f4b
+0,        437,        437,        1,   115200, 0x52bc0f3c
+0,        438,        438,        1,   115200, 0x8c50033d
+0,        439,        439,        1,   115200, 0x0147f6b5
+0,        440,        440,        1,   115200, 0x5da1e9f2
+0,        441,        441,        1,   115200, 0xf5fce75b
+0,        442,        442,        1,   115200, 0x90aee4e5
+0,        443,        443,        1,   115200, 0xd73ae879
+0,        444,        444,        1,   115200, 0xb578f62a
+0,        445,        445,        1,   115200, 0x9ebcf6dd
+0,        446,        446,        1,   115200, 0x7a3cf909
+0,        447,        447,        1,   115200, 0x7240f4b6
+0,        448,        448,        1,   115200, 0x55a9ffcd
+0,        449,        449,        1,   115200, 0x95c7fd1b
+0,        450,        450,        1,   115200, 0x40e3f3c4
+0,        451,        451,        1,   115200, 0x2059e762
+0,        452,        452,        1,   115200, 0xa0bee25d
+0,        453,        453,        1,   115200, 0xedf9e470
+0,        454,        454,        1,   115200, 0x83a9e2b0
+0,        455,        455,        1,   115200, 0xf420e78e
+0,        456,        456,        1,   115200, 0x5512e1ad
+0,        457,        457,        1,   115200, 0xca18e192
+0,        458,        458,        1,   115200, 0x46d5d6cb
+0,        459,        459,        1,   115200, 0x40c7c6bc
+0,        460,        460,        1,   115200, 0x45e4d06b
+0,        461,        461,        1,   115200, 0xeefffb82
+0,        462,        462,        1,   115200, 0x6f9a1394
+0,        463,        463,        1,   115200, 0xec521ebc
+0,        464,        464,        1,   115200, 0x8b632329
+0,        465,        465,        1,   115200, 0x858732ba
+0,        466,        466,        1,   115200, 0x1f364406
+0,        467,        467,        1,   115200, 0xf6870af0
+0,        468,        468,        1,   115200, 0x8738d586
+0,        469,        469,        1,   115200, 0x52761588
+0,        470,        470,        1,   115200, 0xc1c8593d
+0,        471,        471,        1,   115200, 0x88a88938
+0,        472,        472,        1,   115200, 0x4a01ccf5
+0,        473,        473,        1,   115200, 0x2d990bde
+0,        474,        474,        1,   115200, 0x2dc9bd2b
+0,        475,        475,        1,   115200, 0xc1599b9b
+0,        476,        476,        1,   115200, 0xce621632
+0,        477,        477,        1,   115200, 0xbe027871
+0,        478,        478,        1,   115200, 0xf48f84a8
+0,        479,        479,        1,   115200, 0x6a240689
+0,        480,        480,        1,   115200, 0xfb90504d
+0,        481,        481,        1,   115200, 0x1a5512ec
+0,        482,        482,        1,   115200, 0x5f124c22
+0,        483,        483,        1,   115200, 0x2ea3180e
+0,        484,        484,        1,   115200, 0x2519e60e
+0,        485,        485,        1,   115200, 0xe240f88d
+0,        486,        486,        1,   115200, 0xac9209d8
+0,        487,        487,        1,   115200, 0x926fc3b8
+0,        488,        488,        1,   115200, 0xa5cdc217
+0,        489,        489,        1,   115200, 0x4d52bfcc
+0,        490,        490,        1,   115200, 0x2ce6bedf
+0,        491,        491,        1,   115200, 0x19e4cd0d
+0,        492,        492,        1,   115200, 0x1cc7cb5c
+0,        493,        493,        1,   115200, 0x74facbbc
+0,        494,        494,        1,   115200, 0xb771cc31
+0,        495,        495,        1,   115200, 0x6aabc273
+0,        496,        496,        1,   115200, 0x0308b854
+0,        497,        497,        1,   115200, 0xa70a1019
+0,        510,        510,        1,   115200, 0x59790ff3
+0,        512,        512,        1,   115200, 0x0e7110b5
diff --git a/tests/ref/lavf/wbmp b/tests/ref/lavf/wbmp
new file mode 100644
index 0000000..746d88f
--- /dev/null
+++ b/tests/ref/lavf/wbmp
@@ -0,0 +1,3 @@
+ebe2a887bd3098ac50502063257b4275 *tests/data/images/wbmp/02.wbmp
+12678 tests/data/images/wbmp/02.wbmp
+tests/data/images/wbmp/%02d.wbmp CRC=0xab19200d
diff --git a/tests/ref/seek/vsynth_lena-mpeg4-adap b/tests/ref/seek/vsynth_lena-mpeg4-adap
index 0611ee4..fe841ef 100644
--- a/tests/ref/seek/vsynth_lena-mpeg4-adap
+++ b/tests/ref/seek/vsynth_lena-mpeg4-adap
@@ -2,45 +2,45 @@ ret: 0         st: 0 flags:1 dts: 0.000000 pts: NOPTS    pos:   5652 size:  6855
 ret: 0         st:-1 flags:0  ts:-1.000000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: NOPTS    pos:   5652 size:  6855
 ret: 0         st:-1 flags:1  ts: 1.894167
-ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 174446 size: 16883
+ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 161318 size: 19176
 ret: 0         st: 0 flags:0  ts: 0.800000
-ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  98220 size: 17063
+ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  75056 size: 19178
 ret:-1         st: 0 flags:1  ts:-0.320000
 ret:-1         st:-1 flags:0  ts: 2.576668
 ret: 0         st:-1 flags:1  ts: 1.470835
-ret: 0         st: 0 flags:1 dts: 1.360000 pts: NOPTS    pos: 135582 size: 17525
+ret: 0         st: 0 flags:1 dts: 1.360000 pts: NOPTS    pos: 118696 size: 20018
 ret: 0         st: 0 flags:0  ts: 0.360000
-ret: 0         st: 0 flags:1 dts: 0.400000 pts: NOPTS    pos:  59446 size: 17261
+ret: 0         st: 0 flags:1 dts: 0.400000 pts: NOPTS    pos:  35800 size: 17261
 ret:-1         st: 0 flags:1  ts:-0.760000
 ret:-1         st:-1 flags:0  ts: 2.153336
 ret: 0         st:-1 flags:1  ts: 1.047503
-ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  98220 size: 17063
+ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  75056 size: 19178
 ret: 0         st: 0 flags:0  ts:-0.040000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: NOPTS    pos:   5652 size:  6855
 ret: 0         st: 0 flags:1  ts: 2.840000
-ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 174446 size: 16883
+ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 161318 size: 19176
 ret: 0         st:-1 flags:0  ts: 1.730004
-ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 174446 size: 16883
+ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 161318 size: 19176
 ret: 0         st:-1 flags:1  ts: 0.624171
-ret: 0         st: 0 flags:1 dts: 0.400000 pts: NOPTS    pos:  59446 size: 17261
+ret: 0         st: 0 flags:1 dts: 0.400000 pts: NOPTS    pos:  35800 size: 17261
 ret: 0         st: 0 flags:0  ts:-0.480000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: NOPTS    pos:   5652 size:  6855
 ret: 0         st: 0 flags:1  ts: 2.400000
-ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 174446 size: 16883
+ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 161318 size: 19176
 ret: 0         st:-1 flags:0  ts: 1.306672
-ret: 0         st: 0 flags:1 dts: 1.360000 pts: NOPTS    pos: 135582 size: 17525
+ret: 0         st: 0 flags:1 dts: 1.360000 pts: NOPTS    pos: 118696 size: 20018
 ret: 0         st:-1 flags:1  ts: 0.200839
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: NOPTS    pos:   5652 size:  6855
 ret: 0         st: 0 flags:0  ts:-0.920000
 ret: 0         st: 0 flags:1 dts: 0.000000 pts: NOPTS    pos:   5652 size:  6855
 ret: 0         st: 0 flags:1  ts: 2.000000
-ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 174446 size: 16883
+ret: 0         st: 0 flags:1 dts: 1.840000 pts: NOPTS    pos: 161318 size: 19176
 ret: 0         st:-1 flags:0  ts: 0.883340
-ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  98220 size: 17063
+ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  75056 size: 19178
 ret:-1         st:-1 flags:1  ts:-0.222493
 ret:-1         st: 0 flags:0  ts: 2.680000
 ret: 0         st: 0 flags:1  ts: 1.560000
-ret: 0         st: 0 flags:1 dts: 1.360000 pts: NOPTS    pos: 135582 size: 17525
+ret: 0         st: 0 flags:1 dts: 1.360000 pts: NOPTS    pos: 118696 size: 20018
 ret: 0         st:-1 flags:0  ts: 0.460008
-ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  98220 size: 17063
+ret: 0         st: 0 flags:1 dts: 0.880000 pts: NOPTS    pos:  75056 size: 19178
 ret:-1         st:-1 flags:1  ts:-0.645825
diff --git a/tests/ref/vsynth/vsynth1-mpeg4-adap b/tests/ref/vsynth/vsynth1-mpeg4-adap
index e6bd6a5..67705f0 100644
--- a/tests/ref/vsynth/vsynth1-mpeg4-adap
+++ b/tests/ref/vsynth/vsynth1-mpeg4-adap
@@ -1,4 +1,4 @@
-f120f0bf976bb510c5b5305fe7d8159a *tests/data/fate/vsynth1-mpeg4-adap.avi
-403436 tests/data/fate/vsynth1-mpeg4-adap.avi
-fad0b9dc08fe4a95b297af1a7411c1e9 *tests/data/fate/vsynth1-mpeg4-adap.out.rawvideo
-stddev:   14.05 PSNR: 25.17 MAXDIFF:  184 bytes:  7603200/  7603200
+0f1cbbdc3f9b91f2d9ac3d1fc2cf7d4e *tests/data/fate/vsynth1-mpeg4-adap.avi
+325518 tests/data/fate/vsynth1-mpeg4-adap.avi
+1e6c596f9f491fbf15920ef1bace7fb8 *tests/data/fate/vsynth1-mpeg4-adap.out.rawvideo
+stddev:   14.12 PSNR: 25.13 MAXDIFF:  184 bytes:  7603200/  7603200
diff --git a/tests/ref/vsynth/vsynth2-mpeg4-adap b/tests/ref/vsynth/vsynth2-mpeg4-adap
index a3223f6..35b2b6a 100644
--- a/tests/ref/vsynth/vsynth2-mpeg4-adap
+++ b/tests/ref/vsynth/vsynth2-mpeg4-adap
@@ -1,4 +1,4 @@
-4bff98da2342836476da817428594403 *tests/data/fate/vsynth2-mpeg4-adap.avi
-213508 tests/data/fate/vsynth2-mpeg4-adap.avi
-0c709f2b81f4593eaa29490332c2cb39 *tests/data/fate/vsynth2-mpeg4-adap.out.rawvideo
-stddev:    4.87 PSNR: 34.36 MAXDIFF:   86 bytes:  7603200/  7603200
+06a397fe43dab7b6cf56870410fbbbaf *tests/data/fate/vsynth2-mpeg4-adap.avi
+203000 tests/data/fate/vsynth2-mpeg4-adap.avi
+686565d42d8ba5aea790824b04fa0a18 *tests/data/fate/vsynth2-mpeg4-adap.out.rawvideo
+stddev:    4.55 PSNR: 34.95 MAXDIFF:   84 bytes:  7603200/  7603200
diff --git a/tests/ref/vsynth/vsynth3-mpeg4-adap b/tests/ref/vsynth/vsynth3-mpeg4-adap
index 0942f83..6386f13 100644
--- a/tests/ref/vsynth/vsynth3-mpeg4-adap
+++ b/tests/ref/vsynth/vsynth3-mpeg4-adap
@@ -1,4 +1,4 @@
-c16e5c2436ca9953517eadba562768e9 *tests/data/fate/vsynth3-mpeg4-adap.avi
-43706 tests/data/fate/vsynth3-mpeg4-adap.avi
-b42b614e19e7c4859fca1af6d4e36eae *tests/data/fate/vsynth3-mpeg4-adap.out.rawvideo
-stddev:    5.48 PSNR: 33.34 MAXDIFF:   53 bytes:    86700/    86700
+6b2f641f2e68b11b992fd6ba1ed66a21 *tests/data/fate/vsynth3-mpeg4-adap.avi
+41012 tests/data/fate/vsynth3-mpeg4-adap.avi
+3483a2032cb02c3a37f5e43b128e59ed *tests/data/fate/vsynth3-mpeg4-adap.out.rawvideo
+stddev:    5.79 PSNR: 32.87 MAXDIFF:   49 bytes:    86700/    86700
diff --git a/tests/ref/vsynth/vsynth_lena-mpeg4-adap b/tests/ref/vsynth/vsynth_lena-mpeg4-adap
index 10af80b..91edafe 100644
--- a/tests/ref/vsynth/vsynth_lena-mpeg4-adap
+++ b/tests/ref/vsynth/vsynth_lena-mpeg4-adap
@@ -1,4 +1,4 @@
-c6108621b1202d32dac68b1944c5b8c2 *tests/data/fate/vsynth_lena-mpeg4-adap.avi
-198500 tests/data/fate/vsynth_lena-mpeg4-adap.avi
-87b6dbe98d276137fceaae2fa672eced *tests/data/fate/vsynth_lena-mpeg4-adap.out.rawvideo
-stddev:    3.75 PSNR: 36.65 MAXDIFF:   71 bytes:  7603200/  7603200
+633da125f46391eef33bb031cd728f4b *tests/data/fate/vsynth_lena-mpeg4-adap.avi
+187598 tests/data/fate/vsynth_lena-mpeg4-adap.avi
+21312bfcb28c40299fb27a5b03477f8c *tests/data/fate/vsynth_lena-mpeg4-adap.out.rawvideo
+stddev:    3.63 PSNR: 36.92 MAXDIFF:   71 bytes:  7603200/  7603200
diff --git a/tools/Makefile b/tools/Makefile
index f4d1327..4afa233 100644
--- a/tools/Makefile
+++ b/tools/Makefile
@@ -20,6 +20,8 @@ tools/target_io_dem_fuzzer.o: tools/target_dem_fuzzer.c
 tools/venc_data_dump$(EXESUF): tools/decode_simple.o
 tools/scale_slice_test$(EXESUF): tools/decode_simple.o
 
+tools/decode_simple.o: | tools
+
 OUTDIRS += tools
 
 clean::
diff --git a/tools/target_dec_fuzzer.c b/tools/target_dec_fuzzer.c
index 017c5cf..a423277 100644
--- a/tools/target_dec_fuzzer.c
+++ b/tools/target_dec_fuzzer.c
@@ -254,6 +254,7 @@ int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
     case AV_CODEC_ID_MSS2:        maxpixels  /= 16384; break;
     case AV_CODEC_ID_MSZH:        maxpixels  /= 128;   break;
     case AV_CODEC_ID_MVC2:        maxpixels  /= 128;   break;
+    case AV_CODEC_ID_MWSC:        maxpixels  /= 256;   break;
     case AV_CODEC_ID_MXPEG:       maxpixels  /= 128;   break;
     case AV_CODEC_ID_OPUS:        maxsamples /= 16384; break;
     case AV_CODEC_ID_PNG:         maxpixels  /= 128;   break;
@@ -337,7 +338,7 @@ int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
         if ((flags & 0x10) && c->p.id != AV_CODEC_ID_H264)
             ctx->flags2 |= AV_CODEC_FLAG2_FAST;
         if (flags & 0x80)
-            ctx->flags2 |= AV_CODEC_FLAG2_EXPORT_MVS;
+            ctx->export_side_data |= AV_CODEC_EXPORT_DATA_MVS;
 
         if (flags & 0x40)
             av_force_cpu_flags(0);
@@ -405,6 +406,12 @@ int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
             ctx->debug |= FF_DEBUG_QP;
         if (flags64 &4)
             ctx->debug |= FF_DEBUG_MB_TYPE;
+        if (flags64 & 8)
+            ctx->export_side_data |= AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS;
+        if (flags64 & 0x10)
+            ctx->err_recognition |= AV_EF_CRCCHECK;
+
+        ctx->workaround_bugs = bytestream2_get_le32(&gbc);
 
         if (extradata_size < size) {
             ctx->extradata = av_mallocz(extradata_size + AV_INPUT_BUFFER_PADDING_SIZE);
-- 
2.39.1.windows.1

